-- Copyright 2022-2023 gsou
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to
-- deal in the Software without restriction, including without limitation the
-- rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-- sell copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in
-- all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-- THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
-- Boot Lua code for LCL. This file defines the metatables for the common
-- required basic Common Lisp types and basic functions to manipulate
-- lisp data.

-----------------------
-- TEMPORARY HELPERS --
-----------------------

if bit then
  function bit.intdiv(x,y)
    -- XXX There must be a better way
    return math.floor(x/y)
  end
else
  bit = {}
  load('function bit.intdiv(x,y) return x // y end function bit.bnot(x) return ~x end function bit.band(x,y) return x & y end function bit.bor(x,y) return x | y end function bit.bxor(x,y) return x ~ y end function bit.lshift(x,y) return x << y end function bit.rshift(x,y) return x >> y end')()
end

function dump(o, maxdepth, car)
  maxdepth = maxdepth or 16
  car = not car
  if getmetatable(o) == CL_LIB["SYMBOL-METATABLE"] then
    return o.package.name .. "." .. o.name
  elseif type(o) == 'table' and getmetatable(o) == nil and maxdepth > 0 then
    if #o == 2 then
      local s = ''
      s = s .. dump(o[1], maxdepth-1)
      if o[2] ~= CL.NIL then
        local cr = false
        if type(o[2]) == 'table' and getmetatable(o[2]) == nil then
          s = s .. ' '
          cr = true
        else
          s = s .. ' . '
        end
        s = s .. dump(o[2], maxdepth, cr)
      end
      if car then
        return '(' .. s ..')'
      else
        return s
      end
    else
      local s = '{ '
      for k,v in pairs(o) do
        if type(k) ~= 'number' then k = '"'..dump(k)..'"' end
        s = s .. '['..k..'] = ' .. dump(v, maxdepth-1) .. ','
      end
      return s .. '} '
    end
  else
    if type(o) == 'string' then
      return '"' .. o .. '"'
    else
      return tostring(o)
    end
  end
end

---------------
-- BOOT CODE --
---------------

LCL = {}

-- Create cl_lib package
LCL["CL-LIB"] = {name = "CL-LIB"}
CL_LIB = LCL["CL-LIB"]

-- Define metatables
CL_LIB["SYMBOL-METATABLE"] = {
  package = CL_LIB,
  name = "SYMBOL-METATABLE"
}

-- alloc-symbol
CL_LIB["ALLOC-SYMBOL"] = {
  package = CL_LIB,
  name = "ALLOC-SYMBOL"
}
setmetatable(CL_LIB["SYMBOL-METATABLE"], CL_LIB["SYMBOL-METATABLE"])
setmetatable(CL_LIB["ALLOC-SYMBOL"], CL_LIB["SYMBOL-METATABLE"])
CL_LIB["ALLOC-SYMBOL"].fbound = function (package, name)
  local this = {}
  setmetatable(this, CL_LIB["SYMBOL-METATABLE"])
  this.package = package
  this.name = name
  return this
end

-- Call a symbol directly
offset = ""
CL_LIB["SYMBOL-METATABLE"].__call = function (symbol, ...)
  -- print(offset, "Trace: ", dump(symbol), dump({...}))
  -- offset = offset .. " "
  -- local ret = symbol.fbound(...)
  -- offset = string.sub(offset, 2)
  -- print(offset, "Return from: ", dump(symbol), dump({...}))
  -- return ret
  return symbol.fbound(...)
end
CL_LIB["SYMBOL-METATABLE"].__tostring = function (o)
  return o.package.name .. "." .. o.name
end
CL_LIB["SYMBOL-METATABLE"].__index = function (table, key)
  if key == "fbound" then
    error("No such function: " .. tostring(table))
  end
  if key == "setfbound" then
    error("No such function: (setf " .. tostring(table) .. ")")
  end
  if key == "bound" then
    error("Symbol " .. tostring(table) .. " is unbound")
  end
  return nil
end

CL_LIB["SYMBOL-METATABLE"].bound = CL_LIB["SYMBOL-METATABLE"]
CL_LIB["FUNCTION-METATABLE"] = CL_LIB["ALLOC-SYMBOL"](CL_LIB, "FUNCTION-METATABLE")
CL_LIB["FUNCTION-METATABLE"].bound = CL_LIB["FUNCTION-METATABLE"]
CL_LIB["MACRO-METATABLE"] = CL_LIB["ALLOC-SYMBOL"](CL_LIB, "MACRO-METATABLE")
CL_LIB["MACRO-METATABLE"].bound = CL_LIB["MACRO-METATABLE"]
CL_LIB["CHAR-METATABLE"] = CL_LIB["ALLOC-SYMBOL"](CL_LIB, "CHAR-METATABLE")
CL_LIB["CHAR-METATABLE"].bound = CL_LIB["CHAR-METATABLE"]
CL_LIB["PACKAGE-METATABLE"] = CL_LIB["ALLOC-SYMBOL"](CL_LIB, "PACKAGE-METATABLE")
CL_LIB["PACKAGE-METATABLE"].bound = CL_LIB["PACKAGE-METATABLE"]
CL_LIB["HASH-TABLE-METATABLE"] = CL_LIB["ALLOC-SYMBOL"](CL_LIB, "HASH-TABLE-METATABLE")
CL_LIB["HASH-TABLE-METATABLE"].bound = CL_LIB["HASH-TABLE-METATABLE"]
CL_LIB["STRUCT-METATABLE"] = CL_LIB["ALLOC-SYMBOL"](CL_LIB, "STRUCT-METATABLE")
CL_LIB["STRUCT-METATABLE"].bound = CL_LIB["STRUCT-METATABLE"]
CL_LIB["COMPLEX-METATABLE"] = CL_LIB["ALLOC-SYMBOL"](CL_LIB, "COMPLEX-METATABLE")
CL_LIB["COMPLEX-METATABLE"].bound = CL_LIB["COMPLEX-METATABLE"]
CL_LIB["RATIONAL-METATABLE"] = CL_LIB["ALLOC-SYMBOL"](CL_LIB, "RATIONAL-METATABLE")
CL_LIB["RATIONAL-METATABLE"].bound = CL_LIB["RATIONAL-METATABLE"]
CL_LIB["ARRAY-METATABLE"] = CL_LIB["ALLOC-SYMBOL"](CL_LIB, "ARRAY-METATABLE")
CL_LIB["ARRAY-METATABLE"].bound = CL_LIB["ARRAY-METATABLE"]

CL_LIB["FUNCTION-METATABLE"].__call = function (fbound, ...)
  return fbound.func(...)
end
CL_LIB["FUNCTION-METATABLE"].__tostring = function (table)
  if table.debugName then
    return "<FUNCTION " .. table.debugName .. ">"
  else
    return "<FUNCTION " .. dump(table.arglist) .. " ".. tostring(table.func) .. ">"
  end
end
CL_LIB["PACKAGE-METATABLE"].__index = function (table, key)
  -- Fake import CL until packages are supported
  if table ~= KEYWORD and rawget(LCL['COMMON-LISP'], key) then
    return LCL['COMMON-LISP'][key]
  else
    table[key] = CL_LIB["ALLOC-SYMBOL"](table, key)
    if table == KEYWORD then table[key].bound = table[key] end
    return table[key]
  end
end
CL_LIB["PACKAGE-METATABLE"].__tostring = function (table)
  return "<PACKAGE " .. table.name .. ">"
end
CL_LIB["CHAR-METATABLE"].__tostring = function (table)
  if table.code == 10 then return "#\\Newline"
  elseif table.code == 32 then return "#\\Space"
  elseif table.code == 9 then return "#\\Tab"
  else
  return "#\\" .. table.char
  end
end
CL_LIB["ARRAY-METATABLE"].__tostring = function (table)
  return "<ARRAY " .. dump(table.dim) .. ">"
end

CL_LIB["STRUCT-METATABLE"].__tostring = function (table)
  str = '#S(' .. table.name.name
  if table.name == CL_LIB['STD-INSTANCE'] then
    return "<CLASS>"
  else
    for key, val in pairs(table) do
      if getmetatable(key) == CL_LIB['SYMBOL-METATABLE'] then
        str = str .. " :" .. key.name .. " " .. dump(val)
      end
    end
    return str .. ")"
  end
end


setmetatable(CL_LIB, CL_LIB["PACKAGE-METATABLE"])
-- Create keyword package
LCL["KEYWORD"] = {name = "KEYWORD"}
KEYWORD = LCL["KEYWORD"]
setmetatable(KEYWORD, CL_LIB["PACKAGE-METATABLE"])

-- Create the actual CL package
COMMON_LISP = {name = "COMMON-LISP"}
CL = COMMON_LISP
LCL["COMMON-LISP"] = CL
LCL["CL"] = CL -- Synonym

-- Make sure the special form symbols are defined
CL.LET = CL_LIB["ALLOC-SYMBOL"](CL, "LET")
CL.FLET = CL_LIB["ALLOC-SYMBOL"](CL, "FLET")
CL.LABELS = CL_LIB["ALLOC-SYMBOL"](CL, "LABELS")
CL.FUNCTION = CL_LIB["ALLOC-SYMBOL"](CL, "FUNCTION")
CL.QUOTE = CL_LIB["ALLOC-SYMBOL"](CL, "QUOTE")
CL.SETQ = CL_LIB["ALLOC-SYMBOL"](CL, "SETQ")
CL.IF = CL_LIB["ALLOC-SYMBOL"](CL, "IF")

-- Complete packages
function complete_package(p)
  p.external = {}
  p.shadowing = CL.NIL
  p.nicknames = CL.NIL
  p.used = CL.NIL
  p.used_by = CL.NIL
end

setmetatable(CL, CL_LIB["PACKAGE-METATABLE"])
-- Create gensym package
LCL["NIL"] = {name = "NIL"}
NIL = LCL["NIL"]
setmetatable(LCL["NIL"], CL_LIB["PACKAGE-METATABLE"])
-- Block return symbols
LCL["%BR"] = {name = "%BR"}
setmetatable(LCL["%BR"], CL_LIB["PACKAGE-METATABLE"])

complete_package(CL)
complete_package(CL_LIB)
complete_package(LCL["NIL"])
complete_package(LCL["%BR"])
complete_package(KEYWORD)
CL_LIB.used = {CL, CL.NIL}
CL.used_by = {CL_LIB, CL.NIL}

CL_LIB["ALLOC-FUNCTION"].fbound = function (arglist,func, pos, opt, rest, key)
  local this = {}
  this.arglist = arglist
  this.func = func
  this.pos = pos
  this.opt = opt
  this.rest = rest
  this.key = key
  setmetatable(this, CL_LIB["FUNCTION-METATABLE"])
  return this
end
CL_LIB["LUA-DEFUN"].fbound = function (symbol, arglist, func)
  local this = CL_LIB["ALLOC-FUNCTION"](arglist,func)
  symbol.fbound = this
  if getmetatable(func) == CL_LIB["FUNCTION-METATABLE"] then
    func.debugName = tostring(symbol)
  end
  return this
end

CL_LIB["MACRO-METATABLE"].__call = function (fbound, ...)
  return fbound.macro_function(...)
end

function eval (str)
  str = str and CL['READ-FROM-STRING'](str, CL.T, CL.NIL, {}) or CL.READ()
  local result = CL.EVAL(str)
  CL.PRINT(result)
  print()
  return result
end

function lclc (str)
  str = str and CL['READ-FROM-STRING'](str, CL.T, CL.NIL, {}) or CL.READ()
  return CL_LIB["COMPILE-TO-LUA"](str, CL.NIL, CL.NIL)
end

function read (str)
  CL.PRINT(str and CL['READ-FROM-STRING'](str, CL.T, CL.NIL, {}) or CL.READ())
  print()
end

-- Self evaluating symbols
CL.NIL.bound = CL.NIL
-- This allows to optimize (car list) to list[1]
CL.NIL[1] = CL.NIL
CL.NIL[2] = CL.NIL
n = CL.NIL
CL.T.bound = CL.T
CL["&ALLOW-OTHER-KEYS"].bound = CL["&ALLOW-OTHER-KEYS"]
CL["&AUX"]        .bound = CL["&AUX"]
CL["&BODY"]       .bound = CL["&BODY"]
CL["&ENVIRONMENT"].bound = CL["&ENVIRONMENT"]
CL["&KEY"]        .bound = CL["&KEY"]
CL["&OPTIONAL"]   .bound = CL["&OPTIONAL"]
CL["&REST"]       .bound = CL["&REST"]
CL["&WHOLE"]      .bound = CL["&WHOLE"]

---------------------------------
-- NATIVE TYPES IMPLEMENTATION --
---------------------------------

function get_complex_lhsrhs (lhs, rhs)
  local x1, y1, x2, y2
  if getmetatable(lhs) == CL_LIB["COMPLEX-METATABLE"] then
    x1 = lhs.r y1 = lhs.i
  elseif type(lhs) == 'number' then
    x1 = lhs y1 = 0
  else
    error("1070")
  end
  if getmetatable(rhs) == CL_LIB["COMPLEX-METATABLE"] then
    x2 = rhs.r y2 = rhs.i
  elseif type(rhs) == 'number' then
    x2 = rhs y2 = 0
  else
    error("1071")
  end
  return x1, y1, x2, y2
end

function get_rational_lhsrhs (lhs, rhs)
  local n1, d1, n2, d2
  if getmetatable(lhs) == CL_LIB["RATIONAL-METATABLE"] then
    n1 = lhs.n d1 = lhs.d
  elseif type(lhs) == 'number' then
    n1 = lhs d1 = 1
  else
    error("1072")
  end
  if getmetatable(rhs) == CL_LIB["RATIONAL-METATABLE"] then
    n2 = rhs.n d2 = rhs.d
  elseif type(rhs) == 'number' then
    n2 = rhs d2 = 1
  else
    error("1073")
  end
  return n1, d1, n2, d2
end

CL_LIB["COMPLEX-METATABLE"].__add = function (lhs, rhs)
  local a, b, c, d = get_complex_lhsrhs(lhs,rhs)
  local r = a + c
  local i = b + d
  if i == 0 then
    return r
  else
    return CL_LIB["MAKE-COMPLEX"](r, i)
  end
end

CL_LIB["COMPLEX-METATABLE"].__sub = function (lhs, rhs)
  local a, b, c, d = get_complex_lhsrhs(lhs,rhs)
  local r = a - c
  local i = b - d
  if i == 0 then
    return r
  else
    return CL_LIB["MAKE-COMPLEX"](r, i)
  end
end

CL_LIB["COMPLEX-METATABLE"].__mul = function (lhs, rhs)
  local a, b, c, d = get_complex_lhsrhs(lhs,rhs)
  local r = a*c - b*d
  local i = a*d + b*c
  if i == 0 then
    return r
  else
    return CL_LIB["MAKE-COMPLEX"](r, i)
  end
end

CL_LIB["COMPLEX-METATABLE"].__div = function (lhs, rhs)
  local a, b, c, d = get_complex_lhsrhs(lhs,rhs)
  local off = c*c + d*d
  local r = (a*c + b*d) / off
  local i = (b*c - a*d) / off
  if i == 0 then
    return r
  else
    return CL_LIB["MAKE-COMPLEX"](r, i)
  end
end

CL_LIB["COMPLEX-METATABLE"].__eq = function (lhs, rhs)
  if CL.NUMBERP(lhs) ~= CL.NIL and CL.NUMBERP(rhs) ~= CL.NIL then
    local a, b, c, d = get_complex_lhsrhs(lhs,rhs)
    return (a == c) and (b == d)
  else
    return false
  end
end

CL_LIB["COMPLEX-METATABLE"].__tostring = function (o)
  return "#C(" .. tostring(o.r) .. " " .. tostring(o.i) .. ")"
end

CL_LIB["RATIONAL-METATABLE"].__add = function (lhs, rhs)
  local a, b, c, d = get_rational_lhsrhs(lhs,rhs)
  local n = a*d + c*b
  local d = b * d
  return CL_LIB["MAKE-RATIONAL"](n, d)
end

CL_LIB["RATIONAL-METATABLE"].__sub = function (lhs, rhs)
  local a, b, c, d = get_rational_lhsrhs(lhs,rhs)
  local n = a*d - c*b
  local d = b * d
  return CL_LIB["MAKE-RATIONAL"](n, d)
end

CL_LIB["RATIONAL-METATABLE"].__mul = function (lhs, rhs)
  local a, b, c, d = get_rational_lhsrhs(lhs,rhs)
  local n = a*c
  local d = b*d
  return CL_LIB["MAKE-RATIONAL"](n, d)
end

CL_LIB["RATIONAL-METATABLE"].__div = function (lhs, rhs)
  local a, b, c, d = get_rational_lhsrhs(lhs,rhs)
  local n = a*d
  local d = b*c
  return CL_LIB["MAKE-RATIONAL"](n, d)
end

CL_LIB["RATIONAL-METATABLE"].__eq = function (lhs, rhs)
  local a, b, c, d = get_rational_lhsrhs(lhs,rhs)
  local left = a * d
  local right = b * c
  return (left == right)
end

CL_LIB["RATIONAL-METATABLE"].__lt = function (lhs, rhs)
  local a, b, c, d = get_rational_lhsrhs(lhs,rhs)
  local left = a * d
  local right = b * c
  return (left < right)
end

CL_LIB["RATIONAL-METATABLE"].__tostring = function (o)
  return tostring(o.n) .. "/" .. tostring(o.d)
end

CL_LIB["CHAR-METATABLE"].__eq = function (lhs, rhs)
  if getmetatable(lhs) == CL_LIB["CHAR-METATABLE"]
  and getmetatable(rhs) == CL_LIB["CHAR-METATABLE"] then
    return lhs.code == rhs.code
  else
    return false
  end
end

------------------------------------
-- NATIVELY IMPLEMENTED FUNCTIONS --
------------------------------------

-- Interop between Lisp lists and Lua
function unpack_lisp_list(args)
  if args == CL.NIL then
    return
  else
    return args[1] , unpack_lisp_list(args[2])
  end
end

CL_LIB['*MULTIPLE-VALUES-COUNT*'].bound = 1
mvc = CL_LIB['*MULTIPLE-VALUES-COUNT*']
CL_LIB['*MULTIPLE-VALUES-STORAGE*'].bound = { [0] = CL.NIL, CL.NIL, CL.NIL, CL.NIL, CL.NIL, CL.NIL, CL.NIL, CL.NIL, CL.NIL, CL.NIL, CL.NIL, CL.NIL, CL.NIL, CL.NIL, CL.NIL, CL.NIL, CL.NIL, CL.NIL, CL.NIL, CL.NIL}
function single_value ()
  mvc.bound = 20
end


function unpack_mv(vals, len)
  vals = {vals}
  if  CL_LIB['*MULTIPLE-VALUES-COUNT*'].bound ~= 20 then
    vals = {(table.unpack or unpack)(CL_LIB['*MULTIPLE-VALUES-STORAGE*'].bound,0,CL_LIB['*MULTIPLE-VALUES-COUNT*'].bound-1)}
    -- Reset here as it's not required normally
    mvc.bound = 20
  end
  if len then
    for i = 1,len  do vals[i] = vals[i] or CL.NIL end
  end
  return (table.unpack or unpack)(vals)
  -- return vals[1]
end

function pcallmv(func)
  -- inline single_value
  mvc.bound = 20
  local ep, res = pcall(func)
  if ep then
    -- No errors, the return value is as is, we have to take the multiple values if any
    return {error = CL.NIL, unpack_mv(res)}
  else
    if type(res) == 'table' and res.tag then
      -- Standard Common Lisp throw
      res.error = KEYWORD.TAG
      return res
    else
      -- Some native error
      return { res, error = CL.T }
    end
  end
end

function list_r(lst, range)
  range = range or 1
  local ret = CL.NIL
  for i = #lst,range,-1 do
    ret = {lst[i], ret}
  end
  return ret
end

function list(...)
  return list_r({...}, 1)
end
l = list

function k(...)
  local lst = {...}
  local this = {}
  for i = 1,#lst,2 do
    this[lst[i]] = lst[i+1]
  end
  return this
end

function f(symb)
  return l(CL.FUNCTION, symb)
end

function q(symb)
  return l(CL.QUOTE, symb)
end

function ql(...)
  return l(CL.LIST, ...)
end

function c(r, i) return CL_LIB["MAKE-COMPLEX"](r, i) end
function r(n, d) return CL_LIB["MAKE-RATIONAL"](n, d) end

-- count_fl_fast = 0
-- count_fc_fast = 0
-- count_fc_slow = 0
-- count_fc_fb = 0

CL_LIB["LUA-DEFUN"](CL_LIB["FUNCALL-LUA"], nil,
function (func, args)

  -- print("LOG FCL: " .. tostring(func) .. " " .. dump(args))

  local ix_base = 1
  if func == CL_LIB["FUNCALL-LUA"].fbound or func == CL.FUNCALL.fbound then
    func = args[1]
    ix_base = 2
  end

  if getmetatable(func) == CL_LIB["SYMBOL-METATABLE"] then
    func = func.fbound
  end

  if getmetatable(func) == CL_LIB["FUNCTION-METATABLE"] and func.pos then
    -- Fast(er) funcall argument parsing using preprocessed func fields
    -- count_fl_fast = count_fl_fast + 1
    local funcargs = {}
    local num = 1
    local ok = false
    local ix = ix_base
    local len = #args
    -- Positional args
    for i = 1,func.pos do
      funcargs[num] = args[ix]
      num = num + 1
      if ix > len then
        error ("1097 Missing argument: " .. dump(func) .. " " .. dump(args) )
      else
        ix = ix + 1
      end
    end
    -- Optional arguments
    for i = 1, func.opt do
      funcargs[num] = ix <= len and args[ix] or false
      num = num + 1
      ix = ix + 1
    end
    -- Rest argument
    if func.rest then
      ok = true
      funcargs[num] = list_r(args, ix)
      num = num + 1
    end
    -- Key arguments
    if func.key then
      local key = {}
      local nextkey = nil
      while ix <= len do
        local argscar = args[ix]
        if nextkey then
          key[nextkey] = argscar
          nextkey = nil
        else
          nextkey = func.key[argscar]
          -- XXX This is a hack
          if not nextkey and CL['&ALLOW-OTHER-KEYS'] ~= CL.LAST(func.arglist)[1] then
            error("1090 Unknown keyword argument: " .. dump(argscar))
          end
        end
        ix = ix + 1
      end
      if nextkey then error("1085 Odd number of key arguments") end
      funcargs[num] = key
      num = num + 1
    end

    if ok or ix > len then
      return func((table.unpack or unpack)(funcargs))
    else
      error("1088 at " .. tostring(func))
    end
  end
  return CL.FUNCALL(func, list_r(args, ix_base))
end)

function funcall_key_get_actual_symbol(func, key)
  arglist = func.arglist
  while arglist ~= CL.NIL do
    symb = arglist[1]
    if getmetatable(symb) ~= CL_LIB["SYMBOL-METATABLE"] then
      symb = symb[1]
    end
    if symb.name == key.name then
      return symb
    elseif symb[1] == key then
      return symb[2][1]
    end
    arglist = arglist[2]
  end
  return nil
end

-- cl-lib:funcall
-- CL.FUNCALL = CL_LIB.FUNCALL
CL_LIB["LUA-DEFUN"](CL.FUNCALL, l(CL_LIB.FUNC, CL['&REST'], CL_LIB.ARGS), function(func,args)
  -- If we somehow managed to enter a funcall / funcall_lua loop we short it here
  if func == CL_LIB["FUNCALL-LUA"].fbound or func == CL.FUNCALL.fbound then
    func = args[1]
    args = args[2]
  end

  if getmetatable(func) == CL_LIB["SYMBOL-METATABLE"] then
    func = func.fbound
  end

  if getmetatable(func) == CL_LIB["FUNCTION-METATABLE"] and func.pos then
    -- Fast(er) funcall argument parsing using preprocessed func fields
    -- count_fc_fast = count_fc_fast + 1
    local funcargs = {}
    local num = 1
    local ok = false
    -- Positional args
    for i = 1,func.pos do
      funcargs[num] =  args[1]
      num = num + 1
      if args == CL.NIL then
        error ("1097 Missing argument: " .. dump(func) .. " " .. dump(args) )
      else
        args = args[2]
      end
    end
    -- Optional arguments
    for i = 1, func.opt do
      funcargs[num] =  args ~= CL.NIL and args[1] or false
      num = num + 1
      args = args[2]
    end
    -- Rest argument
    if func.rest then
      ok = true
      funcargs[num] = args
      num = num + 1
    end
    -- Key arguments
    if func.key then
      local key = {}
      local nextkey = nil
      while args ~= CL.NIL do
        local argscar = args[1]
        if nextkey then
          key[nextkey] = argscar
          nextkey = nil
        else
          nextkey = func.key[argscar]
          -- XXX This is a hack
          if not nextkey and CL['&ALLOW-OTHER-KEYS'] ~= CL.LAST(func.arglist)[1] then
            error("1091 Unknown keyword argument: " .. dump(func) .. " - ".. dump(argscar))
          end
        end
        args = args[2]
      end
      if nextkey then error("1085 Odd number of key arguments") end
      funcargs[num] = key
      num = num + 1
    end

    if ok or args == CL.NIL then
      return func((table.unpack or unpack)(funcargs))
    else
      error("1088 at " .. tostring(func))
    end
  elseif getmetatable(func) == CL_LIB["FUNCTION-METATABLE"] and func.arglist then
    -- Fallback arglist parsing (old method)
    -- count_fc_slow = count_fc_slow + 1
    local arglist = func.arglist
    local funcargs = {}
    local state = 0
    local key = nil
    local nextkey = nil
    local ok = nil
    -- print(dump(func))
    -- print("CCCC: " .. dump(args))
    while arglist ~= CL.NIL or args ~= CL.NIL do
      local argscar = args ~= CL.NIL and args[1]
      local arglistcar = arglist ~= CL.NIL and arglist[1] or CL.NIL
      -- print("LOOPEXEC:" , state, dump(arglist), dump(args), dump(argscar))
      if arglistcar == CL["&OPTIONAL"] then
        state = 1
        goto funcallcontinue
      elseif arglistcar == CL["&REST"] or arglistcar == CL["&BODY"] then
        state = 2
        goto funcallcontinue
      elseif arglistcar == CL["&KEY"] then
        state = 3
        key = {}
        goto funcallcontinue
      elseif arglistcar == CL["&AUX"] then
        break
      elseif state == 0 then
        if args ~= CL.NIL then
          if argscar == nil then
            error "1022"
          else
            table.insert(funcargs, argscar)
          end
        else
          -- We missing an argument
          error ("1097 Missing argument: " .. dump(func) .. " " .. dump(args) )
        end
      elseif state == 1 then
        if argscar then
          table.insert(funcargs, argscar)
        else
          table.insert(funcargs, false)
        end
      elseif state == 2 then
        table.insert(funcargs, args)
        ok = true
        state = 5
        goto funcallcontinue
      elseif state == 3 then
        if nextkey then
          key[nextkey] = argscar
          nextkey = nil
        else
          if argscar then
            nextkey = funcall_key_get_actual_symbol(func, argscar)
            if not nextkey and CL['&ALLOW-OTHER-KEYS'] ~= CL.LAST(func.arglist)[1] then
              error("1092 Unknown keyword argument: " .. dump(argscar))
            end
          else
            nextkey = argscar
          end
        end
      else
        if ok then break end
        error("1055: " .. dump(args) .. " <> " .. dump(arglist))
      end
      if args ~= CL.NIL then args = args[2] end
      :: funcallcontinue ::
      arglist = arglist ~= CL.NIL and arglist[2] or CL.NIL
      -- print("BBBB: " .. dump(args) .. " <> " .. dump(arglist))
    end
    if key then table.insert(funcargs, key) end

    -- print("AAAA: " .. dump(funcargs) .. " - " .. dump(args))

    if ok or args == CL.NIL then
      return func((table.unpack or unpack)(funcargs))
    else
      error("1088 at " .. tostring(func))
    end
  else
    -- count_fc_fb = count_fc_fb + 1
    -- We assume standard
    if type(func) == 'table' then
      if not getmetatable(func) then
        CL.ERROR("Calling cons cell ~A with args ~A", l(func, args))
      end
      if not rawget(getmetatable(func), "__call") then
        CL.WARN("Calling non-callable object ~A with args ~A", l(func, args))
      end
    end
    return func(unpack_lisp_list(args))
  end
end)

CL_LIB["LUA-DEFUN"](CL["ERROR"], l(CL.DATUM, CL["&REST"], CL_LIB["ARGS"]),
function (datum, rest)
  error("SIMPLE-ERROR " .. dump(datum) .. " " .. dump(rest))
end)

CL_LIB["LUA-DEFUN"](CL["WARN"], l(CL.DATUM, CL["&REST"], CL_LIB["ARGS"]),
function (datum, rest)
  print("WARNING: " .. dump(datum) .. " " .. dump(rest))
end)

CL_LIB["LUA-DEFUN"](CL_LIB["DBG"], l(CL["&REST"], CL["VALUES"]),
function (vals)
  local out = ""
  while vals ~= CL.NIL do
    out = out .. dump(vals[1]) .. " "
    vals = vals[2]
  end
  print(out)
  return CL.NIL
end)

-- cl-lib:id. Identity function
CL_LIB["LUA-DEFUN"](CL_LIB.ID, l(CL_LIB.A), function (a) return a end)
i = CL_LIB.ID

-- cl-lib:lua-null
-- Return a lua nil when the lisp value is cl:nil
CL_LIB["LUA-DEFUN"](CL_LIB["LUA-NULL"], l(CL_LIB.VALUE), function(value)
  if value == CL.NIL then
    return nil
  else
      return value
  end
end)

-- cl:values-list
CL_LIB["LUA-DEFUN"](CL["VALUES-LIST"], l(CL.LIST), function (l)
  -- local tbl = {unpack_lisp_list(l)}
  -- Only pass through the first value, the rest uses the multiple-values-storage array
  -- local tbl = {l[1]}
  local tbl = l[1]

  local i = 0
  while l ~= CL.NIL do
    CL_LIB['*MULTIPLE-VALUES-STORAGE*'].bound[i] = l[1]
    l = l[2]
    i = i + 1
  end
  CL_LIB['*MULTIPLE-VALUES-COUNT*'].bound = i

  -- setmetatable(tbl, CL_LIB["MULTIPLE-VALUES-METATABLE"])
  return tbl
end)

-- cl-lib:macro-setq
-- setq, but sets the macro metatable for the function
CL_LIB["LUA-DEFUN"](CL_LIB["MACRO-SETQ"], l(CL.SYMBOL, CL_LIB.FUNC),
function (symbol, func)
  local f = {macro_function = func}
  setmetatable(f, CL_LIB["MACRO-METATABLE"])
  symbol.fbound = f
  return CL.NIL
end)

-- cl-lib:function-setq
-- setq, but sets the function binding for the symbol
CL_LIB["LUA-DEFUN"](CL_LIB["FUNCTION-SETQ"], l(CL.SYMBOL, CL_LIB.FUNC), function(symbol, func)
  symbol.fbound = func
  if getmetatable(func) == CL_LIB["FUNCTION-METATABLE"] then
    func.debugName = tostring(symbol)
  end
  return func
end)

CL_LIB["LUA-DEFUN"](CL_LIB["SETF-FUNCTION-SETQ"], l(CL.SYMBOL, CL_LIB.FUNC), function(symbol, func)
  symbol.setfbound = func
  if getmetatable(func) == CL_LIB["FUNCTION-METATABLE"] then
    func.debugName = "(SETF " .. tostring(symbol) .. ")"
  end
  return func
end)

-- cl-lib:def
CL_LIB["LUA-DEFUN"](CL_LIB["DEF"], l(CL.SYMBOL, CL["&OPTIONAL"], CL_LIB.VALUE, CL_LIB.DOCUMENTATION),
function(symbol, value, doc)
  value = value or CL.NIL
  symbol.bound = value
  return value
end)

-- cl:list
CL_LIB["LUA-DEFUN"](CL.LIST, { CL["&REST"] , {CL["REST"], CL.NIL} },
function (rest) return rest end)

-- cl:cons
CL_LIB["LUA-DEFUN"](CL.CONS, { CL.CAR , {CL.CDR , CL.NIL} },
function (car, cdr) return {car, cdr} end)

-- cl-lib:make-char
CL_LIB["LUA-DEFUN"](CL_LIB["MAKE-CHAR"], l(CL_LIB.STR, CL["&OPTIONAL"], CL_LIB.OFFSET),
function (str, offset)
  local this = {}
  offset = offset or 0
  offset = offset + 1
  this.char = string.sub(str, offset, offset)
  this.code = string.byte(this.char)
  setmetatable(this, CL_LIB["CHAR-METATABLE"])
  if this.char == "" then
    return CL.NIL
  else
    return this
  end
end)

-- cl-lib:gensym
CL_LIB["LUA-DEFUN"](CL.GENSYM, { CL["&OPTIONAL"] , {CL_LIB.X , CL.NIL }},
function (x)
  x = x or "G"
  local gensymid = CL_LIB["*GENSYM-COUNTER*"].bound
  if type(x) == 'number' then
    return CL_LIB["ALLOC-SYMBOL"](CL.NIL, "G" .. x)
  else
    CL_LIB["*GENSYM-COUNTER*"].bound = CL_LIB["*GENSYM-COUNTER*"].bound + 1
    return CL_LIB["ALLOC-SYMBOL"](CL.NIL, tostring(x) .. gensymid)
  end
end)
-- CL.GENSYM = CL_LIB.GENSYM
CL_LIB["*GENSYM-COUNTER*"].bound = 0

CL_LIB["LUA-DEFUN"](CL['MAKE-PACKAGE'], { CL['PACKAGE-NAME'] , {CL['&KEY'] , {CL_LIB.NICKNAMES, {CL_LIB.USE ,CL.NIL}}}},
function (name, key)
  -- Use symbol name
  if getmetatable(name) == CL_LIB["SYMBOL-METATABLE"] then
    name = name.name
  end
  if LCL[name] then
    CL.ERROR("MAKE-PACKAGE: Package ~S already exists", l(name))
  end
  lst = key[CL_LIB.NICKNAMES] or CL.NIL
  this = {}
  this.name = name
  this.external = {}
  this.shadowing = l()
  this.nicknames = lst
  -- By default use CL
  this.used = key[CL_LIB.USE] or {CL,CL.NIL}
  this.used_by = CL.NIL
  LCL[name] = this
  setmetatable(this, CL_LIB['PACKAGE-METATABLE'])
  while lst ~= CL.NIL do
    if LCL[lst[1]] then
      CL.ERROR("MAKE-PACKAGE: Package (nickname) ~S already exists", l(lst[1]))
    end
    LCL[lst[1]] = this
    lst = lst[2]
  end
  return this
end)


CL_LIB["LUA-DEFUN"](CL_LIB["MAKE-COMPLEX"], l(CL_LIB["REAL"], CL_LIB["IMAG"]),
function (r, i)
  local this = { ['r'] = r, ['i'] = i }
  setmetatable(this, CL_LIB["COMPLEX-METATABLE"])
  return this
end)

function gcd(n, d)
  if d == 0 then return n else return gcd(d, n % d) end
end
CL_LIB["LUA-DEFUN"](CL_LIB["MAKE-RATIONAL"], l(CL_LIB["NUM"], CL_LIB["DENUM"]),
function (n, d)
  local gcd = gcd(n, d)
  local this = { ['n'] = bit.intdiv(n, gcd), ['d'] = bit.intdiv(d, gcd) }
  setmetatable(this, CL_LIB["RATIONAL-METATABLE"])
  return this
end)

-- cl:make-hash-table
CL_LIB["LUA-DEFUN"](CL["MAKE-HASH-TABLE"],
                    l(CL["&KEY"], CL_LIB.TEST, CL_LIB.SIZE, CL_LIB["REHASH-SIZE"], CL_LIB["REHASH-THRESHOLD"]),
function (key)
  local ret = { data = {} }
  setmetatable(ret, CL_LIB["HASH-TABLE-METATABLE"])
  return ret
  end)

-- cl:hash-table-count
CL_LIB["LUA-DEFUN"](CL["HASH-TABLE-COUNT"], l(CL_LIB.HASHTABLE),
function (ht)
  local count = 0
  for _ in pairs(ht.data) do count = count + 1 end
  return count
end)

-- cl:clrhash
CL_LIB["LUA-DEFUN"](CL.CLRHASH, l(CL_LIB.HASHTABLE),
function (ht)
  ht.data = {}
  return ht
end)

-- cl:gethash
CL_LIB["LUA-DEFUN"](CL.GETHASH, l(CL_LIB.KEY, CL_LIB.HASHTABLE, CL["&OPTIONAL"], CL_LIB.DEFAULT),
function (key, ht, default)
  default = default or CL.NIL
  local dat = ht.data[key]
  return CL.VALUES(l(dat or default, dat and CL.T or CL.NIL))
end)

-- cl-lib:sethash
CL_LIB["LUA-DEFUN"](CL_LIB.SETHASH, l(CL_LIB.KEY, CL_LIB.HASHTABLE, CL_LIB.VALUE),
function (key, ht, value)
  ht.data[key] = value
  return value
end)

CL_LIB["LUA-DEFUN"](CL_LIB["ALLOC-ARRAY"], l(),
function ()
  local this = {}
  setmetatable(this, CL_LIB['ARRAY-METATABLE'])
  return this
end)

-- Structs

CL_LIB["LUA-DEFUN"](CL_LIB["ALLOC-STRUCT"], l(),
function ()
  local this = {}
  setmetatable(this, CL_LIB['STRUCT-METATABLE'])
  return this
end)

CL_LIB["LUA-DEFUN"](CL["COPY-STRUCTURE"], l(CL_LIB.STRUCT),
function (struct)
  local this = CL_LIB["ALLOC-STRUCT"]()
  for key, val in pairs(struct) do
    this[key] = val
  end
  return this
end)

CL_LIB["LUA-DEFUN"](CL_LIB["WRITE-STRUCT-TOSTRING"], l(),
function (struct, stream)
  nokeys = {}
  CL['WRITE-STRING']("#S(", stream, nokeys)
  CL['WRITE-STRING'](struct.name.name, stream, nokeys)
  for key, val in pairs(struct) do
    if getmetatable(key) == CL_LIB['SYMBOL-METATABLE'] then
      CL['WRITE-STRING'](" :", stream, nokeys)
      CL['WRITE-STRING'](key.name, stream, nokeys)
      CL['WRITE-STRING'](" ", stream, nokeys)
      CL['PRINT-OBJECT'](l(val, stream))
    end
  end
  CL['WRITE-STRING'](")", stream, nokeys)
  return CL.NIL
end)

-----------------
-- QUOTED DATA --
-----------------

QUOTE = {name = "QUOTE", data = {}}
setmetatable(QUOTE, CL_LIB["PACKAGE-METATABLE"])
CL_LIB["LUA-DEFUN"](QUOTE.ALLOC, l(CL_LIB.DATA),
function (data)
  newnum = 1 + #QUOTE.data
  table.insert(QUOTE.data, data)
  return "QUOTE.data[" .. newnum .. "]"
end)

-------------------------------
-- COMPILER HELPER FUNCTIONS --
-------------------------------

CL_LIB["LUA-DEFUN"](CL_LIB["CONCAT-STRING"], nil,
function (a, b, ...)
  if a then
    if b then
      if type(a) == 'table' then
        error("Trying to concat table type " .. dump(a))
      end
      if type(b) == 'table' then
        error("Trying to concat table type " .. dump(b))
      end
      return CL_LIB["CONCAT-STRING"](a .. b, ...)
    else
      return a
    end
  else
    return ""
  end
end)

CL_LIB["LUA-DEFUN"](CL_LIB["NUMBER-TO-LUA"], l(CL.NUMBER),
function (number)
  if getmetatable(number) == CL_LIB["COMPLEX-METATABLE"] then
    return "c(" .. number.r .. "," .. number.i .. ")"
  elseif getmetatable(number) == CL_LIB["RATIONAL-METATABLE"] then
    return "r(" .. number.n .. "," .. number.d .. ")"
  else
    return "" .. number
  end
end)

CL_LIB["LUA-DEFUN"](CL_LIB["STRING-TO-LUA"], l(CL_LIB.STR),
function (str) return CL_LIB["%QUOTE-TO-LUA"](str) end)

CL_LIB["LUA-DEFUN"](CL_LIB["%QUOTE-TO-LUA"], l(CL_LIB.STR, CL_LIB.ENV),
function (str, env) return QUOTE.ALLOC(str) end)

CL_LIB["LUA-DEFUN"](CL_LIB["%IN-PACKAGE"], l(CL_LIB.PACK),
function (pack) return pack end)

CL_LIB["LUA-DEFUN"](CL_LIB["CALL-TO-LUA"], l(CL_LIB.AST, CL_LIB.ENV, CL_LIB.CTX),
function (ast, env, ctx)
  local func = ast[1]
  local funcall_args = {}

  -- FIXME To allow for local macro defintions, this has to change
  if getmetatable(rawget(func,'fbound')) == CL_LIB["MACRO-METATABLE"] then
    -- Execute the macro and call compile again with the result
    return CL_LIB["COMPILE-TO-LUA"](func.fbound.macro_function(ast, env), env, ctx)
  else
    return CL_LIB["FUNCTION-CALL-TO-LUA"](ast, env, ctx)
  end
end)

-- Manually include some required funcitons for later bootstrap steps (init.lisp)
-- CL_LIB["MACRO-SETQ"]((LCL["COMMON-LISP"]["DEFMACRO"]),CL_LIB["ALLOC-FUNCTION"]({(LCL["CL-LIB"]["NAME"]),{(LCL["CL-LIB"]["ARGLIST"]),{(LCL["COMMON-LISP"]["&BODY"]),{(LCL["CL-LIB"]["BODY"]),(LCL["COMMON-LISP"]["NIL"])}}}},function (l1, l2, l3,  ...)   return CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["LIST"]).fbound,(LCL["COMMON-LISP"]["SETQ"]),CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["LIST"]).fbound,(LCL["COMMON-LISP"]["MACRO-FUNCTION"]),CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["LIST"]).fbound,(LCL["COMMON-LISP"]["QUOTE"]),l1)),CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["LIST"]).fbound,(LCL["COMMON-LISP"]["FUNCTION"]),CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["CONS"]).fbound,(LCL["COMMON-LISP"]["LAMBDA"]),CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["CONS"]).fbound,l2,l3)))) end)) CL_LIB.ID( CL_LIB["MACRO-SETQ"]((LCL["COMMON-LISP"]["LET"]),CL_LIB["ALLOC-FUNCTION"]({(LCL["COMMON-LISP"]["&REST"]),{(LCL["COMMON-LISP"]["REST"]),(LCL["COMMON-LISP"]["NIL"])}},function (l1,  ...)   return CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["LIST*"]).fbound,(LCL["CL-LIB"]["%LET"]),l1) end)) );
CL_LIB["MACRO-SETQ"]((LCL["COMMON-LISP"]["DEFMACRO"]),CL_LIB["ALLOC-FUNCTION"]({(LCL["CL-LIB"]["FORM"]),{(LCL["COMMON-LISP"]["&OPTIONAL"]),{(LCL["CL-LIB"]["ENV"]),(LCL["COMMON-LISP"]["NIL"])}}},function (l1, l2,  ...)  if not l2 then  l2 = (LCL["COMMON-LISP"]["NIL"]).bound end  local l3 = CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["SECOND"]).fbound,l1); local l4 = CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["THIRD"]).fbound,l1); local l5 = CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["CDDDR"]).fbound,l1); return CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["LIST"]).fbound,(LCL["COMMON-LISP"]["SETQ"]),CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["LIST"]).fbound,(LCL["COMMON-LISP"]["MACRO-FUNCTION"]),CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["LIST"]).fbound,(LCL["COMMON-LISP"]["QUOTE"]),l3)),CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["LIST"]).fbound,(LCL["COMMON-LISP"]["FUNCTION"]),CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["LIST"]).fbound,(LCL["COMMON-LISP"]["LAMBDA"]),{(LCL["CL-LIB"]["FORM"]),{(LCL["COMMON-LISP"]["&OPTIONAL"]),{(LCL["CL-LIB"]["ENV"]),(LCL["COMMON-LISP"]["NIL"])}}},CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["LIST*"]).fbound,(LCL["COMMON-LISP"]["APPLY"]),CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["LIST"]).fbound,(LCL["COMMON-LISP"]["FUNCTION"]),CL_LIB["FUNCALL-LUA"]( (LCL["COMMON-LISP"]["LIST*"]).fbound,(LCL["COMMON-LISP"]["LAMBDA"]),l4,l5)),{{(LCL["COMMON-LISP"]["CDR"]),{(LCL["CL-LIB"]["FORM"]),(LCL["COMMON-LISP"]["NIL"])}},(LCL["COMMON-LISP"]["NIL"])})))) end))

local mvc = mvc
local CL = CL
local CL_LIB = CL_LIB
local n = n
local i = i
 tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["MACRO-SETQ"](CL["LET"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G34276"],{CL["&OPTIONAL"],{LCL["NIL"]["G34277"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  return CL["CONS"](CL_LIB["%LET"], CL["APPEND"](l(l5,n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DEFUN"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G34307"],{CL["&OPTIONAL"],{LCL["NIL"]["G34308"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  single_value();  local l14 = n if n ~= CL["STRINGP"]((l13)[1]) then  l14 = (l13)[2] else  l14 = l13 end return CL["CONS"](CL["SETQ"], CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](l5, n)), CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](l9, CL["APPEND"](l(l14,n)))), n)), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["THE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G34389"],{CL["&OPTIONAL"],{LCL["NIL"]["G34390"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  single_value();  return l9 end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["PROGN"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G34457"],{CL["&OPTIONAL"],{LCL["NIL"]["G34458"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  return CL["CONS"](CL["LET"], CL["CONS"](n, CL["APPEND"](l(l5,n)))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["COND"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G34489"],{CL["&OPTIONAL"],{LCL["NIL"]["G34490"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = n if n ~= l5 then  local l7 = (l5)[1]; local l8 = (l5)[2]; single_value();  l6 = CL["CONS"](CL["IF"], CL["CONS"]((l7)[1], CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l((l7)[2],n))), CL["CONS"](CL["CONS"](CL["COND"], CL["APPEND"](l(l8,n))), n)))) else  l6 = n.bound end return l6 end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["AND"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G34530"],{CL["&OPTIONAL"],{LCL["NIL"]["G34531"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = n if n ~= CL["NULL"](l5) then  single_value();  l6 = CL["T"].bound else  local l7 = n if n ~= CL["ENDP"]((l5)[2]) then  single_value();  l7 = (l5)[1] else  local l8 = n if n ~= CL["T"].bound then  single_value();  l8 = CL["CONS"](CL["IF"], CL["CONS"]((l5)[1], CL["CONS"](CL["CONS"](CL["AND"], CL["APPEND"](l((l5)[2],n))), n))) else  l8 = n.bound end l7 = l8 end l6 = l7 end return l6 end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["OR"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G34575"],{CL["&OPTIONAL"],{LCL["NIL"]["G34576"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = n if n ~= CL["NULL"](l5) then  single_value();  l6 = n.bound else  local l7 = n if n ~= CL["NULL"]((l5)[2]) then  single_value();  l7 = (l5)[1] else  local l8 = n if n ~= CL["T"].bound then  single_value();  local l9 = CL["GENSYM"](false); single_value();  l8 = CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l9, CL["CONS"]((l5)[1], n)), n), CL["CONS"](CL["CONS"](CL["IF"], CL["CONS"](l9, CL["CONS"](l9, CL["CONS"](CL["CONS"](CL["OR"], CL["APPEND"](l((l5)[2],n))), n)))), n))) else  l8 = n.bound end l7 = l8 end l6 = l7 end return l6 end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["WHEN"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G34631"],{CL["&OPTIONAL"],{LCL["NIL"]["G34632"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  return CL["CONS"](CL["IF"], CL["CONS"](l5, CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(l9,n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["UNLESS"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G34686"],{CL["&OPTIONAL"],{LCL["NIL"]["G34687"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  return CL["CONS"](CL["IF"], CL["CONS"](l5, CL["CONS"](n, CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(l9,n))), n)))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["LAMBDA"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G34742"],{CL["&OPTIONAL"],{LCL["NIL"]["G34743"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  return CL["CONS"](CL["FUNCTION"], CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](l5, CL["APPEND"](l(l9,n)))), n)) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["CASE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G34797"],{CL["&OPTIONAL"],{LCL["NIL"]["G34798"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l10, CL["CONS"](l5, n)), n), CL["CONS"](CL["CONS"](CL["COND"], CL["APPEND"](l(CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["CLAUSE"],n},function (l11,  ...)   single_value();  local l13 = CL["EQ"]((l11)[1], CL["T"].bound); single_value();  local l14 = n if n ~= l13 then  l14 = l13 else  l14 = CL["EQ"]((l11)[1], CL["OTHERWISE"]) end local l12 = n if n ~= l14 then  single_value();  l12 = CL["T"] else  local l15 = n if n ~= CL["LISTP"]((l11)[1]) then  single_value();  l15 = CL["LIST"](l(CL["MEMBER"],l10,CL["LIST"](l(CL["QUOTE"],(l11)[1])))) else  local l16 = n if n ~= CL["T"].bound then  single_value();  l16 = CL["LIST"](l(CL["EQL"],l10,CL["LIST"](l(CL["QUOTE"],(l11)[1])))) else  l16 = n.bound end l15 = l16 end l12 = l15 end return CL["CONS"](l12, (l11)[2]) end, 1, 0, false, false), l(l9)),n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["CCASE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G34893"],{CL["&OPTIONAL"],{LCL["NIL"]["G34894"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  return CL["CONS"](CL["ECASE"], CL["CONS"](l5, CL["APPEND"](l(l9,n)))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["ECASE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G34946"],{CL["&OPTIONAL"],{LCL["NIL"]["G34947"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  return CL["CONS"](CL["CASE"], CL["CONS"](l5, CL["APPEND"](l(l9,CL["CONS"](CL["CONS"](CL["T"], CL["CONS"](CL["CONS"](CL["ERROR"], CL["CONS"]("ECASE", n)), n)), n))))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DEFVAR"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G35004"],{CL["&OPTIONAL"],{LCL["NIL"]["G35005"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = n if n ~= l4 then  local l11 = l4; single_value();  local l12 = (l11)[1]; single_value();  single_value();  local l13 = (l11)[2]; single_value();  l4 = l13 i( l4 );
 single_value();  l10 = l12 else  l10 = n.bound end local l9 = l10; single_value();  local l15 = n if n ~= l4 then  local l16 = l4; single_value();  local l17 = (l16)[1]; single_value();  single_value();  local l18 = (l16)[2]; single_value();  l4 = l18 i( l4 );
 single_value();  l15 = l17 else  l15 = n.bound end local l14 = l15; single_value();  single_value();  local l19 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l19, CL["CONS"](l9, n)), n), CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"]("CL_LIB.DEF(", CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), CL["CONS"](",", CL["CONS"](l19, CL["CONS"](")", n)))))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DEFPARAMETER"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G35113"],{CL["&OPTIONAL"],{LCL["NIL"]["G35114"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = n if n ~= l4 then  local l11 = l4; single_value();  local l12 = (l11)[1]; single_value();  single_value();  local l13 = (l11)[2]; single_value();  l4 = l13 i( l4 );
 single_value();  l10 = l12 else  l10 = n.bound end local l9 = l10; single_value();  local l15 = n if n ~= l4 then  local l16 = l4; single_value();  local l17 = (l16)[1]; single_value();  single_value();  local l18 = (l16)[2]; single_value();  l4 = l18 i( l4 );
 single_value();  l15 = l17 else  l15 = n.bound end local l14 = l15; single_value();  single_value();  local l19 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l19, CL["CONS"](l9, n)), n), CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"]("CL_LIB.DEF(", CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), CL["CONS"](",", CL["CONS"](l19, CL["CONS"](")", n)))))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DEFCONSTANT"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G35222"],{CL["&OPTIONAL"],{LCL["NIL"]["G35223"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = n if n ~= l4 then  local l11 = l4; single_value();  local l12 = (l11)[1]; single_value();  single_value();  local l13 = (l11)[2]; single_value();  l4 = l13 i( l4 );
 single_value();  l10 = l12 else  l10 = n.bound end local l9 = l10; single_value();  local l15 = n if n ~= l4 then  local l16 = l4; single_value();  local l17 = (l16)[1]; single_value();  single_value();  local l18 = (l16)[2]; single_value();  l4 = l18 i( l4 );
 single_value();  l15 = l17 else  l15 = n.bound end local l14 = l15; single_value();  single_value();  local l19 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l19, CL["CONS"](l9, n)), n), CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"]("CL_LIB.DEF(", CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), CL["CONS"](",", CL["CONS"](l19, CL["CONS"](")", n)))))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["PROG1"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G35331"],{CL["&OPTIONAL"],{LCL["NIL"]["G35332"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l10, CL["CONS"](l5, n)), n), CL["APPEND"](l(l9,CL["CONS"](l10, n))))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["PROG2"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G35392"],{CL["&OPTIONAL"],{LCL["NIL"]["G35393"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  single_value();  return CL["CONS"](CL["PROG1"], CL["CONS"](CL["CONS"](CL["PROGN"], CL["CONS"](l5, CL["CONS"](l9, n))), CL["APPEND"](l(l13,n)))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["LOCALLY"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G35469"],{CL["&OPTIONAL"],{LCL["NIL"]["G35470"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  return CL["CONS"](CL["PROGN"], CL["APPEND"](l(l5,n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["LET*"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G35500"],{CL["&OPTIONAL"],{LCL["NIL"]["G35501"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = n if n ~= l5 then  l10 = CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"]((l5)[1], n), CL["CONS"](CL["CONS"](CL["LET*"], CL["CONS"]((l5)[2], CL["APPEND"](l(l9,n)))), n))) else  l10 = CL["CONS"](CL["PROGN"], CL["APPEND"](l(l9,n))) end return l10 end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["PROG"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G35560"],{CL["&OPTIONAL"],{LCL["NIL"]["G35561"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  return CL["CONS"](CL["BLOCK"], CL["CONS"](n, CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](l5, CL["CONS"](CL["CONS"](CL["TAGBODY"], CL["APPEND"](l(l9,n))), n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["PROG*"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G35618"],{CL["&OPTIONAL"],{LCL["NIL"]["G35619"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  return CL["CONS"](CL["BLOCK"], CL["CONS"](n, CL["CONS"](CL["CONS"](CL["LET*"], CL["CONS"](l5, CL["CONS"](CL["CONS"](CL["TAGBODY"], CL["APPEND"](l(l9,n))), n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DECLARE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G35676"],{CL["&OPTIONAL"],{LCL["NIL"]["G35677"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  return n.bound end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DECLAIM"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G35704"],{CL["&OPTIONAL"],{LCL["NIL"]["G35705"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  return n.bound end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["PROCLAIM"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G35732"],{CL["&OPTIONAL"],{LCL["NIL"]["G35733"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  return n.bound end, 1, 1, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["LUA-INDEX-TABLE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G38311"],{CL["&OPTIONAL"],{LCL["NIL"]["G38312"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l14 = n if n ~= l4 then  local l15 = l4; single_value();  local l16 = (l15)[1]; single_value();  single_value();  local l17 = (l15)[2]; single_value();  l4 = l17 i( l4 );
 single_value();  l14 = l16 else  l14 = n.bound end local l13 = l14; single_value();  single_value();  local l18 = CL["GENSYM"](false); local l19 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l18, CL["CONS"](l9, n)), CL["CONS"](CL["CONS"](l19, CL["CONS"](l13, n)), n)), CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"]("((", CL["CONS"](l5, CL["CONS"](")[", CL["CONS"](l18, CL["CONS"]("] or ", CL["CONS"](l19, CL["CONS"](")", n)))))))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["LUA-RAW-INDEX-TABLE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G38423"],{CL["&OPTIONAL"],{LCL["NIL"]["G38424"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  single_value();  return CL["CONS"](CL_LIB["LUA"], CL["CONS"]("((", CL["CONS"](l5, CL["CONS"](")[", CL["CONS"](CL["CONS"](CL["IDENTITY"], CL["CONS"](l9, n)), CL["CONS"]("])", n)))))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["LUA-SET-TABLE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G38499"],{CL["&OPTIONAL"],{LCL["NIL"]["G38500"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l14 = l4; single_value();  local l15 = (l14)[1]; single_value();  single_value();  local l16 = (l14)[2]; single_value();  l4 = l16 i( l4 );
 single_value();  local l13 = l15; single_value();  single_value();  local l17 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l17, CL["CONS"](l13, n)), n), CL["CONS"](CL["CONS"](CL_LIB["LUA-PUSH"], CL["CONS"](CL["CONS"](l5, CL["CONS"]("[", CL["CONS"](CL["CONS"](CL["IDENTITY"], CL["CONS"](l9, n)), CL["CONS"]("] = ", CL["CONS"](l17, n))))), CL["CONS"](l17, n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["LUA-GET-METATABLE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G38608"],{CL["&OPTIONAL"],{LCL["NIL"]["G38609"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  single_value();  return CL["CONS"](CL_LIB["LUA"], CL["CONS"]("(getmetatable(", CL["CONS"](l5, CL["CONS"](") or n)", n)))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["LUA-CALL"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G38659"],{CL["&OPTIONAL"],{LCL["NIL"]["G38660"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  return CL["CONS"](CL["FUNCALL"], CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"](l5, n)), CL["APPEND"](l(l9,n)))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["LUA-MCALL"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G38714"],{CL["&OPTIONAL"],{LCL["NIL"]["G38715"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  single_value();  local l14 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l14, CL["CONS"](l5, n)), n), CL["CONS"](CL["CONS"](CL["FUNCALL"], CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"](l14, CL["CONS"](".", CL["CONS"](l9, n)))), CL["APPEND"](l(CL["CONS"](l14, l13),n)))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["%MODF"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G38803"],{CL["&OPTIONAL"],{LCL["NIL"]["G38804"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  single_value();  return CL["CONS"](CL_LIB["LUA"], CL["CONS"]("(({math.modf(", CL["CONS"](l5, CL["CONS"](")})[2])", n)))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["%BREAK"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G38854"],{CL["&OPTIONAL"],{LCL["NIL"]["G38855"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = n if n ~= l4 then  local l7 = l4; single_value();  local l8 = (l7)[1]; single_value();  single_value();  local l9 = (l7)[2]; single_value();  l4 = l9 i( l4 );
 single_value();  l6 = l8 else  l6 = n.bound end local l5 = l6; single_value();  single_value();  return CL["CONS"](CL_LIB["LUA-PUSH"], CL["CONS"](CL["CONS"]("do break end;", n), CL["CONS"](l5, n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["%RETURN"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G38906"],{CL["&OPTIONAL"],{LCL["NIL"]["G38907"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = n if n ~= l4 then  local l7 = l4; single_value();  local l8 = (l7)[1]; single_value();  single_value();  local l9 = (l7)[2]; single_value();  l4 = l9 i( l4 );
 single_value();  l6 = l8 else  l6 = n.bound end local l5 = l6; single_value();  single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](CL_LIB["V"], CL["CONS"](l5, n)), n), CL["CONS"](CL["CONS"](CL_LIB["LUA-PUSH"], CL["CONS"](CL["CONS"]("do return ", CL["CONS"](CL_LIB["V"], CL["CONS"](" end;", n))), CL["CONS"](n, n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["TOSTRING"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJ"],n},function (l1,  ...)   single_value();  return tostring(l1) end, 1, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["LUA-ARRAY"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G38973"],{CL["&OPTIONAL"],{LCL["NIL"]["G38974"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  return CL["CONS"](CL_LIB["LUA"], CL["CONS"]("{", CL["APPEND"](l(CL["MAPCAN"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l6,  ...)   single_value();  return CL["LIST"](l(CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](CL_LIB["EL"], CL["CONS"](l6, n)), n), CL["CONS"](CL_LIB["EL"], n))),", ")) end, 1, 0, false, false), l(l5)),CL["CONS"]("}", n))))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["LUA-NILP"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G39023"],{CL["&OPTIONAL"],{LCL["NIL"]["G39024"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  single_value();  return CL["CONS"](CL_LIB["LUA"], CL["CONS"]("nil == ", CL["CONS"](CL["CONS"](CL["IDENTITY"], CL["CONS"](l5, n)), CL["CONS"](" and CL.T or n", n)))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%PAIRS-VALUE-LIST"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["TABLE"],{CL["&KEY"],{CL_LIB["TEST"],n}}},function (l1, keys,  ...)  if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end  i( "Get the values in a TABLE into a list. The values can be filtered with the TEST predicate." );
 single_value();  local l2 = n.bound; for __k, __v in pairs(l1) do  local l3 = __k; local l4 = __v; single_value();  local l6 = CL["NOT"](keys[CL_LIB["TEST"]]); single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  local l8 = l4; single_value();  l7 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["TEST"]],{l8, }) end local l5 = n if n ~= l7 then  single_value();  single_value();  single_value();  local l9 = CL["CONS"](l4, l2); single_value();  l2 = l9 l5 = l2 else  l5 = n.bound end local tmpres = l5 end i( n );
 single_value();  return l2 end, 1, 0, false, {0 , [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"]})); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["%NLR"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G39111"],{CL["&OPTIONAL"],{LCL["NIL"]["G39112"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  single_value();  local l14 = CL["FIRST"](l5); local l15 = CL["SECOND"](l5); single_value();  return CL_LIB["%NON-LOCAL-RETURN"](l14, l15, l9, l13) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["THROW"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G39187"],{CL["&OPTIONAL"],{LCL["NIL"]["G39188"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  single_value();  return CL["CONS"](CL_LIB["LUA"], CL["CONS"]("error({tag=", CL["CONS"](CL["CONS"](CL["IDENTITY"], CL["CONS"](l5, n)), CL["CONS"](",(function () single_value() return unpack_mv(", CL["CONS"](l9, CL["CONS"](") end)()})", n)))))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["CATCH"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G39263"],{CL["&OPTIONAL"],{LCL["NIL"]["G39264"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  return CL["CONS"](CL_LIB["%NLR"], CL["CONS"](CL["CONS"](LCL["KEYWORD"]["TAG"], CL["CONS"](l5, n)), CL["CONS"](n, CL["APPEND"](l(l9,n))))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["UNWIND-PROTECT"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G39319"],{CL["&OPTIONAL"],{LCL["NIL"]["G39320"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  return CL["CONS"](CL_LIB["%NLR"], CL["CONS"](n, CL["CONS"](l9, CL["CONS"](l5, n)))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["LET"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G39372"],{CL["&OPTIONAL"],{LCL["NIL"]["G39373"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l11 = n if n ~= l5 then  l11 = CL["SOME"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l12,  ...)   single_value();  local l13 = n if n ~= CL["CONSP"](l12) then  l13 = (l12)[1] else  l13 = l12 end return CL["BOUNDP"](l13) end, 1, 0, false, false), l(l5)) else  l11 = n.bound end local l10 = n if n ~= l11 then  local l14 = n.bound; single_value();  local l15 = CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l16,  ...)   single_value();  local l18 = n if n ~= CL["CONSP"](l16) then  l18 = (l16)[1] else  l18 = l16 end local l17 = l18; local l20 = n if n ~= CL["CONSP"](l16) then  l20 = CL["CADR"](l16) else  l20 = n.bound end local l19 = l20; single_value();  local l21 = n if n ~= CL["BOUNDP"](l17) then  local l22 = CL["GENSYM"](false); single_value();  single_value();  local l23 = CL["CONS"](CL["LIST"](l(l22,l17)), l14); single_value();  l14 = l23 i( l14 );
 single_value();  l21 = CL["LIST"](l(l22,CL["CONS"](CL["PROG1"], CL["CONS"](l17, CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](l17, CL["CONS"](l19, n))), n))))) else  l21 = l16 end return l21 end, 1, 0, false, false), l(l5)); single_value();  single_value();  l10 = CL["CONS"](CL_LIB["%LET"], CL["CONS"](l14, CL["CONS"](CL["CONS"](CL["UNWIND-PROTECT"], CL["CONS"](CL["CONS"](CL_LIB["%LET"], CL["CONS"](l15, CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(l9,n))), n))), CL["APPEND"](l(CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SP"],n},function (l24,  ...)   single_value();  return CL["CONS"](CL["SETQ"], CL["CONS"](CL["CADR"](l24), CL["CONS"]((l24)[1], n))) end, 1, 0, false, false), l(l14)),n)))), n))) else  l10 = CL["CONS"](CL_LIB["%LET"], CL["CONS"](l5, CL["APPEND"](l(l9,n)))) end return l10 end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["RETURN-FROM"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G39512"],{CL["&OPTIONAL"],{LCL["NIL"]["G39513"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = n if n ~= l4 then  local l11 = l4; single_value();  local l12 = (l11)[1]; single_value();  single_value();  local l13 = (l11)[2]; single_value();  l4 = l13 i( l4 );
 single_value();  l10 = l12 else  l10 = n.bound end local l9 = l10; single_value();  single_value();  local l14 = CL_LIB["BLOCK-TO-TAGNAME"](l5); local l15 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l15, CL["CONS"](CL["CONS"](CL["MULTIPLE-VALUE-LIST"], CL["CONS"](l9, n)), n)), n), CL["CONS"](CL["CONS"](CL["THROW"], CL["CONS"](l14, CL["CONS"](CL["CONS"](CL["VALUES-LIST"], CL["CONS"](l15, n)), n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["RETURN"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G39599"],{CL["&OPTIONAL"],{LCL["NIL"]["G39600"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = n if n ~= l4 then  local l7 = l4; single_value();  local l8 = (l7)[1]; single_value();  single_value();  local l9 = (l7)[2]; single_value();  l4 = l9 i( l4 );
 single_value();  l6 = l8 else  l6 = n.bound end local l5 = l6; single_value();  single_value();  return CL["CONS"](CL["RETURN-FROM"], CL["CONS"](n, CL["CONS"](l5, n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["BLOCK"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G39650"],{CL["&OPTIONAL"],{LCL["NIL"]["G39651"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = CL_LIB["BLOCK-TO-TAGNAME"](l5); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l10, CL["CONS"](CL["CONS"](CL["GENSYM"], n), n)), n), CL["CONS"](CL["CONS"](CL["CATCH"], CL["CONS"](l10, CL["APPEND"](l(l9,n)))), n))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   i( "Returns the car of the given cons cell." );
 single_value();  local l2 = n if n ~= l1 then  local l3 = n if n ~= CL["CONSP"](l1) then  l3 = l1[1] else  l3 = CL["ERROR"]("Taking CAR of not a list ~S ", l(l1)) end l2 = l3 else  l2 = n.bound end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CDR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   i( "Returns the cdr of the given cons cell." );
 single_value();  local l2 = n if n ~= l1 then  local l3 = n if n ~= CL["CONSP"](l1) then  l3 = l1[2] else  l3 = CL["ERROR"]("Taking CDR of not a list ~S ", l(l1)) end l2 = l3 else  l2 = n.bound end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["RPLACA"] , CL_LIB["ALLOC-FUNCTION"]({CL["CONS"],{CL_LIB["OBJECT"],n}},function (l1, l2,  ...)   single_value();  l1[1] = l2 return l2 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["RPLACD"] , CL_LIB["ALLOC-FUNCTION"]({CL["CONS"],{CL_LIB["OBJECT"],n}},function (l1, l2,  ...)   single_value();  l1[2] = l2 return l2 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CONS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["LEFT"],{CL_LIB["RIGHT"],n}},function (l1, l2,  ...)   i( "Construct a cons cell" );
 single_value();  return {l1,l2} end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LIST"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL["LIST"],n}},function (l1,  ...)   single_value();  return l1 end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CONSP"] , CL_LIB["ALLOC-FUNCTION"]({CL["CONS"],n},function (l1,  ...)   single_value();  return ('table' == type(l1) and nil == getmetatable(l1)) and CL.T or n end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%CONSP"] , CL_LIB["ALLOC-FUNCTION"]({CL["CONS"],n},function (l1,  ...)   i( "More precise but slow version of consp" );
 single_value();  local l2 = n if n ~= CL["EQ"]("table", type(l1)) then  local l3 = n if n ~= CL["EQ"](2, CL_LIB["%LEN"](l1)) then  l3 = CL["NULL"]((getmetatable(l1) or n)) else  l3 = n.bound end l2 = l3 else  l2 = n.bound end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["EQ"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],{CL_LIB["Y"],n}},function (l1, l2,  ...)   single_value();  return ((l1 == l2 ) and CL.T or n) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR-CODE"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],n},function (l1,  ...)   single_value();  local l2 = "code"; local l3 = n.bound; single_value();  return ((l1)[l2] or l3) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CODE-CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["CODE"],n},function (l1,  ...)   single_value();  return CL_LIB["MAKE-CHAR"](string.char(l1), false) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["CHAR-STRING"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],n},function (l1,  ...)   single_value();  local l2 = "char"; local l3 = n.bound; single_value();  return ((l1)[l2] or l3) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR-DOWNCASE"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],n},function (l1,  ...)   single_value();  return CL_LIB["MAKE-CHAR"](string.lower(CL_LIB["CHAR-STRING"](l1)), false) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR-UPCASE"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],n},function (l1,  ...)   single_value();  return CL_LIB["MAKE-CHAR"](string.upper(CL_LIB["CHAR-STRING"](l1)), false) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHARACTERP"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],n},function (l1,  ...)   single_value();  return CL["EQ"]((getmetatable(l1) or n), CL_LIB["CHAR-METATABLE"].bound) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%STRINGP"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],n},function (l1,  ...)   single_value();  return ((type(l1) == 'string') and CL.T or n) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["COMPLEXP"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL["EQ"]((getmetatable(l1) or n), CL_LIB["COMPLEX-METATABLE"].bound) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%RATIONALP"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL["EQ"]((getmetatable(l1) or n), CL_LIB["RATIONAL-METATABLE"].bound) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%NUMBERP"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return ((type(l1) == 'number') and CL.T or n) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["CHARP"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],n},function (l1,  ...)   single_value();  return CL["EQ"]((getmetatable(l1) or n), CL_LIB["CHAR-METATABLE"].bound) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SYMBOLP"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],n},function (l1,  ...)   single_value();  return CL["EQ"]((getmetatable(l1) or n), CL_LIB["SYMBOL-METATABLE"].bound) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SYMBOL-NAME"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],n},function (l1,  ...)   single_value();  local l2 = "name"; local l3 = n.bound; single_value();  return ((l1)[l2] or l3) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SYMBOL-PACKAGE"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],n},function (l1,  ...)   single_value();  local l2 = "package"; local l3 = n.bound; single_value();  return ((l1)[l2] or l3) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PACKAGE-NAME"] , CL_LIB["ALLOC-FUNCTION"]({CL["PACKAGE"],n},function (l1,  ...)   single_value();  local l2 = "name"; local l3 = n.bound; single_value();  return ((l1)[l2] or l3) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%GET-PACKAGE-BY-NAME"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NAME"],n},function (l1,  ...)   single_value();  local l2 = l1; local l3 = n.bound; single_value();  return ((LCL)[l2] or l3) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["INTERN"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL["&OPTIONAL"],{{CL["PACKAGE"],{CL["*PACKAGE*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*PACKAGE*"].bound end  single_value();  local l5 = n if n ~= CL_LIB["%STRINGP"](l2) then  l5 = CL_LIB["%GET-PACKAGE-BY-NAME"](l2) else  l5 = n.bound end local l4 = l5; single_value();  local l6 = n if n ~= l4 then  l6 = l4 else  local l8 = n if n ~= CL["SYMBOLP"](l2) then  l8 = CL_LIB["%GET-PACKAGE-BY-NAME"](CL["SYMBOL-NAME"](l2)) else  l8 = n.bound end local l7 = l8; single_value();  local l9 = n if n ~= l7 then  l9 = l7 else  l9 = l2 end l6 = l9 end local l3 = l6; single_value();  local l10 = n if n ~= CL_LIB["%STRINGP"](l1) then  local l11 = l1; local l12 = n.bound; single_value();  l10 = ((l3)[l11] or l12) else  l10 = CL["ERROR"]("Argument to intern must be a string ~S", l(l1)) end return l10 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["GET"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],{CL_LIB["INDICATOR"],{CL["&OPTIONAL"],{CL_LIB["DEFAULT"],n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = n.bound end  single_value();  return (l1.plist[l2] or l3) end, 2, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["BOUNDP"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],n},function (l1,  ...)   single_value();  return (rawget(l1,"bound") and CL.T or n) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAKUNBOUND"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],n},function (l1,  ...)   single_value(); l1.bound = nil return n.bound end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FMAKUNBOUND"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],n},function (l1,  ...)   single_value(); l1.fbound = nil return n.bound end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FBOUNDP"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["SYMBOLP"](l1) then  l2 = (rawget(l1, 'fbound') and l1 or n) else  local l3 = n if n ~= CL["CONSP"](l1) then  local l4 = n if n ~= CL["EQ"](CL["SETF"], (l1)[1]) then  l4 = (rawget(CL["CADR"](l1), 'setfbound') and l1 or n) else  l4 = CL["ERROR"]("Invalid argument to fboundp ~S", l(l1)) end l3 = l4 else  l3 = n.bound end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FDEFINITION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FUNCTION-NAME"],n},function (l1,  ...)   single_value();  local l2 = "fbound"; local l3 = n.bound; single_value();  return ((l1)[l2] or l3) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SYMBOL-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],n},function (l1,  ...)   single_value();  return CL["FDEFINITION"](l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["SYMBOL-MACRO-BOUNDP"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],n},function (l1,  ...)   single_value();  return (rawget(l1,"sm_bound") and CL.T or n) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SYMBOL-MACRO"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],n},function (l1,  ...)   single_value();  return (rawget(l1,"sm_bound") or n) end, 1, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DEFINE-SYMBOL-MACRO"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G40045"],{CL["&OPTIONAL"],{LCL["NIL"]["G40046"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  single_value();  local l13 = n if n ~= CL["SYMBOLP"](l5) then  l13 = CL["CONS"](CL["PROGN"], CL["CONS"](CL["CONS"](CL_LIB["LUA-SET-TABLE"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), CL["CONS"]("sm_bound", CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l9, n)), n)))), CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), n))) else  l13 = CL["ERROR"]("define-symbol-macro, not a symbol", l()) end return l13 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["HASH-TABLE-P"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["HT"],n},function (l1,  ...)   single_value();  return CL["EQ"]((getmetatable(l1) or n), CL_LIB["HASH-TABLE-METATABLE"].bound) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%ARRAYP"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["EQ"]((getmetatable(l1) or n), CL_LIB["ARRAY-METATABLE"].bound) then  l2 = CL["T"].bound else  l2 = n.bound end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ARRAYP"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],n},function (l1,  ...)   single_value();  local l2 = CL_LIB["%ARRAYP"](l1); single_value();  local l3 = n if n ~= l2 then  l3 = l2 else  l3 = CL_LIB["%STRINGP"](l1) end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FUNCTIONP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["F"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["EQ"]((getmetatable(l1) or n), CL_LIB["FUNCTION-METATABLE"].bound) then  l2 = CL["T"].bound else  l2 = n.bound end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["VALUES"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["VALS"],n}},function (l1,  ...)   single_value();  return CL["VALUES-LIST"](l1) end, 0, 0, true, false)); i( CL_LIB["MACRO-SETQ"](CL["MULTIPLE-VALUE-PROG1"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G40176"],{CL["&OPTIONAL"],{LCL["NIL"]["G40177"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l10, CL["CONS"](CL["CONS"](CL["MULTIPLE-VALUE-LIST"], CL["CONS"](l5, n)), n)), n), CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(l9,CL["CONS"](CL["CONS"](CL["VALUES-LIST"], CL["CONS"](l10, n)), n)))), n))) end, 1, 1, false, false)) );
 i( CL_LIB["MACRO-SETQ"](CL["MULTIPLE-VALUE-LIST"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G40243"],{CL["&OPTIONAL"],{LCL["NIL"]["G40244"],n}}},function (l11, l12,  ...)  if not l12 then  l12 = n.bound end  single_value();  local l13 = (l11)[2]; single_value();  local l14 = (l11)[2]; single_value();  local l16 = l14; single_value();  local l17 = (l16)[1]; single_value();  single_value();  local l18 = (l16)[2]; single_value();  l14 = l18 i( l14 );
 single_value();  local l15 = l17; single_value();  single_value();  local l19 = n if n ~= CL_LIB["%STRINGP"](l15) then  l19 = l15 else  l19 = CL["CONS"](CL_LIB["LUA-CALL"], CL["CONS"]("l", CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"]("unpack_mv(", CL["CONS"](l15, CL["CONS"](")", n)))), n))) end return l19 end, 1, 1, false, false)) );
 i( CL_LIB["MACRO-SETQ"](CL["NTH-VALUE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G40298"],{CL["&OPTIONAL"],{LCL["NIL"]["G40299"],n}}},function (l20, l21,  ...)  if not l21 then  l21 = n.bound end  single_value();  local l22 = (l20)[2]; single_value();  local l23 = (l20)[2]; single_value();  local l25 = l23; single_value();  local l26 = (l25)[1]; single_value();  single_value();  local l27 = (l25)[2]; single_value();  l23 = l27 i( l23 );
 single_value();  local l24 = l26; single_value();  local l29 = l23; single_value();  local l30 = (l29)[1]; single_value();  single_value();  local l31 = (l29)[2]; single_value();  l23 = l31 i( l23 );
 single_value();  local l28 = l30; single_value();  single_value();  return CL["CONS"](CL["NTH"], CL["CONS"](l24, CL["CONS"](CL["CONS"](CL["MULTIPLE-VALUE-LIST"], CL["CONS"](l28, n)), n))) end, 1, 1, false, false)) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["MULTIPLE-VALUE-BIND-VARS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["VARS"],n},function (l32,  ...)   single_value();  local l33 = n if n ~= CL["NULL"](l32) then  single_value();  l33 = n.bound else  local l34 = n if n ~= CL["EQ"](1, CL["LENGTH"](l32)) then  single_value();  l34 = l32 else  local l35 = n if n ~= CL["T"].bound then  single_value();  l35 = CL["CONS"]((l32)[1], CL["CONS"](",", CL["APPEND"](l(CL_LIB["MULTIPLE-VALUE-BIND-VARS"]((l32)[2]),n)))) else  l35 = n.bound end l34 = l35 end l33 = l34 end return l33 end, 1, 0, false, false)) );
 i( CL_LIB["MACRO-SETQ"](CL["MULTIPLE-VALUE-BIND"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G40395"],{CL["&OPTIONAL"],{LCL["NIL"]["G40396"],n}}},function (l36, l37,  ...)  if not l37 then  l37 = n.bound end  single_value();  local l38 = (l36)[2]; single_value();  local l39 = (l36)[2]; single_value();  local l41 = l39; single_value();  local l42 = (l41)[1]; single_value();  single_value();  local l43 = (l41)[2]; single_value();  l39 = l43 i( l39 );
 single_value();  local l40 = l42; single_value();  local l45 = l39; single_value();  local l46 = (l45)[1]; single_value();  single_value();  local l47 = (l45)[2]; single_value();  l39 = l47 i( l39 );
 single_value();  local l44 = l46; single_value();  local l48 = l39; single_value();  single_value();  return CL["CONS"](CL["LET"], CL["CONS"](l40, CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](CL_LIB["*MULTIPLE-VALUES-COUNT*"], CL["CONS"](CL["MULTIPLE-VALUES-LIMIT"], n)), n), CL["CONS"](CL["CONS"](CL_LIB["LUA-PUSH"], CL["CONS"](CL["CONS"](" ", CL["APPEND"](l(CL_LIB["MULTIPLE-VALUE-BIND-VARS"](l40),CL["CONS"]("= unpack_mv(", CL["CONS"](l44, CL["CONS"](", ", CL["CONS"](CL["LENGTH"](l40), CL["CONS"](")", n)))))))), CL["CONS"](n, n))), n))), CL["APPEND"](l(l48,n))))) end, 1, 1, false, false)) );
 single_value();  tmp = CL_LIB["MACRO-SETQ"](CL["MULTIPLE-VALUE-SETQ"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G40490"],{CL["&OPTIONAL"],{LCL["NIL"]["G40491"],n}}},function (l49, l50,  ...)  if not l50 then  l50 = n.bound end  single_value();  local l51 = (l49)[2]; single_value();  local l52 = (l49)[2]; single_value();  local l54 = l52; single_value();  local l55 = (l54)[1]; single_value();  single_value();  local l56 = (l54)[2]; single_value();  l52 = l56 i( l52 );
 single_value();  local l53 = l55; single_value();  local l58 = l52; single_value();  local l59 = (l58)[1]; single_value();  single_value();  local l60 = (l58)[2]; single_value();  l52 = l60 i( l52 );
 single_value();  local l57 = l59; single_value();  single_value();  local l61 = CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l62,  ...)   single_value();  return CL["GENSYM"](false) end, 1, 0, false, false), l(l53)); single_value();  return CL["CONS"](CL["MULTIPLE-VALUE-BIND"], CL["CONS"](l61, CL["CONS"](l57, CL["APPEND"](l(CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["VAR"],{CL_LIB["TEMP"],n}},function (l63, l64,  ...)   single_value();  return CL["LIST"](l(CL["SETQ"],l63,l64)) end, 2, 0, false, false), l(l53,l61)),n))))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MACRO-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],{CL["&OPTIONAL"],{CL_LIB["ENVIRONMENT"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  local l3 = n if n ~= l2 then  single_value();  local l4 = CL_LIB["ENV-MLOCAL"](l2, l1); single_value();  local l5 = n if n ~= l4 then  single_value();  local l6 = (l4)[2]; single_value(); do return l6 end; l5 = n.bound else  l5 = n.bound end l3 = l5 else  l3 = n.bound end i( l3 );
 single_value();  local l7 = n if n ~= CL["FBOUNDP"](l1) then  single_value();  local l8 = CL["FDEFINITION"](l1); local l9 = n if n ~= CL["EQ"](CL_LIB["MACRO-METATABLE"].bound, (getmetatable(l8) or n)) then  single_value();  l9 = n.bound else  l9 = n.bound end i( l9 );
 single_value();  local l10 = "macro_function"; local l11 = n.bound; single_value();  l7 = ((l8)[l10] or l11) else  l7 = n.bound end return l7 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MACROEXPAND"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FORM"],{CL["&OPTIONAL"],{CL_LIB["ENV"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  return CL["VALUES"](l(l1,n.bound)) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MACROEXPAND-1"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FORM"],{CL["&OPTIONAL"],{CL_LIB["ENV"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  return CL["VALUES"](l(l1,n.bound)) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%+"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return (l1+l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%-"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return (l1-l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%*"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return (l1*l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%/"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return (l1/l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%//"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return bit.intdiv(l1,l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%%"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return (l1%l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%LOGAND"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return bit.band(l1,l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%LOGIOR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return bit.bor(l1,l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%LOGXOR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return bit.bxor(l1,l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%LSH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return bit.lshift(l1,l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%RSH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return bit.rshift(l1,l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%LOGNOT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],n},function (l1,  ...)   single_value();  return bit.bnot(l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%<="] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return ((l1<=l2) and CL.T or n) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%<"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return ((l1<l2) and CL.T or n) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%>"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return ((l1>l2) and CL.T or n) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%>="] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return ((l1>=l2) and CL.T or n) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%="] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return ((l1==l2) and CL.T or n) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%/="] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return ((l1~=l2) and CL.T or n) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%LEN"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],n},function (l1,  ...)   single_value();  return (# l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SQRT"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL["FUNCALL"](math.sqrt, l(l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%COS"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL["FUNCALL"](math.cos, l(l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SIN"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL["FUNCALL"](math.sin, l(l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%TAN"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL["FUNCALL"](math.tan, l(l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%COSH"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL["FUNCALL"](math.cosh, l(l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SINH"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL["FUNCALL"](math.sinh, l(l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%TANH"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL["FUNCALL"](math.tanh, l(l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%EXP"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL["FUNCALL"](math.exp, l(l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%EXPT"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],{CL_LIB["POWER"],n}},function (l1, l2,  ...)   single_value();  return CL["FUNCALL"](math.pow, l(l1,l2)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%LOG"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL["FUNCALL"](math.log, l(l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%FLOOR"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL["FUNCALL"](math.floor, l(l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%ASIN"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["Y"],n},function (l1,  ...)   single_value();  return CL["FUNCALL"](math.asin, l(l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%ACOS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["Y"],n},function (l1,  ...)   single_value();  return CL["FUNCALL"](math.acos, l(l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%ATAN2"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["Y"],{CL_LIB["X"],n}},function (l1, l2,  ...)   single_value();  return CL["FUNCALL"](math.atan2, l(l1,l2)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%MODF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l1,  ...)   single_value();  return CL["VALUES-LIST"](l(math.modf(l1))) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["REALPART"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["COMPLEXP"](l1) then  single_value();  local l3 = "r"; local l4 = n.bound; single_value();  l2 = ((l1)[l3] or l4) else  local l5 = n if n ~= CL["NUMBERP"](l1) then  single_value();  l5 = l1 else  local l6 = n if n ~= CL["T"].bound then  single_value();  l6 = CL["ERROR"]("Can't get real part of non number ~S", l(l1)) else  l6 = n.bound end l5 = l6 end l2 = l5 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["IMAGPART"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["COMPLEXP"](l1) then  single_value();  local l3 = "i"; local l4 = n.bound; single_value();  l2 = ((l1)[l3] or l4) else  local l5 = n if n ~= CL["NUMBERP"](l1) then  single_value();  l5 = (0 * l1) else  local l6 = n if n ~= CL["T"].bound then  single_value();  l6 = CL["ERROR"]("Can't get imag part of non number ~S", l(l1)) else  l6 = n.bound end l5 = l6 end l2 = l5 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["NUMERATOR"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL_LIB["%RATIONALP"](l1) then  single_value();  local l3 = "n"; local l4 = n.bound; single_value();  l2 = ((l1)[l3] or l4) else  local l5 = n if n ~= CL_LIB["%NUMBERP"](l1) then  single_value();  l5 = l1 else  local l6 = n if n ~= CL["T"].bound then  single_value();  l6 = CL["ERROR"]("Can't get numerator of non rational ~S", l(l1)) else  l6 = n.bound end l5 = l6 end l2 = l5 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["DENOMINATOR"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL_LIB["%RATIONALP"](l1) then  single_value();  local l3 = "d"; local l4 = n.bound; single_value();  l2 = ((l1)[l3] or l4) else  local l5 = n if n ~= CL_LIB["%NUMBERP"](l1) then  single_value();  l5 = 1 else  local l6 = n if n ~= CL["T"].bound then  single_value();  l6 = CL["ERROR"]("Can't get denominator of non rational ~S", l(l1)) else  l6 = n.bound end l5 = l6 end l2 = l5 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAKE-SYMBOL"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],n},function (l1,  ...)   single_value();  return CL["FUNCALL"](CL_LIB["ALLOC-SYMBOL"].fbound, l(n.bound,l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SYMBOL-VALUE"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["SYMBOLP"](l1) then  l2 = l1.bound else  l2 = CL["ERROR"]("symbol-value of non symbol ~S", l(l1)) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SET"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],{CL_LIB["VALUE"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["SYMBOLP"](l1) then l1.bound = l2; l3 = l2 else  l3 = CL["ERROR"]("set symbol-value of non symbol ~S", l(l1)) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); local l1 = LCL['CL-LIB']; single_value();  tmp = CL_LIB.DEF(CL["*PACKAGE*"],l1); local l1 = CL["LIST"](l(LCL["KEYWORD"]["LCL"],LCL["KEYWORD"]["64-BIT"],LCL["KEYWORD"]["ANSI-CL"],LCL["KEYWORD"]["COMMON-LISP"],LCL["KEYWORD"]["IEEE-FLOATING-POINT"],LCL["KEYWORD"]["LITTLE-ENDIAN"])); single_value();  tmp = CL_LIB.DEF(CL["*FEATURES*"],l1); local l1 = CL["FUNCALL"].fbound; single_value();  tmp = CL_LIB.DEF(CL["*MACROEXPAND-HOOK*"],l1); local l1 = 4.5035996273705e+15; single_value();  tmp = CL_LIB.DEF(CL["MOST-POSITIVE-FIXNUM"],l1); local l1 = -4.5035996273705e+15; single_value();  tmp = CL_LIB.DEF(CL["MOST-NEGATIVE-FIXNUM"],l1); local l1 = 50; single_value();  tmp = CL_LIB.DEF(CL["CALL-ARGUMENTS-LIMIT"],l1); local l1 = 50; single_value();  tmp = CL_LIB.DEF(CL["LAMBDA-PARAMETERS-LIMIT"],l1); local l1 = {CL["&ALLOW-OTHER-KEYS"],{CL["&AUX"],{CL["&BODY"],{CL["&ENVIRONMENT"],{CL["&KEY"],{CL["&OPTIONAL"],{CL["&REST"],{CL["&WHOLE"],n}}}}}}}}; single_value();  tmp = CL_LIB.DEF(CL["LAMBDA-LIST-KEYWORDS"],l1); local l1 = 20; single_value();  tmp = CL_LIB.DEF(CL["MULTIPLE-VALUES-LIMIT"],l1); local l1 = 1024; single_value();  tmp = CL_LIB.DEF(CL["ARRAY-DIMENSION-LIMIT"],l1); local l1 = 1024; single_value();  tmp = CL_LIB.DEF(CL["ARRAY-TOTAL-SIZE-LIMIT"],l1); local l1 = 8; single_value();  tmp = CL_LIB.DEF(CL["ARRAY-RANK-LIMIT"],l1); local l1 = 256; single_value();  tmp = CL_LIB.DEF(CL["CHAR-CODE-LIMIT"],l1); local l1 = 3.1415926535898; single_value();  tmp = CL_LIB.DEF(CL["PI"],l1); local l1 = 2; single_value();  tmp = CL_LIB.DEF(CL["BOOLE-1"],l1); local l1 = 3; single_value();  tmp = CL_LIB.DEF(CL["BOOLE-2"],l1); local l1 = 12; single_value();  tmp = CL_LIB.DEF(CL["BOOLE-ANDC1"],l1); local l1 = 13; single_value();  tmp = CL_LIB.DEF(CL["BOOLE-ANDC2"],l1); local l1 = 6; single_value();  tmp = CL_LIB.DEF(CL["BOOLE-AND"],l1); local l1 = 4; single_value();  tmp = CL_LIB.DEF(CL["BOOLE-C1"],l1); local l1 = 5; single_value();  tmp = CL_LIB.DEF(CL["BOOLE-C2"],l1); local l1 = 0; single_value();  tmp = CL_LIB.DEF(CL["BOOLE-CLR"],l1); local l1 = 9; single_value();  tmp = CL_LIB.DEF(CL["BOOLE-EQV"],l1); local l1 = 7; single_value();  tmp = CL_LIB.DEF(CL["BOOLE-IOR"],l1); local l1 = 10; single_value();  tmp = CL_LIB.DEF(CL["BOOLE-NAND"],l1); local l1 = 11; single_value();  tmp = CL_LIB.DEF(CL["BOOLE-NOR"],l1); local l1 = 14; single_value();  tmp = CL_LIB.DEF(CL["BOOLE-ORC1"],l1); local l1 = 15; single_value();  tmp = CL_LIB.DEF(CL["BOOLE-ORC2"],l1); local l1 = 1; single_value();  tmp = CL_LIB.DEF(CL["BOOLE-SET"],l1); local l1 = 8; single_value();  tmp = CL_LIB.DEF(CL["BOOLE-XOR"],l1); local l1 = 3.4028235e+38; single_value();  tmp = CL_LIB.DEF(CL["MOST-POSITIVE-SHORT-FLOAT"],l1); local l1 = 1.4012985e-45; single_value();  tmp = CL_LIB.DEF(CL["LEAST-POSITIVE-SHORT-FLOAT"],l1); local l1 = 1.1754944e-38; single_value();  tmp = CL_LIB.DEF(CL["LEAST-POSITIVE-NORMALIZED-SHORT-FLOAT"],l1); local l1 = 3.4028235e+38; single_value();  tmp = CL_LIB.DEF(CL["MOST-POSITIVE-SINGLE-FLOAT"],l1); local l1 = 1.4012985e-45; single_value();  tmp = CL_LIB.DEF(CL["LEAST-POSITIVE-SINGLE-FLOAT"],l1); local l1 = 1.1754944e-38; single_value();  tmp = CL_LIB.DEF(CL["LEAST-POSITIVE-NORMALIZED-SINGLE-FLOAT"],l1); local l1 = -3.4028235e+38; single_value();  tmp = CL_LIB.DEF(CL["MOST-NEGATIVE-SHORT-FLOAT"],l1); local l1 = -1.4012985e-45; single_value();  tmp = CL_LIB.DEF(CL["LEAST-NEGATIVE-SHORT-FLOAT"],l1); local l1 = -1.1754944e-38; single_value();  tmp = CL_LIB.DEF(CL["LEAST-NEGATIVE-NORMALIZED-SHORT-FLOAT"],l1); local l1 = -3.4028235e+38; single_value();  tmp = CL_LIB.DEF(CL["MOST-NEGATIVE-SINGLE-FLOAT"],l1); local l1 = -1.4012985e-45; single_value();  tmp = CL_LIB.DEF(CL["LEAST-NEGATIVE-SINGLE-FLOAT"],l1); local l1 = -1.1754944e-38; single_value();  tmp = CL_LIB.DEF(CL["LEAST-NEGATIVE-NORMALIZED-SINGLE-FLOAT"],l1); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAKE-LIST"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SIZE"],{CL["&KEY"],{CL_LIB["INITIAL-ELEMENT"],n}}},function (l1, keys,  ...)  if not keys[CL_LIB["INITIAL-ELEMENT"]] then  keys[CL_LIB["INITIAL-ELEMENT"]] = n.bound end  single_value();  local l2 = n if n ~= CL["ZEROP"](l1) then  single_value();  l2 = n.bound else  local l3 = n if n ~= CL["PLUSP"](l1) then  single_value();  l3 = CL["CONS"](keys[CL_LIB["INITIAL-ELEMENT"]], CL["MAKE-LIST"]((l1 - 1), k(CL_LIB["INITIAL-ELEMENT"], keys[CL_LIB["INITIAL-ELEMENT"]]))) else  local l4 = n if n ~= CL["T"].bound then  single_value();  l4 = CL["ERROR"]("Can't make list of size ~A", l(l1)) else  l4 = n.bound end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, {0 , [LCL["KEYWORD"]["INITIAL-ELEMENT"]] = CL_LIB["INITIAL-ELEMENT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["ACONS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["KEY"],{CL["DATUM"],{CL_LIB["ALIST"],n}}},function (l1, l2, l3,  ...)   single_value();  return CL["CONS"](CL["CONS"](l1, l2), l3) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PAIRLIS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["KEYS"],{CL_LIB["DATA"],{CL["&OPTIONAL"],{CL_LIB["ALIST"],n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = n.bound end  single_value();  local l5 = n if n ~= l1 then  l5 = l2 else  l5 = n.bound end local l4 = n if n ~= l5 then  l4 = CL["ACONS"]((l1)[1], (l2)[1], CL["PAIRLIS"]((l1)[2], (l2)[2], l3)) else  l4 = l3 end return l4 end, 2, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["APPEND-LIST"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= (l1)[2] then  local l3 = (l1)[1]; local l4 = (l1)[2]; single_value();  local l5 = n if n ~= l3 then  l5 = CL["CONS"]((l3)[1], CL_LIB["APPEND-LIST"](CL["CONS"]((l3)[2], l4))) else  l5 = CL_LIB["APPEND-LIST"](l4) end l2 = l5 else  l2 = (l1)[1] end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["APPEND"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL["LIST"],n}},function (l1,  ...)   single_value();  return CL_LIB["APPEND-LIST"](l1) end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%LIST*-REC"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["ENDP"](l1) then  single_value();  l2 = n.bound else  local l3 = n if n ~= CL["NULL"]((l1)[2]) then  single_value();  l3 = (l1)[1] else  local l4 = n if n ~= CL["T"].bound then  single_value();  l4 = CL["CONS"]((l1)[1], CL_LIB["%LIST*-REC"]((l1)[2])) else  l4 = n.bound end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LIST*"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL["LIST"],n}},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["ENDP"](l1) then  single_value();  l2 = n.bound else  local l3 = n if n ~= CL["NULL"]((l1)[2]) then  single_value();  l3 = (l1)[1] else  local l4 = n if n ~= CL["T"].bound then  single_value();  l4 = CL["CONS"]((l1)[1], CL_LIB["%LIST*-REC"]((l1)[2])) else  l4 = n.bound end l3 = l4 end l2 = l3 end return l2 end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["REST"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return (l1)[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CAAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((l1)[1])[1] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CADR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((l1)[2])[1] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CDAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((l1)[1])[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CDDR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((l1)[2])[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CAAAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return (((l1)[1])[1])[1] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CAADR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return (((l1)[2])[1])[1] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CADAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return (((l1)[1])[2])[1] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CADDR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return (((l1)[2])[2])[1] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CDAAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return (((l1)[1])[1])[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CDADR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return (((l1)[2])[1])[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CDDAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return (((l1)[1])[2])[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CDDDR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return (((l1)[2])[2])[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CAAAAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((((l1)[1])[1])[1])[1] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CAAADR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((((l1)[2])[1])[1])[1] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CAADAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((((l1)[1])[2])[1])[1] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CAADDR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((((l1)[2])[2])[1])[1] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CADAAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((((l1)[1])[1])[2])[1] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CADADR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((((l1)[2])[1])[2])[1] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CADDAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((((l1)[1])[2])[2])[1] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CADDDR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((((l1)[2])[2])[2])[1] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CDAAAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((((l1)[1])[1])[1])[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CDAADR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((((l1)[2])[1])[1])[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CDADAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((((l1)[1])[2])[1])[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CDADDR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((((l1)[2])[2])[1])[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CDDAAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((((l1)[1])[1])[2])[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CDDADR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((((l1)[2])[1])[2])[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CDDDAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((((l1)[1])[2])[2])[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CDDDDR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return ((((l1)[2])[2])[2])[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["REST"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return (l1)[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["NTHCDR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["N"],{CL["LIST"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["NOT"](CL["NUMBERP"](l1)) then  single_value();  l3 = CL["ERROR"]("nthcdr n must be a number ~S", l(l1)) else  local l4 = n if n ~= CL_LIB["%<"](l1, 0) then  single_value();  l4 = CL["ERROR"]("nthcdr n must be a nonnegative integer ~S", l(l1)) else  local l5 = n if n ~= CL["EQ"](l1, 0) then  single_value();  l5 = l2 else  local l6 = n if n ~= CL["T"].bound then  single_value();  l6 = CL["NTHCDR"]((l1 - 1), (l2)[2]) else  l6 = n.bound end l5 = l6 end l4 = l5 end l3 = l4 end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["NTH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["N"],{CL["LIST"],n}},function (l1, l2,  ...)   single_value();  return (CL["NTHCDR"](l1, l2))[1] end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FIRST"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return CL["NTH"](0, l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SECOND"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return CL["NTH"](1, l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["THIRD"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return CL["NTH"](2, l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FOURTH"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return CL["NTH"](3, l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FIFTH"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return CL["NTH"](4, l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SIXTH"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return CL["NTH"](5, l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SEVENTH"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return CL["NTH"](6, l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["EIGHTH"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return CL["NTH"](7, l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["NINTH"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return CL["NTH"](8, l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["TENTH"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return CL["NTH"](9, l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%ASSOC"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ITEM"],{CL_LIB["ALIST"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= l2 then  local l4 = n if n ~= CL["EQ"](l1, CL["CAAR"](l2)) then  l4 = (l2)[1] else  l4 = CL["ASSOC"](l1, (l2)[2], k()) end l3 = l4 else  l3 = n.bound end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ASSOC-IF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PREDICATE"],{CL_LIB["ALIST"],{CL["&KEY"],{{CL_LIB["KEY"],{{CL["FUNCTION"],{CL["IDENTITY"],n}},n}},n}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound end  single_value();  local l3 = n if n ~= l2 then  local l6 = CL["CAAR"](l2); single_value();  local l5 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l6, }); single_value();  local l4 = n if n ~= CL_LIB['FUNCALL-LUA'](l1,{l5, }) then  l4 = (l2)[1] else  l4 = CL["ASSOC-IF"](l1, (l2)[2], k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end l3 = l4 else  l3 = n.bound end return l3 end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["ASSOC-IF-NOT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PREDICATE"],{CL_LIB["ALIST"],{CL["&KEY"],{{CL_LIB["KEY"],{{CL["FUNCTION"],{CL["IDENTITY"],n}},n}},n}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound end  single_value();  return CL["ASSOC-IF"](CL["COMPLEMENT"](l1), l2, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["ASSOC"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ITEM"],{CL_LIB["ALIST"],{CL["&KEY"],{{CL_LIB["KEY"],{{CL["FUNCTION"],{CL["IDENTITY"],n}},n}},{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  local l4 = keys[CL_LIB["TEST"]]; single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  local l7 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l7 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l7 = n.bound end local l6 = l7; single_value();  local l8 = n if n ~= l6 then  l8 = l6 else  l8 = CL["EQ"].fbound end l5 = l8 end local l3 = l5; single_value();  return CL["ASSOC-IF"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l9,  ...)   single_value();  local l10 = l1; single_value();  local l11 = l9; single_value();  return CL_LIB['FUNCALL-LUA'](l3,{l10, l11, }) end, 1, 0, false, false), l2, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["RASSOC-IF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PREDICATE"],{CL_LIB["ALIST"],{CL["&KEY"],{{CL_LIB["KEY"],{{CL["FUNCTION"],{CL["IDENTITY"],n}},n}},n}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound end  single_value();  local l3 = n if n ~= l2 then  local l6 = CL["CDAR"](l2); single_value();  local l5 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l6, }); single_value();  local l4 = n if n ~= CL_LIB['FUNCALL-LUA'](l1,{l5, }) then  l4 = (l2)[1] else  l4 = CL["RASSOC-IF"](l1, (l2)[2], k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end l3 = l4 else  l3 = n.bound end return l3 end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["RASSOC-IF-NOT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PREDICATE"],{CL_LIB["ALIST"],{CL["&KEY"],{CL_LIB["KEY"],n}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  return CL["RASSOC-IF"](CL["COMPLEMENT"](l1), l2, k(CL_LIB["KEY"], CL_LIB["FUNCALL-LUA"]( CL_LIB["KEY"].fbound, {CL["IDENTITY"].fbound, }))) end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["RASSOC"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ITEM"],{CL_LIB["ALIST"],{CL["&KEY"],{{CL_LIB["KEY"],{{CL["FUNCTION"],{CL["IDENTITY"],n}},n}},{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  local l4 = keys[CL_LIB["TEST"]]; single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  local l7 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l7 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l7 = n.bound end local l6 = l7; single_value();  local l8 = n if n ~= l6 then  l8 = l6 else  l8 = CL["EQ"].fbound end l5 = l8 end local l3 = l5; single_value();  return CL["RASSOC-IF"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l9,  ...)   single_value();  local l10 = l1; single_value();  local l11 = l9; single_value();  return CL_LIB['FUNCALL-LUA'](l3,{l10, l11, }) end, 1, 0, false, false), l2, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["DLIST-LENGTH"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["CONSP"](l1) then  l2 = (1 + CL_LIB["DLIST-LENGTH"]((l1)[2])) else  l2 = 0 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["BUTLAST"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],{CL["&OPTIONAL"],{{CL_LIB["N"],{1,n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = 1 end  single_value();  local l3 = n if n ~= CL["NULL"](l1) then  single_value();  l3 = n.bound else  local l4 = n if n ~= CL["NOT"](CL["CONSP"](l1)) then  single_value();  l4 = CL["ERROR"]("butlast, ~S is not a list", l(l1)) else  local l5 = n if n ~= CL["<="](l(CL_LIB["DLIST-LENGTH"](l1),l2)) then  single_value();  l5 = n.bound else  local l6 = n if n ~= CL["T"].bound then  single_value();  l6 = CL["CONS"]((l1)[1], CL["BUTLAST"]((l1)[2], l2)) else  l6 = n.bound end l5 = l6 end l4 = l5 end l3 = l4 end return l3 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["NBUTLAST"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],{CL["&OPTIONAL"],{{CL_LIB["N"],{1,n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = 1 end  single_value();  return CL["BUTLAST"](l1, l2) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%LAST"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["NULL"](l1) then  single_value();  l2 = l1 else  local l4 = n if n ~= CL["CONSP"](l1) then  l4 = CL["NOT"](CL["CONSP"]((l1)[2])) else  l4 = n.bound end local l3 = n if n ~= l4 then  single_value();  l3 = l1 else  local l5 = n if n ~= CL["T"].bound then  single_value();  l5 = CL_LIB["%LAST"]((l1)[2]) else  l5 = n.bound end l3 = l5 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LAST"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],{CL["&OPTIONAL"],{{CL_LIB["N"],{1,n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = 1 end  single_value();  return CL["NTHCDR"](CL["MAX"](l(0,(CL_LIB["DLIST-LENGTH"](l1) - l2))), l1) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["GETF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLIST"],{CL_LIB["INDICATOR"],{CL["&OPTIONAL"],{CL_LIB["DEFAULT"],n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = n.bound end  single_value();  local l4 = n if n ~= CL["NULL"](l1) then  single_value();  l4 = l3 else  local l5 = n if n ~= CL["EQ"](l2, (l1)[1]) then  single_value();  l5 = CL["CADR"](l1) else  local l6 = n if n ~= CL["T"].bound then  single_value();  l6 = CL["GETF"](CL["CDDR"](l1), l2, l3) else  l6 = n.bound end l5 = l6 end l4 = l5 end return l4 end, 2, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["SETGETF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLIST"],{CL_LIB["INDICATOR"],{CL_LIB["VALUE"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = l1; local l5 = l1; while true do  single_value();  local l6 = n if n ~= CL["NULL"](l4) then  l5 = CL["CONS"](l2, CL["CONS"](l3, l1)) i( l5 );
 single_value(); do break end; l6 = n.bound else  local l7 = n if n ~= CL["EQ"](l2, (l4)[1]) then  i( CL["RPLACA"]((l4)[2], l3) );
 single_value(); do break end; l7 = n.bound else  local l8 = n if n ~= CL["T"].bound then  single_value();  l4 = CL["CDDR"](l4) l8 = l4 else  l8 = n.bound end l7 = l8 end l6 = l7 end local tmpres = l6 end i( n );
 single_value();  return l5 end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SYMBOL-PLIST"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["SYMBOLP"](l1) then  local l4 = "plist"; local l5 = l1; single_value();  local l3 = ((l1)[l4] or l5); single_value();  local l6 = n if n ~= CL["EQ"](l3, l1) then  local l7 = n.bound; single_value(); l1[CL["IDENTITY"]("plist")] = l7 i( l7 );
 single_value();  l6 = n.bound else  l6 = l3 end l2 = l6 else  l2 = CL["ERROR"]("symbol-plist, ~S not a symbol", l(l1)) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["GET"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],{CL_LIB["INDICATOR"],{CL["&OPTIONAL"],{CL_LIB["DEFAULT"],n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = n.bound end  single_value();  local l4 = "plist"; local l5 = n.bound; single_value();  return CL["GETF"](((l1)[l4] or l5), l2, l3) end, 2, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%GET-PROPERTIES"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLIST"],{CL_LIB["INDICATOR-LIST"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= l1 then  local l4 = n if n ~= CL["MEMBER"]((l1)[1], l2, k()) then  l4 = l1 else  l4 = CL_LIB["%GET-PROPERTIES"](CL["CDDR"](l1), l2) end l3 = l4 else  l3 = n.bound end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["GET-PROPERTIES"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLIST"],{CL_LIB["INDICATOR-LIST"],n}},function (l1, l2,  ...)   single_value();  local l3 = CL_LIB["%GET-PROPERTIES"](l1, l2); single_value();  return CL["VALUES"](l((l3)[1],CL["CADR"](l3),l3)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["COPY-LIST"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["CONSP"](l1) then  local l3 = n if n ~= l1 then  l3 = CL["CONS"]((l1)[1], CL["COPY-LIST"]((l1)[2])) else  l3 = n.bound end l2 = l3 else  l2 = l1 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["COPY-ALIST"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["CONSP"](l1) then  local l3 = n if n ~= l1 then  l3 = CL["CONS"](CL["COPY-LIST"]((l1)[1]), CL["COPY-ALIST"]((l1)[2])) else  l3 = n.bound end l2 = l3 else  l2 = l1 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["COPY-TREE"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["CONSP"](l1) then  local l3 = n if n ~= l1 then  l3 = CL["CONS"](CL["COPY-TREE"]((l1)[1]), CL["COPY-TREE"]((l1)[2])) else  l3 = n.bound end l2 = l3 else  l2 = l1 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ENDP"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= l1 then  local l3 = n if n ~= CL["CONSP"](l1) then  l3 = n.bound else  l3 = CL["ERROR"]("endp, ~S is not a list", l(l1)) end l2 = l3 else  l2 = CL["T"].bound end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ATOM"] , CL_LIB["ALLOC-FUNCTION"]({CL["ATOM"],n},function (l1,  ...)   single_value();  return CL["NOT"](CL["CONSP"](l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LISTP"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return (n == l1 or ('table' == type(l1) and nil == getmetatable(l1))) and CL.T or n end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LIST-LENGTH"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["LISTP"](l1) then  local l3 = n if n ~= l1 then  l3 = (1 + CL["LIST-LENGTH"]((l1)[2])) else  l3 = 0 end l2 = l3 else  l2 = CL["ERROR"]("list-length, ~S is not a list", l(l1)) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["NCONC"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["LISTS"],n}},function (l1,  ...)   single_value();  local l2 = CL["LENGTH"](l1); single_value();  local l3 = l2; single_value();  local l4 = n if n ~= CL["EQL"](l3, 0) then  single_value();  l4 = n.bound else  local l5 = n if n ~= CL["EQL"](l3, 1) then  single_value();  l5 = (l1)[1] else  local l6 = n if n ~= CL["T"].bound then  single_value();  local l7 = n if n ~= CL["CONSP"]((l1)[1]) then  i( CL["RPLACD"](CL["LAST"]((l1)[1], false), CL["APPLY"](CL["NCONC"].fbound, (l1)[2], l())) );
 single_value();  l7 = (l1)[1] else  local l8 = n if n ~= CL["NULL"]((l1)[1]) then  single_value();  l8 = CL["APPLY"](CL["NCONC"].fbound, (l1)[2], l()) else  local l9 = n if n ~= CL["T"].bound then  single_value();  l9 = CL["ERROR"]("nconc", l()) else  l9 = n.bound end l8 = l9 end l7 = l8 end l6 = l7 else  l6 = n.bound end l5 = l6 end l4 = l5 end return l4 end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["REVAPPEND"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],{CL_LIB["TAIL"],n}},function (l1, l2,  ...)   single_value();  return CL["NCONC"](l(CL["REVERSE"](l1),l2)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["NRECONC"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],{CL_LIB["TAIL"],n}},function (l1, l2,  ...)   single_value();  return CL["NCONC"](l(CL["NREVERSE"](l1),l2)) end, 2, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["PUSH"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G47201"],{CL["&OPTIONAL"],{LCL["NIL"]["G47202"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  single_value();  return CL["CONS"](CL["SETF"], CL["CONS"](l9, CL["CONS"](CL["CONS"](CL["CONS"], CL["CONS"](l5, CL["CONS"](l9, n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["PUSHNEW"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G47275"],{CL["&OPTIONAL"],{LCL["NIL"]["G47276"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  single_value();  local l13 = CL["GENSYM"](false); local l14 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l13, CL["CONS"](l5, n)), CL["CONS"](CL["CONS"](l14, CL["CONS"](l9, n)), n)), CL["CONS"](CL["CONS"](CL["IF"], CL["CONS"](CL["CONS"](CL["MEMBER"], CL["CONS"](l13, CL["CONS"](l14, n))), CL["CONS"](l14, CL["CONS"](CL["CONS"](CL["PUSH"], CL["CONS"](l13, CL["CONS"](l9, n))), n)))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["POP"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G47367"],{CL["&OPTIONAL"],{LCL["NIL"]["G47368"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  single_value();  local l9 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l9, CL["CONS"](l5, n)), n), CL["CONS"](CL["CONS"](CL["PROG1"], CL["CONS"](CL["CONS"](CL["CAR"], CL["CONS"](l9, n)), CL["CONS"](CL["CONS"](CL["SETF"], CL["CONS"](l5, CL["CONS"](CL["CONS"](CL["CDR"], CL["CONS"](l9, n)), n))), n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DOLIST"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G47434"],{CL["&OPTIONAL"],{LCL["NIL"]["G47435"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = (l5)[1]; local l11 = CL["CADR"](l5); single_value();  return CL["CONS"](CL["PROGN"], CL["CONS"](CL["CONS"](CL["MAPCAR"], CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](CL["CONS"](l10, n), CL["APPEND"](l(l9,n)))), CL["CONS"](l11, n))), CL["CONS"](n, n))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["GROUP"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= l1 then  l2 = CL["ACONS"]((l1)[1], CL["CADR"](l1), CL_LIB["GROUP"](CL["CDDR"](l1))) else  l2 = n.bound end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["MAPONE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FUNC"],{CL["LIST"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= l2 then  local l4 = (l2)[1]; single_value();  l3 = CL["CONS"](CL_LIB['FUNCALL-LUA'](l1,{l4, }), CL_LIB["MAPONE"](l1, (l2)[2])) else  l3 = n.bound end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAPCAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FUNC"],{CL["&REST"],{CL_LIB["LISTS"],n}}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["NULL"](l2) then  single_value();  l3 = n.bound else  local l4 = n if n ~= CL["NULL"]((l2)[1]) then  single_value();  l4 = n.bound else  local l5 = n if n ~= CL["T"].bound then  single_value();  l5 = CL["CONS"](CL["APPLY"](l1, CL_LIB["MAPONE"](CL["CAR"].fbound, l2), l()), CL["APPLY"](CL["MAPCAR"].fbound, l1, l(CL_LIB["MAPONE"](CL["CDR"].fbound, l2)))) else  l5 = n.bound end l4 = l5 end l3 = l4 end return l3 end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAPLIST"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FUNC"],{CL["&REST"],{CL_LIB["LISTS"],n}}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["NULL"](l2) then  single_value();  l3 = n.bound else  local l4 = n if n ~= CL["NULL"]((l2)[1]) then  single_value();  l4 = n.bound else  local l5 = n if n ~= CL["T"].bound then  single_value();  l5 = CL["CONS"](CL["APPLY"](l1, l2, l()), CL["APPLY"](CL["MAPLIST"].fbound, l1, l(CL_LIB["MAPONE"](CL["CDR"].fbound, l2)))) else  l5 = n.bound end l4 = l5 end l3 = l4 end return l3 end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAPC"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FUNC"],{CL["&REST"],{CL_LIB["LISTS"],n}}},function (l1, l2,  ...)   i( CL["APPLY"](CL["MAPCAR"].fbound, l1, l(l2)) );
 single_value();  return (l2)[1] end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAPL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FUNC"],{CL["&REST"],{CL_LIB["LISTS"],n}}},function (l1, l2,  ...)   i( CL["APPLY"](CL["MAPLIST"].fbound, l1, l(l2)) );
 single_value();  return (l2)[1] end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAPCAN"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FUNC"],{CL["&REST"],{CL_LIB["LISTS"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](CL["NCONC"].fbound, CL["APPLY"](CL["MAPCAR"].fbound, l1, l(l2)), l()) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAPCON"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FUNC"],{CL["&REST"],{CL_LIB["LISTS"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](CL["NCONC"].fbound, CL["APPLY"](CL["MAPLIST"].fbound, l1, l(l2)), l()) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["TAILP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],{CL["LIST"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["LISTP"](l2) then  while true do  single_value();  local l4 = n if n ~= CL["EQ"](l1, l2) then  single_value();  local l5 = CL["T"].bound; single_value(); do return l5 end; l4 = n.bound else  local l6 = n if n ~= CL["ATOM"](l2) then  single_value();  local l7 = n.bound; single_value(); do return l7 end; l6 = n.bound else  local l8 = n if n ~= CL["T"].bound then  single_value();  l2 = (l2)[2] l8 = l2 else  l8 = n.bound end l6 = l8 end l4 = l6 end local tmpres = l4 end l3 = n else  l3 = CL["ERROR"]("tailp, not a list", l()) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LDIFF"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],{CL_LIB["OBJECT"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["EQ"](l1, l2) then  l3 = n.bound else  local l4 = n if n ~= CL["LISTP"](l1) then  local l5 = CL["COPY-LIST"](l1); single_value();  local l6 = CL["CONS"](n.bound, l5); single_value();  single_value();  while true do  single_value();  local l7 = n if n ~= CL["EQ"](l2, l1) then  i( CL["RPLACD"](l6, n.bound) );
 single_value();  local l8 = l5; single_value(); do return l8 end; l7 = n.bound else  local l9 = n if n ~= CL["ATOM"](l1) then  single_value();  local l10 = l5; single_value(); do return l10 end; l9 = n.bound else  local l11 = n if n ~= CL["T"].bound then  l1 = (l1)[2] i( l1 );
 single_value();  l6 = (l6)[2] l11 = l6 else  l11 = n.bound end l9 = l11 end l7 = l9 end local tmpres = l7 end l4 = n else  l4 = CL["ERROR"]("ldiff, not a list", l()) end l3 = l4 end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MEMBER-IF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PREDICATE"],{CL["LIST"],{CL["&KEY"],{{CL_LIB["KEY"],{{CL["FUNCTION"],{CL["IDENTITY"],n}},n}},n}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound end  single_value();  local l3 = n if n ~= CL["NULL"](l2) then  single_value();  l3 = n.bound else  local l4 = n if n ~= CL["CONSP"](l2) then  single_value();  local l7 = keys[CL_LIB["KEY"]]; single_value();  local l8 = n if n ~= l7 then  l8 = l7 else  l8 = CL["IDENTITY"].fbound end local l6 = CL["FUNCALL"](l8, l((l2)[1])); single_value();  local l5 = n if n ~= CL_LIB['FUNCALL-LUA'](l1,{l6, }) then  l5 = l2 else  l5 = CL["MEMBER-IF"](l1, (l2)[2], k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end l4 = l5 else  l4 = n.bound end l3 = l4 end return l3 end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["MEMBER-IF-NOT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PREDICATE"],{CL["LIST"],{CL["&KEY"],{{CL_LIB["KEY"],{{CL["FUNCTION"],{CL["IDENTITY"],n}},n}},n}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound end  single_value();  return CL["MEMBER-IF"](CL["COMPLEMENT"](l1), l2, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["MEMBER"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ITEM"],{CL["LIST"],{CL["&KEY"],{{CL_LIB["KEY"],{{CL["FUNCTION"],{CL["IDENTITY"],n}},n}},{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  local l4 = keys[CL_LIB["TEST"]]; single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  local l7 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l7 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l7 = n.bound end local l6 = l7; single_value();  local l8 = n if n ~= l6 then  l8 = l6 else  l8 = CL["EQ"].fbound end l5 = l8 end local l3 = l5; single_value();  return CL["MEMBER-IF"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l9,  ...)   single_value();  local l10 = l1; single_value();  local l11 = l9; single_value();  return CL_LIB['FUNCALL-LUA'](l3,{l10, l11, }) end, 1, 0, false, false), l2, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["MACRO-SETQ"](CL["EVAL-WHEN"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G47754"],{CL["&OPTIONAL"],{LCL["NIL"]["G47755"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l11 = CL["MEMBER"](LCL["KEYWORD"]["EXECUTE"], l5, k()); single_value();  local l12 = n if n ~= l11 then  l12 = l11 else  l12 = CL["MEMBER"](CL["EVAL"], l5, k()) end local l10 = n if n ~= l12 then  l10 = CL["CONS"](CL["PROGN"], CL["APPEND"](l(l9,n))) else  l10 = n.bound end return l10 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ADJOIN"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ITEM"],{CL["LIST"],{CL["&KEY"],{{CL_LIB["KEY"],{{CL["FUNCTION"],{CL["IDENTITY"],n}},n}},{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  local l4 = keys[CL_LIB["TEST"]]; single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  local l7 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l7 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l7 = n.bound end local l6 = l7; single_value();  local l8 = n if n ~= l6 then  l8 = l6 else  l8 = CL["EQ"].fbound end l5 = l8 end local l3 = l5; single_value();  local l9 = n if n ~= CL["MEMBER"](l1, l2, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]], CL_LIB["TEST"], l3)) then  l9 = l2 else  l9 = CL["CONS"](l1, l2) end return l9 end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["INTERSECTION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["LIST-1"],{CL_LIB["LIST-2"],{CL["&KEY"],{{CL_LIB["KEY"],{{CL["FUNCTION"],{CL["IDENTITY"],n}},n}},{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  local l4 = keys[CL_LIB["TEST"]]; single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  local l7 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l7 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l7 = n.bound end local l6 = l7; single_value();  local l8 = n if n ~= l6 then  l8 = l6 else  l8 = CL["EQ"].fbound end l5 = l8 end local l3 = l5; local l9 = n.bound; local l10 = l1; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = CL["GENSYM"](false); single_value();  local l13 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l14 = n if n ~= CL["NOT"](l10) then  single_value(); do break end; l14 = n.bound else  l14 = n.bound end i( l14 );
 local l15 = n if n ~= CL["MEMBER"](l11, l2, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]], CL_LIB["TEST"], l3)) then  single_value();  single_value();  single_value();  local l16 = CL["CONS"](l11, l9); single_value();  l9 = l16 l15 = l9 else  l15 = n.bound end i( l15 );
 single_value();  single_value();  local l17 = (l10)[2]; single_value();  l10 = l17 i( l10 );
 single_value();  single_value();  single_value();  local l18 = (l10)[1]; single_value();  l11 = l18 local tmpres = l11 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l13.error ~= n and (l13.error ~= KEYWORD.TAG or l13.tag ~= l12) then if l13.error == KEYWORD.TAG then  error(l13) else error(l13[1]) end end i( CL["VALUES-LIST"](list_r(l13)) );
 single_value();  return l9 end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["NINTERSECTION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["LIST-1"],{CL_LIB["LIST-2"],{CL["&KEY"],{{CL_LIB["KEY"],{{CL["FUNCTION"],{CL["IDENTITY"],n}},n}},{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  return CL["INTERSECTION"](l1, l2, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]], CL_LIB["TEST"], keys[CL_LIB["TEST"]], CL_LIB["TEST-NOT"], keys[CL_LIB["TEST-NOT"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["UNION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["LIST-1"],{CL_LIB["LIST-2"],{CL["&KEY"],{{CL_LIB["KEY"],{{CL["FUNCTION"],{CL["IDENTITY"],n}},n}},{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  local l4 = keys[CL_LIB["TEST"]]; single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  local l7 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l7 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l7 = n.bound end local l6 = l7; single_value();  local l8 = n if n ~= l6 then  l8 = l6 else  l8 = CL["EQ"].fbound end l5 = l8 end local l3 = l5; local l9 = l2; local l10 = l1; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = CL["GENSYM"](false); single_value();  local l13 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l14 = n if n ~= CL["NOT"](l10) then  single_value(); do break end; l14 = n.bound else  l14 = n.bound end i( l14 );
 local l15 = n if n ~= CL["MEMBER"](l11, l2, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]], CL_LIB["TEST"], l3)) then  l15 = n.bound else  single_value();  single_value();  single_value();  local l16 = CL["CONS"](l11, l9); single_value();  l9 = l16 l15 = l9 end i( l15 );
 single_value();  single_value();  local l17 = (l10)[2]; single_value();  l10 = l17 i( l10 );
 single_value();  single_value();  single_value();  local l18 = (l10)[1]; single_value();  l11 = l18 local tmpres = l11 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l13.error ~= n and (l13.error ~= KEYWORD.TAG or l13.tag ~= l12) then if l13.error == KEYWORD.TAG then  error(l13) else error(l13[1]) end end i( CL["VALUES-LIST"](list_r(l13)) );
 single_value();  return l9 end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["NUNION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["LIST-1"],{CL_LIB["LIST-2"],{CL["&KEY"],{{CL_LIB["KEY"],{{CL["FUNCTION"],{CL["IDENTITY"],n}},n}},{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  return CL["UNION"](l1, l2, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]], CL_LIB["TEST"], keys[CL_LIB["TEST"]], CL_LIB["TEST-NOT"], keys[CL_LIB["TEST-NOT"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["COUNT-IF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PREDICATE"],{CL["LIST"],{CL["&KEY"],{CL_LIB["FROM-END"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL_LIB["KEY"],n}}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  local l3 = 0; local l9 = n if n ~= keys[CL_LIB["FROM-END"]] then  l9 = CL["REVERSE"](l2) else  l9 = l2 end i( CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l4,  ...)   single_value();  local l7 = keys[CL_LIB["KEY"]]; single_value();  local l8 = n if n ~= l7 then  l8 = l7 else  l8 = CL["IDENTITY"].fbound end local l6 = CL["FUNCALL"](l8, l(l4)); single_value();  local l5 = n if n ~= CL_LIB['FUNCALL-LUA'](l1,{l6, }) then  single_value();  l3 = (1 + l3) l5 = l3 else  l5 = n.bound end return l5 end, 1, 0, false, false), l(l9)) );
 single_value();  return l3 end, 2, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["COUNT-IF-NOT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PREDICATE"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL_LIB["KEY"],n}}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  return CL["COUNT-IF"](CL["COMPLEMENT"](l1), l2, k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]], CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["COUNT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ITEM"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL_LIB["KEY"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  local l4 = keys[CL_LIB["TEST"]]; single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  local l7 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l7 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l7 = n.bound end local l6 = l7; single_value();  local l8 = n if n ~= l6 then  l8 = l6 else  l8 = CL["EQ"].fbound end l5 = l8 end local l3 = l5; single_value();  return CL["COUNT-IF"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l9,  ...)   single_value();  local l10 = l1; single_value();  local l11 = l9; single_value();  return CL_LIB['FUNCALL-LUA'](l3,{l10, l11, }) end, 1, 0, false, false), l2, k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]], CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAX"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["REALS"],n}},function (l1,  ...)   single_value();  local l2 = n if n ~= l1 then  local l3 = (l1)[1]; local l4 = (l1)[2]; single_value();  local l5 = (l4)[1]; single_value();  single_value();  local l6 = CL["GENSYM"](false); single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l8 = n if n ~= CL["NOT"](l4) then  single_value(); do break end; l8 = n.bound else  l8 = n.bound end i( l8 );
 local l9 = n if n ~= CL[">"](l(l5,l3)) then  l3 = l5 l9 = l3 else  l9 = n.bound end i( l9 );
 single_value();  single_value();  local l10 = (l4)[2]; single_value();  l4 = l10 i( l4 );
 single_value();  single_value();  single_value();  local l11 = (l4)[1]; single_value();  l5 = l11 local tmpres = l5 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l7.error ~= n and (l7.error ~= KEYWORD.TAG or l7.tag ~= l6) then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end i( CL["VALUES-LIST"](list_r(l7)) );
 single_value();  l2 = l3 else  l2 = CL["ERROR"]("Taking max of an empty list", l()) end return l2 end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MIN"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["REALS"],n}},function (l1,  ...)   single_value();  local l2 = n if n ~= l1 then  local l3 = (l1)[1]; local l4 = (l1)[2]; single_value();  local l5 = (l4)[1]; single_value();  single_value();  local l6 = CL["GENSYM"](false); single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l8 = n if n ~= CL["NOT"](l4) then  single_value(); do break end; l8 = n.bound else  l8 = n.bound end i( l8 );
 local l9 = n if n ~= CL_LIB["%<"](l5, l3) then  l3 = l5 l9 = l3 else  l9 = n.bound end i( l9 );
 single_value();  single_value();  local l10 = (l4)[2]; single_value();  l4 = l10 i( l4 );
 single_value();  single_value();  single_value();  local l11 = (l4)[1]; single_value();  l5 = l11 local tmpres = l5 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l7.error ~= n and (l7.error ~= KEYWORD.TAG or l7.tag ~= l6) then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end i( CL["VALUES-LIST"](list_r(l7)) );
 single_value();  l2 = l3 else  l2 = CL["ERROR"]("Taking min of an empty list", l()) end return l2 end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%REVERSE-ACCUMULATOR"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],{CL_LIB["ACC"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["ENDP"](l1) then  l3 = l2 else  l3 = CL_LIB["%REVERSE-ACCUMULATOR"]((l1)[2], CL["CONS"]((l1)[1], l2)) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["REVERSE"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return CL_LIB["%REVERSE-ACCUMULATOR"](l1, n.bound) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["NREVERSE"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  return CL["REVERSE"](l1) end, 1, 0, false, false)); local l1 = CL["GENSYM"](false); single_value();  tmp = CL_LIB["FUNCTION-SETQ"](CL["REDUCE"] , CL_LIB["ALLOC-FUNCTION"]({CL["FUNCTION"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["KEY"],{CL_LIB["FROM-END"],{CL_LIB["START"],{CL_LIB["END"],{{CL_LIB["INITIAL-VALUE"],{CL_LIB["NONE"],n}},n}}}}}}}},function (l2, l3, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = n.bound end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL_LIB["INITIAL-VALUE"]] then  keys[CL_LIB["INITIAL-VALUE"]] = l1 end  local l5 = keys[CL_LIB["START"]]; single_value();  local l6 = n if n ~= l5 then  l6 = l5 else  l6 = keys[CL_LIB["END"]] end local l4 = n if n ~= l6 then  single_value();  l4 = CL["ERROR"]("TODO Support start and end for reduce", l()) else  l4 = n.bound end i( l4 );
 local l7 = n if n ~= keys[CL_LIB["FROM-END"]] then  single_value();  l3 = CL["REVERSE"](l3) l7 = l3 else  l7 = n.bound end i( l7 );
 local l8 = n if n ~= keys[CL_LIB["KEY"]] then  single_value();  l3 = CL["MAPCAR"](keys[CL_LIB["KEY"]], l(l3)) l8 = l3 else  l8 = n.bound end i( l8 );
 single_value();  local l9 = n.bound; local l10 = n if n ~= CL["EQ"](keys[CL_LIB["INITIAL-VALUE"]], l1) then  l9 = (l3)[1] i( l9 );
 single_value();  l3 = (l3)[2] l10 = l3 else  l9 = keys[CL_LIB["INITIAL-VALUE"]] l10 = l9 end i( l10 );
 local l11 = n if n ~= keys[CL_LIB["FROM-END"]] then  l11 = CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ELEM"],n},function (l12,  ...)   single_value();  local l13 = l12; single_value();  local l14 = l9; single_value();  l9 = CL_LIB['FUNCALL-LUA'](l2,{l13, l14, }) return l9 end, 1, 0, false, false) else  l11 = CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ELEM"],n},function (l15,  ...)   single_value();  local l16 = l9; single_value();  local l17 = l15; single_value();  l9 = CL_LIB['FUNCALL-LUA'](l2,{l16, l17, }) return l9 end, 1, 0, false, false) end i( CL["MAPCAR"](l11, l(l3)) );
 single_value();  return l9 end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["INITIAL-VALUE"]] = CL_LIB["INITIAL-VALUE"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["EVERY"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PREDICATE"],{CL["&REST"],{CL_LIB["SEQS"],n}}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["NULL"](l2) then  single_value();  l3 = CL["ERROR"]("every, specify at least one seq", l()) else  local l4 = n if n ~= CL["NULL"]((l2)[1]) then  single_value();  l4 = CL["T"].bound else  local l5 = n if n ~= CL["T"].bound then  single_value();  local l6 = n if n ~= CL["APPLY"](l1, CL_LIB["MAPONE"](CL["CAR"].fbound, l2), l()) then  l6 = CL["APPLY"](CL["EVERY"].fbound, l1, l(CL_LIB["MAPONE"](CL["CDR"].fbound, l2))) else  l6 = n.bound end l5 = l6 else  l5 = n.bound end l4 = l5 end l3 = l4 end return l3 end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SOME"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PREDICATE"],{CL["&REST"],{CL_LIB["SEQS"],n}}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["NULL"](l2) then  single_value();  l3 = CL["ERROR"]("some, specify at least one seq", l()) else  local l4 = n if n ~= CL["NULL"]((l2)[1]) then  single_value();  l4 = n.bound else  local l5 = n if n ~= CL["T"].bound then  single_value();  local l6 = CL["APPLY"](l1, CL_LIB["MAPONE"](CL["CAR"].fbound, l2), l()); single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  l7 = CL["APPLY"](CL["SOME"].fbound, l1, l(CL_LIB["MAPONE"](CL["CDR"].fbound, l2))) end l5 = l7 else  l5 = n.bound end l4 = l5 end l3 = l4 end return l3 end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["NOTEVERY"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PREDICATE"],{CL["&REST"],{CL_LIB["SEQS"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](CL["SOME"].fbound, CL["COMPLEMENT"](l1), l(l2)) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["NOTANY"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PREDICATE"],{CL["&REST"],{CL_LIB["SEQS"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](CL["EVERY"].fbound, CL["COMPLEMENT"](l1), l(l2)) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SET-DIFFERENCE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["LIST-1"],{CL_LIB["LIST-2"],{CL["&KEY"],{CL_LIB["KEY"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  return CL["REMOVE-IF"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l3,  ...)   single_value();  local l4 = n if n ~= keys[CL_LIB["KEY"]] then  local l5 = l3; single_value();  l4 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l5, }) else  l4 = l3 end local l6 = keys[CL_LIB["TEST"]]; single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  local l8 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l8 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l8 = n.bound end l7 = l8 end return CL["MEMBER"](l4, l2, k(CL_LIB["TEST"], l7)) end, 1, 0, false, false), l1, k()) end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["NSET-DIFFERENCE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["LIST-1"],{CL_LIB["LIST-2"],{CL["&KEY"],{CL_LIB["KEY"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  return CL["DELETE-IF"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l3,  ...)   single_value();  local l4 = n if n ~= keys[CL_LIB["KEY"]] then  local l5 = l3; single_value();  l4 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l5, }) else  l4 = l3 end local l6 = keys[CL_LIB["TEST"]]; single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  local l8 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l8 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l8 = n.bound end l7 = l8 end return CL["MEMBER"](l4, l2, k(CL_LIB["TEST"], l7)) end, 1, 0, false, false), l1, k()) end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["SUBSETP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["LIST-1"],{CL_LIB["LIST-2"],{CL["&KEY"],{CL_LIB["KEY"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  local l4 = keys[CL_LIB["TEST"]]; single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  local l7 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l7 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l7 = n.bound end local l6 = l7; single_value();  local l8 = n if n ~= l6 then  l8 = l6 else  l8 = CL["EQL"].fbound end l5 = l8 end local l3 = l5; single_value();  return CL["EVERY"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l9,  ...)   single_value();  local l10 = n if n ~= keys[CL_LIB["KEY"]] then  local l11 = l9; single_value();  l10 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l11, }) else  l10 = l9 end return CL["MEMBER"](l10, l2, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]], CL_LIB["TEST"], l3)) end, 1, 0, false, false), l(l1)) end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["TREE-EQUAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["TREE-1"],{CL_LIB["TREE-2"],{CL["&KEY"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  local l4 = keys[CL_LIB["TEST"]]; single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  local l7 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l7 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l7 = n.bound end local l6 = l7; single_value();  local l8 = n if n ~= l6 then  l8 = l6 else  l8 = CL["EQL"].fbound end l5 = l8 end local l3 = l5; single_value();  local l10 = CL["ATOM"](l1); single_value();  local l11 = n if n ~= l10 then  l11 = l10 else  l11 = CL["ATOM"](l2) end local l9 = n if n ~= l11 then  local l12 = l1; single_value();  local l13 = l2; single_value();  l9 = CL_LIB['FUNCALL-LUA'](l3,{l12, l13, }) else  l9 = CL["EVERY"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL1"],{CL_LIB["EL2"],n}},function (l14, l15,  ...)   single_value();  return CL["TREE-EQUAL"](l14, l15, k(CL_LIB["TEST"], l3)) end, 2, 0, false, false), l(l1,l2)) end return l9 end, 2, 0, false, {0 , [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["SPECIAL-OPERATOR-P"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["MEMBER"](l1, {CL["BLOCK"],{CL["CATCH"],{CL["EVAL-WHEN"],{CL["FLET"],{CL["FUNCTION"],{CL["GO"],{CL["IF"],{CL["LABELS"],{CL["LET"],{CL["LET*"],{CL_LIB["LOAD-TIME-VALUE"],{CL["LOCALLY"],{CL["MACROLET"],{CL_LIB["MULTIPLE-VALUE-CALL"],{CL["MULTIPLE-VALUE-PROG1"],{CL["PROGN"],{CL["PROGV"],{CL["QUOTE"],{CL["RETURN-FROM"],{CL["SETQ"],{CL["SYMBOL-MACROLET"],{CL["TAGBODY"],{CL["THE"],{CL["THROW"],{CL["UNWIND-PROTECT"],n}}}}}}}}}}}}}}}}}}}}}}}}}, k()) then  l2 = CL["T"].bound else  l2 = n.bound end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%NSUBLIS-IF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ALIST"],{CL_LIB["TREE"],{CL["&KEY"],{CL_LIB["KEY"],n}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  local l3 = n if n ~= l2 then  local l4 = CL["T"].bound; local l5 = l1; while true do  local l6 = n if n ~= l5 then  l6 = n.bound else  single_value(); do break end; l6 = n.bound end i( l6 );
 local l8 = n if n ~= keys[CL_LIB["KEY"]] then  local l9 = (l2)[1]; single_value();  l8 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l9, }) else  l8 = (l2)[1] end local l7 = n if n ~= CL["FUNCALL"](CL["CDAR"](l5), l(l8)) then  l4 = n.bound i( l4 );
 i( CL["RPLACA"](l2, CL["CAAR"](l5)) );
 single_value(); do break end; l7 = n.bound else  l7 = n.bound end i( l7 );
 single_value();  l5 = (l5)[2] local tmpres = l5 end i( n );
 single_value();  local l10 = n if n ~= l4 then  local l11 = n if n ~= CL["LISTP"]((l2)[1]) then  l11 = CL_LIB["%NSUBLIS-IF"](l1, (l2)[1], k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) else  l11 = n.bound end l10 = l11 else  l10 = n.bound end i( l10 );
 local l12 = CL["T"].bound; local l13 = l1; while true do  local l14 = n if n ~= l13 then  l14 = n.bound else  single_value(); do break end; l14 = n.bound end i( l14 );
 local l16 = n if n ~= keys[CL_LIB["KEY"]] then  local l17 = (l2)[2]; single_value();  l16 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l17, }) else  l16 = (l2)[2] end local l15 = n if n ~= CL["FUNCALL"](CL["CDAR"](l13), l(l16)) then  l12 = n.bound i( l12 );
 i( CL["RPLACD"](l2, CL["CAAR"](l13)) );
 single_value(); do break end; l15 = n.bound else  l15 = n.bound end i( l15 );
 single_value();  l13 = (l13)[2] local tmpres = l13 end i( n );
 single_value();  local l18 = n if n ~= l12 then  local l19 = n if n ~= CL["LISTP"]((l2)[2]) then  l19 = CL_LIB["%NSUBLIS-IF"](l1, (l2)[2], k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) else  l19 = n.bound end l18 = l19 else  l18 = n.bound end i( l18 );
 single_value();  l3 = l2 else  l3 = n.bound end return l3 end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["NSUBLIS-IF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ALIST"],{CL_LIB["TREE"],{CL["&KEY"],{CL_LIB["KEY"],n}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  local l3 = CL["T"].bound; local l4 = n.bound; local l5 = l1; while true do  local l6 = n if n ~= l5 then  l6 = n.bound else  single_value(); do break end; l6 = n.bound end i( l6 );
 local l8 = n if n ~= keys[CL_LIB["KEY"]] then  local l9 = (l2)[2]; single_value();  l8 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l9, }) else  l8 = (l2)[2] end local l7 = n if n ~= CL["FUNCALL"](CL["CDAR"](l5), l(l8)) then  l3 = n.bound i( l3 );
 l4 = CL["CAAR"](l5) i( l4 );
 single_value(); do break end; l7 = n.bound else  l7 = n.bound end i( l7 );
 single_value();  l5 = (l5)[2] local tmpres = l5 end i( n );
 single_value();  local l10 = n if n ~= l3 then  l10 = CL_LIB["%NSUBLIS-IF"](l1, l2, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) else  l10 = l4 end return l10 end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["NSUBLIS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ALIST"],{CL_LIB["TREE"],{CL["&KEY"],{CL_LIB["KEY"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  local l4 = keys[CL_LIB["TEST"]]; single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  local l7 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l7 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l7 = n.bound end local l6 = l7; single_value();  local l8 = n if n ~= l6 then  l8 = l6 else  l8 = CL["EQL"].fbound end l5 = l8 end local l3 = l5; single_value();  return CL_LIB["NSUBLIS-IF"](CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l9,  ...)   single_value();  return CL["CONS"]((l9)[2], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["Y"],n},function (l10,  ...)   single_value();  local l11 = (l9)[1]; single_value();  local l12 = l10; single_value();  return CL_LIB['FUNCALL-LUA'](l3,{l11, l12, }) end, 1, 0, false, false)) end, 1, 0, false, false), l(l1)), l2, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["SUBLIS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ALIST"],{CL_LIB["TREE"],{CL["&KEY"],{CL_LIB["KEY"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  return CL["NSUBLIS"](l1, CL["COPY-TREE"](l2), k(CL_LIB["KEY"], keys[CL_LIB["KEY"]], CL_LIB["TEST"], keys[CL_LIB["TEST"]], CL_LIB["TEST-NOT"], keys[CL_LIB["TEST-NOT"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%NSUBST-IF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW"],{CL_LIB["PREDICATE"],{CL_LIB["TREE"],{CL["&KEY"],{CL_LIB["KEY"],n}}}}},function (l1, l2, l3, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  local l4 = n if n ~= l3 then  local l7 = n if n ~= keys[CL_LIB["KEY"]] then  local l8 = (l3)[1]; single_value();  l7 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l8, }) else  l7 = (l3)[1] end local l6 = l7; single_value();  local l5 = n if n ~= CL_LIB['FUNCALL-LUA'](l2,{l6, }) then  l5 = CL["RPLACA"](l3, l1) else  local l9 = n if n ~= CL["LISTP"]((l3)[1]) then  l9 = CL_LIB["%NSUBST-IF"](l1, l2, (l3)[1], k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) else  l9 = n.bound end l5 = l9 end i( l5 );
 local l12 = n if n ~= keys[CL_LIB["KEY"]] then  local l13 = (l3)[2]; single_value();  l12 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l13, }) else  l12 = (l3)[2] end local l11 = l12; single_value();  local l10 = n if n ~= CL_LIB['FUNCALL-LUA'](l2,{l11, }) then  l10 = CL["RPLACD"](l3, l1) else  local l14 = n if n ~= CL["LISTP"]((l3)[2]) then  l14 = CL_LIB["%NSUBST-IF"](l1, l2, (l3)[2], k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) else  l14 = n.bound end l10 = l14 end i( l10 );
 single_value();  l4 = l3 else  l4 = n.bound end return l4 end, 3, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["NSUBST-IF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW"],{CL_LIB["PREDICATE"],{CL_LIB["TREE"],{CL["&KEY"],{CL_LIB["KEY"],n}}}}},function (l1, l2, l3, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  local l6 = n if n ~= keys[CL_LIB["KEY"]] then  local l7 = l3; single_value();  l6 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l7, }) else  l6 = l3 end local l5 = l6; single_value();  local l4 = n if n ~= CL_LIB['FUNCALL-LUA'](l2,{l5, }) then  l4 = l1 else  l4 = CL_LIB["%NSUBST-IF"](l1, l2, l3, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end return l4 end, 3, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["NSUBST-IF-NOT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW"],{CL_LIB["PREDICATE"],{CL_LIB["TREE"],{CL["&KEY"],{CL_LIB["KEY"],n}}}}},function (l1, l2, l3, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  return CL["NSUBST-IF"](l1, CL["COMPLEMENT"](l2), l3, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 3, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["NSUBST"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW"],{CL_LIB["OLD"],{CL_LIB["TREE"],{CL["&KEY"],{CL_LIB["KEY"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}}},function (l1, l2, l3, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  local l5 = keys[CL_LIB["TEST"]]; single_value();  local l6 = n if n ~= l5 then  l6 = l5 else  local l8 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l8 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l8 = n.bound end local l7 = l8; single_value();  local l9 = n if n ~= l7 then  l9 = l7 else  l9 = CL["EQL"].fbound end l6 = l9 end local l4 = l6; single_value();  return CL["NSUBST-IF"](l1, CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l10,  ...)   single_value();  local l11 = l2; single_value();  local l12 = l10; single_value();  return CL_LIB['FUNCALL-LUA'](l4,{l11, l12, }) end, 1, 0, false, false), l3, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 3, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["SUBST-IF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW"],{CL_LIB["PREDICATE"],{CL_LIB["TREE"],{CL["&KEY"],{CL_LIB["KEY"],n}}}}},function (l1, l2, l3, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  return CL["NSUBST-IF"](l1, l2, CL["COPY-TREE"](l3), k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 3, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["SUBST-IF-NOT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW"],{CL_LIB["PREDICATE"],{CL_LIB["TREE"],{CL["&KEY"],{CL_LIB["KEY"],n}}}}},function (l1, l2, l3, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  return CL["NSUBST-IF-NOT"](l1, l2, CL["COPY-TREE"](l3), k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 3, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["SUBST"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW"],{CL_LIB["OLD"],{CL_LIB["TREE"],{CL["&KEY"],{CL_LIB["KEY"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}}},function (l1, l2, l3, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  return CL["NSUBST"](l1, l2, CL["COPY-TREE"](l3), k(CL_LIB["KEY"], keys[CL_LIB["KEY"]], CL_LIB["TEST"], keys[CL_LIB["TEST"]], CL_LIB["TEST-NOT"], keys[CL_LIB["TEST-NOT"]])) end, 3, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["APPLY-GEN-LIST"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ARGS"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["NULL"](l1) then  single_value();  l2 = n.bound else  local l3 = n if n ~= CL["NULL"]((l1)[2]) then  single_value();  l3 = (l1)[1] else  local l4 = n if n ~= CL["T"].bound then  single_value();  l4 = CL["CONS"]((l1)[1], CL_LIB["APPLY-GEN-LIST"]((l1)[2])) else  l4 = n.bound end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["APPLY"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FUNC"],{CL_LIB["ARG"],{CL["&REST"],{CL_LIB["ARGS"],n}}}},function (l1, l2, l3,  ...)   single_value();  local l4 = n if n ~= CL["ENDP"](l3) then  single_value();  l4 = CL.FUNCALL(l1, l2) else  local l5 = n if n ~= CL["T"].bound then  single_value();  l5 = CL.FUNCALL(l1, CL["CONS"](l2, CL_LIB["APPLY-GEN-LIST"](l3))) else  l5 = n.bound end l4 = l5 end return l4 end, 2, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["IDENTITY"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],n},function (l1,  ...)   single_value();  return l1 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["COMPLEMENT"] , CL_LIB["ALLOC-FUNCTION"]({CL["FUNCTION"],n},function (l1,  ...)   single_value();  return CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["ARGS"],n}},function (l2,  ...)   single_value();  return CL["NOT"](CL["APPLY"](l1, l2, l())) end, 0, 0, true, false) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CONSTANTLY"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["VALUE"],n},function (l1,  ...)   single_value();  return CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["ARGS"],n}},function (l2,  ...)   single_value();  return l1 end, 0, 0, true, false) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["NOT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= l1 then  l2 = n.bound else  l2 = CL["T"].bound end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["NULL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],n},function (l1,  ...)   single_value();  return CL["NOT"](l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["COMPILED-FUNCTION-P"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FUN"],n},function (l1,  ...)   single_value();  return CL["FUNCTIONP"](l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CONSTANTP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FORM"],{CL["&OPTIONAL"],{CL_LIB["ENVIRONMENT"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  return n.bound end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LISP-IMPLEMENTATION-TYPE"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   i( "" );
 single_value();  return "LCL" end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LISP-IMPLEMENTATION-VERSION"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   i( "" );
 single_value();  return "0.1" end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SHORT-SITE-NAME"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return n.bound end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LONG-SITE-NAME"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return n.bound end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ROOM"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{{CL_LIB["X"],{LCL["KEYWORD"]["DEFAULT"],n}},n}},function (l1,  ...)  if not l1 then  l1 = LCL["KEYWORD"]["DEFAULT"] end  single_value();  return n.bound end, 0, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SOFTWARE-TYPE"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return n.bound end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SOFTWARE-VERSION"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return n.bound end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MACHINE-INSTANCE"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return n.bound end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MACHINE-TYPE"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return n.bound end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MACHINE-VERSION"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return n.bound end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FUNCTION-LAMBDA-EXPRESSION"] , CL_LIB["ALLOC-FUNCTION"]({CL["FUNCTION"],n},function (l1,  ...)   single_value();  return CL["VALUES"](l(n.bound,CL["T"].bound,n.bound)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ED"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{CL_LIB["X"],n}},function (l1,  ...)  if not l1 then  l1 = n.bound end  single_value();  return n.bound end, 0, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["IN-PACKAGE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G51549"],{CL["&OPTIONAL"],{LCL["NIL"]["G51550"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  single_value();  return n.bound end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["PERFORM-QUASIQUOTE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ARG"],{CL["&OPTIONAL"],{{CL_LIB["LEVEL"],{0,n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = 0 end  single_value();  local l3 = n if n ~= CL["NOT"](CL["CONSP"](l1)) then  single_value();  local l4 = n if n ~= CL["EQ"](0, l2) then  l4 = CL["LIST"](l(CL["QUOTE"],l1)) else  l4 = l1 end l3 = l4 else  local l5 = n if n ~= CL["EQ"]((l1)[1], CL_LIB["QUASIQUOTE"]) then  single_value();  l5 = CL["LIST"](l(CL["QUOTE"],CL["LIST"](l(CL_LIB["%QUASIQUOTE"],CL_LIB["PERFORM-QUASIQUOTE"](CL["CADR"](l1), (l2 + 1)))))) else  local l6 = n if n ~= CL["EQ"]((l1)[1], CL_LIB["UNQUOTE"]) then  single_value();  local l7 = n if n ~= CL["EQ"](0, l2) then  l7 = CL["CADR"](l1) else  l7 = CL["LIST"](l(CL_LIB["UNQUOTE"],CL_LIB["PERFORM-QUASIQUOTE"](CL["CADR"](l1), (l2 - 1)))) end l6 = l7 else  local l8 = n if n ~= CL["EQ"]((l1)[1], CL_LIB["UNQUOTE-LIST"]) then  single_value();  l8 = CL["ERROR"]("Malformed quasiquote expression", l()) else  local l10 = n if n ~= CL["CONSP"]((l1)[1]) then  l10 = CL["EQ"](CL["CAAR"](l1), CL_LIB["UNQUOTE-LIST"]) else  l10 = n.bound end local l9 = n if n ~= l10 then  single_value();  local l11 = n if n ~= CL["EQ"](0, l2) then  l11 = CL["LIST"](l(CL["APPEND"],CL["CADAR"](l1),CL_LIB["PERFORM-QUASIQUOTE"]((l1)[2], l2))) else  l11 = CL["LIST*"](l(CL["LIST"](l(CL_LIB["UNQUOTE-LIST"],CL_LIB["PERFORM-QUASIQUOTE"](CL["CADAR"](l1), l2))),CL_LIB["PERFORM-QUASIQUOTE"]((l1)[2], l2))) end l9 = l11 else  local l12 = n if n ~= CL["T"].bound then  single_value();  local l13 = n if n ~= CL["EQ"](0, l2) then  l13 = CL["LIST"](l(CL["CONS"],CL_LIB["PERFORM-QUASIQUOTE"]((l1)[1], l2),CL_LIB["PERFORM-QUASIQUOTE"]((l1)[2], l2))) else  l13 = CL["CONS"](CL_LIB["PERFORM-QUASIQUOTE"]((l1)[1], l2), CL_LIB["PERFORM-QUASIQUOTE"]((l1)[2], l2)) end l12 = l13 else  l12 = n.bound end l9 = l12 end l8 = l9 end l6 = l8 end l5 = l6 end l3 = l5 end return l3 end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["QUASIQUOTE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G51666"],{CL["&OPTIONAL"],{LCL["NIL"]["G51667"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  single_value();  return CL_LIB["PERFORM-QUASIQUOTE"](l5, false) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["%QUASIQUOTE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G51714"],{CL["&OPTIONAL"],{LCL["NIL"]["G51715"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  single_value();  return CL_LIB["PERFORM-QUASIQUOTE"](l5, false) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["UNQUOTE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G51762"],{CL["&OPTIONAL"],{LCL["NIL"]["G51763"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  single_value();  return CL["ERROR"](", not inside a quasiquote", l()) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["UNQUOTE-LIST"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G51811"],{CL["&OPTIONAL"],{LCL["NIL"]["G51812"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  single_value();  return CL["ERROR"](",@ not inside a quasiquote", l()) end, 1, 1, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["FUNCTION-SETQ"](CL["HASH-TABLE-SIZE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["HT"],n},function (l1,  ...)   single_value();  return 0 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["HASH-TABLE-REHASH-SIZE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["HT"],n},function (l1,  ...)   single_value();  return 1 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["HASH-TABLE-REHASH-THRESHOLD"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["HT"],n},function (l1,  ...)   single_value();  return 0.5 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["HASH-TABLE-TEST"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["HT"],n},function (l1,  ...)   single_value();  return CL["EQL"] end, 1, 0, false, false)); local l1 = CL["GENSYM"](false); single_value();  tmp = CL_LIB["FUNCTION-SETQ"](CL["REMHASH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["KEY"],{CL["HASH-TABLE"],n}},function (l2, l3,  ...)   single_value();  local l4 = CL["GETHASH"](l2, l3, l1); i( CL_LIB["SETHASH"](l2, l3, nil) );
 single_value();  return CL["EQ"](l4, l1) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAPHASH"] , CL_LIB["ALLOC-FUNCTION"]({CL["FUNCTION"],{CL["HASH-TABLE"],n}},function (l1, l2,  ...)   single_value();  local l3 = "data"; local l4 = n.bound; single_value();  for __k, __v in pairs(((l2)[l3] or l4)) do  local l5 = __k; local l6 = __v; single_value();  local l7 = l5; single_value();  local l8 = l6; single_value();  local tmpres = CL_LIB['FUNCALL-LUA'](l1,{l7, l8, }) end return n end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SXHASH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l1,  ...)   single_value();  return l1 end, 1, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["WITH-HASH-TABLE-ITERATOR"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G54485"],{CL["&OPTIONAL"],{LCL["NIL"]["G54486"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = l5; single_value();  local l11 = l5; single_value();  local l13 = l11; single_value();  local l14 = (l13)[1]; single_value();  single_value();  local l15 = (l13)[2]; single_value();  l11 = l15 i( l11 );
 single_value();  local l12 = l14; single_value();  local l17 = l11; single_value();  local l18 = (l17)[1]; single_value();  single_value();  local l19 = (l17)[2]; single_value();  l11 = l19 i( l11 );
 single_value();  local l16 = l18; single_value();  single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](CL_LIB["%%PL"], CL["CONS"](l16, n)), n), CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](CL_LIB["%%PL"], CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](CL_LIB["EL"], CL["CONS"](CL_LIB["%%PL"], n)), n), CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](CL_LIB["EL"], CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"](CL_LIB["EL"], CL["CONS"](".data", n))), n))), CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](CL_LIB["ITER"], CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"]("pairs(", CL["CONS"](CL_LIB["EL"], CL["CONS"](")", n)))), n)), CL["CONS"](CL["CONS"](CL_LIB["KEY"], CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"]("nil", n)), n)), n)), CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](n, CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL_LIB["K"], CL["CONS"](CL_LIB["V"], n)), CL["CONS"](CL["CONS"](CL_LIB["LUA-PUSH"], CL["CONS"](CL["CONS"](CL_LIB["K"], CL["CONS"](", ", CL["CONS"](CL_LIB["V"], CL["CONS"](" = ", CL["CONS"](CL_LIB["ITER"], CL["CONS"]("(", CL["CONS"](CL_LIB["EL"], CL["CONS"](", ", CL["CONS"](CL_LIB["KEY"], CL["CONS"](")", n)))))))))), CL["CONS"](CL["CONS"](CL["IF"], CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"](CL_LIB["K"], CL["CONS"](" or n", n))), CL["CONS"](CL["CONS"](CL["PROGN"], CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](CL_LIB["KEY"], CL["CONS"](CL_LIB["K"], n))), CL["CONS"](CL["CONS"](CL["VALUES"], CL["CONS"](CL_LIB["KEY"], CL["CONS"](CL_LIB["V"], CL["CONS"](CL["T"], n)))), n))), CL["CONS"](CL["CONS"](CL["VALUES"], CL["CONS"](n, CL["CONS"](n, CL["CONS"](n, n)))), n)))), n))), n))), n))), n))), n)))), n))), CL["CONS"](CL["CONS"](CL["MACROLET"], CL["CONS"](CL["CONS"](CL["CONS"](l12, CL["CONS"](n, CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["CONS"](CL["BLOCK"], CL["CONS"](n, CL["CONS"](CL["CONS"](CL_LIB["%LOOP"], CL["CONS"](CL["CONS"](CL["IF"], CL["CONS"](CL_LIB["%%PL"], CL["CONS"](CL["CONS"](CL["MULTIPLE-VALUE-BIND"], CL["CONS"](CL["CONS"](CL_LIB["K"], CL["CONS"](CL_LIB["V"], CL["CONS"](CL_LIB["IS"], n))), CL["CONS"](CL["CONS"](CL["FUNCALL"], CL["CONS"](CL_LIB["%%PL"], n)), CL["CONS"](CL["CONS"](CL["IF"], CL["CONS"](CL_LIB["IS"], CL["CONS"](CL["CONS"](CL["RETURN"], CL["CONS"](CL["CONS"](CL["VALUES"], CL["CONS"](CL["T"], CL["CONS"](CL_LIB["K"], CL["CONS"](CL_LIB["V"], n)))), n)), CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](CL_LIB["%%PL"], CL["CONS"](n, n))), n)))), n)))), CL["CONS"](CL["CONS"](CL["RETURN"], CL["CONS"](CL["CONS"](CL["VALUES"], CL["CONS"](n, CL["CONS"](n, CL["CONS"](n, n)))), n)), n)))), n)), n))), n)), n))), n), CL["APPEND"](l(l9,n)))), n)))) end, 1, 1, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["NEQ"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],{CL_LIB["Y"],n}},function (l1, l2,  ...)   single_value();  return CL["NOT"](CL["EQ"](l1, l2)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["EQL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],{CL_LIB["Y"],n}},function (l1, l2,  ...)   single_value();  return CL["EQ"](l1, l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["EQUAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],{CL_LIB["Y"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["EQL"](l1, l2) then  single_value();  l3 = CL["T"].bound else  local l4 = n if n ~= CL["CONSP"](l1) then  single_value();  local l5 = n if n ~= CL["CONSP"](l2) then  local l6 = n if n ~= CL["EQUAL"]((l1)[1], (l2)[1]) then  l6 = CL["EQUAL"]((l1)[2], (l2)[2]) else  l6 = n.bound end l5 = l6 else  l5 = n.bound end l4 = l5 else  local l7 = n if n ~= CL["STRINGP"](l1) then  single_value();  local l8 = n if n ~= CL["STRINGP"](l2) then  l8 = CL["STRING="](l1, l(l2)) else  l8 = n.bound end l7 = l8 else  local l9 = n if n ~= CL["T"].bound then  single_value();  l9 = n.bound else  l9 = n.bound end l7 = l9 end l4 = l7 end l3 = l4 end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["EQUALP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],{CL_LIB["Y"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["EQ"](l1, l2) then  single_value();  l3 = CL["T"].bound else  local l4 = n if n ~= CL["CHARACTERP"](l1) then  single_value();  local l5 = n if n ~= CL["CHARACTERP"](l2) then  l5 = CL["CHAR-EQUAL"](l1, l(l2)) else  l5 = n.bound end l4 = l5 else  local l6 = n if n ~= CL["STRINGP"](l1) then  single_value();  local l7 = n if n ~= CL["STRINGP"](l2) then  l7 = CL["EQ"](CL["STRING-DOWNCASE"](l1, k()), CL["STRING-DOWNCASE"](l2, k())) else  l7 = n.bound end l6 = l7 else  local l8 = n if n ~= CL["NUMBERP"](l1) then  single_value();  local l9 = n if n ~= CL["NUMBERP"](l2) then  l9 = CL["EQ"](l1, l2) else  l9 = n.bound end l8 = l9 else  local l10 = n if n ~= CL["CONSP"](l1) then  single_value();  local l11 = n if n ~= CL["CONSP"](l2) then  local l12 = n if n ~= CL["EQUALP"]((l1)[1], (l2)[1]) then  l12 = CL["EQUALP"]((l1)[2], (l2)[2]) else  l12 = n.bound end l11 = l12 else  l11 = n.bound end l10 = l11 else  local l13 = n if n ~= CL["ARRAYP"](l1) then  single_value();  local l14 = n if n ~= CL["ARRAYP"](l2) then  local l16 = n if n ~= CL["STRINGP"](l1) then  l16 = CL["STRINGP"](l2) else  l16 = n.bound end local l15 = n if n ~= l16 then  single_value();  l15 = CL["STRING-EQUAL"](l1, l(l2)) else  local l18 = n if n ~= CL_LIB["FUNCALL-LUA"]( CL_LIB["BIT-VECTOR-P"].fbound, {l1, }) then  l18 = CL_LIB["FUNCALL-LUA"]( CL_LIB["BIT-VECTOR-P"].fbound, {l2, }) else  l18 = n.bound end local l17 = n if n ~= l18 then  single_value();  l17 = CL_LIB["FUNCALL-LUA"]( CL_LIB["BIT-VECTOR-="].fbound, {l1, l2, }) else  local l19 = n if n ~= CL["T"].bound then  single_value();  l19 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ARRAY-EQUALP"].fbound, {l1, l2, }) else  l19 = n.bound end l17 = l19 end l15 = l17 end l14 = l15 else  l14 = n.bound end l13 = l14 else  local l20 = n if n ~= CL["T"].bound then  single_value();  l20 = n.bound else  l20 = n.bound end l13 = l20 end l10 = l13 end l8 = l10 end l6 = l8 end l4 = l6 end l3 = l4 end return l3 end, 2, 0, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["FUNCTION-SETQ"](CL["ZEROP"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["NUMBERP"](l1) then  l2 = CL["EQ"](0, l1) else  l2 = CL["ERROR"]("zerop, not a number", l()) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PLUSP"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL[">"](l(l1,0)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MINUSP"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL_LIB["%<"](l1, 0) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%INTEGERP"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL_LIB["%NUMBERP"](l1) then  l2 = CL["EQ"](l1, CL_LIB["%//"](l1, 1)) else  l2 = n.bound end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FIXNUMP"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL_LIB["%INTEGERP"](l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["RATIONALP"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  local l2 = CL_LIB["%INTEGERP"](l1); single_value();  local l3 = n if n ~= l2 then  l3 = l2 else  l3 = CL_LIB["%RATIONALP"](l1) end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["NUMBERP"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  local l2 = CL["REALP"](l1); single_value();  local l3 = n if n ~= l2 then  l3 = l2 else  l3 = CL["COMPLEXP"](l1) end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["INTEGERP"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL_LIB["%NUMBERP"](l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FLOATP"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL_LIB["%NUMBERP"](l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["REALP"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  local l2 = CL["RATIONALP"](l1); single_value();  local l3 = n if n ~= l2 then  l3 = l2 else  l3 = CL["FLOATP"](l1) end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["EVENP"] , CL_LIB["ALLOC-FUNCTION"]({CL["INTEGER"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["INTEGERP"](l1) then  l2 = CL["EQ"](0, CL_LIB["%%"](l1, 2)) else  l2 = CL["ERROR"]("EVENP expects an integer, got ~S", l(l1)) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ODDP"] , CL_LIB["ALLOC-FUNCTION"]({CL["INTEGER"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["INTEGERP"](l1) then  l2 = CL["EQ"](1, CL_LIB["%%"](l1, 2)) else  l2 = CL["ERROR"]("ODDP expects an integer, got ~S", l(l1)) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["+"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["NUMBERS"],n}},function (l1,  ...)   single_value();  local l2 = 0; local l3 = l1; single_value();  local l4 = (l3)[1]; single_value();  single_value();  local l5 = CL["GENSYM"](false); single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l7 = n if n ~= CL["NOT"](l3) then  single_value(); do break end; l7 = n.bound else  l7 = n.bound end i( l7 );
 l2 = CL_LIB["%+"](l2, l4) i( l2 );
 single_value();  single_value();  local l8 = (l3)[2]; single_value();  l3 = l8 i( l3 );
 single_value();  single_value();  single_value();  local l9 = (l3)[1]; single_value();  l4 = l9 local tmpres = l4 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l6.error ~= n and (l6.error ~= KEYWORD.TAG or l6.tag ~= l5) then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end i( CL["VALUES-LIST"](list_r(l6)) );
 single_value();  return l2 end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["-"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["NUMBERS"],n}},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["EQ"](CL["LENGTH"](l1), 1) then  single_value();  l2 = CL_LIB["%-"](0, (l1)[1]) else  local l3 = n if n ~= CL["EQ"](CL["LENGTH"](l1), 0) then  single_value();  l3 = CL["ERROR"]("-, no arguments", l()) else  local l4 = n if n ~= CL["T"].bound then  single_value();  local l5 = (l1)[1]; local l6 = (l1)[2]; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = CL["GENSYM"](false); single_value();  local l9 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l10 = n if n ~= CL["NOT"](l6) then  single_value(); do break end; l10 = n.bound else  l10 = n.bound end i( l10 );
 l5 = CL_LIB["%-"](l5, l7) i( l5 );
 single_value();  single_value();  local l11 = (l6)[2]; single_value();  l6 = l11 i( l6 );
 single_value();  single_value();  single_value();  local l12 = (l6)[1]; single_value();  l7 = l12 local tmpres = l7 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l9.error ~= n and (l9.error ~= KEYWORD.TAG or l9.tag ~= l8) then if l9.error == KEYWORD.TAG then  error(l9) else error(l9[1]) end end i( CL["VALUES-LIST"](list_r(l9)) );
 single_value();  l4 = l5 else  l4 = n.bound end l3 = l4 end l2 = l3 end return l2 end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["*"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["NUMBERS"],n}},function (l1,  ...)   single_value();  local l2 = 1; local l3 = l1; single_value();  local l4 = (l3)[1]; single_value();  single_value();  local l5 = CL["GENSYM"](false); single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l7 = n if n ~= CL["NOT"](l3) then  single_value(); do break end; l7 = n.bound else  l7 = n.bound end i( l7 );
 l2 = CL_LIB["%*"](l2, l4) i( l2 );
 single_value();  single_value();  local l8 = (l3)[2]; single_value();  l3 = l8 i( l3 );
 single_value();  single_value();  single_value();  local l9 = (l3)[1]; single_value();  l4 = l9 local tmpres = l4 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l6.error ~= n and (l6.error ~= KEYWORD.TAG or l6.tag ~= l5) then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end i( CL["VALUES-LIST"](list_r(l6)) );
 single_value();  return l2 end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["/"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["NUMBERS"],n}},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["EQ"](CL["LENGTH"](l1), 1) then  single_value();  l2 = CL_LIB["%/"](1, (l1)[1]) else  local l3 = n if n ~= CL["EQ"](CL["LENGTH"](l1), 0) then  single_value();  l3 = CL["ERROR"]("/, no arguments", l()) else  local l4 = n if n ~= CL["T"].bound then  single_value();  local l5 = (l1)[1]; local l6 = (l1)[2]; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = CL["GENSYM"](false); single_value();  local l9 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l10 = n if n ~= CL["NOT"](l6) then  single_value(); do break end; l10 = n.bound else  l10 = n.bound end i( l10 );
 l5 = CL_LIB["%/"](l5, l7) i( l5 );
 single_value();  single_value();  local l11 = (l6)[2]; single_value();  l6 = l11 i( l6 );
 single_value();  single_value();  single_value();  local l12 = (l6)[1]; single_value();  l7 = l12 local tmpres = l7 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l9.error ~= n and (l9.error ~= KEYWORD.TAG or l9.tag ~= l8) then if l9.error == KEYWORD.TAG then  error(l9) else error(l9[1]) end end i( CL["VALUES-LIST"](list_r(l9)) );
 single_value();  l4 = l5 else  l4 = n.bound end l3 = l4 end l2 = l3 end return l2 end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FLOOR"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],{CL["&OPTIONAL"],{{CL_LIB["DIVISOR"],{1,n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = 1 end  single_value();  local l3 = CL_LIB["%//"](l1, l2); single_value();  local l4 = (l1 - (l3 * l2)); single_value();  single_value();  return CL["VALUES"](l(l3,l4)) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FFLOOR"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],{CL["&OPTIONAL"],{{CL_LIB["DIVISOR"],{1,n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = 1 end  single_value();  return CL["FLOOR"](l1, l2) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["TRUNCATE"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],{CL["&OPTIONAL"],{{CL_LIB["DIVISOR"],{1,n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = 1 end  single_value();  local l3 = (CL["SIGNUM"](l1) * CL["SIGNUM"](l2) * CL_LIB["%//"](CL["ABS"](l1), CL["ABS"](l2))); single_value();  local l4 = (l1 - (l3 * l2)); single_value();  single_value();  return CL["VALUES"](l(l3,l4)) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FTRUNCATE"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],{CL["&OPTIONAL"],{{CL_LIB["DIVISOR"],{1,n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = 1 end  single_value();  return CL["TRUNCATE"](l1, l2) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CEILING"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],{CL["&OPTIONAL"],{{CL_LIB["DIVISOR"],{1,n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = 1 end  single_value();  local l3 = CL["FUNCALL"](math.ceil, l(CL_LIB["%/"](l1, l2))); single_value();  local l4 = (l1 - (l3 * l2)); single_value();  single_value();  return CL["VALUES"](l(l3,l4)) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FCEILING"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],{CL["&OPTIONAL"],{{CL_LIB["DIVISOR"],{1,n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = 1 end  single_value();  return CL["CEILING"](l1, l2) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ROUND"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],{CL["&OPTIONAL"],{{CL_LIB["DIVISOR"],{1,n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = 1 end  single_value();  local l3 = (0.5 + CL_LIB["%/"](l1, l2)); single_value();  local l4 = CL_LIB["%MODF"](l3); single_value();  local l6 = n if n ~= CL["NOT"](CL["ZEROP"](l4)) then  single_value();  l6 = CL["FUNCALL"](math.floor, l(l3)) else  local l7 = n if n ~= CL["EVENP"](l3) then  single_value();  l7 = l3 else  local l8 = n if n ~= CL["T"].bound then  single_value();  l8 = (l3 - 1) else  l8 = n.bound end l7 = l8 end l6 = l7 end local l5 = l6; single_value();  local l9 = (l1 - (l5 * l2)); single_value();  single_value();  return CL["VALUES"](l(l5,l9)) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FROUND"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],{CL["&OPTIONAL"],{{CL_LIB["DIVISOR"],{1,n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = 1 end  single_value();  return CL["ROUND"](l1, l2) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MOD"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],{CL_LIB["DIVISOR"],n}},function (l1, l2,  ...)   single_value();  return CL["NTH"](1, CL["FUNCALL"](l, l(unpack_mv(CL["FLOOR"](l1, l2))))) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["REM"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],{CL_LIB["DIVISOR"],n}},function (l1, l2,  ...)   single_value();  return CL["NTH"](1, CL["FUNCALL"](l, l(unpack_mv(CL["TRUNCATE"](l1, l2))))) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["1+"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return (l1 + 1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["1-"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return (l1 - 1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%COMPARE-WITH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FUNC"],{CL_LIB["NUMBERS"],n}},function (l1, l2,  ...)   single_value();  local l3 = CL["LENGTH"](l2); single_value();  local l4 = n if n ~= CL_LIB["%="](0, l3) then  single_value();  l4 = CL["ERROR"]("Can't compare 0 elements", l()) else  local l5 = n if n ~= CL_LIB["%="](1, l3) then  single_value();  l5 = CL["T"].bound else  local l6 = n if n ~= CL["T"].bound then  single_value();  local l8 = (l2)[1]; single_value();  local l9 = CL["CADR"](l2); single_value();  local l7 = n if n ~= CL_LIB['FUNCALL-LUA'](l1,{l8, l9, }) then  l7 = CL_LIB["%COMPARE-WITH"](l1, (l2)[2]) else  l7 = n.bound end l6 = l7 else  l6 = n.bound end l5 = l6 end l4 = l5 end return l4 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["<"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["NUMBERS"],n}},function (l1,  ...)   single_value();  return CL_LIB["%COMPARE-WITH"](CL_LIB["%<"].fbound, l1) end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["<="] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["NUMBERS"],n}},function (l1,  ...)   single_value();  return CL_LIB["%COMPARE-WITH"](CL_LIB["%<="].fbound, l1) end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL[">"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["NUMBERS"],n}},function (l1,  ...)   single_value();  return CL_LIB["%COMPARE-WITH"](CL_LIB["%>"].fbound, l1) end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL[">="] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["NUMBERS"],n}},function (l1,  ...)   single_value();  return CL_LIB["%COMPARE-WITH"](CL_LIB["%>="].fbound, l1) end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["="] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["NUMBERS"],n}},function (l1,  ...)   single_value();  return CL_LIB["%COMPARE-WITH"](CL_LIB["%="].fbound, l1) end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["/="] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],{CL_LIB["B"],n}},function (l1, l2,  ...)   single_value();  return CL_LIB["%/="](l1, l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LOGAND"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["INTEGERS"],n}},function (l1,  ...)   single_value();  local l2 = n if n ~= l1 then  local l3 = (l1)[1]; local l4 = (l1)[2]; single_value();  local l5 = (l4)[1]; single_value();  single_value();  local l6 = CL["GENSYM"](false); single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l8 = n if n ~= CL["NOT"](l4) then  single_value(); do break end; l8 = n.bound else  l8 = n.bound end i( l8 );
 l3 = CL_LIB["%LOGAND"](l3, l5) i( l3 );
 single_value();  single_value();  local l9 = (l4)[2]; single_value();  l4 = l9 i( l4 );
 single_value();  single_value();  single_value();  local l10 = (l4)[1]; single_value();  l5 = l10 local tmpres = l5 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l7.error ~= n and (l7.error ~= KEYWORD.TAG or l7.tag ~= l6) then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end i( CL["VALUES-LIST"](list_r(l7)) );
 single_value();  l2 = l3 else  l2 = -1 end return l2 end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LOGANDC1"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["INT1"],{CL_LIB["INT2"],n}},function (l1, l2,  ...)   single_value();  return CL_LIB["%LOGAND"](CL_LIB["%LOGNOT"](l1), l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LOGANDC2"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["INT1"],{CL_LIB["INT2"],n}},function (l1, l2,  ...)   single_value();  return CL_LIB["%LOGAND"](l1, CL_LIB["%LOGNOT"](l2)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LOGIOR"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["INTEGERS"],n}},function (l1,  ...)   single_value();  local l2 = 0; local l3 = l1; single_value();  local l4 = (l3)[1]; single_value();  single_value();  local l5 = CL["GENSYM"](false); single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l7 = n if n ~= CL["NOT"](l3) then  single_value(); do break end; l7 = n.bound else  l7 = n.bound end i( l7 );
 l2 = CL_LIB["%LOGIOR"](l2, l4) i( l2 );
 single_value();  single_value();  local l8 = (l3)[2]; single_value();  l3 = l8 i( l3 );
 single_value();  single_value();  single_value();  local l9 = (l3)[1]; single_value();  l4 = l9 local tmpres = l4 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l6.error ~= n and (l6.error ~= KEYWORD.TAG or l6.tag ~= l5) then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end i( CL["VALUES-LIST"](list_r(l6)) );
 single_value();  return l2 end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LOGNAND"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["INT1"],{CL_LIB["INT2"],n}},function (l1, l2,  ...)   single_value();  return CL_LIB["%LOGNOT"](CL_LIB["%LOGAND"](l1, l2)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LOGNOR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["INT1"],{CL_LIB["INT2"],n}},function (l1, l2,  ...)   single_value();  return CL_LIB["%LOGNOT"](CL_LIB["%LOGIOR"](l1, l2)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LOGNOT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["INT"],n},function (l1,  ...)   single_value();  return CL_LIB["%LOGNOT"](l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LOGORC1"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["INT1"],{CL_LIB["INT2"],n}},function (l1, l2,  ...)   single_value();  return CL_LIB["%LOGIOR"](CL_LIB["%LOGNOT"](l1), l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LOGORC2"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["INT1"],{CL_LIB["INT2"],n}},function (l1, l2,  ...)   single_value();  return CL_LIB["%LOGIOR"](l1, CL_LIB["%LOGNOT"](l2)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LOGXOR"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["INTEGERS"],n}},function (l1,  ...)   single_value();  local l2 = 0; local l3 = l1; single_value();  local l4 = (l3)[1]; single_value();  single_value();  local l5 = CL["GENSYM"](false); single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l7 = n if n ~= CL["NOT"](l3) then  single_value(); do break end; l7 = n.bound else  l7 = n.bound end i( l7 );
 l2 = CL_LIB["%LOGXOR"](l2, l4) i( l2 );
 single_value();  single_value();  local l8 = (l3)[2]; single_value();  l3 = l8 i( l3 );
 single_value();  single_value();  single_value();  local l9 = (l3)[1]; single_value();  l4 = l9 local tmpres = l4 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l6.error ~= n and (l6.error ~= KEYWORD.TAG or l6.tag ~= l5) then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end i( CL["VALUES-LIST"](list_r(l6)) );
 single_value();  return l2 end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LOGBITP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["INDEX"],{CL["NUMBER"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["INTEGERP"](l2) then  l3 = CL["/="](0, CL["LOGAND"](l(CL_LIB["%LSH"](1, l1),l2))) else  l3 = CL["ERROR"]("logbitp, not an integer", l()) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LOGTEST"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["INT1"],{CL_LIB["INT2"],n}},function (l1, l2,  ...)   single_value();  return CL["NOT"](CL["ZEROP"](CL["LOGAND"](l(l1,l2)))) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["BOOLE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OP"],{CL_LIB["INT1"],{CL_LIB["INT2"],n}}},function (l1, l2, l3,  ...)   local l5 = n if n ~= CL["INTEGERP"](l2) then  l5 = CL["INTEGERP"](l3) else  l5 = n.bound end local l4 = n if n ~= l5 then  l4 = n.bound else  single_value();  l4 = CL["ERROR"]("boole, not integers", l()) end i( l4 );
 single_value();  local l6 = n if n ~= CL["EQ"](CL["BOOLE-1"].bound, l1) then  single_value();  l6 = l2 else  local l7 = n if n ~= CL["EQ"](CL["BOOLE-2"].bound, l1) then  single_value();  l7 = l3 else  local l8 = n if n ~= CL["EQ"](CL["BOOLE-ANDC1"].bound, l1) then  single_value();  l8 = CL["LOGANDC1"](l2, l3) else  local l9 = n if n ~= CL["EQ"](CL["BOOLE-ANDC2"].bound, l1) then  single_value();  l9 = CL["LOGANDC2"](l2, l3) else  local l10 = n if n ~= CL["EQ"](CL["BOOLE-AND"].bound, l1) then  single_value();  l10 = CL["LOGAND"](l(l2,l3)) else  local l11 = n if n ~= CL["EQ"](CL["BOOLE-C1"].bound, l1) then  single_value();  l11 = CL_LIB["%LOGNOT"](l2) else  local l12 = n if n ~= CL["EQ"](CL["BOOLE-C2"].bound, l1) then  single_value();  l12 = CL_LIB["%LOGNOT"](l3) else  local l13 = n if n ~= CL["EQ"](CL["BOOLE-CLR"].bound, l1) then  single_value();  l13 = 0 else  local l14 = n if n ~= CL["EQ"](CL["BOOLE-EQV"].bound, l1) then  single_value();  l14 = CL["LOGXOR"](l(l2,CL_LIB["%LOGNOT"](l3))) else  local l15 = n if n ~= CL["EQ"](CL["BOOLE-IOR"].bound, l1) then  single_value();  l15 = CL["LOGIOR"](l(l2,l3)) else  local l16 = n if n ~= CL["EQ"](CL["BOOLE-NAND"].bound, l1) then  single_value();  l16 = CL["LOGNAND"](l2, l3) else  local l17 = n if n ~= CL["EQ"](CL["BOOLE-NOR"].bound, l1) then  single_value();  l17 = CL["LOGNOR"](l2, l3) else  local l18 = n if n ~= CL["EQ"](CL["BOOLE-ORC1"].bound, l1) then  single_value();  l18 = CL["LOGORC1"](l2, l3) else  local l19 = n if n ~= CL["EQ"](CL["BOOLE-ORC2"].bound, l1) then  single_value();  l19 = CL["LOGORC2"](l2, l3) else  local l20 = n if n ~= CL["EQ"](CL["BOOLE-SET"].bound, l1) then  single_value();  l20 = -1 else  local l21 = n if n ~= CL["EQ"](CL["BOOLE-XOR"].bound, l1) then  single_value();  l21 = CL["LOGXOR"](l(l2,l3)) else  l21 = n.bound end l20 = l21 end l19 = l20 end l18 = l19 end l17 = l18 end l16 = l17 end l15 = l16 end l14 = l15 end l13 = l14 end l12 = l13 end l11 = l12 end l10 = l11 end l9 = l10 end l8 = l9 end l7 = l8 end l6 = l7 end return l6 end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["COMPLEX"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["REAL"],{CL["&OPTIONAL"],{{CL_LIB["IMAG"],{0,n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = 0 end  single_value();  local l3 = n if n ~= CL["EQ"](l2, 0) then  l3 = l1 else  l3 = CL_LIB["MAKE-COMPLEX"](l1, l2) end return l3 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CONJUGATE"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["COMPLEXP"](l1) then  single_value();  l2 = CL["COMPLEX"](CL["REALPART"](l1), - CL["IMAGPART"](l1)) else  local l3 = n if n ~= CL_LIB["%NUMBERP"](l1) then  single_value();  l3 = l1 else  local l4 = n if n ~= CL["T"].bound then  single_value();  l4 = CL["ERROR"]("conjugate, not a number", l()) else  l4 = n.bound end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ABS"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["COMPLEXP"](l1) then  single_value();  local l3 = CL["REALPART"](l1); local l4 = CL["IMAGPART"](l1); single_value();  l2 = CL_LIB["%SQRT"](((l3 * l3) + (l4 * l4))) else  local l5 = n if n ~= CL["NOT"](CL_LIB["%NUMBERP"](l1)) then  single_value();  l5 = CL["ERROR"]("abs, not a number", l()) else  local l6 = n if n ~= CL_LIB["%<"](l1, 0) then  single_value();  l6 = - l1 else  local l7 = n if n ~= CL["T"].bound then  single_value();  l7 = l1 else  l7 = n.bound end l6 = l7 end l5 = l6 end l2 = l5 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PHASE"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  return CL["ATAN"](CL["IMAGPART"](l1), CL["REALPART"](l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ASH"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],{CL["COUNT"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL_LIB["%NUMBERP"](l1) then  local l4 = n if n ~= CL_LIB["%<"](l2, 0) then  l4 = CL_LIB["%RSH"](l1, - l2) else  l4 = CL_LIB["%LSH"](l1, l2) end l3 = l4 else  l3 = CL["ERROR"]("ash, not a number", l()) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SIGNUM"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["ZEROP"](l1) then  l2 = l1 else  l2 = CL["/"](l(l1,CL["ABS"](l1))) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SQRT"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["COMPLEXP"](l1) then  single_value();  l2 = CL["EXPT"](l1, 0.5) else  local l3 = n if n ~= CL_LIB["%<"](l1, 0) then  single_value();  l3 = CL["COMPLEX"](0, CL_LIB["%SQRT"](- l1)) else  local l4 = n if n ~= CL["T"].bound then  single_value();  l4 = CL_LIB["%SQRT"](l1) else  l4 = n.bound end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ISQRT"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  local l3 = n if n ~= CL["INTEGERP"](l1) then  l3 = CL[">="](l(l1,0)) else  l3 = n.bound end local l2 = n if n ~= l3 then  l2 = CL_LIB["%FLOOR"](CL_LIB["%SQRT"](l1)) else  l2 = CL["ERROR"]("isqrt, not a number", l()) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CIS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["RADIANS"],n},function (l1,  ...)   single_value();  return CL["EXP"]((c(0,1) * l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["EXP"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["COMPLEXP"](l1) then  local l3 = CL["REALPART"](l1); local l4 = CL["IMAGPART"](l1); single_value();  l2 = (CL["EXP"](l3) * (CL["COS"](l4) + (c(0,1) * CL["SIN"](l4)))) else  l2 = CL_LIB["%EXP"](l1) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LOG"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],{CL["&OPTIONAL"],{CL_LIB["BASE"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = n if n ~= CL["NULL"](l2) then  single_value();  local l5 = CL["COMPLEXP"](l1); single_value();  local l6 = n if n ~= l5 then  l6 = l5 else  l6 = CL_LIB["%<"](l1, 0) end local l4 = n if n ~= l6 then  l4 = CL["COMPLEX"](CL["LOG"](CL["ABS"](l1), false), CL["PHASE"](l1)) else  l4 = CL_LIB["%LOG"](l1) end l3 = l4 else  local l7 = n if n ~= CL["EQ"](0, l2) then  single_value();  l7 = 0 else  local l8 = n if n ~= CL["T"].bound then  single_value();  l8 = CL["/"](l(CL["LOG"](l1, false),CL["LOG"](l2, false))) else  l8 = n.bound end l7 = l8 end l3 = l7 end return l3 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["EXPT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["BASE"],{CL_LIB["POWER"],n}},function (l1, l2,  ...)   single_value();  local l4 = CL["COMPLEXP"](l1); single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  local l6 = CL["COMPLEXP"](l2); single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  l7 = CL_LIB["%<"](l1, 0) end l5 = l7 end local l3 = n if n ~= l5 then  single_value();  l3 = (CL["EXP"](l2) * CL["LOG"](l1, false)) else  local l8 = n if n ~= CL[">"](l(l1,0)) then  single_value();  l8 = CL_LIB["%EXPT"](l1, l2) else  local l9 = n if n ~= CL["EQ"](l1, 0) then  single_value();  local l10 = n if n ~= CL[">"](l(l2,0)) then  l10 = 0 else  l10 = CL["ERROR"]("expt, invalid operands", l()) end l9 = l10 else  l9 = n.bound end l8 = l9 end l3 = l8 end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["COS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["RAD"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["COMPLEXP"](l1) then  local l3 = (c(0,1) * l1); single_value();  l2 = CL["/"](l((CL["EXP"](l3) + CL["EXP"](- l3)),2)) else  l2 = CL_LIB["%COS"](l1) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SIN"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["RAD"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["COMPLEXP"](l1) then  local l3 = (c(0,1) * l1); single_value();  l2 = CL["/"](l((CL["EXP"](l3) - CL["EXP"](- l3)),c(0,2))) else  l2 = CL_LIB["%SIN"](l1) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["TAN"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["RAD"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["COMPLEXP"](l1) then  l2 = CL["/"](l(CL["SIN"](l1),CL["COS"](l1))) else  l2 = CL_LIB["%TAN"](l1) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ASIN"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  local l3 = CL["COMPLEXP"](l1); single_value();  local l4 = n if n ~= l3 then  l4 = l3 else  local l5 = CL_LIB["%<"](l1, -1); single_value();  local l6 = n if n ~= l5 then  l6 = l5 else  l6 = CL[">"](l(l1,1)) end l4 = l6 end local l2 = n if n ~= l4 then  l2 = (c(0,-1) * CL["LOG"](((c(0,1) * l1) + CL["SQRT"]((1 - (l1 * l1)))), false)) else  l2 = CL_LIB["%ASIN"](l1) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ACOS"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],n},function (l1,  ...)   single_value();  local l3 = CL["COMPLEXP"](l1); single_value();  local l4 = n if n ~= l3 then  l4 = l3 else  local l5 = CL_LIB["%<"](l1, -1); single_value();  local l6 = n if n ~= l5 then  l6 = l5 else  l6 = CL[">"](l(l1,1)) end l4 = l6 end local l2 = n if n ~= l4 then  l2 = (CL["/"](l(CL["PI"].bound,2)) - CL["ASIN"](l1)) else  l2 = CL_LIB["%ACOS"](l1) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ATAN"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],{CL["&OPTIONAL"],{CL_LIB["X"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = n if n ~= l2 then  l3 = CL_LIB["%ATAN2"](l1, l2) else  l3 = (c(0,-1) * CL["LOG"](((1 + (c(0,1) * l1)) * CL["SQRT"](CL["/"](l((1 + (l1 * l1)))))), false)) end return l3 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SINH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l1,  ...)   single_value();  return CL["/"](l((CL["EXP"](l1) - CL["EXP"](- l1)),2)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["COSH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l1,  ...)   single_value();  return CL["/"](l((CL["EXP"](l1) + CL["EXP"](- l1)),2)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["TANH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l1,  ...)   single_value();  local l2 = CL["EXP"](l1); local l3 = CL["EXP"](- l1); single_value();  return CL["/"](l((l2 - l3),(l2 + l3))) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ASINH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l1,  ...)   single_value();  return CL["LOG"]((l1 + CL["SQRT"]((1 + (l1 * l1)))), false) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ACOSH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l1,  ...)   single_value();  return (2 * CL["LOG"]((CL["SQRT"](CL["/"](l((1 + l1),2))) + CL["SQRT"](CL["/"](l((l1 - 1),2)))), false)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ATANH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l1,  ...)   single_value();  return CL["/"](l((CL["LOG"]((1 + l1), false) - CL["LOG"]((1 - l1), false)),2)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FLOAT"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],{CL["&OPTIONAL"],{CL_LIB["PROTOTYPE"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  return l1 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["DECODE-FLOAT"] , CL_LIB["ALLOC-FUNCTION"]({CL["FLOAT"],n},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; l2, l3 = math.frexp(l1) i( n.bound );
 single_value();  local l4 = n if n ~= CL[">="](l(l1,0)) then  l4 = 1 else  l4 = -1 end return CL["VALUES"](l(l2,l3,l4)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FLOAT-RADIX"] , CL_LIB["ALLOC-FUNCTION"]({CL["FLOAT"],n},function (l1,  ...)   single_value();  return 2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SCALE-FLOAT"] , CL_LIB["ALLOC-FUNCTION"]({CL["FLOAT"],{CL["INTEGER"],n}},function (l1, l2,  ...)   single_value();  return math.ldexp(l1,l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FLOAT-SIGN"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FLOAT-1"],{CL["&OPTIONAL"],{{CL_LIB["FLOAT-2"],{1,n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = 1 end  single_value();  local l3 = CL["ABS"](l2); single_value();  local l4 = n if n ~= CL[">="](l(l1,0)) then  l4 = l3 else  l4 = - l3 end return l4 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FLOAT-DIGITS"] , CL_LIB["ALLOC-FUNCTION"]({CL["FLOAT"],n},function (l1,  ...)   single_value();  return 24 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FLOAT-PRECISION"] , CL_LIB["ALLOC-FUNCTION"]({CL["FLOAT"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["EQ"](0, l1) then  l2 = 0 else  l2 = CL["FLOAT-DIGITS"](l1) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["INTEGER-DECODE-FLOAT"] , CL_LIB["ALLOC-FUNCTION"]({CL["FLOAT"],n},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l8 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l7 = l8; single_value();  single_value();  l2,l3,l4= unpack_mv(CL["DECODE-FLOAT"](l1), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l5 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l6.error ~= n and true then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end i( CL["VALUES-LIST"](list_r(l6)) );
 single_value();  local l9 = CL["FLOAT-DIGITS"](l1); single_value();  return CL["VALUES"](l(CL["SCALE-FLOAT"](l2, l9),(l3 - l9),l4)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["INTEGER-LENGTH"] , CL_LIB["ALLOC-FUNCTION"]({CL["INTEGER"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["MINUSP"](l1) then  l2 = - l1 else  l2 = CL["1+"](l1) end return CL["CEILING"](CL["LOG"](l2, 2), false) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["GCD"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["INTEGERS"],n}},function (l1,  ...)   local l2 = n if n ~= CL["NOTEVERY"](CL["INTEGERP"].fbound, l(l1)) then  single_value();  l2 = CL["ERROR"]("gcd, not a number", l()) else  l2 = n.bound end i( l2 );
 single_value();  return CL["REDUCE"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],{CL_LIB["Y"],n}},function (l3, l4,  ...)   single_value();  return gcd(l3,l4) end, 2, 0, false, false), l1, k(CL_LIB["INITIAL-VALUE"], 0, CL_LIB["KEY"], CL["ABS"].fbound)) end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LCM"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["INTEGERS"],n}},function (l1,  ...)   local l2 = n if n ~= CL["NOTEVERY"](CL["INTEGERP"].fbound, l(l1)) then  single_value();  l2 = CL["ERROR"]("lcm, not a number", l()) else  l2 = n.bound end i( l2 );
 single_value();  local l3 = n if n ~= l1 then  local l4 = n if n ~= (l1)[2] then  local l5 = (l1)[1]; local l6 = CL["APPLY"](CL["LCM"].fbound, (l1)[2], l()); single_value();  l4 = CL_LIB["%//"](CL["ABS"]((l5 * l6)), CL["GCD"](l(l5,l6))) else  l4 = (l1)[1] end l3 = l4 else  l3 = 1 end return l3 end, 0, 0, true, false)); local l1 = 2209006800; single_value();  tmp = CL_LIB.DEF(CL_LIB["+UNIX-TS-TO-UNIVERSAL+"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["UNIX->UNIVERSAL-TIME"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["UNIX"],n},function (l1,  ...)   single_value();  return (l1 + CL_LIB["+UNIX-TS-TO-UNIVERSAL+"].bound) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["UNIVERSAL-TIME->UNIX"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["UNIX"],n},function (l1,  ...)   single_value();  return (l1 - CL_LIB["+UNIX-TS-TO-UNIVERSAL+"].bound) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["GET-UNIVERSAL-TIME"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["UNIX->UNIVERSAL-TIME"](os.time()) end, 0, 0, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["FUNCTION-SETQ"](CL["KEYWORDP"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["SYMBOLP"](l1) then  l2 = CL["STRING="]("KEYWORD", l(CL["PACKAGE-NAME"](CL["SYMBOL-PACKAGE"](l1)))) else  l2 = n.bound end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["SEQUENCEP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SEQ"],n},function (l1,  ...)   single_value();  local l2 = CL["LISTP"](l1); single_value();  local l3 = n if n ~= l2 then  l3 = l2 else  local l4 = CL["STRINGP"](l1); single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  l5 = CL["VECTORP"](l1) end l3 = l5 end return l3 end, 1, 0, false, false)); local l1 = CL["MAKE-HASH-TABLE"](k()); single_value();  tmp = CL_LIB.DEF(CL_LIB["*TYPE-SPECIFIERS*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%REGISTER-TYPE-SPECIFIER"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],{CL["FUNCTION"],{CL_LIB["SUPER"],n}}},function (l1, l2, l3,  ...)   single_value();  return CL_LIB["SETHASH"](l1, CL_LIB["*TYPE-SPECIFIERS*"].bound, CL["CONS"](l2, l3)) end, 3, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["%REGTYPE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G64174"],{CL["&OPTIONAL"],{LCL["NIL"]["G64175"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  single_value();  local l15 = n if n ~= CL["CONSP"](l5) then  l15 = (l5)[1] else  l15 = l5 end local l14 = l15; local l17 = n if n ~= CL["CONSP"](l5) then  l17 = (l5)[2] else  l17 = n.bound end local l16 = l17; single_value();  return CL["CONS"](CL_LIB["%REGISTER-TYPE-SPECIFIER"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l14, n)), CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](CL["CONS"](CL_LIB["EL"], l16), CL["APPEND"](l(l13,n)))), CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l9, n)), n)))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DEFTYPE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G64262"],{CL["&OPTIONAL"],{LCL["NIL"]["G64263"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  single_value();  return CL["CONS"](CL_LIB["%REGISTER-TYPE-SPECIFIER"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](CL["CONS"](CL["GENSYM"](false), l9), CL["APPEND"](l(l13,n)))), CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["CONS"](CL["T"], n), n)), n)))) end, 1, 1, false, false)); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["AND"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&REST"],{CL_LIB["CONDS"],n}}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= l2 then  local l4 = n if n ~= CL["TYPEP"](l1, (l2)[1], false) then  l4 = CL["TYPEP"](l1, CL["CONS"](CL["AND"], (l2)[2]), false) else  l4 = n.bound end l3 = l4 else  l3 = CL["T"].bound end return l3 end, 1, 0, true, false), n); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["EQL"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL_LIB["OBJECT"],n}},function (l1, l2,  ...)   single_value();  return CL["EQL"](l2, l1) end, 2, 0, false, false), n); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["MEMBER"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&REST"],{CL_LIB["OBJECTS"],n}}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["MEMBER"](l1, l2, k(CL_LIB["TEST"], CL["EQL"].fbound)) then  l3 = CL["T"].bound else  l3 = n.bound end return l3 end, 1, 0, true, false), n); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["MOD"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL_LIB["N"],n}},function (l1, l2,  ...)   single_value();  return CL["CONS"](CL["INTEGER"], CL["CONS"](0, CL["CONS"]((l2 - 1), n))) end, 2, 0, false, false), n); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["NOT"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL_LIB["SPEC"],n}},function (l1, l2,  ...)   single_value();  return CL["NOT"](CL["TYPEP"](l1, l2, false)) end, 2, 0, false, false), n); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["OR"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&REST"],{CL_LIB["CONDS"],n}}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= l2 then  local l4 = CL["TYPEP"](l1, (l2)[1], false); single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  l5 = CL["TYPEP"](l1, CL["CONS"](CL["OR"], (l2)[2]), false) end l3 = l5 else  l3 = n.bound end return l3 end, 1, 0, true, false), n); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["SATISFIES"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL_LIB["FUNC"],n}},function (l1, l2,  ...)   single_value();  local l4 = l1; single_value();  local l3 = n if n ~= CL_LIB['FUNCALL-LUA'](l2,{l4, }) then  l3 = CL["T"].bound else  l3 = n.bound end return l3 end, 2, 0, false, false), n); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["T"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL["T"].bound end, 1, 0, false, false), n); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["OTHERWISE"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL["T"].bound end, 1, 0, false, false), n); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](n, CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return n.bound end, 1, 0, false, false), n); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["SYMBOL"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL["SYMBOLP"](l1) end, 1, 0, false, false), {CL["T"],n}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["CHARACTER"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL_LIB["CHARP"](l1) end, 1, 0, false, false), {CL["T"],n}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["BASE-CHAR"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL_LIB["CHARP"](l1) end, 1, 0, false, false), {CL["CHARACTER"],n}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["STANDARD-CHAR"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL["STANDARD-CHAR-P"](l1) end, 1, 0, false, false), {CL["T"],n}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["KEYWORD"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL["KEYWORDP"](l1) end, 1, 0, false, false), {CL["SYMBOL"],{CL["T"],n}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["BOOLEAN"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  local l2 = CL["EQ"](l1, CL["T"].bound); single_value();  local l3 = n if n ~= l2 then  l3 = l2 else  l3 = CL["EQ"](l1, n.bound) end return l3 end, 1, 0, false, false), {CL["SYMBOL"],{CL["T"],n}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["NULL"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL["NULL"](l1) end, 1, 0, false, false), {CL["SYMBOL"],{CL["LIST"],{CL["SEQUENCE"],{CL["T"],n}}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["CONS"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&OPTIONAL"],{{CL["CAR"],{{CL["QUOTE"],{CL["*"],n}},n}},{{CL["CDR"],{{CL["QUOTE"],{CL["*"],n}},n}},n}}}},function (l1, l2, l3,  ...)  if not l2 then  l2 = CL["*"] end if not l3 then  l3 = CL["*"] end  single_value();  local l4 = n if n ~= CL["CONSP"](l1) then  local l6 = CL["EQ"](l2, CL["*"]); single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  l7 = CL["TYPEP"]((l1)[1], l2, false) end local l5 = n if n ~= l7 then  local l9 = CL["EQ"](l3, CL["*"]); single_value();  local l10 = n if n ~= l9 then  l10 = l9 else  l10 = CL["TYPEP"]((l1)[2], l2, false) end local l8 = n if n ~= l10 then  l8 = CL["T"].bound else  l8 = n.bound end l5 = l8 else  l5 = n.bound end l4 = l5 else  l4 = n.bound end return l4 end, 1, 2, false, false), {CL["LIST"],{CL["SEQUENCE"],{CL["T"],n}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["LIST"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL["LISTP"](l1) end, 1, 0, false, false), {CL["SEQUENCE"],{CL["T"],n}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["ATOM"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL["ATOM"](l1) end, 1, 0, false, false), {CL["T"],n}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["HASH-TABLE"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL["HASH-TABLE-P"](l1) end, 1, 0, false, false), {CL["T"],n}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["FIXNUM"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL_LIB["%INTEGERP"](l1) end, 1, 0, false, false), {CL["INTEGER"],{CL["RATIONAL"],{CL_LIB["REAL"],{CL["NUMBER"],{CL["T"],n}}}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["BIGNUM"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL["CONS"](CL["AND"], CL["CONS"](CL["INTEGER"], CL["CONS"](CL["CONS"](CL["NOT"], CL["CONS"](CL["FIXNUM"], n)), n))) end, 1, 0, false, false), {CL["INTEGER"],{CL["RATIONAL"],{CL_LIB["REAL"],{CL["NUMBER"],{CL["T"],n}}}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["BIT"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL["LIST"](l(CL["INTEGER"],0,1)) end, 1, 0, false, false), {CL["UNSIGNED-BYTE"],{CL["SIGNED-BYTE"],{CL["INTEGER"],{CL["RATIONAL"],{CL_LIB["REAL"],{CL["NUMBER"],{CL["T"],n}}}}}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["UNSIGNED-BYTE"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&OPTIONAL"],{{CL_LIB["S"],{{CL["QUOTE"],{CL["*"],n}},n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*"] end  single_value();  local l3 = n if n ~= CL["EQ"](l2, CL["*"]) then  l3 = CL["CONS"](CL["INTEGER"], CL["CONS"](0, CL["CONS"](CL["*"], n))) else  l3 = CL["CONS"](CL["INTEGER"], CL["CONS"](0, CL["CONS"]((CL["EXPT"](2, l2) - 1), n))) end return l3 end, 1, 1, false, false), {CL["SIGNED-BYTE"],{CL["INTEGER"],{CL["RATIONAL"],{CL_LIB["REAL"],{CL["NUMBER"],{CL["T"],n}}}}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["SIGNED-BYTE"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&OPTIONAL"],{{CL_LIB["S"],{{CL["QUOTE"],{CL["*"],n}},n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*"] end  single_value();  local l3 = n if n ~= CL["EQ"](l2, CL["*"]) then  l3 = CL["INTEGER"] else  local l4 = CL["EXPT"](2, (l2 - 1)); single_value();  l3 = CL["CONS"](CL["INTEGER"], CL["CONS"](- l4, CL["CONS"]((l4 - 1), n))) end return l3 end, 1, 1, false, false), {CL["INTEGER"],{CL["RATIONAL"],{CL_LIB["REAL"],{CL["NUMBER"],{CL["T"],n}}}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["INTEGER"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&OPTIONAL"],{{CL_LIB["LOWER"],{{CL["QUOTE"],{CL["*"],n}},n}},{{CL_LIB["UPPER"],{{CL["QUOTE"],{CL["*"],n}},n}},n}}}},function (l1, l2, l3,  ...)  if not l2 then  l2 = CL["*"] end if not l3 then  l3 = CL["*"] end  single_value();  local l4 = n if n ~= CL["INTEGERP"](l1) then  local l6 = CL["EQ"](l2, CL["*"]); single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  local l8 = n if n ~= CL["CONSP"](l2) then  l8 = CL[">"](l(l1,(l2)[1])) else  l8 = CL[">="](l(l1,l2)) end l7 = l8 end local l5 = n if n ~= l7 then  local l10 = CL["EQ"](l3, CL["*"]); single_value();  local l11 = n if n ~= l10 then  l11 = l10 else  local l12 = n if n ~= CL["CONSP"](l3) then  l12 = CL_LIB["%<"](l1, (l3)[1]) else  l12 = CL["<="](l(l1,l3)) end l11 = l12 end local l9 = n if n ~= l11 then  l9 = CL["T"].bound else  l9 = n.bound end l5 = l9 else  l5 = n.bound end l4 = l5 else  l4 = n.bound end return l4 end, 1, 2, false, false), {CL["RATIONAL"],{CL_LIB["REAL"],{CL["NUMBER"],{CL["T"],n}}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["RATIO"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL_LIB["%RATIONALP"](l1) end, 1, 0, false, false), {CL["RATIONAL"],{CL_LIB["REAL"],{CL["NUMBER"],{CL["T"],n}}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["RATIONAL"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL["RATIONALP"](l1) end, 1, 0, false, false), {CL_LIB["REAL"],{CL["NUMBER"],{CL["T"],n}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["SHORT-FLOAT"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&OPTIONAL"],{{CL_LIB["LOWER"],{{CL["QUOTE"],{CL["*"],n}},n}},{{CL_LIB["UPPER"],{{CL["QUOTE"],{CL["*"],n}},n}},n}}}},function (l1, l2, l3,  ...)  if not l2 then  l2 = CL["*"] end if not l3 then  l3 = CL["*"] end  single_value();  return CL["CONS"](CL["FLOAT"], CL["CONS"](l2, CL["CONS"](l3, n))) end, 1, 2, false, false), {CL["FLOAT"],{CL_LIB["REAL"],{CL["NUMBER"],{CL["T"],n}}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["SINGLE-FLOAT"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&OPTIONAL"],{{CL_LIB["LOWER"],{{CL["QUOTE"],{CL["*"],n}},n}},{{CL_LIB["UPPER"],{{CL["QUOTE"],{CL["*"],n}},n}},n}}}},function (l1, l2, l3,  ...)  if not l2 then  l2 = CL["*"] end if not l3 then  l3 = CL["*"] end  single_value();  return CL["CONS"](CL["FLOAT"], CL["CONS"](l2, CL["CONS"](l3, n))) end, 1, 2, false, false), {CL["FLOAT"],{CL_LIB["REAL"],{CL["NUMBER"],{CL["T"],n}}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["DOUBLE-FLOAT"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&OPTIONAL"],{{CL_LIB["LOWER"],{{CL["QUOTE"],{CL["*"],n}},n}},{{CL_LIB["UPPER"],{{CL["QUOTE"],{CL["*"],n}},n}},n}}}},function (l1, l2, l3,  ...)  if not l2 then  l2 = CL["*"] end if not l3 then  l3 = CL["*"] end  single_value();  return CL["CONS"](CL["FLOAT"], CL["CONS"](l2, CL["CONS"](l3, n))) end, 1, 2, false, false), {CL["FLOAT"],{CL_LIB["REAL"],{CL["NUMBER"],{CL["T"],n}}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["LONG-FLOAT"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&OPTIONAL"],{{CL_LIB["LOWER"],{{CL["QUOTE"],{CL["*"],n}},n}},{{CL_LIB["UPPER"],{{CL["QUOTE"],{CL["*"],n}},n}},n}}}},function (l1, l2, l3,  ...)  if not l2 then  l2 = CL["*"] end if not l3 then  l3 = CL["*"] end  single_value();  return CL["CONS"](CL["FLOAT"], CL["CONS"](l2, CL["CONS"](l3, n))) end, 1, 2, false, false), {CL["FLOAT"],{CL_LIB["REAL"],{CL["NUMBER"],{CL["T"],n}}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["FLOAT"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&OPTIONAL"],{{CL_LIB["LOWER"],{{CL["QUOTE"],{CL["*"],n}},n}},{{CL_LIB["UPPER"],{{CL["QUOTE"],{CL["*"],n}},n}},n}}}},function (l1, l2, l3,  ...)  if not l2 then  l2 = CL["*"] end if not l3 then  l3 = CL["*"] end  single_value();  local l4 = n if n ~= CL["FLOATP"](l1) then  local l6 = CL["EQ"](l2, CL["*"]); single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  l7 = CL[">="](l(l1,l2)) end local l5 = n if n ~= l7 then  local l9 = CL["EQ"](l3, CL["*"]); single_value();  local l10 = n if n ~= l9 then  l10 = l9 else  local l11 = n if n ~= CL["CONSP"](l3) then  l11 = CL_LIB["%<"](l1, (l3)[1]) else  l11 = CL["<="](l(l1,l3)) end l10 = l11 end local l8 = n if n ~= l10 then  l8 = CL["T"].bound else  l8 = n.bound end l5 = l8 else  l5 = n.bound end l4 = l5 else  l4 = n.bound end return l4 end, 1, 2, false, false), {CL_LIB["REAL"],{CL["NUMBER"],{CL["T"],n}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL_LIB["REAL"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&OPTIONAL"],{{CL_LIB["LOWER"],{{CL["QUOTE"],{CL["*"],n}},n}},{{CL_LIB["UPPER"],{{CL["QUOTE"],{CL["*"],n}},n}},n}}}},function (l1, l2, l3,  ...)  if not l2 then  l2 = CL["*"] end if not l3 then  l3 = CL["*"] end  single_value();  local l4 = n if n ~= CL["REALP"](l1) then  local l6 = CL["EQ"](l2, CL["*"]); single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  l7 = CL[">="](l(l1,l2)) end local l5 = n if n ~= l7 then  local l9 = CL["EQ"](l3, CL["*"]); single_value();  local l10 = n if n ~= l9 then  l10 = l9 else  local l11 = n if n ~= CL["CONSP"](l3) then  l11 = CL_LIB["%<"](l1, (l3)[1]) else  l11 = CL["<="](l(l1,l3)) end l10 = l11 end local l8 = n if n ~= l10 then  l8 = CL["T"].bound else  l8 = n.bound end l5 = l8 else  l5 = n.bound end l4 = l5 else  l4 = n.bound end return l4 end, 1, 2, false, false), {CL["NUMBER"],{CL["T"],n}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["COMPLEX"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&OPTIONAL"],{{CL_LIB["SPEC"],{{CL["QUOTE"],{CL["*"],n}},n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*"] end  single_value();  local l3 = n if n ~= CL["COMPLEXP"](l1) then  local l5 = CL["EQ"](l2, CL["*"]); single_value();  local l6 = n if n ~= l5 then  l6 = l5 else  local l7 = n if n ~= CL["TYPEP"](CL["REALPART"](l1), l2, false) then  l7 = CL["TYPEP"](CL["IMAGPART"](l1), l2, false) else  l7 = n.bound end l6 = l7 end local l4 = n if n ~= l6 then  l4 = CL["T"].bound else  l4 = n.bound end l3 = l4 else  l3 = n.bound end return l3 end, 1, 1, false, false), {CL["NUMBER"],{CL["T"],n}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["NUMBER"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL["NUMBERP"](l1) end, 1, 0, false, false), {CL["T"],n}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["FUNCTION"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&OPTIONAL"],{{CL_LIB["ARG-TYPE"],{{CL["QUOTE"],{CL["*"],n}},n}},{{CL_LIB["VALUE-TYPE"],{{CL["QUOTE"],{CL["*"],n}},n}},n}}}},function (l1, l2, l3,  ...)  if not l2 then  l2 = CL["*"] end if not l3 then  l3 = CL["*"] end  single_value();  return CL["FUNCTIONP"](l1) end, 1, 2, false, false), {CL["T"],n}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["COMPILED-FUNCTION"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL["FUNCTION"] end, 1, 0, false, false), {CL["FUNCTION"],{CL["T"],n}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["SEQUENCE"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return {CL["OR"],{CL["VECTOR"],{CL["LIST"],{CL["STRING"],n}}}} end, 1, 0, false, false), {CL["T"],n}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["ARRAY"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&OPTIONAL"],{{CL_LIB["ELEMENT-TYPE"],{{CL["QUOTE"],{CL["*"],n}},n}},{{CL_LIB["DIMENSION-SPEC"],{{CL["QUOTE"],{CL["*"],n}},n}},n}}}},function (l1, l2, l3,  ...)  if not l2 then  l2 = CL["*"] end if not l3 then  l3 = CL["*"] end  single_value();  local l4 = n if n ~= CL["ARRAYP"](l1) then  local l6 = CL["EQ"](CL["*"], l2); single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  l7 = CL["EQL"](CL["ARRAY-ELEMENT-TYPE"](l1), l2) end local l5 = n if n ~= l7 then  local l8 = n if n ~= CL["EQ"](l3, CL["*"]) then  single_value();  l8 = CL["T"].bound else  local l9 = n if n ~= CL["INTEGERP"](l3) then  single_value();  l9 = CL["EQL"](CL["ARRAY-RANK"](l1), l3) else  local l10 = n if n ~= CL["LISTP"](l3) then  single_value();  l10 = CL["EQUAL"](CL["ARRAY-DIMENSIONS"](l1), l3) else  local l11 = n if n ~= CL["T"].bound then  single_value();  l11 = n.bound else  l11 = n.bound end l10 = l11 end l9 = l10 end l8 = l9 end l5 = l8 else  l5 = n.bound end l4 = l5 else  l4 = n.bound end return l4 end, 1, 2, false, false), {CL["T"],n}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["VECTOR"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&OPTIONAL"],{{CL_LIB["ELEMENT-TYPE"],{{CL["QUOTE"],{CL["*"],n}},n}},{{CL_LIB["SIZE"],{{CL["QUOTE"],{CL["*"],n}},n}},n}}}},function (l1, l2, l3,  ...)  if not l2 then  l2 = CL["*"] end if not l3 then  l3 = CL["*"] end  single_value();  local l4 = n if n ~= CL["VECTORP"](l1) then  local l6 = CL["EQ"](CL["*"], l2); single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  l7 = CL["EQL"](CL["ARRAY-ELEMENT-TYPE"](l1), l2) end local l5 = n if n ~= l7 then  local l8 = CL["EQ"](CL["*"], l3); single_value();  local l9 = n if n ~= l8 then  l9 = l8 else  l9 = CL["EQL"](CL["LENGTH"](l1), l3) end l5 = l9 else  l5 = n.bound end l4 = l5 else  l4 = n.bound end return l4 end, 1, 2, false, false), {CL["ARRAY"],{CL["SEQUENCE"],{CL["T"],n}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["STRING"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&OPTIONAL"],{{CL_LIB["SIZE"],{{CL["QUOTE"],{CL["*"],n}},n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*"] end  single_value();  local l3 = n if n ~= CL["STRINGP"](l1) then  local l4 = CL["EQ"](CL["*"], l2); single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  l5 = CL["EQ"](l2, CL["LENGTH"](l1)) end l3 = l5 else  l3 = n.bound end return l3 end, 1, 1, false, false), {CL["VECTOR"],{CL["ARRAY"],{CL["SEQUENCE"],{CL["T"],n}}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["SIMPLE-STRING"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&OPTIONAL"],{{CL_LIB["SIZE"],{{CL["QUOTE"],{CL["*"],n}},n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*"] end  single_value();  return CL["CONS"](CL["STRING"], CL["CONS"](l2, n)) end, 1, 1, false, false), {CL["STRING"],{CL["VECTOR"],{CL["ARRAY"],{CL["SEQUENCE"],{CL["T"],n}}}}}); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL_LIB["NATIVE-STRING"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["&OPTIONAL"],{{CL_LIB["SIZE"],{{CL["QUOTE"],{CL["*"],n}},n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*"] end  single_value();  local l3 = n if n ~= CL_LIB["%STRINGP"](l1) then  local l4 = CL["EQ"](CL["*"], l2); single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  l5 = CL["EQ"](l2, CL_LIB["%LEN"](l1)) end l3 = l5 else  l3 = n.bound end return l3 end, 1, 1, false, false), {CL["SIMPLE-STRING"],{CL["STRING"],{CL["VECTOR"],{CL["SIMPLE-ARRAY"],{CL["ARRAY"],{CL["SEQUENCE"],{CL["T"],n}}}}}}}); tmp = CL_LIB["MACRO-SETQ"](CL["CHECK-TYPE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G64920"],{CL["&OPTIONAL"],{LCL["NIL"]["G64921"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l14 = n if n ~= l4 then  l14 = CL["T"].bound else  l14 = n.bound end local l13 = l14; single_value();  local l16 = n if n ~= l4 then  local l17 = l4; single_value();  local l18 = (l17)[1]; single_value();  single_value();  local l19 = (l17)[2]; single_value();  l4 = l19 i( l4 );
 single_value();  l16 = l18 else  l16 = n.bound end local l15 = l16; single_value();  single_value();  local l20 = n if n ~= l13 then  l20 = l15 else  l20 = l9 end return CL["CONS"](CL["UNLESS"], CL["CONS"](CL["CONS"](CL["TYPEP"], CL["CONS"](l5, CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l9, n)), n))), CL["CONS"](CL["CONS"](CL["ERROR"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["TYPE-ERROR"], n)), CL["CONS"](LCL["KEYWORD"]["FORM"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), CL["CONS"](LCL["KEYWORD"]["DATUM"], CL["CONS"](l5, CL["CONS"](LCL["KEYWORD"]["EXPECTED-TYPE"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l20, n)), n)))))))), n))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["TYPEP-EXT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],{CL["SYMBOL"],{CL_LIB["ARGS"],n}}},function (l1, l2, l3,  ...)   single_value();  return n.bound end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["TYPEP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],{CL_LIB["TYPE-SPECIFIER"],{CL["&OPTIONAL"],{CL_LIB["ENVIRONMENT"],n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = n.bound end  single_value();  local l5 = n if n ~= CL["CONSP"](l2) then  l5 = (l2)[1] else  l5 = l2 end local l4 = l5; single_value();  local l7 = n if n ~= CL["CONSP"](l2) then  l7 = (l2)[2] else  l7 = n.bound end local l6 = l7; single_value();  local l8 = (CL["GETHASH"](l4, CL_LIB["*TYPE-SPECIFIERS*"].bound, false))[1]; single_value();  single_value();  local l9 = n if n ~= l8 then  local l10 = CL["APPLY"](l8, l1, l(l6)); single_value();  local l11 = n if n ~= CL["EQ"](l10, CL["T"].bound) then  single_value();  l11 = CL["T"].bound else  local l12 = n if n ~= CL["EQ"](l10, n.bound) then  single_value();  l12 = n.bound else  local l13 = n if n ~= CL["T"].bound then  single_value();  l13 = CL["TYPEP"](l1, l10, l3) else  l13 = n.bound end l12 = l13 end l11 = l12 end l9 = l11 else  l9 = CL_LIB["TYPEP-EXT"](l1, l4, l6) end return l9 end, 2, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%FIND-CLASS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["CLS"],n},function (l1,  ...)   single_value();  return n.bound end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SUBTYPEP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["TYPE-1"],{CL_LIB["TYPE-2"],{CL["&OPTIONAL"],{CL_LIB["ENVIRONMENT"],n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = n.bound end  single_value();  local l4 = n if n ~= l1 then  local l6 = n if n ~= CL["CONSP"](l1) then  local l7 = n if n ~= CL["SYMBOLP"](l2) then  l7 = CL["EQ"]((l1)[1], l2) else  l7 = n.bound end l6 = l7 else  l6 = n.bound end local l5 = n if n ~= l6 then  single_value();  l5 = CL["T"].bound else  local l8 = n if n ~= CL["EQ"](l1, l2) then  single_value();  l8 = CL["T"].bound else  local l10 = n if n ~= CL_LIB["%FIND-CLASS"](l1) then  l10 = CL_LIB["%FIND-CLASS"](l2) else  l10 = n.bound end local l9 = n if n ~= l10 then  single_value();  l9 = CL_LIB["%SUBCLASSP"](CL_LIB["%FIND-CLASS"](l1), CL_LIB["%FIND-CLASS"](l2)) else  local l12 = n if n ~= CL["SYMBOLP"](l1) then  l12 = CL["SYMBOLP"](l2) else  l12 = n.bound end local l11 = n if n ~= l12 then  single_value();  local l13 = (CL["GETHASH"](l1, CL_LIB["*TYPE-SPECIFIERS*"].bound, false))[2]; single_value();  l11 = CL["SOME"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l14,  ...)   single_value();  return CL["SUBTYPEP"](l14, l2, false) end, 1, 0, false, false), l(l13)) else  local l15 = n if n ~= CL["T"].bound then  single_value();  l15 = CL["ERROR"]("Unable to subtypep type ~S to ~S.", l(l1,l2)) else  l15 = n.bound end l11 = l15 end l9 = l11 end l8 = l9 end l5 = l8 end l4 = l5 else  l4 = CL["T"].bound end return l4 end, 2, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["TYPECASE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G65138"],{CL["&OPTIONAL"],{LCL["NIL"]["G65139"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l10, CL["CONS"](l5, n)), n), CL["CONS"](CL["CONS"](CL["COND"], CL["APPEND"](l(CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["CLAUSE"],n},function (l11,  ...)   single_value();  return CL["CONS"](CL["LIST"](l(CL["TYPEP"],l10,CL["LIST"](l(CL["QUOTE"],(l11)[1])))), (l11)[2]) end, 1, 0, false, false), l(l9)),n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["CTYPECASE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G65214"],{CL["&OPTIONAL"],{LCL["NIL"]["G65215"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  return CL["CONS"](CL["ETYPECASE"], CL["CONS"](l5, CL["APPEND"](l(l9,n)))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["ETYPECASE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G65267"],{CL["&OPTIONAL"],{LCL["NIL"]["G65268"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  return CL["CONS"](CL["TYPECASE"], CL["CONS"](l5, CL["APPEND"](l(l9,CL["CONS"](CL["CONS"](CL["T"], CL["CONS"](CL["CONS"](CL["ERROR"], CL["CONS"]("etypecase, no matching branches", n)), n)), n))))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["COERCE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],{CL_LIB["RESULT-TYPE"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["SUBTYPEP"](l2, CL["SEQUENCE"], false) then  single_value();  local l4 = n if n ~= CL_LIB["SEQUENCEP"](l1) then  l4 = CL["CONCATENATE"](l2, l(l1)) else  l4 = CL["ERROR"]("Can't coerce non sequence to list", l()) end l3 = l4 else  local l5 = n if n ~= CL["SUBTYPEP"](l2, CL["CHARACTER"], false) then  single_value();  local l6 = n if n ~= CL["CHARACTERP"](l1) then  single_value();  l6 = l1 else  local l7 = n if n ~= CL["STRINGP"](l1) then  single_value();  l7 = CL["CHAR"](l1, 0) else  local l8 = n if n ~= CL["T"].bound then  single_value();  l8 = CL["ERROR"]("Can't coerce ~S to character", l(l1)) else  l8 = n.bound end l7 = l8 end l6 = l7 end l5 = l6 else  local l9 = n if n ~= CL["SUBTYPEP"](l2, CL["COMPLEX"], false) then  single_value();  local l10 = n if n ~= CL["INTEGERP"](l1) then  single_value();  l10 = l1 else  local l11 = n if n ~= CL["REALP"](l1) then  single_value();  l11 = CL["COMPLEX"](l1, false) else  local l12 = n if n ~= CL["T"].bound then  single_value();  l12 = CL["ERROR"]("Can't coerce ~S to complex", l(l1)) else  l12 = n.bound end l11 = l12 end l10 = l11 end l9 = l10 else  local l13 = n if n ~= CL["SUBTYPEP"](l2, CL["FLOAT"], false) then  single_value();  local l14 = n if n ~= CL["RATIONALP"](l1) then  single_value();  l14 = (0 + CL["/"](l(CL["NUMERATOR"](l1),CL["DENOMINATOR"](l1)))) else  local l15 = n if n ~= CL["REALP"](l1) then  single_value();  l15 = (0 + l1) else  local l16 = n if n ~= CL["T"].bound then  single_value();  l16 = CL["ERROR"]("Can't coerce non real to float", l()) else  l16 = n.bound end l15 = l16 end l14 = l15 end l13 = l14 else  local l17 = n if n ~= CL["SUBTYPEP"](l2, CL["FUNCTION"], false) then  single_value();  local l19 = n if n ~= CL["LISTP"](l1) then  l19 = CL["EQ"](CL["LAMBDA"], (l1)[1]) else  l19 = n.bound end local l18 = n if n ~= l19 then  single_value();  l18 = CL["EVAL"](l1) else  local l20 = n if n ~= CL["SYMBOLP"](l1) then  single_value();  l20 = CL["FDEFINITION"](l1) else  local l21 = n if n ~= CL["T"].bound then  single_value();  l21 = CL["ERROR"]("Can't coerce ~S to function", l(l2)) else  l21 = n.bound end l20 = l21 end l18 = l20 end l17 = l18 else  local l22 = n if n ~= CL["EQ"](l2, CL["T"].bound) then  single_value();  l22 = l1 else  local l23 = n if n ~= CL["T"].bound then  single_value();  l23 = CL["ERROR"]("Can't coerce to result-type ~S", l(l2)) else  l23 = n.bound end l22 = l23 end l17 = l22 end l13 = l17 end l9 = l13 end l5 = l9 end l3 = l5 end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHARACTER"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHARACTER"],n},function (l1,  ...)   single_value();  return CL["COERCE"](l1, CL["CHARACTER"]) end, 1, 0, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL_LIB["INDEX"],n}},function (l1, l2,  ...)   i( "Char for a native string" );
 local l3 = n if n ~= CL["STRINGP"](l1) then  l3 = n.bound else  single_value();  l3 = CL["ERROR"]("char, ~S not a string", l(l1)) end i( l3 );
 local l4 = n if n ~= CL["INTEGERP"](l2) then  l4 = n.bound else  single_value();  l4 = CL["ERROR"]("char, index ~S not a number", l(l2)) end i( l4 );
 single_value();  return CL_LIB["MAKE-CHAR"](l1, l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL_LIB["INDEX"],n}},function (l1, l2,  ...)   single_value();  return CL_LIB["%CHAR"](l1, l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SET-CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL_LIB["INDEX"],{CL["CHAR"],n}}},function (l1, l2, l3,  ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL["SUBSEQ"](l1, 0, l2), CL_LIB["CHAR-STRING"](l3), CL["SUBSEQ"](l1, (l2 + 1), false), }) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR-INT"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],n},function (l1,  ...)   single_value();  return CL["CHAR-CODE"](l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SCHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL_LIB["INDEX"],n}},function (l1, l2,  ...)   single_value();  return CL["CHAR"](l1, l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["CHARACTERP"](l1) then  single_value();  l2 = CL_LIB["CHAR-STRING"](l1) else  local l3 = n if n ~= CL["SYMBOLP"](l1) then  single_value();  l3 = CL["SYMBOL-NAME"](l1) else  local l4 = n if n ~= CL["STRINGP"](l1) then  single_value();  l4 = l1 else  local l5 = n if n ~= CL["T"].bound then  single_value();  l5 = CL["ERROR"]("Can't convert ~S to string", l(l1)) else  l5 = n.bound end l4 = l5 end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["DEF-CHARACTER-COMP"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G68067"],{CL["&OPTIONAL"],{LCL["NIL"]["G68068"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l14 = n if n ~= l4 then  local l15 = l4; single_value();  local l16 = (l15)[1]; single_value();  single_value();  local l17 = (l15)[2]; single_value();  l4 = l17 i( l4 );
 single_value();  l14 = l16 else  l14 = n.bound end local l13 = l14; single_value();  single_value();  local l18 = n if n ~= l13 then  l18 = CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](CL_LIB["C"], CL["CONS"](CL["CONS"](l13, CL["CONS"](CL_LIB["C"], n)), n))), n) else  l18 = n.bound end local l19 = n if n ~= l13 then  l19 = CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](CL_LIB["NEXT"], CL["CONS"](CL["CONS"](l13, CL["CONS"](CL_LIB["NEXT"], n)), n))), n) else  l19 = n.bound end return CL["CONS"](CL["DEFUN"], CL["CONS"](l5, CL["CONS"](CL["CONS"](CL_LIB["C"], CL["CONS"](CL["&REST"], CL["CONS"](CL_LIB["CS"], CL["CONS"](CL["&AUX"], CL["CONS"](CL_LIB["NEXT"], n))))), CL["APPEND"](l(l18,CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](CL_LIB["NEXT"], CL["CONS"](CL["CONS"](CL["CAR"], CL["CONS"](CL_LIB["CS"], n)), n))), CL["CONS"](CL["CONS"](CL_LIB["%LOOP"], CL["CONS"](CL["CONS"](CL["IF"], CL["CONS"](CL_LIB["CS"], CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(l19,CL["CONS"](CL["CONS"](CL["UNLESS"], CL["CONS"](CL["CONS"](l9, CL["CONS"](CL_LIB["C"], CL["CONS"](CL_LIB["NEXT"], n))), CL["CONS"](CL["CONS"](CL_LIB["%RETURN"], CL["CONS"](n, n)), n))), CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](CL_LIB["C"], CL["CONS"](CL_LIB["NEXT"], n))), CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](CL_LIB["NEXT"], CL["CONS"](CL["CONS"](CL["CADR"], CL["CONS"](CL_LIB["CS"], n)), n))), CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](CL_LIB["CS"], CL["CONS"](CL["CONS"](CL["CDR"], CL["CONS"](CL_LIB["CS"], n)), n))), n))))))), CL["CONS"](CL["CONS"](CL_LIB["%BREAK"], n), n)))), n)), CL["CONS"](CL["T"], n)))))))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR="] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],{CL["&AUX"],{CL_LIB["NEXT"],n}}}}},function (l1, l2,  ...)  l3 = n.bound  l1 = CL["CHAR-CODE"](l1) i( l1 );
 l3 = (l2)[1] i( l3 );
 while true do  single_value();  local l4 = n if n ~= l2 then  l3 = CL["CHAR-CODE"](l3) i( l3 );
 local l5 = n if n ~= CL["EQ"](l1, l3) then  l5 = n.bound else  single_value();  local l6 = n.bound; single_value(); do return l6 end; l5 = n.bound end i( l5 );
 l1 = l3 i( l1 );
 l3 = CL["CADR"](l2) i( l3 );
 single_value();  l2 = (l2)[2] l4 = l2 else do break end; l4 = n.bound end local tmpres = l4 end i( n );
 single_value();  return CL["T"].bound end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR<"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],{CL["&AUX"],{CL_LIB["NEXT"],n}}}}},function (l1, l2,  ...)  l3 = n.bound  l1 = CL["CHAR-CODE"](l1) i( l1 );
 l3 = (l2)[1] i( l3 );
 while true do  single_value();  local l4 = n if n ~= l2 then  l3 = CL["CHAR-CODE"](l3) i( l3 );
 local l5 = n if n ~= CL_LIB["%<"](l1, l3) then  l5 = n.bound else  single_value();  local l6 = n.bound; single_value(); do return l6 end; l5 = n.bound end i( l5 );
 l1 = l3 i( l1 );
 l3 = CL["CADR"](l2) i( l3 );
 single_value();  l2 = (l2)[2] l4 = l2 else do break end; l4 = n.bound end local tmpres = l4 end i( n );
 single_value();  return CL["T"].bound end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR<="] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],{CL["&AUX"],{CL_LIB["NEXT"],n}}}}},function (l1, l2,  ...)  l3 = n.bound  l1 = CL["CHAR-CODE"](l1) i( l1 );
 l3 = (l2)[1] i( l3 );
 while true do  single_value();  local l4 = n if n ~= l2 then  l3 = CL["CHAR-CODE"](l3) i( l3 );
 local l5 = n if n ~= CL["<="](l(l1,l3)) then  l5 = n.bound else  single_value();  local l6 = n.bound; single_value(); do return l6 end; l5 = n.bound end i( l5 );
 l1 = l3 i( l1 );
 l3 = CL["CADR"](l2) i( l3 );
 single_value();  l2 = (l2)[2] l4 = l2 else do break end; l4 = n.bound end local tmpres = l4 end i( n );
 single_value();  return CL["T"].bound end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR>"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],{CL["&AUX"],{CL_LIB["NEXT"],n}}}}},function (l1, l2,  ...)  l3 = n.bound  l1 = CL["CHAR-CODE"](l1) i( l1 );
 l3 = (l2)[1] i( l3 );
 while true do  single_value();  local l4 = n if n ~= l2 then  l3 = CL["CHAR-CODE"](l3) i( l3 );
 local l5 = n if n ~= CL_LIB["%<"](l1, l3) then  l5 = n.bound else  single_value();  local l6 = n.bound; single_value(); do return l6 end; l5 = n.bound end i( l5 );
 l1 = l3 i( l1 );
 l3 = CL["CADR"](l2) i( l3 );
 single_value();  l2 = (l2)[2] l4 = l2 else do break end; l4 = n.bound end local tmpres = l4 end i( n );
 single_value();  return CL["T"].bound end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR>="] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],{CL["&AUX"],{CL_LIB["NEXT"],n}}}}},function (l1, l2,  ...)  l3 = n.bound  l1 = CL["CHAR-CODE"](l1) i( l1 );
 l3 = (l2)[1] i( l3 );
 while true do  single_value();  local l4 = n if n ~= l2 then  l3 = CL["CHAR-CODE"](l3) i( l3 );
 local l5 = n if n ~= CL["<="](l(l1,l3)) then  l5 = n.bound else  single_value();  local l6 = n.bound; single_value(); do return l6 end; l5 = n.bound end i( l5 );
 l1 = l3 i( l1 );
 l3 = CL["CADR"](l2) i( l3 );
 single_value();  l2 = (l2)[2] l4 = l2 else do break end; l4 = n.bound end local tmpres = l4 end i( n );
 single_value();  return CL["T"].bound end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING="] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],{CL["&AUX"],{CL_LIB["NEXT"],n}}}}},function (l1, l2,  ...)  l3 = n.bound  l3 = (l2)[1] i( l3 );
 while true do  single_value();  local l4 = n if n ~= l2 then  local l5 = n if n ~= CL_LIB["%="](l1, l3) then  l5 = n.bound else  single_value();  local l6 = n.bound; single_value(); do return l6 end; l5 = n.bound end i( l5 );
 l1 = l3 i( l1 );
 l3 = CL["CADR"](l2) i( l3 );
 single_value();  l2 = (l2)[2] l4 = l2 else do break end; l4 = n.bound end local tmpres = l4 end i( n );
 single_value();  return CL["T"].bound end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING<"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],{CL["&AUX"],{CL_LIB["NEXT"],n}}}}},function (l1, l2,  ...)  l3 = n.bound  l3 = (l2)[1] i( l3 );
 while true do  single_value();  local l4 = n if n ~= l2 then  local l5 = n if n ~= CL_LIB["%<"](l1, l3) then  l5 = n.bound else  single_value();  local l6 = n.bound; single_value(); do return l6 end; l5 = n.bound end i( l5 );
 l1 = l3 i( l1 );
 l3 = CL["CADR"](l2) i( l3 );
 single_value();  l2 = (l2)[2] l4 = l2 else do break end; l4 = n.bound end local tmpres = l4 end i( n );
 single_value();  return CL["T"].bound end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING<="] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],{CL["&AUX"],{CL_LIB["NEXT"],n}}}}},function (l1, l2,  ...)  l3 = n.bound  l3 = (l2)[1] i( l3 );
 while true do  single_value();  local l4 = n if n ~= l2 then  local l5 = n if n ~= CL_LIB["%<="](l1, l3) then  l5 = n.bound else  single_value();  local l6 = n.bound; single_value(); do return l6 end; l5 = n.bound end i( l5 );
 l1 = l3 i( l1 );
 l3 = CL["CADR"](l2) i( l3 );
 single_value();  l2 = (l2)[2] l4 = l2 else do break end; l4 = n.bound end local tmpres = l4 end i( n );
 single_value();  return CL["T"].bound end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING>"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],{CL["&AUX"],{CL_LIB["NEXT"],n}}}}},function (l1, l2,  ...)  l3 = n.bound  l3 = (l2)[1] i( l3 );
 while true do  single_value();  local l4 = n if n ~= l2 then  local l5 = n if n ~= CL_LIB["%<"](l1, l3) then  l5 = n.bound else  single_value();  local l6 = n.bound; single_value(); do return l6 end; l5 = n.bound end i( l5 );
 l1 = l3 i( l1 );
 l3 = CL["CADR"](l2) i( l3 );
 single_value();  l2 = (l2)[2] l4 = l2 else do break end; l4 = n.bound end local tmpres = l4 end i( n );
 single_value();  return CL["T"].bound end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING>="] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],{CL["&AUX"],{CL_LIB["NEXT"],n}}}}},function (l1, l2,  ...)  l3 = n.bound  l3 = (l2)[1] i( l3 );
 while true do  single_value();  local l4 = n if n ~= l2 then  local l5 = n if n ~= CL_LIB["%<="](l1, l3) then  l5 = n.bound else  single_value();  local l6 = n.bound; single_value(); do return l6 end; l5 = n.bound end i( l5 );
 l1 = l3 i( l1 );
 l3 = CL["CADR"](l2) i( l3 );
 single_value();  l2 = (l2)[2] l4 = l2 else do break end; l4 = n.bound end local tmpres = l4 end i( n );
 single_value();  return CL["T"].bound end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR/="] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],n}}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= l2 then  local l4 = n if n ~= CL["APPLY"](CL["CHAR/="].fbound, l2, l()) then  local l5 = CL["T"].bound; local l6 = l2; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = CL["GENSYM"](false); single_value();  local l9 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l10 = n if n ~= CL["NOT"](l6) then  single_value(); do break end; l10 = n.bound else  l10 = n.bound end i( l10 );
 local l11 = n if n ~= CL["CHAR="](l1, l(l7)) then  l5 = n.bound i( l5 );
 single_value();  local l12 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l11 = error({tag=CL["IDENTITY"](l8),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l12)) end)()}) else  l11 = n.bound end i( l11 );
 single_value();  single_value();  local l13 = (l6)[2]; single_value();  l6 = l13 i( l6 );
 single_value();  single_value();  single_value();  local l14 = (l6)[1]; single_value();  l7 = l14 local tmpres = l7 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l9.error ~= n and (l9.error ~= KEYWORD.TAG or l9.tag ~= l8) then if l9.error == KEYWORD.TAG then  error(l9) else error(l9[1]) end end i( CL["VALUES-LIST"](list_r(l9)) );
 single_value();  l4 = l5 else  l4 = n.bound end l3 = l4 else  l3 = CL["T"].bound end return l3 end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING/="] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],n}}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= l2 then  local l4 = n if n ~= CL["APPLY"](CL["STRING/="].fbound, l2, l()) then  local l5 = CL["T"].bound; local l6 = l2; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = CL["GENSYM"](false); single_value();  local l9 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l10 = n if n ~= CL["NOT"](l6) then  single_value(); do break end; l10 = n.bound else  l10 = n.bound end i( l10 );
 local l11 = n if n ~= CL["STRING="](l1, l(l7)) then  l5 = n.bound i( l5 );
 single_value();  local l12 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l11 = error({tag=CL["IDENTITY"](l8),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l12)) end)()}) else  l11 = n.bound end i( l11 );
 single_value();  single_value();  local l13 = (l6)[2]; single_value();  l6 = l13 i( l6 );
 single_value();  single_value();  single_value();  local l14 = (l6)[1]; single_value();  l7 = l14 local tmpres = l7 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l9.error ~= n and (l9.error ~= KEYWORD.TAG or l9.tag ~= l8) then if l9.error == KEYWORD.TAG then  error(l9) else error(l9[1]) end end i( CL["VALUES-LIST"](list_r(l9)) );
 single_value();  l4 = l5 else  l4 = n.bound end l3 = l4 else  l3 = CL["T"].bound end return l3 end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SIMPLE-STRING-P"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STR"],n},function (l1,  ...)   single_value();  return CL["STRINGP"](l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STANDARD-CHAR-P"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHARACTER"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL_LIB["CHARP"](l1) then  local l3 = CL["CHAR-CODE"](l1); single_value();  local l5 = n if n ~= CL[">="](l(l3,32)) then  l5 = CL["<="](l(l3,126)) else  l5 = n.bound end local l4 = l5; single_value();  local l6 = n if n ~= l4 then  l6 = l4 else  l6 = CL["EQ"](l3, 10) end l2 = l6 else  l2 = n.bound end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["UPPER-CASE-P"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL_LIB["CHARP"](l1) then  local l3 = n if n ~= CL["<="](l(65,CL["CHAR-CODE"](l1))) then  l3 = CL["<="](l(CL["CHAR-CODE"](l1),90)) else  l3 = n.bound end l2 = l3 else  l2 = CL["ERROR"]("upper-case-p, not a char", l()) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LOWER-CASE-P"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL_LIB["CHARP"](l1) then  local l3 = n if n ~= CL["<="](l(97,CL["CHAR-CODE"](l1))) then  l3 = CL["<="](l(CL["CHAR-CODE"](l1),122)) else  l3 = n.bound end l2 = l3 else  l2 = CL["ERROR"]("lower-case-p, not a char", l()) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["BOTH-CASE-P"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],n},function (l1,  ...)   single_value();  local l2 = CL["UPPER-CASE-P"](l1); single_value();  local l3 = n if n ~= l2 then  l3 = l2 else  l3 = CL["LOWER-CASE-P"](l1) end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["DIGIT-CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["WEIGHT"],{CL["&OPTIONAL"],{{CL_LIB["RADIX"],{10,n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = 10 end  single_value();  local l3 = n if n ~= CL[">"](l(l2,36)) then  single_value();  l3 = CL["ERROR"]("digit-char, radix must be <= 36", l()) else  local l4 = n if n ~= CL_LIB["%<"](l1, 0) then  single_value();  l4 = CL["ERROR"]("digit-char, weight must be >= 0", l()) else  local l5 = n if n ~= CL[">="](l(l1,l2)) then  single_value();  l5 = n.bound else  local l6 = n if n ~= CL_LIB["%<"](l1, 10) then  single_value();  l6 = CL["CODE-CHAR"]((l1 + 48)) else  local l7 = n if n ~= CL_LIB["%<"](l1, 36) then  single_value();  l7 = CL["CODE-CHAR"]((l1 + 55)) else  local l8 = n if n ~= CL["T"].bound then  single_value();  l8 = CL["ERROR"]("digit-char, Invalid arguments", l()) else  l8 = n.bound end l7 = l8 end l6 = l7 end l5 = l6 end l4 = l5 end l3 = l4 end return l3 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["CHAR-DIGIT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["WEIGHT"],{CL["&OPTIONAL"],{{CL_LIB["RADIX"],{10,n}},{CL["&AUX"],{{CL_LIB["TMP"],{n,n}},n}}}}},function (l1, l2,  ...)  if not l2 then  l2 = 10 end l3 = n.bound  l1 = CL["CHAR-CODE"](l1) i( l1 );
 local l4 = n if n ~= CL[">"](l(l2,36)) then  single_value();  l4 = CL["ERROR"]("char-digit, radix must be <= 36", l()) else  local l5 = n if n ~= CL_LIB["%<"](l1, 48) then  single_value();  l5 = n.bound else  local l6 = n if n ~= CL_LIB["%<"](l1, 58) then  single_value();  l3 = (l1 - 48) l6 = l3 else  local l7 = n if n ~= CL_LIB["%<"](l1, 65) then  single_value();  l7 = n.bound else  local l8 = n if n ~= CL_LIB["%<"](l1, 91) then  single_value();  l3 = (l1 - 55) l8 = l3 else  local l9 = n if n ~= CL_LIB["%<"](l1, 97) then  single_value();  l9 = n.bound else  local l10 = n if n ~= CL_LIB["%<"](l1, 123) then  single_value();  l3 = (l1 - 87) l10 = l3 else  l10 = n.bound end l9 = l10 end l8 = l9 end l7 = l8 end l6 = l7 end l5 = l6 end l4 = l5 end i( l4 );
 single_value();  local l11 = n if n ~= l3 then  local l12 = n if n ~= CL_LIB["%<"](l3, l2) then  l12 = l3 else  l12 = n.bound end l11 = l12 else  l11 = n.bound end return l11 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["DIGIT-CHAR-P"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL["&OPTIONAL"],{{CL_LIB["RADIX"],{10,n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = 10 end  single_value();  local l3 = n if n ~= CL[">"](l(l2,36)) then  single_value();  l3 = CL["ERROR"]("digit-char-p, radix must be <= 36", l()) else  local l4 = n if n ~= CL_LIB["%<"](l2, 2) then  single_value();  l4 = CL["ERROR"]("digit-char-p, radix must be >= 2", l()) else  local l5 = n if n ~= CL["UPPER-CASE-P"](l1) then  single_value();  l5 = CL_LIB["%<"]((CL["CHAR-CODE"](l1) - 55), l2) else  local l6 = n if n ~= CL["LOWER-CASE-P"](l1) then  single_value();  l6 = CL_LIB["%<"]((CL["CHAR-CODE"](l1) - 87), l2) else  local l7 = n if n ~= CL["T"].bound then  single_value();  local l8 = CL["CHAR-CODE"](l1); single_value();  local l10 = n if n ~= CL["<="](l(l8,57)) then  l10 = CL[">="](l(l8,48)) else  l10 = n.bound end local l9 = n if n ~= l10 then  l9 = CL_LIB["%<"]((l8 - 48), l2) else  l9 = n.bound end l7 = l9 else  l7 = n.bound end l6 = l7 end l5 = l6 end l4 = l5 end l3 = l4 end return l3 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ALPHA-CHAR-P"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],n},function (l1,  ...)   single_value();  return CL["BOTH-CASE-P"](l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ALPHANUMERICP"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],n},function (l1,  ...)   single_value();  local l2 = CL["ALPHA-CHAR-P"](l1); single_value();  local l3 = n if n ~= l2 then  l3 = l2 else  l3 = CL["DIGIT-CHAR-P"](l1, false) end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["GRAPHIC-CHAR-P"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],n},function (l1,  ...)   single_value();  local l2 = CL["CHAR-CODE"](l1); single_value();  local l3 = n if n ~= CL[">="](l(l2,32)) then  l3 = CL_LIB["%<"](l2, 128) else  l3 = n.bound end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING-UPCASE"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL["&KEY"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],n}}}},function (l1, keys,  ...)  if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end  single_value();  local l3 = n if n ~= CL["NOT"](keys[CL_LIB["END"]]) then  l3 = CL["EQ"](0, keys[CL_LIB["START"]]) else  l3 = n.bound end local l2 = n if n ~= l3 then  l2 = CL["FUNCALL"](string.upper, l(l1)) else  local l4 = n if n ~= keys[CL_LIB["END"]] then  l4 = CL["SUBSEQ"](l1, keys[CL_LIB["END"]], false) else  l4 = n.bound end l2 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL["SUBSEQ"](l1, 0, keys[CL_LIB["START"]]), CL["FUNCALL"](string.upper, l(CL["SUBSEQ"](l1, keys[CL_LIB["START"]], keys[CL_LIB["END"]]))), l4, }) end return l2 end, 1, 0, false, {0 , [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING-DOWNCASE"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL["&KEY"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],n}}}},function (l1, keys,  ...)  if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end  single_value();  local l3 = n if n ~= CL["NOT"](keys[CL_LIB["END"]]) then  l3 = CL["EQ"](0, keys[CL_LIB["START"]]) else  l3 = n.bound end local l2 = n if n ~= l3 then  l2 = CL["FUNCALL"](string.lower, l(l1)) else  local l4 = n if n ~= keys[CL_LIB["END"]] then  l4 = CL["SUBSEQ"](l1, keys[CL_LIB["END"]], false) else  l4 = n.bound end l2 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL["SUBSEQ"](l1, 0, keys[CL_LIB["START"]]), CL["FUNCALL"](string.lower, l(CL["SUBSEQ"](l1, keys[CL_LIB["START"]], keys[CL_LIB["END"]]))), l4, }) end return l2 end, 1, 0, false, {0 , [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR-UPCASE"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHARACTER"],n},function (l1,  ...)   single_value();  return CL["CHAR"](CL["STRING-UPCASE"](CL_LIB["CHAR-STRING"](l1), k()), 0) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR-DOWNCASE"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHARACTER"],n},function (l1,  ...)   single_value();  return CL["CHAR"](CL["STRING-DOWNCASE"](CL_LIB["CHAR-STRING"](l1), k()), 0) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING-CAPITALIZE"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL["&KEY"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],n}}}},function (l1, keys,  ...)  if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end  single_value();  local l2 = CL["LENGTH"](l1); local l3 = 0; local l4 = keys[CL_LIB["START"]]; single_value();  single_value();  local l5 = CL["GENSYM"](false); single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  local l9 = n if n ~= keys[CL_LIB["END"]] then  l9 = CL[">="](l(l4,keys[CL_LIB["END"]])) else  l9 = n.bound end local l8 = l9; single_value();  local l10 = n if n ~= l8 then  l10 = l8 else  l10 = CL[">="](l(l4,l2)) end local l7 = n if n ~= l10 then  single_value(); do break end; l7 = n.bound else  l7 = n.bound end i( l7 );
 local l11 = CL["CHAR"](l1, l4); single_value();  local l12 = l3; single_value();  local l13 = n if n ~= CL["EQL"](l12, 0) then  single_value();  local l14 = n if n ~= CL["ALPHANUMERICP"](l11) then  l3 = 1 i( l3 );
 single_value();  l1 = CL_LIB["%SET-CHAR"](l1, l4, CL["CHAR-UPCASE"](l11)) l14 = l1 else  l14 = n.bound end l13 = l14 else  local l15 = n if n ~= CL["EQL"](l12, 1) then  single_value();  local l16 = n if n ~= CL["ALPHANUMERICP"](l11) then  l1 = CL_LIB["%SET-CHAR"](l1, l4, CL["CHAR-DOWNCASE"](l11)) l16 = l1 else  l3 = 0 l16 = l3 end l15 = l16 else  local l17 = n if n ~= CL["T"].bound then  single_value();  l17 = CL["ERROR"]("ECASE", l()) else  l17 = n.bound end l15 = l17 end l13 = l15 end i( l13 );
 single_value();  single_value();  single_value();  local l18 = CL["1+"](l4); single_value();  l4 = l18 local tmpres = l4 end return n end, 0, 0, false, false))); single_value(); if l6.error ~= n and (l6.error ~= KEYWORD.TAG or l6.tag ~= l5) then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end i( CL["VALUES-LIST"](list_r(l6)) );
 single_value();  return l1 end, 1, 0, false, {0 , [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["NSTRING-UPCASE"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL["&KEY"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],n}}}},function (l1, keys,  ...)  if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end  single_value();  return CL["STRING-UPCASE"](l1, k(CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]])) end, 1, 0, false, {0 , [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["NSTRING-DOWNCASE"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL["&KEY"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],n}}}},function (l1, keys,  ...)  if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end  single_value();  return CL["STRING-DOWNCASE"](l1, k(CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]])) end, 1, 0, false, {0 , [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["NSTRING-CAPITALIZE"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL["&KEY"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],n}}}},function (l1, keys,  ...)  if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end  single_value();  return CL["STRING-CAPITALIZE"](l1, k(CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]])) end, 1, 0, false, {0 , [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"]})); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["DEF-CHARACTER-COMP-CI"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G69007"],{CL["&OPTIONAL"],{LCL["NIL"]["G69008"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  single_value();  return CL["CONS"](CL["DEFUN"], CL["CONS"](l5, CL["CONS"](CL["CONS"](CL_LIB["C"], CL["CONS"](CL["&REST"], CL["CONS"](CL_LIB["CS"], n))), CL["CONS"](CL["CONS"](CL["APPLY"], CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](l9, n)), CL["CONS"](CL["CONS"](CL["MAPCAR"], CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](CL["CHAR-DOWNCASE"], n)), CL["CONS"](CL["CONS"](CL["CONS"], CL["CONS"](CL_LIB["C"], CL["CONS"](CL_LIB["CS"], n))), n))), n))), n)))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR-EQUAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](CL["CHAR="].fbound, CL["MAPCAR"](CL["CHAR-DOWNCASE"].fbound, l(CL["CONS"](l1, l2))), l()) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR-NOT-EQUAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](CL["CHAR/="].fbound, CL["MAPCAR"](CL["CHAR-DOWNCASE"].fbound, l(CL["CONS"](l1, l2))), l()) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR-LESSP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](CL["CHAR<"].fbound, CL["MAPCAR"](CL["CHAR-DOWNCASE"].fbound, l(CL["CONS"](l1, l2))), l()) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR-GREATERP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](CL["CHAR>"].fbound, CL["MAPCAR"](CL["CHAR-DOWNCASE"].fbound, l(CL["CONS"](l1, l2))), l()) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR-NOT-GREATERP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](CL["CHAR<="].fbound, CL["MAPCAR"](CL["CHAR-DOWNCASE"].fbound, l(CL["CONS"](l1, l2))), l()) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR-NOT-LESSP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](CL["CHAR>="].fbound, CL["MAPCAR"](CL["CHAR-DOWNCASE"].fbound, l(CL["CONS"](l1, l2))), l()) end, 1, 0, true, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["DEF-STRING-COMP-CI"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G69167"],{CL["&OPTIONAL"],{LCL["NIL"]["G69168"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  single_value();  return CL["CONS"](CL["DEFUN"], CL["CONS"](l5, CL["CONS"](CL["CONS"](CL_LIB["C"], CL["CONS"](CL["&REST"], CL["CONS"](CL_LIB["CS"], n))), CL["CONS"](CL["CONS"](CL["APPLY"], CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](l9, n)), CL["CONS"](CL["CONS"](CL["MAPCAR"], CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](CL["STRING-DOWNCASE"], n)), CL["CONS"](CL["CONS"](CL["CONS"], CL["CONS"](CL_LIB["C"], CL["CONS"](CL_LIB["CS"], n))), n))), n))), n)))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING-EQUAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](CL["STRING="].fbound, CL["MAPCAR"](CL["STRING-DOWNCASE"].fbound, l(CL["CONS"](l1, l2))), l()) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING-NOT-EQUAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](CL["STRING/="].fbound, CL["MAPCAR"](CL["STRING-DOWNCASE"].fbound, l(CL["CONS"](l1, l2))), l()) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING-LESSP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](CL["STRING<"].fbound, CL["MAPCAR"](CL["STRING-DOWNCASE"].fbound, l(CL["CONS"](l1, l2))), l()) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING-GREATERP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](CL["STRING>"].fbound, CL["MAPCAR"](CL["STRING-DOWNCASE"].fbound, l(CL["CONS"](l1, l2))), l()) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING-NOT-GREATERP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](CL["STRING<="].fbound, CL["MAPCAR"](CL["STRING-DOWNCASE"].fbound, l(CL["CONS"](l1, l2))), l()) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING-NOT-LESSP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&REST"],{CL_LIB["CS"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](CL["STRING>="].fbound, CL["MAPCAR"](CL["STRING-DOWNCASE"].fbound, l(CL["CONS"](l1, l2))), l()) end, 1, 0, true, false)); local l1 = CL["MAKE-HASH-TABLE"](k()); single_value();  tmp = CL_LIB.DEF(CL_LIB["*CHARACTER-NAMES*"],l1); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["DEF-ALL-CHARS"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G69333"],{CL["&OPTIONAL"],{LCL["NIL"]["G69334"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  single_value();  local l9 = n.bound; local l10 = 0; single_value();  local l11 = CL["GENSYM"](false); single_value();  local l12 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l13 = n if n ~= CL[">="](l(l10,l5)) then  single_value(); do break end; l13 = n.bound else  l13 = n.bound end i( l13 );
 local l14 = CL["CHAR-NAME"](CL["CODE-CHAR"](l10)); single_value();  single_value();  local l15 = CL["CONS"](CL["CONS"](CL_LIB["SETHASH"], CL["CONS"](CL["STRING-UPCASE"](l14, k()), CL["CONS"](CL_LIB["*CHARACTER-NAMES*"], CL["CONS"](l10, n)))), l9); single_value();  l9 = l15 i( l9 );
 single_value();  single_value();  single_value();  local l16 = CL["CONS"](CL["CONS"](CL_LIB["SETHASH"], CL["CONS"](l10, CL["CONS"](CL_LIB["*CHARACTER-NAMES*"], CL["CONS"](l14, n)))), l9); single_value();  l9 = l16 i( l9 );
 single_value();  local l17 = (1 + l10); single_value();  single_value();  single_value();  local l18 = l17; single_value();  l10 = l18 local tmpres = l10 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l12.error ~= n and (l12.error ~= KEYWORD.TAG or l12.tag ~= l11) then if l12.error == KEYWORD.TAG then  error(l12) else error(l12[1]) end end i( CL["VALUES-LIST"](list_r(l12)) );
 single_value();  return CL["CONS"](CL["PROGN"], CL["APPEND"](l(l9,n))) end, 1, 1, false, false)); i( CL_LIB["SETHASH"](255, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_Y_WITH_DIAERESIS") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_Y_WITH_DIAERESIS", CL_LIB["*CHARACTER-NAMES*"].bound, 255) );
 i( CL_LIB["SETHASH"](254, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_THORN") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_THORN", CL_LIB["*CHARACTER-NAMES*"].bound, 254) );
 i( CL_LIB["SETHASH"](253, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_Y_WITH_ACUTE") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_Y_WITH_ACUTE", CL_LIB["*CHARACTER-NAMES*"].bound, 253) );
 i( CL_LIB["SETHASH"](252, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_U_WITH_DIAERESIS") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_U_WITH_DIAERESIS", CL_LIB["*CHARACTER-NAMES*"].bound, 252) );
 i( CL_LIB["SETHASH"](251, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_U_WITH_CIRCUMFLEX") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_U_WITH_CIRCUMFLEX", CL_LIB["*CHARACTER-NAMES*"].bound, 251) );
 i( CL_LIB["SETHASH"](250, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_U_WITH_ACUTE") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_U_WITH_ACUTE", CL_LIB["*CHARACTER-NAMES*"].bound, 250) );
 i( CL_LIB["SETHASH"](249, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_U_WITH_GRAVE") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_U_WITH_GRAVE", CL_LIB["*CHARACTER-NAMES*"].bound, 249) );
 i( CL_LIB["SETHASH"](248, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_O_WITH_STROKE") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_O_WITH_STROKE", CL_LIB["*CHARACTER-NAMES*"].bound, 248) );
 i( CL_LIB["SETHASH"](247, CL_LIB["*CHARACTER-NAMES*"].bound, "DIVISION_SIGN") );
 i( CL_LIB["SETHASH"]("DIVISION_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 247) );
 i( CL_LIB["SETHASH"](246, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_O_WITH_DIAERESIS") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_O_WITH_DIAERESIS", CL_LIB["*CHARACTER-NAMES*"].bound, 246) );
 i( CL_LIB["SETHASH"](245, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_O_WITH_TILDE") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_O_WITH_TILDE", CL_LIB["*CHARACTER-NAMES*"].bound, 245) );
 i( CL_LIB["SETHASH"](244, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_O_WITH_CIRCUMFLEX") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_O_WITH_CIRCUMFLEX", CL_LIB["*CHARACTER-NAMES*"].bound, 244) );
 i( CL_LIB["SETHASH"](243, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_O_WITH_ACUTE") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_O_WITH_ACUTE", CL_LIB["*CHARACTER-NAMES*"].bound, 243) );
 i( CL_LIB["SETHASH"](242, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_O_WITH_GRAVE") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_O_WITH_GRAVE", CL_LIB["*CHARACTER-NAMES*"].bound, 242) );
 i( CL_LIB["SETHASH"](241, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_N_WITH_TILDE") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_N_WITH_TILDE", CL_LIB["*CHARACTER-NAMES*"].bound, 241) );
 i( CL_LIB["SETHASH"](240, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_ETH") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_ETH", CL_LIB["*CHARACTER-NAMES*"].bound, 240) );
 i( CL_LIB["SETHASH"](239, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_I_WITH_DIAERESIS") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_I_WITH_DIAERESIS", CL_LIB["*CHARACTER-NAMES*"].bound, 239) );
 i( CL_LIB["SETHASH"](238, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_I_WITH_CIRCUMFLEX") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_I_WITH_CIRCUMFLEX", CL_LIB["*CHARACTER-NAMES*"].bound, 238) );
 i( CL_LIB["SETHASH"](237, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_I_WITH_ACUTE") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_I_WITH_ACUTE", CL_LIB["*CHARACTER-NAMES*"].bound, 237) );
 i( CL_LIB["SETHASH"](236, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_I_WITH_GRAVE") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_I_WITH_GRAVE", CL_LIB["*CHARACTER-NAMES*"].bound, 236) );
 i( CL_LIB["SETHASH"](235, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_E_WITH_DIAERESIS") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_E_WITH_DIAERESIS", CL_LIB["*CHARACTER-NAMES*"].bound, 235) );
 i( CL_LIB["SETHASH"](234, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_E_WITH_CIRCUMFLEX") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_E_WITH_CIRCUMFLEX", CL_LIB["*CHARACTER-NAMES*"].bound, 234) );
 i( CL_LIB["SETHASH"](233, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_E_WITH_ACUTE") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_E_WITH_ACUTE", CL_LIB["*CHARACTER-NAMES*"].bound, 233) );
 i( CL_LIB["SETHASH"](232, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_E_WITH_GRAVE") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_E_WITH_GRAVE", CL_LIB["*CHARACTER-NAMES*"].bound, 232) );
 i( CL_LIB["SETHASH"](231, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_C_WITH_CEDILLA") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_C_WITH_CEDILLA", CL_LIB["*CHARACTER-NAMES*"].bound, 231) );
 i( CL_LIB["SETHASH"](230, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_AE") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_AE", CL_LIB["*CHARACTER-NAMES*"].bound, 230) );
 i( CL_LIB["SETHASH"](229, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_A_WITH_RING_ABOVE") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_A_WITH_RING_ABOVE", CL_LIB["*CHARACTER-NAMES*"].bound, 229) );
 i( CL_LIB["SETHASH"](228, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_A_WITH_DIAERESIS") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_A_WITH_DIAERESIS", CL_LIB["*CHARACTER-NAMES*"].bound, 228) );
 i( CL_LIB["SETHASH"](227, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_A_WITH_TILDE") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_A_WITH_TILDE", CL_LIB["*CHARACTER-NAMES*"].bound, 227) );
 i( CL_LIB["SETHASH"](226, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_A_WITH_CIRCUMFLEX") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_A_WITH_CIRCUMFLEX", CL_LIB["*CHARACTER-NAMES*"].bound, 226) );
 i( CL_LIB["SETHASH"](225, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_A_WITH_ACUTE") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_A_WITH_ACUTE", CL_LIB["*CHARACTER-NAMES*"].bound, 225) );
 i( CL_LIB["SETHASH"](224, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_A_WITH_GRAVE") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_A_WITH_GRAVE", CL_LIB["*CHARACTER-NAMES*"].bound, 224) );
 i( CL_LIB["SETHASH"](223, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_SHARP_S") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_SHARP_S", CL_LIB["*CHARACTER-NAMES*"].bound, 223) );
 i( CL_LIB["SETHASH"](222, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_THORN") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_THORN", CL_LIB["*CHARACTER-NAMES*"].bound, 222) );
 i( CL_LIB["SETHASH"](221, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_Y_WITH_ACUTE") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_Y_WITH_ACUTE", CL_LIB["*CHARACTER-NAMES*"].bound, 221) );
 i( CL_LIB["SETHASH"](220, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_U_WITH_DIAERESIS") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_U_WITH_DIAERESIS", CL_LIB["*CHARACTER-NAMES*"].bound, 220) );
 i( CL_LIB["SETHASH"](219, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_U_WITH_CIRCUMFLEX") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_U_WITH_CIRCUMFLEX", CL_LIB["*CHARACTER-NAMES*"].bound, 219) );
 i( CL_LIB["SETHASH"](218, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_U_WITH_ACUTE") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_U_WITH_ACUTE", CL_LIB["*CHARACTER-NAMES*"].bound, 218) );
 i( CL_LIB["SETHASH"](217, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_U_WITH_GRAVE") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_U_WITH_GRAVE", CL_LIB["*CHARACTER-NAMES*"].bound, 217) );
 i( CL_LIB["SETHASH"](216, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_O_WITH_STROKE") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_O_WITH_STROKE", CL_LIB["*CHARACTER-NAMES*"].bound, 216) );
 i( CL_LIB["SETHASH"](215, CL_LIB["*CHARACTER-NAMES*"].bound, "MULTIPLICATION_SIGN") );
 i( CL_LIB["SETHASH"]("MULTIPLICATION_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 215) );
 i( CL_LIB["SETHASH"](214, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_O_WITH_DIAERESIS") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_O_WITH_DIAERESIS", CL_LIB["*CHARACTER-NAMES*"].bound, 214) );
 i( CL_LIB["SETHASH"](213, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_O_WITH_TILDE") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_O_WITH_TILDE", CL_LIB["*CHARACTER-NAMES*"].bound, 213) );
 i( CL_LIB["SETHASH"](212, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_O_WITH_CIRCUMFLEX") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_O_WITH_CIRCUMFLEX", CL_LIB["*CHARACTER-NAMES*"].bound, 212) );
 i( CL_LIB["SETHASH"](211, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_O_WITH_ACUTE") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_O_WITH_ACUTE", CL_LIB["*CHARACTER-NAMES*"].bound, 211) );
 i( CL_LIB["SETHASH"](210, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_O_WITH_GRAVE") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_O_WITH_GRAVE", CL_LIB["*CHARACTER-NAMES*"].bound, 210) );
 i( CL_LIB["SETHASH"](209, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_N_WITH_TILDE") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_N_WITH_TILDE", CL_LIB["*CHARACTER-NAMES*"].bound, 209) );
 i( CL_LIB["SETHASH"](208, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_ETH") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_ETH", CL_LIB["*CHARACTER-NAMES*"].bound, 208) );
 i( CL_LIB["SETHASH"](207, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_I_WITH_DIAERESIS") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_I_WITH_DIAERESIS", CL_LIB["*CHARACTER-NAMES*"].bound, 207) );
 i( CL_LIB["SETHASH"](206, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_I_WITH_CIRCUMFLEX") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_I_WITH_CIRCUMFLEX", CL_LIB["*CHARACTER-NAMES*"].bound, 206) );
 i( CL_LIB["SETHASH"](205, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_I_WITH_ACUTE") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_I_WITH_ACUTE", CL_LIB["*CHARACTER-NAMES*"].bound, 205) );
 i( CL_LIB["SETHASH"](204, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_I_WITH_GRAVE") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_I_WITH_GRAVE", CL_LIB["*CHARACTER-NAMES*"].bound, 204) );
 i( CL_LIB["SETHASH"](203, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_E_WITH_DIAERESIS") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_E_WITH_DIAERESIS", CL_LIB["*CHARACTER-NAMES*"].bound, 203) );
 i( CL_LIB["SETHASH"](202, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_E_WITH_CIRCUMFLEX") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_E_WITH_CIRCUMFLEX", CL_LIB["*CHARACTER-NAMES*"].bound, 202) );
 i( CL_LIB["SETHASH"](201, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_E_WITH_ACUTE") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_E_WITH_ACUTE", CL_LIB["*CHARACTER-NAMES*"].bound, 201) );
 i( CL_LIB["SETHASH"](200, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_E_WITH_GRAVE") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_E_WITH_GRAVE", CL_LIB["*CHARACTER-NAMES*"].bound, 200) );
 i( CL_LIB["SETHASH"](199, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_C_WITH_CEDILLA") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_C_WITH_CEDILLA", CL_LIB["*CHARACTER-NAMES*"].bound, 199) );
 i( CL_LIB["SETHASH"](198, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_AE") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_AE", CL_LIB["*CHARACTER-NAMES*"].bound, 198) );
 i( CL_LIB["SETHASH"](197, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE", CL_LIB["*CHARACTER-NAMES*"].bound, 197) );
 i( CL_LIB["SETHASH"](196, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_A_WITH_DIAERESIS") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_A_WITH_DIAERESIS", CL_LIB["*CHARACTER-NAMES*"].bound, 196) );
 i( CL_LIB["SETHASH"](195, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_A_WITH_TILDE") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_A_WITH_TILDE", CL_LIB["*CHARACTER-NAMES*"].bound, 195) );
 i( CL_LIB["SETHASH"](194, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_A_WITH_CIRCUMFLEX") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_A_WITH_CIRCUMFLEX", CL_LIB["*CHARACTER-NAMES*"].bound, 194) );
 i( CL_LIB["SETHASH"](193, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_A_WITH_ACUTE") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_A_WITH_ACUTE", CL_LIB["*CHARACTER-NAMES*"].bound, 193) );
 i( CL_LIB["SETHASH"](192, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_A_WITH_GRAVE") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_A_WITH_GRAVE", CL_LIB["*CHARACTER-NAMES*"].bound, 192) );
 i( CL_LIB["SETHASH"](191, CL_LIB["*CHARACTER-NAMES*"].bound, "INVERTED_QUESTION_MARK") );
 i( CL_LIB["SETHASH"]("INVERTED_QUESTION_MARK", CL_LIB["*CHARACTER-NAMES*"].bound, 191) );
 i( CL_LIB["SETHASH"](190, CL_LIB["*CHARACTER-NAMES*"].bound, "VULGAR_FRACTION_THREE_QUARTERS") );
 i( CL_LIB["SETHASH"]("VULGAR_FRACTION_THREE_QUARTERS", CL_LIB["*CHARACTER-NAMES*"].bound, 190) );
 i( CL_LIB["SETHASH"](189, CL_LIB["*CHARACTER-NAMES*"].bound, "VULGAR_FRACTION_ONE_HALF") );
 i( CL_LIB["SETHASH"]("VULGAR_FRACTION_ONE_HALF", CL_LIB["*CHARACTER-NAMES*"].bound, 189) );
 i( CL_LIB["SETHASH"](188, CL_LIB["*CHARACTER-NAMES*"].bound, "VULGAR_FRACTION_ONE_QUARTER") );
 i( CL_LIB["SETHASH"]("VULGAR_FRACTION_ONE_QUARTER", CL_LIB["*CHARACTER-NAMES*"].bound, 188) );
 i( CL_LIB["SETHASH"](187, CL_LIB["*CHARACTER-NAMES*"].bound, "RIGHT-POINTING_DOUBLE_ANGLE_QUOTATION_MARK") );
 i( CL_LIB["SETHASH"]("RIGHT-POINTING_DOUBLE_ANGLE_QUOTATION_MARK", CL_LIB["*CHARACTER-NAMES*"].bound, 187) );
 i( CL_LIB["SETHASH"](186, CL_LIB["*CHARACTER-NAMES*"].bound, "MASCULINE_ORDINAL_INDICATOR") );
 i( CL_LIB["SETHASH"]("MASCULINE_ORDINAL_INDICATOR", CL_LIB["*CHARACTER-NAMES*"].bound, 186) );
 i( CL_LIB["SETHASH"](185, CL_LIB["*CHARACTER-NAMES*"].bound, "SUPERSCRIPT_ONE") );
 i( CL_LIB["SETHASH"]("SUPERSCRIPT_ONE", CL_LIB["*CHARACTER-NAMES*"].bound, 185) );
 i( CL_LIB["SETHASH"](184, CL_LIB["*CHARACTER-NAMES*"].bound, "CEDILLA") );
 i( CL_LIB["SETHASH"]("CEDILLA", CL_LIB["*CHARACTER-NAMES*"].bound, 184) );
 i( CL_LIB["SETHASH"](183, CL_LIB["*CHARACTER-NAMES*"].bound, "MIDDLE_DOT") );
 i( CL_LIB["SETHASH"]("MIDDLE_DOT", CL_LIB["*CHARACTER-NAMES*"].bound, 183) );
 i( CL_LIB["SETHASH"](182, CL_LIB["*CHARACTER-NAMES*"].bound, "PILCROW_SIGN") );
 i( CL_LIB["SETHASH"]("PILCROW_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 182) );
 i( CL_LIB["SETHASH"](181, CL_LIB["*CHARACTER-NAMES*"].bound, "MICRO_SIGN") );
 i( CL_LIB["SETHASH"]("MICRO_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 181) );
 i( CL_LIB["SETHASH"](180, CL_LIB["*CHARACTER-NAMES*"].bound, "ACUTE_ACCENT") );
 i( CL_LIB["SETHASH"]("ACUTE_ACCENT", CL_LIB["*CHARACTER-NAMES*"].bound, 180) );
 i( CL_LIB["SETHASH"](179, CL_LIB["*CHARACTER-NAMES*"].bound, "SUPERSCRIPT_THREE") );
 i( CL_LIB["SETHASH"]("SUPERSCRIPT_THREE", CL_LIB["*CHARACTER-NAMES*"].bound, 179) );
 i( CL_LIB["SETHASH"](178, CL_LIB["*CHARACTER-NAMES*"].bound, "SUPERSCRIPT_TWO") );
 i( CL_LIB["SETHASH"]("SUPERSCRIPT_TWO", CL_LIB["*CHARACTER-NAMES*"].bound, 178) );
 i( CL_LIB["SETHASH"](177, CL_LIB["*CHARACTER-NAMES*"].bound, "PLUS-MINUS_SIGN") );
 i( CL_LIB["SETHASH"]("PLUS-MINUS_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 177) );
 i( CL_LIB["SETHASH"](176, CL_LIB["*CHARACTER-NAMES*"].bound, "DEGREE_SIGN") );
 i( CL_LIB["SETHASH"]("DEGREE_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 176) );
 i( CL_LIB["SETHASH"](175, CL_LIB["*CHARACTER-NAMES*"].bound, "MACRON") );
 i( CL_LIB["SETHASH"]("MACRON", CL_LIB["*CHARACTER-NAMES*"].bound, 175) );
 i( CL_LIB["SETHASH"](174, CL_LIB["*CHARACTER-NAMES*"].bound, "REGISTERED_SIGN") );
 i( CL_LIB["SETHASH"]("REGISTERED_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 174) );
 i( CL_LIB["SETHASH"](173, CL_LIB["*CHARACTER-NAMES*"].bound, "SOFT_HYPHEN") );
 i( CL_LIB["SETHASH"]("SOFT_HYPHEN", CL_LIB["*CHARACTER-NAMES*"].bound, 173) );
 i( CL_LIB["SETHASH"](172, CL_LIB["*CHARACTER-NAMES*"].bound, "NOT_SIGN") );
 i( CL_LIB["SETHASH"]("NOT_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 172) );
 i( CL_LIB["SETHASH"](171, CL_LIB["*CHARACTER-NAMES*"].bound, "LEFT-POINTING_DOUBLE_ANGLE_QUOTATION_MARK") );
 i( CL_LIB["SETHASH"]("LEFT-POINTING_DOUBLE_ANGLE_QUOTATION_MARK", CL_LIB["*CHARACTER-NAMES*"].bound, 171) );
 i( CL_LIB["SETHASH"](170, CL_LIB["*CHARACTER-NAMES*"].bound, "FEMININE_ORDINAL_INDICATOR") );
 i( CL_LIB["SETHASH"]("FEMININE_ORDINAL_INDICATOR", CL_LIB["*CHARACTER-NAMES*"].bound, 170) );
 i( CL_LIB["SETHASH"](169, CL_LIB["*CHARACTER-NAMES*"].bound, "COPYRIGHT_SIGN") );
 i( CL_LIB["SETHASH"]("COPYRIGHT_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 169) );
 i( CL_LIB["SETHASH"](168, CL_LIB["*CHARACTER-NAMES*"].bound, "DIAERESIS") );
 i( CL_LIB["SETHASH"]("DIAERESIS", CL_LIB["*CHARACTER-NAMES*"].bound, 168) );
 i( CL_LIB["SETHASH"](167, CL_LIB["*CHARACTER-NAMES*"].bound, "SECTION_SIGN") );
 i( CL_LIB["SETHASH"]("SECTION_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 167) );
 i( CL_LIB["SETHASH"](166, CL_LIB["*CHARACTER-NAMES*"].bound, "BROKEN_BAR") );
 i( CL_LIB["SETHASH"]("BROKEN_BAR", CL_LIB["*CHARACTER-NAMES*"].bound, 166) );
 i( CL_LIB["SETHASH"](165, CL_LIB["*CHARACTER-NAMES*"].bound, "YEN_SIGN") );
 i( CL_LIB["SETHASH"]("YEN_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 165) );
 i( CL_LIB["SETHASH"](164, CL_LIB["*CHARACTER-NAMES*"].bound, "CURRENCY_SIGN") );
 i( CL_LIB["SETHASH"]("CURRENCY_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 164) );
 i( CL_LIB["SETHASH"](163, CL_LIB["*CHARACTER-NAMES*"].bound, "POUND_SIGN") );
 i( CL_LIB["SETHASH"]("POUND_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 163) );
 i( CL_LIB["SETHASH"](162, CL_LIB["*CHARACTER-NAMES*"].bound, "CENT_SIGN") );
 i( CL_LIB["SETHASH"]("CENT_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 162) );
 i( CL_LIB["SETHASH"](161, CL_LIB["*CHARACTER-NAMES*"].bound, "INVERTED_EXCLAMATION_MARK") );
 i( CL_LIB["SETHASH"]("INVERTED_EXCLAMATION_MARK", CL_LIB["*CHARACTER-NAMES*"].bound, 161) );
 i( CL_LIB["SETHASH"](160, CL_LIB["*CHARACTER-NAMES*"].bound, "NO-BREAK_SPACE") );
 i( CL_LIB["SETHASH"]("NO-BREAK_SPACE", CL_LIB["*CHARACTER-NAMES*"].bound, 160) );
 i( CL_LIB["SETHASH"](159, CL_LIB["*CHARACTER-NAMES*"].bound, "Application-Program-Command") );
 i( CL_LIB["SETHASH"]("APPLICATION-PROGRAM-COMMAND", CL_LIB["*CHARACTER-NAMES*"].bound, 159) );
 i( CL_LIB["SETHASH"](158, CL_LIB["*CHARACTER-NAMES*"].bound, "Privacy-Message") );
 i( CL_LIB["SETHASH"]("PRIVACY-MESSAGE", CL_LIB["*CHARACTER-NAMES*"].bound, 158) );
 i( CL_LIB["SETHASH"](157, CL_LIB["*CHARACTER-NAMES*"].bound, "Operating-System-Command") );
 i( CL_LIB["SETHASH"]("OPERATING-SYSTEM-COMMAND", CL_LIB["*CHARACTER-NAMES*"].bound, 157) );
 i( CL_LIB["SETHASH"](156, CL_LIB["*CHARACTER-NAMES*"].bound, "String-Terminator") );
 i( CL_LIB["SETHASH"]("STRING-TERMINATOR", CL_LIB["*CHARACTER-NAMES*"].bound, 156) );
 i( CL_LIB["SETHASH"](155, CL_LIB["*CHARACTER-NAMES*"].bound, "Control-Sequence-Introducer") );
 i( CL_LIB["SETHASH"]("CONTROL-SEQUENCE-INTRODUCER", CL_LIB["*CHARACTER-NAMES*"].bound, 155) );
 i( CL_LIB["SETHASH"](154, CL_LIB["*CHARACTER-NAMES*"].bound, "Single-Character-Introducer") );
 i( CL_LIB["SETHASH"]("SINGLE-CHARACTER-INTRODUCER", CL_LIB["*CHARACTER-NAMES*"].bound, 154) );
 i( CL_LIB["SETHASH"](153, CL_LIB["*CHARACTER-NAMES*"].bound, "C99") );
 i( CL_LIB["SETHASH"]("C99", CL_LIB["*CHARACTER-NAMES*"].bound, 153) );
 i( CL_LIB["SETHASH"](152, CL_LIB["*CHARACTER-NAMES*"].bound, "Start-String") );
 i( CL_LIB["SETHASH"]("START-STRING", CL_LIB["*CHARACTER-NAMES*"].bound, 152) );
 i( CL_LIB["SETHASH"](151, CL_LIB["*CHARACTER-NAMES*"].bound, "End-Guarded-Area") );
 i( CL_LIB["SETHASH"]("END-GUARDED-AREA", CL_LIB["*CHARACTER-NAMES*"].bound, 151) );
 i( CL_LIB["SETHASH"](150, CL_LIB["*CHARACTER-NAMES*"].bound, "Start-Guarded-Area") );
 i( CL_LIB["SETHASH"]("START-GUARDED-AREA", CL_LIB["*CHARACTER-NAMES*"].bound, 150) );
 i( CL_LIB["SETHASH"](149, CL_LIB["*CHARACTER-NAMES*"].bound, "Message-Waiting") );
 i( CL_LIB["SETHASH"]("MESSAGE-WAITING", CL_LIB["*CHARACTER-NAMES*"].bound, 149) );
 i( CL_LIB["SETHASH"](148, CL_LIB["*CHARACTER-NAMES*"].bound, "Cancel-Character") );
 i( CL_LIB["SETHASH"]("CANCEL-CHARACTER", CL_LIB["*CHARACTER-NAMES*"].bound, 148) );
 i( CL_LIB["SETHASH"](147, CL_LIB["*CHARACTER-NAMES*"].bound, "Set-Transmit-State") );
 i( CL_LIB["SETHASH"]("SET-TRANSMIT-STATE", CL_LIB["*CHARACTER-NAMES*"].bound, 147) );
 i( CL_LIB["SETHASH"](146, CL_LIB["*CHARACTER-NAMES*"].bound, "Private-Use-Two") );
 i( CL_LIB["SETHASH"]("PRIVATE-USE-TWO", CL_LIB["*CHARACTER-NAMES*"].bound, 146) );
 i( CL_LIB["SETHASH"](145, CL_LIB["*CHARACTER-NAMES*"].bound, "Private-Use-One") );
 i( CL_LIB["SETHASH"]("PRIVATE-USE-ONE", CL_LIB["*CHARACTER-NAMES*"].bound, 145) );
 i( CL_LIB["SETHASH"](144, CL_LIB["*CHARACTER-NAMES*"].bound, "Device-Control-String") );
 i( CL_LIB["SETHASH"]("DEVICE-CONTROL-STRING", CL_LIB["*CHARACTER-NAMES*"].bound, 144) );
 i( CL_LIB["SETHASH"](143, CL_LIB["*CHARACTER-NAMES*"].bound, "Single-Shift-Three") );
 i( CL_LIB["SETHASH"]("SINGLE-SHIFT-THREE", CL_LIB["*CHARACTER-NAMES*"].bound, 143) );
 i( CL_LIB["SETHASH"](142, CL_LIB["*CHARACTER-NAMES*"].bound, "Single-Shift-Two") );
 i( CL_LIB["SETHASH"]("SINGLE-SHIFT-TWO", CL_LIB["*CHARACTER-NAMES*"].bound, 142) );
 i( CL_LIB["SETHASH"](141, CL_LIB["*CHARACTER-NAMES*"].bound, "Reverse-Linefeed") );
 i( CL_LIB["SETHASH"]("REVERSE-LINEFEED", CL_LIB["*CHARACTER-NAMES*"].bound, 141) );
 i( CL_LIB["SETHASH"](140, CL_LIB["*CHARACTER-NAMES*"].bound, "Partial-Line-Backward") );
 i( CL_LIB["SETHASH"]("PARTIAL-LINE-BACKWARD", CL_LIB["*CHARACTER-NAMES*"].bound, 140) );
 i( CL_LIB["SETHASH"](139, CL_LIB["*CHARACTER-NAMES*"].bound, "Partial-Line-Forward") );
 i( CL_LIB["SETHASH"]("PARTIAL-LINE-FORWARD", CL_LIB["*CHARACTER-NAMES*"].bound, 139) );
 i( CL_LIB["SETHASH"](138, CL_LIB["*CHARACTER-NAMES*"].bound, "Line-Tabulation-Set") );
 i( CL_LIB["SETHASH"]("LINE-TABULATION-SET", CL_LIB["*CHARACTER-NAMES*"].bound, 138) );
 i( CL_LIB["SETHASH"](137, CL_LIB["*CHARACTER-NAMES*"].bound, "Character-Tabulation-With-Justification") );
 i( CL_LIB["SETHASH"]("CHARACTER-TABULATION-WITH-JUSTIFICATION", CL_LIB["*CHARACTER-NAMES*"].bound, 137) );
 i( CL_LIB["SETHASH"](136, CL_LIB["*CHARACTER-NAMES*"].bound, "Character-Tabulation-Set") );
 i( CL_LIB["SETHASH"]("CHARACTER-TABULATION-SET", CL_LIB["*CHARACTER-NAMES*"].bound, 136) );
 i( CL_LIB["SETHASH"](135, CL_LIB["*CHARACTER-NAMES*"].bound, "End-Selected-Area") );
 i( CL_LIB["SETHASH"]("END-SELECTED-AREA", CL_LIB["*CHARACTER-NAMES*"].bound, 135) );
 i( CL_LIB["SETHASH"](134, CL_LIB["*CHARACTER-NAMES*"].bound, "Start-Selected-Area") );
 i( CL_LIB["SETHASH"]("START-SELECTED-AREA", CL_LIB["*CHARACTER-NAMES*"].bound, 134) );
 i( CL_LIB["SETHASH"](133, CL_LIB["*CHARACTER-NAMES*"].bound, "Next-Line") );
 i( CL_LIB["SETHASH"]("NEXT-LINE", CL_LIB["*CHARACTER-NAMES*"].bound, 133) );
 i( CL_LIB["SETHASH"](132, CL_LIB["*CHARACTER-NAMES*"].bound, "C84") );
 i( CL_LIB["SETHASH"]("C84", CL_LIB["*CHARACTER-NAMES*"].bound, 132) );
 i( CL_LIB["SETHASH"](131, CL_LIB["*CHARACTER-NAMES*"].bound, "No-Break-Permitted") );
 i( CL_LIB["SETHASH"]("NO-BREAK-PERMITTED", CL_LIB["*CHARACTER-NAMES*"].bound, 131) );
 i( CL_LIB["SETHASH"](130, CL_LIB["*CHARACTER-NAMES*"].bound, "Break-Permitted") );
 i( CL_LIB["SETHASH"]("BREAK-PERMITTED", CL_LIB["*CHARACTER-NAMES*"].bound, 130) );
 i( CL_LIB["SETHASH"](129, CL_LIB["*CHARACTER-NAMES*"].bound, "C81") );
 i( CL_LIB["SETHASH"]("C81", CL_LIB["*CHARACTER-NAMES*"].bound, 129) );
 i( CL_LIB["SETHASH"](128, CL_LIB["*CHARACTER-NAMES*"].bound, "C80") );
 i( CL_LIB["SETHASH"]("C80", CL_LIB["*CHARACTER-NAMES*"].bound, 128) );
 i( CL_LIB["SETHASH"](127, CL_LIB["*CHARACTER-NAMES*"].bound, "Rubout") );
 i( CL_LIB["SETHASH"]("RUBOUT", CL_LIB["*CHARACTER-NAMES*"].bound, 127) );
 i( CL_LIB["SETHASH"](126, CL_LIB["*CHARACTER-NAMES*"].bound, "TILDE") );
 i( CL_LIB["SETHASH"]("TILDE", CL_LIB["*CHARACTER-NAMES*"].bound, 126) );
 i( CL_LIB["SETHASH"](125, CL_LIB["*CHARACTER-NAMES*"].bound, "RIGHT_CURLY_BRACKET") );
 i( CL_LIB["SETHASH"]("RIGHT_CURLY_BRACKET", CL_LIB["*CHARACTER-NAMES*"].bound, 125) );
 i( CL_LIB["SETHASH"](124, CL_LIB["*CHARACTER-NAMES*"].bound, "VERTICAL_LINE") );
 i( CL_LIB["SETHASH"]("VERTICAL_LINE", CL_LIB["*CHARACTER-NAMES*"].bound, 124) );
 i( CL_LIB["SETHASH"](123, CL_LIB["*CHARACTER-NAMES*"].bound, "LEFT_CURLY_BRACKET") );
 i( CL_LIB["SETHASH"]("LEFT_CURLY_BRACKET", CL_LIB["*CHARACTER-NAMES*"].bound, 123) );
 i( CL_LIB["SETHASH"](122, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_Z") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_Z", CL_LIB["*CHARACTER-NAMES*"].bound, 122) );
 i( CL_LIB["SETHASH"](121, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_Y") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_Y", CL_LIB["*CHARACTER-NAMES*"].bound, 121) );
 i( CL_LIB["SETHASH"](120, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_X") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_X", CL_LIB["*CHARACTER-NAMES*"].bound, 120) );
 i( CL_LIB["SETHASH"](119, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_W") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_W", CL_LIB["*CHARACTER-NAMES*"].bound, 119) );
 i( CL_LIB["SETHASH"](118, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_V") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_V", CL_LIB["*CHARACTER-NAMES*"].bound, 118) );
 i( CL_LIB["SETHASH"](117, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_U") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_U", CL_LIB["*CHARACTER-NAMES*"].bound, 117) );
 i( CL_LIB["SETHASH"](116, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_T") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_T", CL_LIB["*CHARACTER-NAMES*"].bound, 116) );
 i( CL_LIB["SETHASH"](115, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_S") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_S", CL_LIB["*CHARACTER-NAMES*"].bound, 115) );
 i( CL_LIB["SETHASH"](114, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_R") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_R", CL_LIB["*CHARACTER-NAMES*"].bound, 114) );
 i( CL_LIB["SETHASH"](113, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_Q") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_Q", CL_LIB["*CHARACTER-NAMES*"].bound, 113) );
 i( CL_LIB["SETHASH"](112, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_P") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_P", CL_LIB["*CHARACTER-NAMES*"].bound, 112) );
 i( CL_LIB["SETHASH"](111, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_O") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_O", CL_LIB["*CHARACTER-NAMES*"].bound, 111) );
 i( CL_LIB["SETHASH"](110, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_N") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_N", CL_LIB["*CHARACTER-NAMES*"].bound, 110) );
 i( CL_LIB["SETHASH"](109, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_M") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_M", CL_LIB["*CHARACTER-NAMES*"].bound, 109) );
 i( CL_LIB["SETHASH"](108, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_L") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_L", CL_LIB["*CHARACTER-NAMES*"].bound, 108) );
 i( CL_LIB["SETHASH"](107, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_K") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_K", CL_LIB["*CHARACTER-NAMES*"].bound, 107) );
 i( CL_LIB["SETHASH"](106, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_J") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_J", CL_LIB["*CHARACTER-NAMES*"].bound, 106) );
 i( CL_LIB["SETHASH"](105, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_I") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_I", CL_LIB["*CHARACTER-NAMES*"].bound, 105) );
 i( CL_LIB["SETHASH"](104, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_H") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_H", CL_LIB["*CHARACTER-NAMES*"].bound, 104) );
 i( CL_LIB["SETHASH"](103, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_G") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_G", CL_LIB["*CHARACTER-NAMES*"].bound, 103) );
 i( CL_LIB["SETHASH"](102, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_F") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_F", CL_LIB["*CHARACTER-NAMES*"].bound, 102) );
 i( CL_LIB["SETHASH"](101, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_E") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_E", CL_LIB["*CHARACTER-NAMES*"].bound, 101) );
 i( CL_LIB["SETHASH"](100, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_D") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_D", CL_LIB["*CHARACTER-NAMES*"].bound, 100) );
 i( CL_LIB["SETHASH"](99, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_C") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_C", CL_LIB["*CHARACTER-NAMES*"].bound, 99) );
 i( CL_LIB["SETHASH"](98, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_B") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_B", CL_LIB["*CHARACTER-NAMES*"].bound, 98) );
 i( CL_LIB["SETHASH"](97, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_SMALL_LETTER_A") );
 i( CL_LIB["SETHASH"]("LATIN_SMALL_LETTER_A", CL_LIB["*CHARACTER-NAMES*"].bound, 97) );
 i( CL_LIB["SETHASH"](96, CL_LIB["*CHARACTER-NAMES*"].bound, "GRAVE_ACCENT") );
 i( CL_LIB["SETHASH"]("GRAVE_ACCENT", CL_LIB["*CHARACTER-NAMES*"].bound, 96) );
 i( CL_LIB["SETHASH"](95, CL_LIB["*CHARACTER-NAMES*"].bound, "LOW_LINE") );
 i( CL_LIB["SETHASH"]("LOW_LINE", CL_LIB["*CHARACTER-NAMES*"].bound, 95) );
 i( CL_LIB["SETHASH"](94, CL_LIB["*CHARACTER-NAMES*"].bound, "CIRCUMFLEX_ACCENT") );
 i( CL_LIB["SETHASH"]("CIRCUMFLEX_ACCENT", CL_LIB["*CHARACTER-NAMES*"].bound, 94) );
 i( CL_LIB["SETHASH"](93, CL_LIB["*CHARACTER-NAMES*"].bound, "RIGHT_SQUARE_BRACKET") );
 i( CL_LIB["SETHASH"]("RIGHT_SQUARE_BRACKET", CL_LIB["*CHARACTER-NAMES*"].bound, 93) );
 i( CL_LIB["SETHASH"](92, CL_LIB["*CHARACTER-NAMES*"].bound, "REVERSE_SOLIDUS") );
 i( CL_LIB["SETHASH"]("REVERSE_SOLIDUS", CL_LIB["*CHARACTER-NAMES*"].bound, 92) );
 i( CL_LIB["SETHASH"](91, CL_LIB["*CHARACTER-NAMES*"].bound, "LEFT_SQUARE_BRACKET") );
 i( CL_LIB["SETHASH"]("LEFT_SQUARE_BRACKET", CL_LIB["*CHARACTER-NAMES*"].bound, 91) );
 i( CL_LIB["SETHASH"](90, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_Z") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_Z", CL_LIB["*CHARACTER-NAMES*"].bound, 90) );
 i( CL_LIB["SETHASH"](89, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_Y") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_Y", CL_LIB["*CHARACTER-NAMES*"].bound, 89) );
 i( CL_LIB["SETHASH"](88, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_X") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_X", CL_LIB["*CHARACTER-NAMES*"].bound, 88) );
 i( CL_LIB["SETHASH"](87, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_W") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_W", CL_LIB["*CHARACTER-NAMES*"].bound, 87) );
 i( CL_LIB["SETHASH"](86, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_V") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_V", CL_LIB["*CHARACTER-NAMES*"].bound, 86) );
 i( CL_LIB["SETHASH"](85, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_U") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_U", CL_LIB["*CHARACTER-NAMES*"].bound, 85) );
 i( CL_LIB["SETHASH"](84, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_T") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_T", CL_LIB["*CHARACTER-NAMES*"].bound, 84) );
 i( CL_LIB["SETHASH"](83, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_S") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_S", CL_LIB["*CHARACTER-NAMES*"].bound, 83) );
 i( CL_LIB["SETHASH"](82, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_R") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_R", CL_LIB["*CHARACTER-NAMES*"].bound, 82) );
 i( CL_LIB["SETHASH"](81, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_Q") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_Q", CL_LIB["*CHARACTER-NAMES*"].bound, 81) );
 i( CL_LIB["SETHASH"](80, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_P") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_P", CL_LIB["*CHARACTER-NAMES*"].bound, 80) );
 i( CL_LIB["SETHASH"](79, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_O") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_O", CL_LIB["*CHARACTER-NAMES*"].bound, 79) );
 i( CL_LIB["SETHASH"](78, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_N") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_N", CL_LIB["*CHARACTER-NAMES*"].bound, 78) );
 i( CL_LIB["SETHASH"](77, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_M") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_M", CL_LIB["*CHARACTER-NAMES*"].bound, 77) );
 i( CL_LIB["SETHASH"](76, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_L") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_L", CL_LIB["*CHARACTER-NAMES*"].bound, 76) );
 i( CL_LIB["SETHASH"](75, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_K") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_K", CL_LIB["*CHARACTER-NAMES*"].bound, 75) );
 i( CL_LIB["SETHASH"](74, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_J") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_J", CL_LIB["*CHARACTER-NAMES*"].bound, 74) );
 i( CL_LIB["SETHASH"](73, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_I") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_I", CL_LIB["*CHARACTER-NAMES*"].bound, 73) );
 i( CL_LIB["SETHASH"](72, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_H") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_H", CL_LIB["*CHARACTER-NAMES*"].bound, 72) );
 i( CL_LIB["SETHASH"](71, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_G") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_G", CL_LIB["*CHARACTER-NAMES*"].bound, 71) );
 i( CL_LIB["SETHASH"](70, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_F") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_F", CL_LIB["*CHARACTER-NAMES*"].bound, 70) );
 i( CL_LIB["SETHASH"](69, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_E") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_E", CL_LIB["*CHARACTER-NAMES*"].bound, 69) );
 i( CL_LIB["SETHASH"](68, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_D") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_D", CL_LIB["*CHARACTER-NAMES*"].bound, 68) );
 i( CL_LIB["SETHASH"](67, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_C") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_C", CL_LIB["*CHARACTER-NAMES*"].bound, 67) );
 i( CL_LIB["SETHASH"](66, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_B") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_B", CL_LIB["*CHARACTER-NAMES*"].bound, 66) );
 i( CL_LIB["SETHASH"](65, CL_LIB["*CHARACTER-NAMES*"].bound, "LATIN_CAPITAL_LETTER_A") );
 i( CL_LIB["SETHASH"]("LATIN_CAPITAL_LETTER_A", CL_LIB["*CHARACTER-NAMES*"].bound, 65) );
 i( CL_LIB["SETHASH"](64, CL_LIB["*CHARACTER-NAMES*"].bound, "COMMERCIAL_AT") );
 i( CL_LIB["SETHASH"]("COMMERCIAL_AT", CL_LIB["*CHARACTER-NAMES*"].bound, 64) );
 i( CL_LIB["SETHASH"](63, CL_LIB["*CHARACTER-NAMES*"].bound, "QUESTION_MARK") );
 i( CL_LIB["SETHASH"]("QUESTION_MARK", CL_LIB["*CHARACTER-NAMES*"].bound, 63) );
 i( CL_LIB["SETHASH"](62, CL_LIB["*CHARACTER-NAMES*"].bound, "GREATER-THAN_SIGN") );
 i( CL_LIB["SETHASH"]("GREATER-THAN_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 62) );
 i( CL_LIB["SETHASH"](61, CL_LIB["*CHARACTER-NAMES*"].bound, "EQUALS_SIGN") );
 i( CL_LIB["SETHASH"]("EQUALS_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 61) );
 i( CL_LIB["SETHASH"](60, CL_LIB["*CHARACTER-NAMES*"].bound, "LESS-THAN_SIGN") );
 i( CL_LIB["SETHASH"]("LESS-THAN_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 60) );
 i( CL_LIB["SETHASH"](59, CL_LIB["*CHARACTER-NAMES*"].bound, "SEMICOLON") );
 i( CL_LIB["SETHASH"]("SEMICOLON", CL_LIB["*CHARACTER-NAMES*"].bound, 59) );
 i( CL_LIB["SETHASH"](58, CL_LIB["*CHARACTER-NAMES*"].bound, "COLON") );
 i( CL_LIB["SETHASH"]("COLON", CL_LIB["*CHARACTER-NAMES*"].bound, 58) );
 i( CL_LIB["SETHASH"](57, CL_LIB["*CHARACTER-NAMES*"].bound, "DIGIT_NINE") );
 i( CL_LIB["SETHASH"]("DIGIT_NINE", CL_LIB["*CHARACTER-NAMES*"].bound, 57) );
 i( CL_LIB["SETHASH"](56, CL_LIB["*CHARACTER-NAMES*"].bound, "DIGIT_EIGHT") );
 i( CL_LIB["SETHASH"]("DIGIT_EIGHT", CL_LIB["*CHARACTER-NAMES*"].bound, 56) );
 i( CL_LIB["SETHASH"](55, CL_LIB["*CHARACTER-NAMES*"].bound, "DIGIT_SEVEN") );
 i( CL_LIB["SETHASH"]("DIGIT_SEVEN", CL_LIB["*CHARACTER-NAMES*"].bound, 55) );
 i( CL_LIB["SETHASH"](54, CL_LIB["*CHARACTER-NAMES*"].bound, "DIGIT_SIX") );
 i( CL_LIB["SETHASH"]("DIGIT_SIX", CL_LIB["*CHARACTER-NAMES*"].bound, 54) );
 i( CL_LIB["SETHASH"](53, CL_LIB["*CHARACTER-NAMES*"].bound, "DIGIT_FIVE") );
 i( CL_LIB["SETHASH"]("DIGIT_FIVE", CL_LIB["*CHARACTER-NAMES*"].bound, 53) );
 i( CL_LIB["SETHASH"](52, CL_LIB["*CHARACTER-NAMES*"].bound, "DIGIT_FOUR") );
 i( CL_LIB["SETHASH"]("DIGIT_FOUR", CL_LIB["*CHARACTER-NAMES*"].bound, 52) );
 i( CL_LIB["SETHASH"](51, CL_LIB["*CHARACTER-NAMES*"].bound, "DIGIT_THREE") );
 i( CL_LIB["SETHASH"]("DIGIT_THREE", CL_LIB["*CHARACTER-NAMES*"].bound, 51) );
 i( CL_LIB["SETHASH"](50, CL_LIB["*CHARACTER-NAMES*"].bound, "DIGIT_TWO") );
 i( CL_LIB["SETHASH"]("DIGIT_TWO", CL_LIB["*CHARACTER-NAMES*"].bound, 50) );
 i( CL_LIB["SETHASH"](49, CL_LIB["*CHARACTER-NAMES*"].bound, "DIGIT_ONE") );
 i( CL_LIB["SETHASH"]("DIGIT_ONE", CL_LIB["*CHARACTER-NAMES*"].bound, 49) );
 i( CL_LIB["SETHASH"](48, CL_LIB["*CHARACTER-NAMES*"].bound, "DIGIT_ZERO") );
 i( CL_LIB["SETHASH"]("DIGIT_ZERO", CL_LIB["*CHARACTER-NAMES*"].bound, 48) );
 i( CL_LIB["SETHASH"](47, CL_LIB["*CHARACTER-NAMES*"].bound, "SOLIDUS") );
 i( CL_LIB["SETHASH"]("SOLIDUS", CL_LIB["*CHARACTER-NAMES*"].bound, 47) );
 i( CL_LIB["SETHASH"](46, CL_LIB["*CHARACTER-NAMES*"].bound, "FULL_STOP") );
 i( CL_LIB["SETHASH"]("FULL_STOP", CL_LIB["*CHARACTER-NAMES*"].bound, 46) );
 i( CL_LIB["SETHASH"](45, CL_LIB["*CHARACTER-NAMES*"].bound, "HYPHEN-MINUS") );
 i( CL_LIB["SETHASH"]("HYPHEN-MINUS", CL_LIB["*CHARACTER-NAMES*"].bound, 45) );
 i( CL_LIB["SETHASH"](44, CL_LIB["*CHARACTER-NAMES*"].bound, "COMMA") );
 i( CL_LIB["SETHASH"]("COMMA", CL_LIB["*CHARACTER-NAMES*"].bound, 44) );
 i( CL_LIB["SETHASH"](43, CL_LIB["*CHARACTER-NAMES*"].bound, "PLUS_SIGN") );
 i( CL_LIB["SETHASH"]("PLUS_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 43) );
 i( CL_LIB["SETHASH"](42, CL_LIB["*CHARACTER-NAMES*"].bound, "ASTERISK") );
 i( CL_LIB["SETHASH"]("ASTERISK", CL_LIB["*CHARACTER-NAMES*"].bound, 42) );
 i( CL_LIB["SETHASH"](41, CL_LIB["*CHARACTER-NAMES*"].bound, "RIGHT_PARENTHESIS") );
 i( CL_LIB["SETHASH"]("RIGHT_PARENTHESIS", CL_LIB["*CHARACTER-NAMES*"].bound, 41) );
 i( CL_LIB["SETHASH"](40, CL_LIB["*CHARACTER-NAMES*"].bound, "LEFT_PARENTHESIS") );
 i( CL_LIB["SETHASH"]("LEFT_PARENTHESIS", CL_LIB["*CHARACTER-NAMES*"].bound, 40) );
 i( CL_LIB["SETHASH"](39, CL_LIB["*CHARACTER-NAMES*"].bound, "APOSTROPHE") );
 i( CL_LIB["SETHASH"]("APOSTROPHE", CL_LIB["*CHARACTER-NAMES*"].bound, 39) );
 i( CL_LIB["SETHASH"](38, CL_LIB["*CHARACTER-NAMES*"].bound, "AMPERSAND") );
 i( CL_LIB["SETHASH"]("AMPERSAND", CL_LIB["*CHARACTER-NAMES*"].bound, 38) );
 i( CL_LIB["SETHASH"](37, CL_LIB["*CHARACTER-NAMES*"].bound, "PERCENT_SIGN") );
 i( CL_LIB["SETHASH"]("PERCENT_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 37) );
 i( CL_LIB["SETHASH"](36, CL_LIB["*CHARACTER-NAMES*"].bound, "DOLLAR_SIGN") );
 i( CL_LIB["SETHASH"]("DOLLAR_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 36) );
 i( CL_LIB["SETHASH"](35, CL_LIB["*CHARACTER-NAMES*"].bound, "NUMBER_SIGN") );
 i( CL_LIB["SETHASH"]("NUMBER_SIGN", CL_LIB["*CHARACTER-NAMES*"].bound, 35) );
 i( CL_LIB["SETHASH"](34, CL_LIB["*CHARACTER-NAMES*"].bound, "QUOTATION_MARK") );
 i( CL_LIB["SETHASH"]("QUOTATION_MARK", CL_LIB["*CHARACTER-NAMES*"].bound, 34) );
 i( CL_LIB["SETHASH"](33, CL_LIB["*CHARACTER-NAMES*"].bound, "EXCLAMATION_MARK") );
 i( CL_LIB["SETHASH"]("EXCLAMATION_MARK", CL_LIB["*CHARACTER-NAMES*"].bound, 33) );
 i( CL_LIB["SETHASH"](32, CL_LIB["*CHARACTER-NAMES*"].bound, "Space") );
 i( CL_LIB["SETHASH"]("SPACE", CL_LIB["*CHARACTER-NAMES*"].bound, 32) );
 i( CL_LIB["SETHASH"](31, CL_LIB["*CHARACTER-NAMES*"].bound, "Us") );
 i( CL_LIB["SETHASH"]("US", CL_LIB["*CHARACTER-NAMES*"].bound, 31) );
 i( CL_LIB["SETHASH"](30, CL_LIB["*CHARACTER-NAMES*"].bound, "Rs") );
 i( CL_LIB["SETHASH"]("RS", CL_LIB["*CHARACTER-NAMES*"].bound, 30) );
 i( CL_LIB["SETHASH"](29, CL_LIB["*CHARACTER-NAMES*"].bound, "Gs") );
 i( CL_LIB["SETHASH"]("GS", CL_LIB["*CHARACTER-NAMES*"].bound, 29) );
 i( CL_LIB["SETHASH"](28, CL_LIB["*CHARACTER-NAMES*"].bound, "Fs") );
 i( CL_LIB["SETHASH"]("FS", CL_LIB["*CHARACTER-NAMES*"].bound, 28) );
 i( CL_LIB["SETHASH"](27, CL_LIB["*CHARACTER-NAMES*"].bound, "Esc") );
 i( CL_LIB["SETHASH"]("ESC", CL_LIB["*CHARACTER-NAMES*"].bound, 27) );
 i( CL_LIB["SETHASH"](26, CL_LIB["*CHARACTER-NAMES*"].bound, "Sub") );
 i( CL_LIB["SETHASH"]("SUB", CL_LIB["*CHARACTER-NAMES*"].bound, 26) );
 i( CL_LIB["SETHASH"](25, CL_LIB["*CHARACTER-NAMES*"].bound, "Em") );
 i( CL_LIB["SETHASH"]("EM", CL_LIB["*CHARACTER-NAMES*"].bound, 25) );
 i( CL_LIB["SETHASH"](24, CL_LIB["*CHARACTER-NAMES*"].bound, "Can") );
 i( CL_LIB["SETHASH"]("CAN", CL_LIB["*CHARACTER-NAMES*"].bound, 24) );
 i( CL_LIB["SETHASH"](23, CL_LIB["*CHARACTER-NAMES*"].bound, "Etb") );
 i( CL_LIB["SETHASH"]("ETB", CL_LIB["*CHARACTER-NAMES*"].bound, 23) );
 i( CL_LIB["SETHASH"](22, CL_LIB["*CHARACTER-NAMES*"].bound, "Syn") );
 i( CL_LIB["SETHASH"]("SYN", CL_LIB["*CHARACTER-NAMES*"].bound, 22) );
 i( CL_LIB["SETHASH"](21, CL_LIB["*CHARACTER-NAMES*"].bound, "Nak") );
 i( CL_LIB["SETHASH"]("NAK", CL_LIB["*CHARACTER-NAMES*"].bound, 21) );
 i( CL_LIB["SETHASH"](20, CL_LIB["*CHARACTER-NAMES*"].bound, "Dc4") );
 i( CL_LIB["SETHASH"]("DC4", CL_LIB["*CHARACTER-NAMES*"].bound, 20) );
 i( CL_LIB["SETHASH"](19, CL_LIB["*CHARACTER-NAMES*"].bound, "Dc3") );
 i( CL_LIB["SETHASH"]("DC3", CL_LIB["*CHARACTER-NAMES*"].bound, 19) );
 i( CL_LIB["SETHASH"](18, CL_LIB["*CHARACTER-NAMES*"].bound, "Dc2") );
 i( CL_LIB["SETHASH"]("DC2", CL_LIB["*CHARACTER-NAMES*"].bound, 18) );
 i( CL_LIB["SETHASH"](17, CL_LIB["*CHARACTER-NAMES*"].bound, "Dc1") );
 i( CL_LIB["SETHASH"]("DC1", CL_LIB["*CHARACTER-NAMES*"].bound, 17) );
 i( CL_LIB["SETHASH"](16, CL_LIB["*CHARACTER-NAMES*"].bound, "Dle") );
 i( CL_LIB["SETHASH"]("DLE", CL_LIB["*CHARACTER-NAMES*"].bound, 16) );
 i( CL_LIB["SETHASH"](15, CL_LIB["*CHARACTER-NAMES*"].bound, "Si") );
 i( CL_LIB["SETHASH"]("SI", CL_LIB["*CHARACTER-NAMES*"].bound, 15) );
 i( CL_LIB["SETHASH"](14, CL_LIB["*CHARACTER-NAMES*"].bound, "So") );
 i( CL_LIB["SETHASH"]("SO", CL_LIB["*CHARACTER-NAMES*"].bound, 14) );
 i( CL_LIB["SETHASH"](13, CL_LIB["*CHARACTER-NAMES*"].bound, "Return") );
 i( CL_LIB["SETHASH"]("RETURN", CL_LIB["*CHARACTER-NAMES*"].bound, 13) );
 i( CL_LIB["SETHASH"](12, CL_LIB["*CHARACTER-NAMES*"].bound, "Page") );
 i( CL_LIB["SETHASH"]("PAGE", CL_LIB["*CHARACTER-NAMES*"].bound, 12) );
 i( CL_LIB["SETHASH"](11, CL_LIB["*CHARACTER-NAMES*"].bound, "Vt") );
 i( CL_LIB["SETHASH"]("VT", CL_LIB["*CHARACTER-NAMES*"].bound, 11) );
 i( CL_LIB["SETHASH"](10, CL_LIB["*CHARACTER-NAMES*"].bound, "Newline") );
 i( CL_LIB["SETHASH"]("NEWLINE", CL_LIB["*CHARACTER-NAMES*"].bound, 10) );
 i( CL_LIB["SETHASH"](9, CL_LIB["*CHARACTER-NAMES*"].bound, "Tab") );
 i( CL_LIB["SETHASH"]("TAB", CL_LIB["*CHARACTER-NAMES*"].bound, 9) );
 i( CL_LIB["SETHASH"](8, CL_LIB["*CHARACTER-NAMES*"].bound, "Backspace") );
 i( CL_LIB["SETHASH"]("BACKSPACE", CL_LIB["*CHARACTER-NAMES*"].bound, 8) );
 i( CL_LIB["SETHASH"](7, CL_LIB["*CHARACTER-NAMES*"].bound, "Bel") );
 i( CL_LIB["SETHASH"]("BEL", CL_LIB["*CHARACTER-NAMES*"].bound, 7) );
 i( CL_LIB["SETHASH"](6, CL_LIB["*CHARACTER-NAMES*"].bound, "Ack") );
 i( CL_LIB["SETHASH"]("ACK", CL_LIB["*CHARACTER-NAMES*"].bound, 6) );
 i( CL_LIB["SETHASH"](5, CL_LIB["*CHARACTER-NAMES*"].bound, "Enq") );
 i( CL_LIB["SETHASH"]("ENQ", CL_LIB["*CHARACTER-NAMES*"].bound, 5) );
 i( CL_LIB["SETHASH"](4, CL_LIB["*CHARACTER-NAMES*"].bound, "Eot") );
 i( CL_LIB["SETHASH"]("EOT", CL_LIB["*CHARACTER-NAMES*"].bound, 4) );
 i( CL_LIB["SETHASH"](3, CL_LIB["*CHARACTER-NAMES*"].bound, "Etx") );
 i( CL_LIB["SETHASH"]("ETX", CL_LIB["*CHARACTER-NAMES*"].bound, 3) );
 i( CL_LIB["SETHASH"](2, CL_LIB["*CHARACTER-NAMES*"].bound, "Stx") );
 i( CL_LIB["SETHASH"]("STX", CL_LIB["*CHARACTER-NAMES*"].bound, 2) );
 i( CL_LIB["SETHASH"](1, CL_LIB["*CHARACTER-NAMES*"].bound, "Soh") );
 i( CL_LIB["SETHASH"]("SOH", CL_LIB["*CHARACTER-NAMES*"].bound, 1) );
 i( CL_LIB["SETHASH"](0, CL_LIB["*CHARACTER-NAMES*"].bound, "Nul") );
 single_value();  tmp = CL_LIB["SETHASH"]("NUL", CL_LIB["*CHARACTER-NAMES*"].bound, 0); tmp = CL_LIB["SETHASH"]("LINEFEED", CL_LIB["*CHARACTER-NAMES*"].bound, 10); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR-NAME"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],n},function (l1,  ...)   single_value();  return CL["GETHASH"](CL["CHAR-CODE"](l1), CL_LIB["*CHARACTER-NAMES*"].bound, false) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["NAME-CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NAME"],n},function (l1,  ...)   single_value();  local l2 = CL["GETHASH"](CL["STRING-UPCASE"](l1, k()), CL_LIB["*CHARACTER-NAMES*"].bound, false); single_value();  local l3 = n if n ~= l2 then  l3 = CL["CODE-CHAR"](l2) else  l3 = n.bound end return l3 end, 1, 0, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["BLOCK-TO-TAGNAME"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],n},function (l1,  ...)   i( "Generate a catch/throw able element from a symbol." );
 single_value();  return CL["INTERN"](CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL["PACKAGE-NAME"](CL["SYMBOL-PACKAGE"](l1)), "*", CL["SYMBOL-NAME"](l1), }), "%BR") end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["GO-TO-TAGNAME"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],n},function (l1,  ...)   i( "Generate a catch/throw able element from a symbol." );
 single_value();  return CL["INTERN"](CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"#TAG|", CL["PACKAGE-NAME"](CL["SYMBOL-PACKAGE"](l1)), "*", CL["SYMBOL-NAME"](l1), }), "%BR") end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-EMPTY"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL["ACONS"](LCL["KEYWORD"]["CHECKMV"], CL["T"].bound, CL["ACONS"](LCL["KEYWORD"]["SMLOCALS"], n.bound, CL["ACONS"](LCL["KEYWORD"]["MLOCALS"], n.bound, CL["ACONS"](LCL["KEYWORD"]["FLOCALS"], n.bound, CL["ACONS"](LCL["KEYWORD"]["LOCALS"], n.bound, CL["ACONS"](LCL["KEYWORD"]["COUNT"], 0, n.bound)))))) end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-COPY"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],n},function (l1,  ...)   single_value();  return CL["ACONS"](LCL["KEYWORD"]["CHECKMV"], (CL_LIB["%ASSOC"](LCL["KEYWORD"]["CHECKMV"], l1))[2], CL["ACONS"](LCL["KEYWORD"]["SMLOCALS"], (CL_LIB["%ASSOC"](LCL["KEYWORD"]["SMLOCALS"], l1))[2], CL["ACONS"](LCL["KEYWORD"]["MLOCALS"], (CL_LIB["%ASSOC"](LCL["KEYWORD"]["MLOCALS"], l1))[2], CL["ACONS"](LCL["KEYWORD"]["FLOCALS"], (CL_LIB["%ASSOC"](LCL["KEYWORD"]["FLOCALS"], l1))[2], CL["ACONS"](LCL["KEYWORD"]["LOCALS"], (CL_LIB["%ASSOC"](LCL["KEYWORD"]["LOCALS"], l1))[2], CL["CONS"](CL_LIB["%ASSOC"](LCL["KEYWORD"]["COUNT"], l1), n.bound)))))) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-SMLOCALS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],n},function (l1,  ...)   single_value();  return CL_LIB["%ASSOC"](LCL["KEYWORD"]["SMLOCALS"], l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-SMLOCAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],{CL_LIB["LOOKUP"],n}},function (l1, l2,  ...)   single_value();  return CL_LIB["%ASSOC"](l2, (CL_LIB["ENV-SMLOCALS"](l1))[2]) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-PUSH-SMLOCAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],{CL_LIB["TARGET"],{CL_LIB["LOCAL"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL_LIB["ENV-SMLOCALS"](l1); single_value();  return CL["RPLACD"](l4, CL["ACONS"](l2, l3, (l4)[2])) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-MLOCALS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],n},function (l1,  ...)   single_value();  return CL_LIB["%ASSOC"](LCL["KEYWORD"]["MLOCALS"], l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-MLOCAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],{CL_LIB["LOOKUP"],n}},function (l1, l2,  ...)   single_value();  return CL_LIB["%ASSOC"](l2, (CL_LIB["ENV-MLOCALS"](l1))[2]) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-PUSH-MLOCAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],{CL_LIB["TARGET"],{CL_LIB["LOCAL"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL_LIB["ENV-MLOCALS"](l1); single_value();  return CL["RPLACD"](l4, CL["ACONS"](l2, l3, (l4)[2])) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-FLOCALS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],n},function (l1,  ...)   single_value();  return CL_LIB["%ASSOC"](LCL["KEYWORD"]["FLOCALS"], l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-FLOCAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],{CL_LIB["LOOKUP"],n}},function (l1, l2,  ...)   single_value();  return CL_LIB["%ASSOC"](l2, (CL_LIB["ENV-FLOCALS"](l1))[2]) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-PUSH-FLOCAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],{CL_LIB["TARGET"],{CL_LIB["LOCAL"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL_LIB["ENV-FLOCALS"](l1); single_value();  return CL["RPLACD"](l4, CL["ACONS"](l2, l3, (l4)[2])) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-LOCALS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],n},function (l1,  ...)   single_value();  return CL_LIB["%ASSOC"](LCL["KEYWORD"]["LOCALS"], l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-LOCAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],{CL_LIB["LOOKUP"],n}},function (l1, l2,  ...)   single_value();  return CL_LIB["%ASSOC"](l2, (CL_LIB["ENV-LOCALS"](l1))[2]) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-PUSH-LOCAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],{CL_LIB["TARGET"],{CL_LIB["LOCAL"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL_LIB["ENV-LOCALS"](l1); single_value();  return CL["RPLACD"](l4, CL["ACONS"](l2, l3, (l4)[2])) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-COUNT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],n},function (l1,  ...)   single_value();  return CL_LIB["%ASSOC"](LCL["KEYWORD"]["COUNT"], l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-INC-COUNT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],n},function (l1,  ...)   single_value();  local l2 = CL_LIB["ENV-COUNT"](l1); i( CL["RPLACD"](l2, (1 + (l2)[2])) );
 single_value();  return (l2)[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-CHECKMV-P"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],n},function (l1,  ...)   single_value();  return (CL_LIB["%ASSOC"](LCL["KEYWORD"]["CHECKMV"], l1))[2] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ENV-CHECKMV"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],{CL_LIB["VAL"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACD"](CL_LIB["%ASSOC"](LCL["KEYWORD"]["CHECKMV"], l1), l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["PUSH-CTX"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["CTX"],{CL_LIB["VALUE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACA"](l1, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {(l1)[1], l2, })) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["COMPILE-LUA-SP-ENTRY"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENTRY"],{CL_LIB["ENV"],{CL_LIB["CTX"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = n if n ~= CL["STRINGP"](l1) then  l4 = l1 else  l4 = CL_LIB["COMPILE-TO-LUA"](l1, l2, l3, false) end return l4 end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["COMPILE-LUA-SP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["LST"],{CL_LIB["ENV"],{CL_LIB["CTX"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = n if n ~= l1 then  l4 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL_LIB["COMPILE-LUA-SP-ENTRY"]((l1)[1], l2, l3), CL_LIB["COMPILE-LUA-SP"]((l1)[2], l2, l3), }) else  l4 = "" end return l4 end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["CHAR-TO-LUA"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],n},function (l1,  ...)   i( "Convert a character to lua code generating the char" );
 single_value();  return CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"LCL['CL-LIB']['MAKE-CHAR'](", CL_LIB["STRING-TO-LUA"](CL["STRING"](l1)), ")", }) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["SYMBOL-TO-LUA"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SYM"],n},function (l1,  ...)   i( "Get the lua expression that will index a symbol" );
 single_value();  local l2 = CL["PACKAGE-NAME"](CL["SYMBOL-PACKAGE"](l1)); single_value();  local l3 = n if n ~= CL["NOT"](l1) then  single_value();  l3 = "n" else  local l4 = n if n ~= CL["STRING="](l2, l("CL-LIB")) then  single_value();  l4 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"CL_LIB[\"", CL["SYMBOL-NAME"](l1), "\"]", }) else  local l5 = n if n ~= CL["STRING="](l2, l("COMMON-LISP")) then  single_value();  l5 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"CL[\"", CL["SYMBOL-NAME"](l1), "\"]", }) else  local l6 = n if n ~= CL["T"].bound then  single_value();  l6 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"LCL[\"", CL["PACKAGE-NAME"](CL["SYMBOL-PACKAGE"](l1)), "\"][\"", CL["SYMBOL-NAME"](l1), "\"]", }) else  l6 = n.bound end l5 = l6 end l4 = l5 end l3 = l4 end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["SYMBOL-VALUE-TO-LUA"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SYM"],{CL_LIB["ENV"],{CL["&OPTIONAL"],{CL_LIB["CTX"],n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = n.bound end  single_value();  local l4 = CL_LIB["ENV-LOCAL"](l2, l1); local l5 = CL_LIB["ENV-SMLOCAL"](l2, l1); single_value();  local l7 = n if n ~= l3 then  l7 = l5 else  l7 = n.bound end local l6 = n if n ~= l7 then  single_value();  l6 = CL_LIB["COMPILE-TO-LUA"]((l5)[2], l2, l3, false) else  local l8 = n if n ~= l4 then  single_value();  l8 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {(l4)[2], }) else  local l10 = n if n ~= l3 then  l10 = CL_LIB["SYMBOL-MACRO-BOUNDP"](l1) else  l10 = n.bound end local l9 = n if n ~= l10 then  single_value();  l9 = CL_LIB["COMPILE-TO-LUA"](CL_LIB["%SYMBOL-MACRO"](l1), l2, l3, false) else  local l11 = n if n ~= CL["KEYWORDP"](l1) then  single_value();  l11 = CL_LIB["SYMBOL-TO-LUA"](l1) else  local l12 = n if n ~= CL["T"].bound then  single_value();  l12 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL_LIB["SYMBOL-TO-LUA"](l1), ".bound", }) else  l12 = n.bound end l11 = l12 end l9 = l11 end l8 = l9 end l6 = l8 end return l6 end, 2, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["QUOTE-TO-LUA"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJ"],{CL["&OPTIONAL"],{CL_LIB["ENV"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  i( "Transform an existing read object to a lua string.\nNormally we would only link the list to a variable and pass it along and pass everything\nelse in the same way as above. But now, we sadly have to generate a new list literal from scratch.\nWe don't have much choice unless we compile in the same lua env as we are running, so this is used\nto generate the closest that we can." );
 single_value();  local l3 = n if n ~= CL["CONSP"](l1) then  l3 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"{", CL_LIB["QUOTE-TO-LUA"]((l1)[1], l2), ",", CL_LIB["QUOTE-TO-LUA"]((l1)[2], l2), "}", }) else  l3 = CL_LIB["ATOM-TO-LUA"](l1) end return l3 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["STRING-TO-LUA"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STR"],n},function (l1,  ...)   i( "String to a lua literal." );
 single_value();  local l2 = "\""; local l3 = 0; while true do  local l4 = CL["CHAR"](l1, l3); single_value();  local l5 = n if n ~= CL["NULL"](l4) then  single_value(); do break end; l5 = n.bound else  local l6 = n if n ~= CL["EQUAL"](LCL['CL-LIB']['MAKE-CHAR']("\""), l4) then  single_value();  l2 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l2, "\\\"", }) l6 = l2 else  local l7 = n if n ~= CL["EQUAL"](LCL['CL-LIB']['MAKE-CHAR']("\\"), l4) then  single_value();  l2 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l2, "\\\\", }) l7 = l2 else  local l8 = n if n ~= CL["EQUAL"](10, CL["CHAR-CODE"](l4)) then  single_value();  l2 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l2, "\\n", }) l8 = l2 else  local l9 = n if n ~= CL["EQUAL"](13, CL["CHAR-CODE"](l4)) then  single_value();  l2 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l2, "\\r", }) l9 = l2 else  local l10 = n if n ~= CL["T"].bound then  single_value();  l2 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l2, CL_LIB["CHAR-STRING"](l4), }) l10 = l2 else  l10 = n.bound end l9 = l10 end l8 = l9 end l7 = l8 end l6 = l7 end l5 = l6 end i( l5 );
 single_value();  l3 = (1 + l3) local tmpres = l3 end i( n );
 single_value();  return CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l2, "\"", }) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ATOM-TO-LUA"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJ"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["NUMBERP"](l1) then  single_value();  l2 = CL_LIB["NUMBER-TO-LUA"](l1) else  local l3 = n if n ~= CL["STRINGP"](l1) then  single_value();  l3 = CL_LIB["STRING-TO-LUA"](l1) else  local l4 = n if n ~= CL["SYMBOLP"](l1) then  single_value();  l4 = CL_LIB["SYMBOL-TO-LUA"](l1) else  local l5 = n if n ~= CL_LIB["CHARP"](l1) then  single_value();  l5 = CL_LIB["CHAR-TO-LUA"](l1) else  local l6 = n if n ~= CL["T"].bound then  single_value();  l6 = CL_LIB["%QUOTE-TO-LUA"](l1, n.bound) else  l6 = n.bound end l5 = l6 end l4 = l5 end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["LUA-UNIQUE-LOCAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ENV"],n},function (l1,  ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"l", CL_LIB["NUMBER-TO-LUA"](CL_LIB["ENV-INC-COUNT"](l1)), }) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["LUA-ERROR"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{{CL_LIB["REASON"],{"",n}},n}},function (l1,  ...)  if not l1 then  l1 = "" end  i( "" );
 single_value();  return CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"(error(", CL_LIB["STRING-TO-LUA"](l1), "))", }) end, 0, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["LAMBDA-GET-POS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ARGLIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["ATOM"](l1) then  single_value();  l2 = n.bound else  local l3 = n if n ~= CL["EQ"]((l1)[1], CL["&OPTIONAL"]) then  single_value();  l3 = n.bound else  local l4 = n if n ~= CL["EQ"]((l1)[1], CL["&KEY"]) then  single_value();  l4 = n.bound else  local l5 = n if n ~= CL["EQ"]((l1)[1], CL["&REST"]) then  single_value();  l5 = n.bound else  local l6 = n if n ~= CL["EQ"]((l1)[1], CL["&BODY"]) then  single_value();  l6 = n.bound else  local l7 = n if n ~= CL["EQ"]((l1)[1], CL["&AUX"]) then  single_value();  l7 = n.bound else  local l8 = n if n ~= CL["T"].bound then  single_value();  l8 = CL["CONS"]((l1)[1], CL_LIB["LAMBDA-GET-POS"]((l1)[2])) else  l8 = n.bound end l7 = l8 end l6 = l7 end l5 = l6 end l4 = l5 end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["LAMBDA-GRAB-OPTIONAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ARGLIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["ATOM"](l1) then  single_value();  l2 = n.bound else  local l3 = n if n ~= CL["EQ"]((l1)[1], CL["&KEY"]) then  single_value();  l3 = n.bound else  local l4 = n if n ~= CL["EQ"]((l1)[1], CL["&REST"]) then  single_value();  l4 = n.bound else  local l5 = n if n ~= CL["EQ"]((l1)[1], CL["&BODY"]) then  single_value();  l5 = n.bound else  local l6 = n if n ~= CL["EQ"]((l1)[1], CL["&AUX"]) then  single_value();  l6 = n.bound else  local l7 = n if n ~= CL["T"].bound then  single_value();  l7 = CL["CONS"]((l1)[1], CL_LIB["LAMBDA-GRAB-OPTIONAL"]((l1)[2])) else  l7 = n.bound end l6 = l7 end l5 = l6 end l4 = l5 end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["LAMBDA-GET-OPTIONAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ARGLIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["ATOM"](l1) then  single_value();  l2 = n.bound else  local l3 = n if n ~= CL["EQ"]((l1)[1], CL["&OPTIONAL"]) then  single_value();  l3 = CL_LIB["LAMBDA-GRAB-OPTIONAL"]((l1)[2]) else  local l4 = n if n ~= CL["T"].bound then  single_value();  l4 = CL_LIB["LAMBDA-GET-OPTIONAL"]((l1)[2]) else  l4 = n.bound end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["LAMBDA-GET-REST"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ARGLIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["ATOM"](l1) then  single_value();  l2 = n.bound else  local l3 = n if n ~= CL["EQ"]((l1)[1], CL["&REST"]) then  single_value();  l3 = CL["CADR"](l1) else  local l4 = n if n ~= CL["EQ"]((l1)[1], CL["&BODY"]) then  single_value();  l4 = CL["CADR"](l1) else  local l5 = n if n ~= CL["T"].bound then  single_value();  l5 = CL_LIB["LAMBDA-GET-REST"]((l1)[2]) else  l5 = n.bound end l4 = l5 end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["LAMBDA-GRAB-KEY"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ARGLIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["NULL"](l1) then  single_value();  l2 = n.bound else  local l3 = n if n ~= CL["EQ"]((l1)[1], CL["&ALLOW-OTHER-KEYS"]) then  single_value();  l3 = n.bound else  local l4 = n if n ~= CL["EQ"]((l1)[1], CL["&OPTIONAL"]) then  single_value();  l4 = n.bound else  local l5 = n if n ~= CL["EQ"]((l1)[1], CL["&REST"]) then  single_value();  l5 = n.bound else  local l6 = n if n ~= CL["EQ"]((l1)[1], CL["&BODY"]) then  single_value();  l6 = n.bound else  local l7 = n if n ~= CL["EQ"]((l1)[1], CL["&AUX"]) then  single_value();  l7 = n.bound else  local l8 = n if n ~= CL["T"].bound then  single_value();  l8 = CL["CONS"]((l1)[1], CL_LIB["LAMBDA-GRAB-KEY"]((l1)[2])) else  l8 = n.bound end l7 = l8 end l6 = l7 end l5 = l6 end l4 = l5 end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["LAMBDA-GET-KEY"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ARGLIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["ATOM"](l1) then  single_value();  l2 = n.bound else  local l3 = n if n ~= CL["EQ"]((l1)[1], CL["&KEY"]) then  single_value();  l3 = CL_LIB["LAMBDA-GRAB-KEY"]((l1)[2]) else  local l4 = n if n ~= CL["T"].bound then  single_value();  l4 = CL_LIB["LAMBDA-GET-KEY"]((l1)[2]) else  l4 = n.bound end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["LAMBDA-GRAB-AUX"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ARGLIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["ATOM"](l1) then  single_value();  l2 = n.bound else  local l3 = n if n ~= CL["EQ"]((l1)[1], CL["&OPTIONAL"]) then  single_value();  l3 = n.bound else  local l4 = n if n ~= CL["EQ"]((l1)[1], CL["&REST"]) then  single_value();  l4 = n.bound else  local l5 = n if n ~= CL["EQ"]((l1)[1], CL["&BODY"]) then  single_value();  l5 = n.bound else  local l6 = n if n ~= CL["EQ"]((l1)[1], CL["&KEY"]) then  single_value();  l6 = n.bound else  local l7 = n if n ~= CL["T"].bound then  single_value();  l7 = CL["CONS"]((l1)[1], CL_LIB["LAMBDA-GRAB-AUX"]((l1)[2])) else  l7 = n.bound end l6 = l7 end l5 = l6 end l4 = l5 end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["LAMBDA-GET-AUX"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ARGLIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["ATOM"](l1) then  single_value();  l2 = n.bound else  local l3 = n if n ~= CL["EQ"]((l1)[1], CL["&AUX"]) then  single_value();  l3 = CL_LIB["LAMBDA-GRAB-KEY"]((l1)[2]) else  local l4 = n if n ~= CL["T"].bound then  single_value();  l4 = CL_LIB["LAMBDA-GET-AUX"]((l1)[2]) else  l4 = n.bound end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["LAMBDA-TO-LUA"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FORM"],{CL_LIB["ARGLIST"],{CL_LIB["BODY"],{CL_LIB["ENV"],n}}}},function (l1, l2, l3, l4,  ...)   single_value();  local l6 = n if n ~= CL["EQ"](l1, CL_LIB["NLAMBDA"]) then  local l8 = n if n ~= CL["CONSP"](l2) then  l8 = n.bound else  l8 = l2 end local l7 = l8; single_value();  local l9 = (l3)[1]; single_value();  l2 = l9 i( l2 );
 single_value();  single_value();  single_value();  local l10 = (l3)[2]; single_value();  l3 = l10 i( l3 );
 single_value();  l6 = l7 else  l6 = n.bound end local l5 = l6; single_value();  local l11 = CL_LIB["LAMBDA-GET-POS"](l2); single_value();  local l12 = CL_LIB["LAMBDA-GET-OPTIONAL"](l2); single_value();  local l13 = CL_LIB["LAMBDA-GET-REST"](l2); single_value();  local l14 = CL_LIB["LAMBDA-GET-KEY"](l2); single_value();  local l15 = CL_LIB["LAMBDA-GET-AUX"](l2); single_value();  local l16 = ""; single_value();  local l17 = ""; single_value();  local l18 = CL_LIB["ENV-COPY"](l4); single_value();  local l19 = n.bound; single_value();  local l20 = CL_LIB["NUMBER-TO-LUA"](CL["LENGTH"](l11)); single_value();  local l21 = CL_LIB["NUMBER-TO-LUA"](CL["LENGTH"](l12)); single_value();  local l23 = n if n ~= l13 then  l23 = "true" else  l23 = "false" end local l22 = l23; single_value();  local l24 = 2; single_value();  local l26 = n if n ~= l14 then  l26 = "{0 " else  l26 = "false" end local l25 = l26; single_value();  local l27 = n if n ~= l5 then  single_value();  l27 = CL_LIB["ENV-PUSH-LOCAL"](l18, CL_LIB["BLOCK-TO-TAGNAME"](l5), "CL.T") else  l27 = n.bound end i( l27 );
 local l28 = l11; single_value();  local l29 = (l28)[1]; single_value();  single_value();  local l30 = CL["GENSYM"](false); single_value();  local l31 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l32 = n if n ~= CL["NOT"](l28) then  single_value(); do break end; l32 = n.bound else  l32 = n.bound end i( l32 );
 local l33 = l29; local l34 = CL_LIB["LUA-UNIQUE-LOCAL"](l4); local l35 = n if n ~= CL["BOUNDP"](l33) then  single_value();  single_value();  local l36 = CL["CONS"](CL["LIST"](l(l33,CL_LIB["LUA-UNIQUE-LOCAL"](l4))), l19); single_value();  l19 = l36 i( l19 );
 single_value();  l17 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l17, " ", CL_LIB["SYMBOL-VALUE-TO-LUA"](l33, l4, false), " = ", l34, }) l35 = l17 else  l35 = CL_LIB["ENV-PUSH-LOCAL"](l18, l33, l34) end i( l35 );
 single_value();  l16 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l16, l34, ", ", }) i( l16 );
 single_value();  single_value();  local l37 = (l28)[2]; single_value();  l28 = l37 i( l28 );
 single_value();  single_value();  single_value();  local l38 = (l28)[1]; single_value();  l29 = l38 local tmpres = l29 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l31.error ~= n and (l31.error ~= KEYWORD.TAG or l31.tag ~= l30) then if l31.error == KEYWORD.TAG then  error(l31) else error(l31[1]) end end i( CL["VALUES-LIST"](list_r(l31)) );
 local l39 = l12; single_value();  local l40 = (l39)[1]; single_value();  single_value();  local l41 = CL["GENSYM"](false); single_value();  local l42 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l43 = n if n ~= CL["NOT"](l39) then  single_value(); do break end; l43 = n.bound else  l43 = n.bound end i( l43 );
 local l45 = n if n ~= CL["CONSP"](l40) then  l45 = (l40)[1] else  l45 = l40 end local l44 = l45; local l47 = n if n ~= CL["CONSP"](l40) then  l47 = CL["CADR"](l40) else  l47 = n.bound end local l46 = l47; local l49 = n if n ~= CL["CONSP"](l40) then  l49 = CL["CADDR"](l40) else  l49 = n.bound end local l48 = l49; local l50 = CL_LIB["LUA-UNIQUE-LOCAL"](l4); local l51 = n if n ~= CL["BOUNDP"](l44) then  single_value();  single_value();  local l52 = CL["CONS"](CL["LIST"](l(l44,CL_LIB["LUA-UNIQUE-LOCAL"](l4))), l19); single_value();  l19 = l52 l51 = l19 else  l51 = CL_LIB["ENV-PUSH-LOCAL"](l18, l44, l50) end i( l51 );
 l16 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l16, l50, ", ", }) i( l16 );
 local l53 = n if n ~= l48 then  local l54 = CL_LIB["LUA-UNIQUE-LOCAL"](l4); i( CL_LIB["ENV-PUSH-LOCAL"](l18, l48, l54) );
 single_value();  l17 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l17, " local ", l54, " = ", l50, " and CL.T or n", }) l53 = l17 else  l53 = n.bound end i( l53 );
 l17 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l17, " if not ", l50, " then ", CL_LIB["COMPILE-TO-LUA"](l46, l18, n.bound, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l50, " = ", })), " end", }) i( l17 );
 single_value();  local l55 = n if n ~= CL["BOUNDP"](l44) then  single_value();  l17 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l17, " ", CL_LIB["SYMBOL-VALUE-TO-LUA"](l44, l4, false), " = ", l50, " ; ", }) l55 = l17 else  l55 = n.bound end i( l55 );
 single_value();  single_value();  local l56 = (l39)[2]; single_value();  l39 = l56 i( l39 );
 single_value();  single_value();  single_value();  local l57 = (l39)[1]; single_value();  l40 = l57 local tmpres = l40 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l42.error ~= n and (l42.error ~= KEYWORD.TAG or l42.tag ~= l41) then if l42.error == KEYWORD.TAG then  error(l42) else error(l42[1]) end end i( CL["VALUES-LIST"](list_r(l42)) );
 local l58 = n if n ~= l13 then  local l59 = CL_LIB["LUA-UNIQUE-LOCAL"](l4); local l60 = n if n ~= CL["BOUNDP"](l13) then  single_value();  single_value();  local l61 = CL["CONS"](CL["LIST"](l(l13,CL_LIB["LUA-UNIQUE-LOCAL"](l4))), l19); single_value();  l19 = l61 i( l19 );
 single_value();  l17 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l17, " ", CL_LIB["SYMBOL-VALUE-TO-LUA"](l13, l4, false), " = ", l59, " ; ", }) l60 = l17 else  l60 = CL_LIB["ENV-PUSH-LOCAL"](l18, l13, l59) end i( l60 );
 single_value();  l16 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l16, l59, ", ", }) l58 = l16 else  l58 = n.bound end i( l58 );
 local l62 = n if n ~= l14 then  l16 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l16, "keys, ", }) l62 = l16 else  l62 = n.bound end i( l62 );
 local l63 = l14; single_value();  local l64 = (l63)[1]; single_value();  single_value();  local l65 = CL["GENSYM"](false); single_value();  local l66 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l67 = n if n ~= CL["NOT"](l63) then  single_value(); do break end; l67 = n.bound else  l67 = n.bound end i( l67 );
 local l69 = n if n ~= CL["CONSP"](l64) then  l69 = (l64)[1] else  l69 = l64 end local l68 = l69; single_value();  local l71 = n if n ~= CL["CONSP"](l68) then  l71 = (l68)[1] else  l71 = CL["INTERN"](CL["SYMBOL-NAME"](l68), LCL["KEYWORD"]["KEYWORD"]) end local l70 = l71; single_value();  local l73 = n if n ~= CL["CONSP"](l68) then  l73 = CL["CADR"](l68) else  l73 = l68 end local l72 = l73; single_value();  local l75 = n if n ~= CL["CONSP"](l64) then  l75 = CL["CADR"](l64) else  l75 = n.bound end local l74 = l75; single_value();  local l77 = n if n ~= CL["CONSP"](l64) then  l77 = CL["CADDR"](l64) else  l77 = n.bound end local l76 = l77; single_value();  local l78 = l24; single_value();  local l79 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"keys[", CL_LIB["SYMBOL-TO-LUA"](l72), "]", }); single_value();  l24 = (1 + l24) i( l24 );
 l25 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l25, ", [", CL_LIB["SYMBOL-TO-LUA"](l70), "] = ", CL_LIB["SYMBOL-TO-LUA"](l72), }) i( l25 );
 local l80 = n if n ~= CL["BOUNDP"](l72) then  single_value();  single_value();  local l81 = CL["CONS"](CL["LIST"](l(l72,CL_LIB["LUA-UNIQUE-LOCAL"](l4))), l19); single_value();  l19 = l81 l80 = l19 else  l80 = CL_LIB["ENV-PUSH-LOCAL"](l18, l72, l79) end i( l80 );
 local l82 = n if n ~= l76 then  local l83 = CL_LIB["LUA-UNIQUE-LOCAL"](l4); i( CL_LIB["ENV-PUSH-LOCAL"](l18, l76, l83) );
 single_value();  l17 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l17, " local ", l83, " = ", l79, " and CL.T or n", }) l82 = l17 else  l82 = n.bound end i( l82 );
 l17 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l17, " if not ", l79, " then ", CL_LIB["COMPILE-TO-LUA"](l74, l18, n.bound, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l79, " = ", })), " end", }) i( l17 );
 single_value();  local l84 = n if n ~= CL["BOUNDP"](l72) then  single_value();  l17 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l17, " ", CL_LIB["SYMBOL-VALUE-TO-LUA"](l72, l4, false), " = ", l79, }) l84 = l17 else  l84 = n.bound end i( l84 );
 single_value();  single_value();  local l85 = (l63)[2]; single_value();  l63 = l85 i( l63 );
 single_value();  single_value();  single_value();  local l86 = (l63)[1]; single_value();  l64 = l86 local tmpres = l64 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l66.error ~= n and (l66.error ~= KEYWORD.TAG or l66.tag ~= l65) then if l66.error == KEYWORD.TAG then  error(l66) else error(l66[1]) end end i( CL["VALUES-LIST"](list_r(l66)) );
 local l87 = n if n ~= l14 then  l25 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l25, "}", }) l87 = l25 else  l87 = n.bound end i( l87 );
 local l88 = l15; single_value();  local l89 = (l88)[1]; single_value();  single_value();  local l90 = CL["GENSYM"](false); single_value();  local l91 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l92 = n if n ~= CL["NOT"](l88) then  single_value(); do break end; l92 = n.bound else  l92 = n.bound end i( l92 );
 local l94 = n if n ~= CL["LISTP"](l89) then  l94 = (l89)[1] else  l94 = l89 end local l93 = l94; local l96 = n if n ~= CL["LISTP"](l89) then  l96 = CL["CADR"](l89) else  l96 = n.bound end local l95 = l96; local l97 = CL_LIB["LUA-UNIQUE-LOCAL"](l4); i( CL_LIB["ENV-PUSH-LOCAL"](l18, l93, l97) );
 single_value();  l17 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l17, CL_LIB["COMPILE-TO-LUA"](l95, l18, n.bound, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l97, " = ", })), }) i( l17 );
 single_value();  single_value();  local l98 = (l88)[2]; single_value();  l88 = l98 i( l88 );
 single_value();  single_value();  single_value();  local l99 = (l88)[1]; single_value();  l89 = l99 local tmpres = l89 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l91.error ~= n and (l91.error ~= KEYWORD.TAG or l91.tag ~= l90) then if l91.error == KEYWORD.TAG then  error(l91) else error(l91[1]) end end i( CL["VALUES-LIST"](list_r(l91)) );
 i( CL_LIB["ENV-CHECKMV"](l18, CL["T"].bound) );
 single_value();  local l100 = n if n ~= l19 then  l100 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"CL_LIB[\"ALLOC-FUNCTION\"](", CL_LIB["QUOTE-TO-LUA"](l2, l4), ",function (", l16, " ...) ", CL["APPLY"](CL_LIB["CONCAT-STRING"].fbound, CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["S"],n},function (l101,  ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {" local ", CL["SECOND"](l101), " = ", CL_LIB["SYMBOL-VALUE-TO-LUA"](CL["FIRST"](l101), l4, false), " ; ", }) end, 1, 0, false, false), l(l19)), l()), "local status, ret = pcall(function () ", l17, " ", CL_LIB["COMPILE-TO-LUA"](CL["CONS"](CL["LET"], CL["CONS"](n.bound, l3)), l18, false, false), " end)", CL["APPLY"](CL_LIB["CONCAT-STRING"].fbound, CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["S"],n},function (l102,  ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL_LIB["SYMBOL-VALUE-TO-LUA"](CL["FIRST"](l102), l4, false), " = ", CL["SECOND"](l102), "; ", }) end, 1, 0, false, false), l(l19)), l()), "if status then return(ret) else error(ret) end end, ", l20, ", ", l21, ", ", l22, ", ", l25, ")", }) else  l100 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"CL_LIB[\"ALLOC-FUNCTION\"](", CL_LIB["QUOTE-TO-LUA"](l2, l4), ",function (", l16, " ...) ", l17, " ", CL_LIB["COMPILE-TO-LUA"](CL["CONS"](CL["LET"], CL["CONS"](n.bound, l3)), l18, false, false), " end, ", l20, ", ", l21, ", ", l22, ", ", l25, ")", }) end return l100 end, 4, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FUNCTION-TO-LUA"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJ"],{CL_LIB["ENV"],n}},function (l1, l2,  ...)   i( "Compile a function (symbol or lambda form) to a lua expression that accesses a callable object matching the function" );
 single_value();  local l3 = n if n ~= CL["CONSP"](l1) then  single_value();  local l4 = (l1)[1]; single_value();  local l5 = n if n ~= CL["MEMBER"](l4, {CL["LAMBDA"],{CL_LIB["NLAMBDA"],n}}, k()) then  single_value();  l5 = CL_LIB["LAMBDA-TO-LUA"]((l1)[1], CL["CADR"](l1), CL["CDDR"](l1), l2) else  local l6 = n if n ~= CL["EQL"](l4, CL["SETF"]) then  single_value();  l6 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL_LIB["SYMBOL-TO-LUA"](CL["CADR"](l1)), ".setfbound", }) else  local l7 = n if n ~= CL["T"].bound then  single_value();  l7 = CL_LIB["LUA-ERROR"](CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"Invalid lambda function ", CL["PRINC-TO-STRING"](l1), })) else  l7 = n.bound end l6 = l7 end l5 = l6 end l3 = l5 else  local l8 = n if n ~= CL["SYMBOLP"](l1) then  single_value();  local l9 = CL_LIB["ENV-FLOCAL"](l2, l1); single_value();  local l10 = n if n ~= l9 then  l10 = (l9)[2] else  l10 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL_LIB["SYMBOL-TO-LUA"](l1), ".fbound", }) end l8 = l10 else  local l11 = n if n ~= CL["T"].bound then  single_value();  l11 = CL_LIB["LUA-ERROR"]("Invalid function") else  l11 = n.bound end l8 = l11 end l3 = l8 end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["SHORT-CALL-TO-LUA"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["AST"],{CL_LIB["ENV"],{CL_LIB["CTX"],n}}},function (l1, l2, l3,  ...)   i( "Try to generate a short function call by precomputing everything in CL-LIB:FUNCALL-LUA if the function already exist.\nThis should also generate a warning if it fails or if the function does not exist. This could also be a problem if a function\nis redefined with different arguments." );
 single_value();  local l5 = n if n ~= CL["SYMBOLP"]((l1)[1]) then  local l6 = n if n ~= CL["FBOUNDP"]((l1)[1]) then  l6 = CL["NOT"](CL_LIB["ENV-FLOCAL"](l2, (l1)[1])) else  l6 = n.bound end l5 = l6 else  l5 = n.bound end local l4 = n if n ~= l5 then  local l8 = "fbound"; local l9 = n.bound; single_value();  local l7 = (((l1)[1])[l8] or l9); single_value();  local l10 = l7.arglist or n; single_value();  local l11 = (l1)[2]; single_value();  local l12 = 0; single_value();  local l13 = LCL["KEYWORD"]["NO"]; single_value();  local l14 = n.bound; single_value();  local l15 = n.bound; single_value();  single_value();  local l16 = n if n ~= l10 then  while true do  local l18 = l10; single_value();  local l19 = n if n ~= l18 then  l19 = l18 else  l19 = l11 end local l17 = n if n ~= l19 then  l17 = n.bound else  single_value(); do break end; l17 = n.bound end i( l17 );
 local l20 = n if n ~= CL["EQ"]((l10)[1], CL["&OPTIONAL"]) then  single_value();  l12 = 1 l20 = l12 else  local l22 = CL["EQ"]((l10)[1], CL["&REST"]); single_value();  local l23 = n if n ~= l22 then  l23 = l22 else  l23 = CL["EQ"]((l10)[1], CL["&BODY"]) end local l21 = n if n ~= l23 then  single_value();  l12 = 2 l21 = l12 else  local l24 = n if n ~= CL["EQ"]((l10)[1], CL["&KEY"]) then  l12 = 3 i( l12 );
 single_value();  l13 = n.bound l24 = l13 else  local l25 = n if n ~= CL["EQ"]((l10)[1], CL["&AUX"]) then  single_value(); do break end; l25 = n.bound else  local l26 = n if n ~= CL["EQ"](l12, 0) then  local l27 = n if n ~= l11 then  local l28 = n if n ~= l10 then  single_value();  single_value();  local l29 = CL["CONS"](CL_LIB["COMPILE-TO-LUA"]((l11)[1], l2, l3, false), l15); single_value();  l15 = l29 l28 = l15 else  i( CL["WARN"]("Invalid call to ~S, too many argument(s).", l((l1)[1])) );
 single_value();  local l30 = n.bound; single_value(); do return l30 end; l28 = n.bound end l27 = l28 else  i( CL["WARN"]("Invalid call to ~S, missing argument(s).", l((l1)[1])) );
 single_value();  local l31 = n.bound; single_value(); do return l31 end; l27 = n.bound end i( l27 );
 single_value();  l11 = (l11)[2] l26 = l11 else  local l32 = n if n ~= CL["EQ"](l12, 1) then  local l33 = n if n ~= l11 then  single_value();  single_value();  local l34 = CL["CONS"](CL_LIB["COMPILE-TO-LUA"]((l11)[1], l2, l3, false), l15); single_value();  l15 = l34 l33 = l15 else  single_value();  single_value();  local l35 = CL["CONS"]("false", l15); single_value();  l15 = l35 l33 = l15 end i( l33 );
 single_value();  l11 = (l11)[2] l32 = l11 else  local l36 = n if n ~= CL["EQ"](l12, 2) then  l12 = 5 i( l12 );
 single_value();  local l37 = "l("; local l38 = n if n ~= l11 then  single_value();  l37 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l37, CL_LIB["COMPILE-TO-LUA"]((l11)[1], l2, l3, false), }) l38 = l37 else  l38 = n.bound end i( l38 );
 local l39 = (l11)[2]; single_value();  local l40 = (l39)[1]; single_value();  single_value();  local l41 = CL["GENSYM"](false); single_value();  local l42 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l43 = n if n ~= CL["NOT"](l39) then  single_value(); do break end; l43 = n.bound else  l43 = n.bound end i( l43 );
 l37 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l37, ",", CL_LIB["COMPILE-TO-LUA"](l40, l2, l3, false), }) i( l37 );
 single_value();  single_value();  local l44 = (l39)[2]; single_value();  l39 = l44 i( l39 );
 single_value();  single_value();  single_value();  local l45 = (l39)[1]; single_value();  l40 = l45 local tmpres = l40 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l42.error ~= n and (l42.error ~= KEYWORD.TAG or l42.tag ~= l41) then if l42.error == KEYWORD.TAG then  error(l42) else error(l42[1]) end end i( CL["VALUES-LIST"](list_r(l42)) );
 single_value();  single_value();  single_value();  local l46 = CL["CONS"](CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l37, ")", }), l15); single_value();  l15 = l46 l36 = l15 else  local l47 = n if n ~= CL["EQ"](l12, 3) then  local l48 = n if n ~= l11 then  local l49 = n if n ~= l14 then  single_value();  single_value();  local l50 = CL["CONS"](CL_LIB["SYMBOL-TO-LUA"](l14), l13); single_value();  l13 = l50 i( l13 );
 single_value();  single_value();  local l51 = CL["CONS"](CL_LIB["COMPILE-TO-LUA"]((l11)[1], l2, l3, false), l13); single_value();  l13 = l51 i( l13 );
 single_value();  l14 = n.bound l49 = l14 else  l14 = funcall_key_get_actual_symbol(l7, (l11)[1]) or n i( l14 );
 single_value();  local l53 = n if n ~= CL["NOT"](l14) then  l53 = CL["NOT"](CL["EQ"]((CL["LAST"](l10, false))[1], CL["&ALLOW-OTHER-KEYS"])) else  l53 = n.bound end local l52 = n if n ~= l53 then  i( CL["WARN"]("Unknown keyword argument ~S on call to ~S. ", l((l11)[1],(l1)[1])) );
 single_value();  local l54 = n.bound; single_value(); do return l54 end; l52 = n.bound else  local l55 = n if n ~= CL["NOT"](l14) then  single_value();  l11 = (l11)[2] l55 = l11 else  l55 = n.bound end l52 = l55 end l49 = l52 end l48 = l49 else  l48 = n.bound end i( l48 );
 single_value();  l11 = (l11)[2] l47 = l11 else  local l56 = n if n ~= CL["T"].bound then  single_value(); do break end; l56 = n.bound else  l56 = n.bound end l47 = l56 end l36 = l47 end l32 = l36 end l26 = l32 end l25 = l26 end l24 = l25 end l21 = l24 end l20 = l21 end i( l20 );
 single_value();  l10 = (l10)[2] local tmpres = l10 end i( n );
 local l57 = n if n ~= l14 then  i( CL["WARN"]("Odd number of keyword arguments on call to ~S.", l((l11)[1])) );
 single_value();  local l58 = n.bound; single_value(); do return l58 end; l57 = n.bound else  l57 = n.bound end i( l57 );
 local l59 = n if n ~= CL["EQ"](LCL["KEYWORD"]["NO"], l13) then  l59 = n.bound else  l13 = CL["REVERSE"](l13) i( l13 );
 single_value();  local l60 = "k("; local l61 = n if n ~= l13 then  single_value();  l60 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l60, (l13)[1], }) l61 = l60 else  l61 = n.bound end i( l61 );
 local l62 = (l13)[2]; single_value();  local l63 = (l62)[1]; single_value();  single_value();  local l64 = CL["GENSYM"](false); single_value();  local l65 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l66 = n if n ~= CL["NOT"](l62) then  single_value(); do break end; l66 = n.bound else  l66 = n.bound end i( l66 );
 l60 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l60, ", ", l63, }) i( l60 );
 single_value();  single_value();  local l67 = (l62)[2]; single_value();  l62 = l67 i( l62 );
 single_value();  single_value();  single_value();  local l68 = (l62)[1]; single_value();  l63 = l68 local tmpres = l63 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l65.error ~= n and (l65.error ~= KEYWORD.TAG or l65.tag ~= l64) then if l65.error == KEYWORD.TAG then  error(l65) else error(l65[1]) end end i( CL["VALUES-LIST"](list_r(l65)) );
 single_value();  single_value();  single_value();  local l69 = CL["CONS"](CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l60, ")", }), l15); single_value();  l15 = l69 l59 = l15 end i( l59 );
 l15 = CL["REVERSE"](l15) i( l15 );
 single_value();  local l70 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL_LIB["SYMBOL-TO-LUA"]((l1)[1]), "(", }); local l71 = n if n ~= l15 then  single_value();  l70 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l70, (l15)[1], }) l71 = l70 else  l71 = n.bound end i( l71 );
 local l72 = (l15)[2]; single_value();  local l73 = (l72)[1]; single_value();  single_value();  local l74 = CL["GENSYM"](false); single_value();  local l75 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l76 = n if n ~= CL["NOT"](l72) then  single_value(); do break end; l76 = n.bound else  l76 = n.bound end i( l76 );
 l70 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l70, ", ", l73, }) i( l70 );
 single_value();  single_value();  local l77 = (l72)[2]; single_value();  l72 = l77 i( l72 );
 single_value();  single_value();  single_value();  local l78 = (l72)[1]; single_value();  l73 = l78 local tmpres = l73 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l75.error ~= n and (l75.error ~= KEYWORD.TAG or l75.tag ~= l74) then if l75.error == KEYWORD.TAG then  error(l75) else error(l75[1]) end end i( CL["VALUES-LIST"](list_r(l75)) );
 single_value();  l16 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l70, ")", }) else  l16 = n.bound end l4 = l16 else  l4 = n.bound end return l4 end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FUNCTION-CALL-TO-LUA"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["AST"],{CL_LIB["ENV"],{CL_LIB["CTX"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL_LIB["SHORT-CALL-TO-LUA"](l1, l2, l3); single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  local l6 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"CL_LIB[\"FUNCALL-LUA\"]( ", CL_LIB["FUNCTION-TO-LUA"]((l1)[1], l2), ", {", }); local l7 = (l1)[2]; single_value();  local l8 = (l7)[1]; single_value();  single_value();  local l9 = CL["GENSYM"](false); single_value();  local l10 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l11 = n if n ~= CL["NOT"](l7) then  single_value(); do break end; l11 = n.bound else  l11 = n.bound end i( l11 );
 l6 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l6, CL_LIB["COMPILE-TO-LUA"](l8, l2, l3, false), ", ", }) i( l6 );
 single_value();  single_value();  local l12 = (l7)[2]; single_value();  l7 = l12 i( l7 );
 single_value();  single_value();  single_value();  local l13 = (l7)[1]; single_value();  l8 = l13 local tmpres = l8 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l10.error ~= n and (l10.error ~= KEYWORD.TAG or l10.tag ~= l9) then if l10.error == KEYWORD.TAG then  error(l10) else error(l10[1]) end end i( CL["VALUES-LIST"](list_r(l10)) );
 single_value();  l5 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l6, "})", }) end return l5 end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FLET-TO-LUA"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["AST"],{CL_LIB["ENV"],{CL_LIB["CTX"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL_LIB["ENV-COPY"](l2); single_value();  local l5 = CL["EQ"]((l1)[1], CL["LABELS"]); single_value();  local l6 = CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ASS"],n},function (l7,  ...)   single_value();  local l8 = (l7)[1]; single_value();  local l9 = CL["CONS"](CL_LIB["NLAMBDA"], CL["CONS"](l8, CL["APPEND"](l((l7)[2],n)))); single_value();  local l10 = CL_LIB["LUA-UNIQUE-LOCAL"](l2); single_value();  local l11 = n if n ~= l5 then  single_value();  l11 = CL_LIB["ENV-PUSH-FLOCAL"](l4, l8, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l10, "[1]", })) else  local l12 = n if n ~= CL["T"].bound then  single_value();  l12 = CL_LIB["ENV-PUSH-FLOCAL"](l4, l8, l10) else  l12 = n.bound end l11 = l12 end i( l11 );
 i( CL_LIB["PUSH-CTX"](l3, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {" local ", l10, ";", })) );
 single_value();  return CL["CONS"](l10, l9) end, 1, 0, false, false), l(CL["CADR"](l1))); single_value();  local l13 = l6; single_value();  local l14 = (l13)[1]; single_value();  single_value();  local l15 = CL["GENSYM"](false); single_value();  local l16 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l17 = n if n ~= CL["NOT"](l13) then  single_value(); do break end; l17 = n.bound else  l17 = n.bound end i( l17 );
 local l18 = n if n ~= l5 then  l18 = CL_LIB["PUSH-CTX"](l3, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {(l14)[1], " = {", CL_LIB["FUNCTION-TO-LUA"]((l14)[2], l4), "};", })) else  l18 = CL_LIB["PUSH-CTX"](l3, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {(l14)[1], " = ", CL_LIB["FUNCTION-TO-LUA"]((l14)[2], l2), ";", })) end i( l18 );
 single_value();  single_value();  local l19 = (l13)[2]; single_value();  l13 = l19 i( l13 );
 single_value();  single_value();  single_value();  local l20 = (l13)[1]; single_value();  l14 = l20 local tmpres = l14 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l16.error ~= n and (l16.error ~= KEYWORD.TAG or l16.tag ~= l15) then if l16.error == KEYWORD.TAG then  error(l16) else error(l16[1]) end end i( CL["VALUES-LIST"](list_r(l16)) );
 single_value();  return CL_LIB["COMPILE-TO-LUA"](CL["CONS"](CL["PROGN"], CL["CDDR"](l1)), l4, l3, false) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["MACROLET-TO-LUA"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["AST"],{CL_LIB["ENV"],{CL_LIB["CTX"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL_LIB["ENV-COPY"](l2); single_value();  local l5 = CL["CADR"](l1); single_value();  local l6 = (l5)[1]; single_value();  single_value();  local l7 = CL["GENSYM"](false); single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l9 = n if n ~= CL["NOT"](l5) then  single_value(); do break end; l9 = n.bound else  l9 = n.bound end i( l9 );
 i( CL_LIB["ENV-PUSH-MLOCAL"](l4, (l6)[1], CL["EVAL"](CL["CONS"](CL_LIB["LAMBDA-MACRO"], CL["CONS"](CL["CADR"](l6), CL["APPEND"](l(CL["CDDR"](l6),n)))))) );
 single_value();  single_value();  local l10 = (l5)[2]; single_value();  l5 = l10 i( l5 );
 single_value();  single_value();  single_value();  local l11 = (l5)[1]; single_value();  l6 = l11 local tmpres = l6 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l8.error ~= n and (l8.error ~= KEYWORD.TAG or l8.tag ~= l7) then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  return CL_LIB["COMPILE-TO-LUA"](CL["CONS"](CL["PROGN"], CL["CDDR"](l1)), l4, l3, false) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["SYMBOL-MACROLET-TO-LUA"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["AST"],{CL_LIB["ENV"],{CL_LIB["CTX"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL_LIB["ENV-COPY"](l2); single_value();  local l5 = CL["CADR"](l1); single_value();  local l6 = (l5)[1]; single_value();  single_value();  local l7 = CL["GENSYM"](false); single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l9 = n if n ~= CL["NOT"](l5) then  single_value(); do break end; l9 = n.bound else  l9 = n.bound end i( l9 );
 i( CL_LIB["ENV-PUSH-SMLOCAL"](l4, (l6)[1], CL["CADR"](l6)) );
 single_value();  single_value();  local l10 = (l5)[2]; single_value();  l5 = l10 i( l5 );
 single_value();  single_value();  single_value();  local l11 = (l5)[1]; single_value();  l6 = l11 local tmpres = l6 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l8.error ~= n and (l8.error ~= KEYWORD.TAG or l8.tag ~= l7) then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  return CL_LIB["COMPILE-TO-LUA"](CL["CONS"](CL["PROGN"], CL["CDDR"](l1)), l4, l3, false) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%NON-LOCAL-RETURN"] , CL_LIB["ALLOC-FUNCTION"]({CL["TYPE"],{CL_LIB["VAL"],{CL_LIB["CLEANUP"],{CL_LIB["BODY"],n}}}},function (l1, l2, l3, l4,  ...)   single_value();  local l5 = CL["GENSYM"](false); single_value();  local l6 = n if n ~= CL["EQ"](LCL["KEYWORD"]["NATIVE"], l1) then  l6 = l2 else  l6 = l5 end local l7 = n if n ~= CL["EQ"](LCL["KEYWORD"]["NATIVE"], l1) then  l7 = n.bound else  single_value();  local l8 = l1; single_value();  local l9 = n if n ~= CL["MEMBER"](l8, {n,n}, k()) then  single_value();  l9 = CL["LIST"](l("true")) else  local l10 = n if n ~= CL["MEMBER"](l8, {CL["T"],n}, k()) then  single_value();  l10 = CL["LIST"](l(l5,".error ~= KEYWORD.TAG")) else  local l11 = n if n ~= CL["EQL"](l8, LCL["KEYWORD"]["TAG"]) then  single_value();  l11 = CL["LIST"](l("(",l5,".error ~= KEYWORD.TAG or ",l5,".tag ~= ",l2,")")) else  local l12 = n if n ~= CL["T"].bound then  single_value();  l12 = CL["ERROR"]("ECASE", l()) else  l12 = n.bound end l11 = l12 end l10 = l11 end l9 = l10 end l7 = CL["CONS"](CL["CONS"](CL_LIB["LUA-PUSH"], CL["CONS"](CL["CONS"]("if ", CL["CONS"](l5, CL["CONS"](".error ~= n and ", CL["APPEND"](l(l9,CL["CONS"](" then if ", CL["CONS"](l5, CL["CONS"](".error == KEYWORD.TAG then ", CL["CONS"](" error(", CL["CONS"](l5, CL["CONS"](") else error(", CL["CONS"](l5, CL["CONS"]("[1]) end end", n))))))))))))), CL["CONS"](CL["CONS"](CL["VALUES-LIST"], CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"]("list_r(", CL["CONS"](l5, CL["CONS"](")", n)))), n)), n))), n) end return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l6, CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"]("(pcallmv(", CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](n, CL["APPEND"](l(l4,n)))), CL["CONS"]("))", n)))), n)), n), CL["APPEND"](l(l3,CL["APPEND"](l(l7,n)))))) end, 4, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["COMPILE-TO-LUA"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["AST"],{CL["&OPTIONAL"],{CL_LIB["ENV"],{CL_LIB["CTX"],{{CL_LIB["RETURN-DO"],{"return ",n}},n}}}}},function (l1, l2, l3, l4,  ...)  if not l2 then  l2 = n.bound end if not l3 then  l3 = n.bound end if not l4 then  l4 = "return " end  single_value();  local l5 = n if n ~= l3 then  local l6 = n if n ~= CL["SYMBOLP"](l1) then  single_value();  l6 = CL_LIB["SYMBOL-VALUE-TO-LUA"](l1, l2, l3) else  local l7 = n if n ~= CL["ATOM"](l1) then  single_value();  l7 = CL_LIB["ATOM-TO-LUA"](l1) else  local l8 = n if n ~= CL["EQ"]((l1)[1], CL_LIB["LUA"]) then  single_value();  l8 = CL_LIB["COMPILE-LUA-SP"]((l1)[2], l2, l3) else  local l9 = n if n ~= CL["EQ"]((l1)[1], CL_LIB["LUA-PUSH"]) then  i( CL_LIB["PUSH-CTX"](l3, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL_LIB["COMPILE-LUA-SP"](CL["CADR"](l1), l2, l3), })) );
 single_value();  l9 = CL_LIB["COMPILE-TO-LUA"](CL["CADDR"](l1), l2, l3, false) else  local l10 = n if n ~= CL["EQ"]((l1)[1], CL["FUNCTION"]) then  single_value();  l10 = CL_LIB["FUNCTION-TO-LUA"](CL["CADR"](l1), l2) else  local l11 = n if n ~= CL["EQ"]((l1)[1], CL["QUOTE"]) then  single_value();  l11 = CL_LIB["QUOTE-TO-LUA"](CL["CADR"](l1), l2) else  local l12 = n if n ~= CL["EQ"]((l1)[1], CL["SETQ"]) then  single_value();  local l13 = n if n ~= CL[">"](l(CL["LENGTH"](l1),3)) then  l13 = CL_LIB["COMPILE-TO-LUA"](CL["CONS"](CL["SETF"], CL["APPEND"](l((l1)[2],n))), l2, l3, false) else  local l14 = CL["CADR"](l1); local l15 = CL["CADDR"](l1); single_value();  local l17 = n if n ~= CL["CONSP"](l14) then  l17 = CL["EQ"]((l14)[1], CL["FUNCTION"]) else  l17 = n.bound end local l16 = n if n ~= l17 then  single_value();  local l19 = n if n ~= CL["CONSP"](CL["CADR"](l14)) then  l19 = CL["EQ"](CL["SETF"], CL["CAADR"](l14)) else  l19 = n.bound end local l18 = n if n ~= l19 then  single_value();  l18 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"CL_LIB[\"SETF-FUNCTION-SETQ\"](", CL_LIB["SYMBOL-TO-LUA"](CL["CADADR"](l14)), " , ", CL_LIB["COMPILE-TO-LUA"](CL["CADDR"](l1), l2, l3, false), ")", }) else  local l20 = n if n ~= CL["SYMBOLP"](CL["CADR"](l14)) then  single_value();  l20 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"CL_LIB[\"FUNCTION-SETQ\"](", CL_LIB["SYMBOL-TO-LUA"](CL["CADR"](l14)), " , ", CL_LIB["COMPILE-TO-LUA"](CL["CADDR"](l1), l2, l3, false), ")", }) else  local l21 = n if n ~= CL["T"].bound then  single_value();  l21 = CL["ERROR"]("Invalid argument for setq function.", l()) else  l21 = n.bound end l20 = l21 end l18 = l20 end l16 = l18 else  local l23 = n if n ~= CL["CONSP"](l14) then  l23 = CL["EQ"]((l14)[1], CL["MACRO-FUNCTION"]) else  l23 = n.bound end local l22 = n if n ~= l23 then  single_value();  l22 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"CL_LIB[\"MACRO-SETQ\"](", CL_LIB["COMPILE-TO-LUA"](CL["CADR"](l14), l2, l3, false), ",", CL_LIB["COMPILE-TO-LUA"](CL["CADDR"](l1), l2, l3, false), ")", }) else  local l24 = n if n ~= CL["T"].bound then  i( CL_LIB["PUSH-CTX"](l3, CL_LIB["COMPILE-LUA-SP"](CL["LIST"](l(" ",l14," = ",CL_LIB["COMPILE-TO-LUA"](l15, l2, l3, false))), l2, l3)) );
 single_value();  l24 = CL_LIB["COMPILE-TO-LUA"](l14, l2, l3, false) else  l24 = n.bound end l22 = l24 end l16 = l22 end l13 = l16 end l12 = l13 else  local l25 = n if n ~= CL["EQ"]((l1)[1], CL["IF"]) then  single_value();  local l26 = CL_LIB["LUA-UNIQUE-LOCAL"](l2); i( CL_LIB["PUSH-CTX"](l3, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {" local ", l26, " = n if n ~= ", CL_LIB["COMPILE-TO-LUA"](CL["CADR"](l1), l2, l3, false), " then ", CL_LIB["COMPILE-TO-LUA"](CL["CADDR"](l1), l2, n.bound, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l26, " = ", })), " else ", CL_LIB["COMPILE-TO-LUA"](CL["CADDDR"](l1), l2, n.bound, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l26, " = ", })), " end", })) );
 single_value();  l25 = l26 else  local l27 = n if n ~= CL["EQ"]((l1)[1], CL_LIB["%PAIRS"]) then  i( CL_LIB["PUSH-CTX"](l3, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {" for __k, __v in pairs(", CL_LIB["COMPILE-TO-LUA"](CL["FOURTH"](l1), l2, l3, ""), ") do ", CL_LIB["COMPILE-TO-LUA"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](CL["SECOND"](l1), CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"]("__k", n)), n)), CL["CONS"](CL["CONS"](CL["THIRD"](l1), CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"]("__v", n)), n)), n)), CL["APPEND"](l(CL["CDDDDR"](l1),n)))), l2, n.bound, "local tmpres = "), " end", })) );
 single_value();  l27 = "n" else  local l28 = n if n ~= CL["EQ"]((l1)[1], CL_LIB["%LOOP"]) then  i( CL_LIB["PUSH-CTX"](l3, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {" while true do ", CL_LIB["COMPILE-TO-LUA"](CL["CONS"](CL["PROGN"], CL["APPEND"](l((l1)[2],n))), l2, n.bound, "local tmpres = "), " end", })) );
 single_value();  l28 = "n" else  local l29 = n if n ~= CL["EQ"]((l1)[1], CL["FLET"]) then  single_value();  l29 = CL_LIB["FLET-TO-LUA"](l1, l2, l3) else  local l30 = n if n ~= CL["EQ"]((l1)[1], CL["LABELS"]) then  single_value();  l30 = CL_LIB["FLET-TO-LUA"](l1, l2, l3) else  local l31 = n if n ~= CL["EQ"]((l1)[1], CL["MACROLET"]) then  single_value();  l31 = CL_LIB["MACROLET-TO-LUA"](l1, l2, l3) else  local l32 = n if n ~= CL["EQ"]((l1)[1], CL["SYMBOL-MACROLET"]) then  single_value();  l32 = CL_LIB["SYMBOL-MACROLET-TO-LUA"](l1, l2, l3) else  local l33 = n if n ~= CL["EQ"]((l1)[1], CL_LIB["%LET"]) then  single_value();  local l34 = CL_LIB["ENV-COPY"](l2); i( CL_LIB["ENV-CHECKMV"](l34, n.bound) );
 local l35 = CL["CADR"](l1); single_value();  local l36 = (l35)[1]; single_value();  single_value();  local l37 = CL["GENSYM"](false); single_value();  local l38 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l39 = n if n ~= CL["NOT"](l35) then  single_value(); do break end; l39 = n.bound else  l39 = n.bound end i( l39 );
 local l41 = n if n ~= CL["CONSP"](l36) then  l41 = (l36)[1] else  l41 = l36 end local l40 = l41; local l43 = n if n ~= CL["CONSP"](l36) then  l43 = CL["CADR"](l36) else  l43 = n.bound end local l42 = l43; local l44 = CL_LIB["LUA-UNIQUE-LOCAL"](l2); i( CL_LIB["ENV-PUSH-LOCAL"](l34, l40, l44) );
 single_value();  i( CL_LIB["PUSH-CTX"](l3, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {" local ", l44, " = ", CL_LIB["COMPILE-TO-LUA"](l42, l2, l3, false), ";", })) );
 single_value();  single_value();  local l45 = (l35)[2]; single_value();  l35 = l45 i( l35 );
 single_value();  single_value();  single_value();  local l46 = (l35)[1]; single_value();  l36 = l46 local tmpres = l36 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l38.error ~= n and (l38.error ~= KEYWORD.TAG or l38.tag ~= l37) then if l38.error == KEYWORD.TAG then  error(l38) else error(l38[1]) end end i( CL["VALUES-LIST"](list_r(l38)) );
 local l47 = n if n ~= CL["LISTP"](CL["CDDR"](l1)) then  local l48 = CL["BUTLAST"](CL["CDDR"](l1), false); single_value();  local l49 = (l48)[1]; single_value();  single_value();  local l50 = CL["GENSYM"](false); single_value();  local l51 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l52 = n if n ~= CL["NOT"](l48) then  single_value(); do break end; l52 = n.bound else  l52 = n.bound end i( l52 );
 i( CL_LIB["PUSH-CTX"](l3, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {" i( ", CL_LIB["COMPILE-TO-LUA"](l49, l34, l3, false), " );\n", })) );
 single_value();  single_value();  local l53 = (l48)[2]; single_value();  l48 = l53 i( l48 );
 single_value();  single_value();  single_value();  local l54 = (l48)[1]; single_value();  l49 = l54 local tmpres = l49 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l51.error ~= n and (l51.error ~= KEYWORD.TAG or l51.tag ~= l50) then if l51.error == KEYWORD.TAG then  error(l51) else error(l51[1]) end end i( CL["VALUES-LIST"](list_r(l51)) );
 single_value();  l47 = CL_LIB["PUSH-CTX"](l3, " single_value(); ") else  l47 = CL["ERROR"]("The given (implicit?) PROGN is not a proper list: ~S ", l(l1)) end i( l47 );
 single_value();  l33 = CL_LIB["COMPILE-TO-LUA"]((CL["LAST"](CL["CDDR"](l1), false))[1], l34, l3, false) else  local l55 = n if n ~= CL["T"].bound then  single_value();  local l56 = n.bound; local l57 = n.bound; local l58 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l59 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l61 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l60 = l61; single_value();  single_value();  l56,l57= unpack_mv(CL["MACROEXPAND"](l1, l2), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l58 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l59.error ~= n and true then if l59.error == KEYWORD.TAG then  error(l59) else error(l59[1]) end end i( CL["VALUES-LIST"](list_r(l59)) );
 single_value();  local l62 = n if n ~= l57 then  l62 = CL_LIB["COMPILE-TO-LUA"](l56, l2, l3, false) else  l62 = CL_LIB["CALL-TO-LUA"](l1, l2, l3) end l55 = l62 else  l55 = n.bound end l33 = l55 end l32 = l33 end l31 = l32 end l30 = l31 end l29 = l30 end l28 = l29 end l27 = l28 end l25 = l27 end l12 = l25 end l11 = l12 end l10 = l11 end l9 = l10 end l8 = l9 end l7 = l8 end l6 = l7 end l5 = l6 else  local l63 = CL["CONS"]("", n.bound); local l65 = n if n ~= l2 then  l65 = l2 else  l65 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ENV-EMPTY"].fbound, {}) end local l64 = l65; single_value();  local l66 = CL_LIB["COMPILE-TO-LUA"](l1, l64, l63, false); single_value();  l5 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {(l63)[1], " ", l4, l66, }) end return l5 end, 1, 3, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["MACRO-SETQ"](CL["DESTRUCTURING-BIND"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G77573"],{CL["&OPTIONAL"],{LCL["NIL"]["G77574"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  single_value();  local l14 = CL["GENSYM"](false); single_value();  local l15 = CL["GENSYM"](false); single_value();  local l16 = CL["LIST"](l(CL["LIST"](l(l14,l9)))); single_value();  single_value();  local l17;l17 = {CL_LIB["ALLOC-FUNCTION"]({CL_LIB["LL"],{CL_LIB["SYM"],n}},function (l18, l19,  ...)   local l20 = n if n ~= CL["EQ"](CL["&WHOLE"], (l18)[1]) then  single_value();  single_value();  local l21 = CL["CONS"](CL["LIST"](l(CL["CADR"](l18),l14)), l16); single_value();  l16 = l21 i( l16 );
 single_value();  l18 = CL["CDDR"](l18) l20 = l18 else  l20 = n.bound end i( l20 );
 single_value();  local l22 = CL_LIB["LAMBDA-GET-POS"](l18); local l23 = CL_LIB["LAMBDA-GET-OPTIONAL"](l18); local l25 = CL_LIB["LAMBDA-GET-REST"](l18); single_value();  local l26 = n if n ~= l25 then  l26 = l25 else  l26 = (CL["LAST"](l18, false))[2] end local l24 = l26; local l27 = CL_LIB["LAMBDA-GET-KEY"](l18); local l28 = CL_LIB["LAMBDA-GET-AUX"](l18); local l29 = l22; single_value();  local l30 = (l29)[1]; single_value();  single_value();  local l31 = CL["GENSYM"](false); single_value();  local l32 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l33 = n if n ~= CL["NOT"](l29) then  single_value(); do break end; l33 = n.bound else  l33 = n.bound end i( l33 );
 local l34 = n if n ~= CL["CONSP"](l30) then  local l35 = CL["GENSYM"](false); single_value();  single_value();  local l36 = CL["CONS"](CL["CONS"](l35, CL["CONS"](CL["CONS"](CL["POP"], CL["CONS"](l19, n)), n)), l16); single_value();  l16 = l36 i( l16 );
 single_value();  l34 = CL_LIB["FUNCALL-LUA"]( l17[1], {l30, l35, }) else  single_value();  single_value();  local l37 = CL["CONS"](CL["CONS"](l30, CL["CONS"](CL["CONS"](CL["POP"], CL["CONS"](l19, n)), n)), l16); single_value();  l16 = l37 l34 = l16 end i( l34 );
 single_value();  single_value();  local l38 = (l29)[2]; single_value();  l29 = l38 i( l29 );
 single_value();  single_value();  single_value();  local l39 = (l29)[1]; single_value();  l30 = l39 local tmpres = l30 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l32.error ~= n and (l32.error ~= KEYWORD.TAG or l32.tag ~= l31) then if l32.error == KEYWORD.TAG then  error(l32) else error(l32[1]) end end i( CL["VALUES-LIST"](list_r(l32)) );
 local l40 = l23; single_value();  local l41 = (l40)[1]; single_value();  single_value();  local l42 = CL["GENSYM"](false); single_value();  local l43 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l44 = n if n ~= CL["NOT"](l40) then  single_value(); do break end; l44 = n.bound else  l44 = n.bound end i( l44 );
 local l46 = n if n ~= CL["CONSP"](l41) then  l46 = (l41)[1] else  l46 = l41 end local l45 = l46; local l48 = n if n ~= CL["CONSP"](l41) then  l48 = CL["CADR"](l41) else  l48 = n.bound end local l47 = l48; local l50 = n if n ~= CL["CONSP"](l41) then  l50 = CL["CADDR"](l41) else  l50 = n.bound end local l49 = l50; local l51 = CL["GENSYM"](false); local l52 = n if n ~= l49 then  single_value();  single_value();  single_value();  local l53 = CL["CONS"](CL["CONS"](l49, CL["CONS"](CL["CONS"](CL["IF"], CL["CONS"](l19, CL["CONS"](CL["T"], n))), n)), l16); single_value();  l16 = l53 l52 = l16 else  l52 = n.bound end i( l52 );
 single_value();  local l54 = n if n ~= CL["CONSP"](l45) then  single_value();  single_value();  local l55 = CL["CONS"](CL["CONS"](l51, CL["CONS"](CL["CONS"](CL["IF"], CL["CONS"](l19, CL["CONS"](CL["CONS"](CL["POP"], CL["CONS"](l19, n)), CL["CONS"](l47, n)))), n)), l16); single_value();  l16 = l55 i( l16 );
 single_value();  l54 = CL_LIB["FUNCALL-LUA"]( l17[1], {l45, l51, }) else  single_value();  single_value();  local l56 = CL["CONS"](CL["CONS"](l45, CL["CONS"](CL["CONS"](CL["IF"], CL["CONS"](l19, CL["CONS"](CL["CONS"](CL["POP"], CL["CONS"](l19, n)), CL["CONS"](l47, n)))), n)), l16); single_value();  l16 = l56 l54 = l16 end i( l54 );
 single_value();  single_value();  local l57 = (l40)[2]; single_value();  l40 = l57 i( l40 );
 single_value();  single_value();  single_value();  local l58 = (l40)[1]; single_value();  l41 = l58 local tmpres = l41 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l43.error ~= n and (l43.error ~= KEYWORD.TAG or l43.tag ~= l42) then if l43.error == KEYWORD.TAG then  error(l43) else error(l43[1]) end end i( CL["VALUES-LIST"](list_r(l43)) );
 local l59 = n if n ~= l24 then  single_value();  local l60 = n if n ~= CL["CONSP"](l24) then  l60 = CL_LIB["FUNCALL-LUA"]( l17[1], {l24, l19, }) else  single_value();  single_value();  local l61 = CL["CONS"](CL["CONS"](l24, CL["CONS"](l19, n)), l16); single_value();  l16 = l61 l60 = l16 end l59 = l60 else  l59 = n.bound end i( l59 );
 local l62 = l27; single_value();  local l63 = (l62)[1]; single_value();  single_value();  local l64 = CL["GENSYM"](false); single_value();  local l65 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l66 = n if n ~= CL["NOT"](l62) then  single_value(); do break end; l66 = n.bound else  l66 = n.bound end i( l66 );
 local l68 = n if n ~= CL["CONSP"](l63) then  l68 = (l63)[1] else  l68 = l63 end local l67 = l68; local l70 = n if n ~= CL["CONSP"](l63) then  l70 = CL["CADR"](l63) else  l70 = n.bound end local l69 = l70; local l72 = n if n ~= CL["CONSP"](l63) then  l72 = CL["CADDR"](l63) else  l72 = n.bound end local l71 = l72; single_value();  local l73 = CL["GENSYM"](false); single_value();  single_value();  local l74 = CL["CONS"](CL["CONS"](l73, CL["CONS"](CL["CONS"](CL["GETF"], CL["CONS"](l19, CL["CONS"](CL["INTERN"](CL["SYMBOL-NAME"](l67), LCL["KEYWORD"]["KEYWORD"]), CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l15, n)), n)))), n)), l16); single_value();  l16 = l74 i( l16 );
 single_value();  single_value();  local l75 = CL["CONS"](CL["CONS"](l67, CL["CONS"](CL["CONS"](CL["IF"], CL["CONS"](CL["CONS"](CL["EQ"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l15, n)), CL["CONS"](l73, n))), CL["CONS"](l69, CL["CONS"](l73, n)))), n)), l16); single_value();  l16 = l75 i( l16 );
 single_value();  local l76 = n if n ~= l71 then  single_value();  single_value();  single_value();  local l77 = CL["CONS"](CL["CONS"](l71, CL["CONS"](CL["CONS"](CL["NOT"], CL["CONS"](CL["CONS"](CL["EQ"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l15, n)), CL["CONS"](l73, n))), n)), n)), l16); single_value();  l16 = l77 l76 = l16 else  l76 = n.bound end i( l76 );
 single_value();  single_value();  local l78 = (l62)[2]; single_value();  l62 = l78 i( l62 );
 single_value();  single_value();  single_value();  local l79 = (l62)[1]; single_value();  l63 = l79 local tmpres = l63 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l65.error ~= n and (l65.error ~= KEYWORD.TAG or l65.tag ~= l64) then if l65.error == KEYWORD.TAG then  error(l65) else error(l65[1]) end end i( CL["VALUES-LIST"](list_r(l65)) );
 single_value();  local l80 = l28; single_value();  local l81 = (l80)[1]; single_value();  single_value();  local l82 = CL["GENSYM"](false); single_value();  local l83 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l84 = n if n ~= CL["NOT"](l80) then  single_value(); do break end; l84 = n.bound else  l84 = n.bound end i( l84 );
 single_value();  single_value();  local l85 = CL["CONS"](l81, l16); single_value();  l16 = l85 i( l16 );
 single_value();  single_value();  local l86 = (l80)[2]; single_value();  l80 = l86 i( l80 );
 single_value();  single_value();  single_value();  local l87 = (l80)[1]; single_value();  l81 = l87 local tmpres = l81 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l83.error ~= n and (l83.error ~= KEYWORD.TAG or l83.tag ~= l82) then if l83.error == KEYWORD.TAG then  error(l83) else error(l83[1]) end end return CL["VALUES-LIST"](list_r(l83)) end, 2, 0, false, false)}; single_value();  single_value();  local l88 = CL["CONS"](CL["CONS"](l14, CL["CONS"](l9, n)), l16); single_value();  l16 = l88 i( l16 );
 i( CL_LIB["FUNCALL-LUA"]( l17[1], {l5, l14, }) );
 single_value();  return CL["CONS"](CL["LET*"], CL["CONS"](CL["REVERSE"](l16), CL["APPEND"](l(l13,n)))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["LAMBDA-MACRO"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G78153"],{CL["&OPTIONAL"],{LCL["NIL"]["G78154"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10; local l11;l10 = {CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l12,  ...)   single_value();  local l13 = n if n ~= l12 then  local l14 = n if n ~= CL["EQ"]((l12)[1], CL["&ENVIRONMENT"]) then  l14 = CL["CADR"](l12) else  l14 = CL_LIB["FUNCALL-LUA"]( l10[1], {(l12)[2], }) end l13 = l14 else  l13 = n.bound end return l13 end, 1, 0, false, false)};l11 = {CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l15,  ...)   single_value();  local l16 = n if n ~= l15 then  local l17 = n if n ~= CL["EQ"]((l15)[1], CL["&ENVIRONMENT"]) then  l17 = CL["CDDR"](l5) else  l17 = CL["CONS"]((l15)[1], CL_LIB["FUNCALL-LUA"]( l11[1], {(l15)[2], })) end l16 = l17 else  l16 = n.bound end return l16 end, 1, 0, false, false)}; single_value();  local l18 = CL["GENSYM"](false); single_value();  local l19 = CL_LIB["FUNCALL-LUA"]( l10[1], {l5, }); single_value();  local l20 = n if n ~= l19 then  l20 = l19 else  l20 = CL["GENSYM"](false) end return CL["CONS"](CL["FUNCTION"], CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](CL["CONS"](l18, CL["CONS"](CL["&OPTIONAL"], CL["CONS"](l20, n))), CL["CONS"](CL["CONS"](CL["DESTRUCTURING-BIND"], CL["CONS"](CL_LIB["FUNCALL-LUA"]( l11[1], {l5, }), CL["CONS"](CL["CONS"](CL["CDR"], CL["CONS"](l18, n)), CL["APPEND"](l(l9,n))))), n))), n)) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DEFMACRO"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G78253"],{CL["&OPTIONAL"],{LCL["NIL"]["G78254"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  single_value();  local l14 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["SETQ"], CL["CONS"](CL["CONS"](CL["MACRO-FUNCTION"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), n)), CL["CONS"](CL["CONS"](CL_LIB["LAMBDA-MACRO"], CL["CONS"](l9, CL["APPEND"](l(l13,n)))), n))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MACROEXPAND-1"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FORM"],{CL["&OPTIONAL"],{CL_LIB["ENV"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = n if n ~= CL["ATOM"](l1) then  l3 = CL["VALUES"](l(l1,n.bound)) else  local l4 = (l1)[1]; single_value();  local l5 = n if n ~= CL["ATOM"](l4) then  local l6 = CL["MACRO-FUNCTION"]((l1)[1], l2); single_value();  local l7 = n if n ~= l6 then  local l8 = l6; single_value();  local l9 = l1; single_value();  local l10 = l2; single_value();  l7 = CL["VALUES"](l(CL_LIB['FUNCALL-LUA'](CL["*MACROEXPAND-HOOK*"].bound,{l8, l9, l10, }),CL["T"].bound)) else  l7 = CL["VALUES"](l(l1,n.bound)) end l5 = l7 else  l5 = CL["VALUES"](l(l1,n.bound)) end l3 = l5 end return l3 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MACROEXPAND"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FORM"],{CL["&OPTIONAL"],{CL_LIB["ENV"],{CL["&AUX"],{CL_LIB["EXPANDED-P"],n}}}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end l3 = n.bound  while true do  single_value();  local l4 = n.bound; local l5 = n.bound; local l6 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l9 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l8 = l9; single_value();  single_value();  l4,l5= unpack_mv(CL["MACROEXPAND-1"](l1, l2), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l6 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l7.error ~= n and true then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end i( CL["VALUES-LIST"](list_r(l7)) );
 single_value();  local l10 = n if n ~= l5 then  l1 = l4 i( l1 );
 single_value();  l3 = CL["T"].bound l10 = l3 else do break end; l10 = n.bound end local tmpres = l10 end i( n );
 single_value();  return CL["VALUES"](l(l1,l3)) end, 1, 1, false, false)); local l1 = CL["MAKE-HASH-TABLE"](k()); single_value();  tmp = CL_LIB.DEF(CL_LIB["*COMPILER-MACROS*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL["COMPILER-MACRO-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NAME"],{CL["&OPTIONAL"],{CL_LIB["ENVIRONMENT"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  return CL["GETHASH"](l1, CL_LIB["*COMPILER-MACROS*"].bound, false) end, 1, 1, false, false)); single_value();  tmp = CL_LIB["MACRO-SETQ"](CL["DEFINE-COMPILER-MACRO"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G78534"],{CL["&OPTIONAL"],{LCL["NIL"]["G78535"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  single_value();  local l15 = n if n ~= CL["EQ"]((l9)[1], CL["&WHOLE"]) then  l15 = CL["CADR"](l9) else  l15 = CL["GENSYM"](false) end local l14 = l15; local l17 = n if n ~= CL["EQ"]((l9)[1], CL["&WHOLE"]) then  l17 = CL["CDDR"](l9) else  l17 = l9 end local l16 = l17; local l18 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL_LIB["SETHASH"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), CL["CONS"](CL_LIB["*COMPILER-MACROS*"], CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](CL["CONS"](l14, CL["CONS"](CL["&OPTIONAL"], CL["CONS"](l18, n))), CL["CONS"](CL["CONS"](CL["DESTRUCTURING-BIND"], CL["CONS"](l16, CL["CONS"](CL["CONS"](CL["CDR"], CL["CONS"](l14, n)), CL["APPEND"](l(l13,n))))), n))), n)))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["CALL-TO-LUA"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["AST"],{CL_LIB["ENV"],{CL_LIB["CTX"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL["COMPILER-MACRO-FUNCTION"]((l1)[1], l2); single_value();  local l5 = n if n ~= l4 then  local l7 = l1; single_value();  local l8 = l2; single_value();  local l6 = CL_LIB['FUNCALL-LUA'](l4,{l7, l8, }); single_value();  local l9 = n if n ~= CL["EQ"](l6, l1) then  l9 = CL_LIB["FUNCTION-CALL-TO-LUA"](l1, l2, l3) else  l9 = CL_LIB["COMPILE-TO-LUA"](l6, l2, l3, false) end l5 = l9 else  l5 = CL_LIB["FUNCTION-CALL-TO-LUA"](l1, l2, l3) end return l5 end, 3, 0, false, false)); tmp = CL_LIB["SETHASH"](CL["+"], CL_LIB["*COMPILER-MACROS*"].bound, CL_LIB["ALLOC-FUNCTION"]({CL_LIB["W"],{CL["&OPTIONAL"],{LCL["NIL"]["G78656"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = n if n ~= CL["EVERY"](CL["NUMBERP"].fbound, l(l5)) then  l6 = CL["APPLY"](CL["+"].fbound, l5, l()) else  local l7 = CL["LENGTH"](l5); single_value();  local l8 = n if n ~= CL["EQL"](l7, 0) then  single_value();  l8 = 0 else  local l9 = n if n ~= CL["EQL"](l7, 1) then  single_value();  l9 = (l5)[1] else  local l10 = n if n ~= CL["EQL"](l7, 2) then  single_value();  l10 = CL["CONS"](CL_LIB["LUA"], CL["CONS"]("(", CL["CONS"]((l5)[1], CL["CONS"](" + ", CL["CONS"](CL["SECOND"](l5), CL["CONS"](")", n)))))) else  local l11 = n if n ~= CL["EQL"](l7, 3) then  single_value();  l11 = CL["CONS"](CL_LIB["LUA"], CL["CONS"]("(", CL["CONS"](CL["FIRST"](l5), CL["CONS"](" + ", CL["CONS"](CL["SECOND"](l5), CL["CONS"](" + ", CL["CONS"](CL["THIRD"](l5), CL["CONS"](")", n)))))))) else  local l12 = n if n ~= CL["EQL"](l7, 4) then  single_value();  l12 = CL["CONS"](CL_LIB["LUA"], CL["CONS"]("(", CL["CONS"](CL["FIRST"](l5), CL["CONS"](" + ", CL["CONS"](CL["SECOND"](l5), CL["CONS"](" + ", CL["CONS"](CL["THIRD"](l5), CL["CONS"](" + ", CL["CONS"](CL["FOURTH"](l5), CL["CONS"](")", n)))))))))) else  local l13 = n if n ~= CL["T"].bound then  single_value();  l13 = l1 else  l13 = n.bound end l12 = l13 end l11 = l12 end l10 = l11 end l9 = l10 end l8 = l9 end l6 = l8 end return l6 end, 1, 1, false, false)); tmp = CL_LIB["SETHASH"](CL["*"], CL_LIB["*COMPILER-MACROS*"].bound, CL_LIB["ALLOC-FUNCTION"]({CL_LIB["W"],{CL["&OPTIONAL"],{LCL["NIL"]["G78747"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = n if n ~= CL["EVERY"](CL["NUMBERP"].fbound, l(l5)) then  l6 = CL["APPLY"](CL["*"].fbound, l5, l()) else  local l7 = CL["LENGTH"](l5); single_value();  local l8 = n if n ~= CL["EQL"](l7, 0) then  single_value();  l8 = 1 else  local l9 = n if n ~= CL["EQL"](l7, 1) then  single_value();  l9 = (l5)[1] else  local l10 = n if n ~= CL["EQL"](l7, 2) then  single_value();  l10 = CL["CONS"](CL_LIB["LUA"], CL["CONS"]("(", CL["CONS"]((l5)[1], CL["CONS"](" * ", CL["CONS"](CL["SECOND"](l5), CL["CONS"](")", n)))))) else  local l11 = n if n ~= CL["EQL"](l7, 3) then  single_value();  l11 = CL["CONS"](CL_LIB["LUA"], CL["CONS"]("(", CL["CONS"](CL["FIRST"](l5), CL["CONS"](" * ", CL["CONS"](CL["SECOND"](l5), CL["CONS"](" * ", CL["CONS"](CL["THIRD"](l5), CL["CONS"](")", n)))))))) else  local l12 = n if n ~= CL["EQL"](l7, 4) then  single_value();  l12 = CL["CONS"](CL_LIB["LUA"], CL["CONS"]("(", CL["CONS"](CL["FIRST"](l5), CL["CONS"](" * ", CL["CONS"](CL["SECOND"](l5), CL["CONS"](" * ", CL["CONS"](CL["THIRD"](l5), CL["CONS"](" * ", CL["CONS"](CL["FOURTH"](l5), CL["CONS"](")", n)))))))))) else  local l13 = n if n ~= CL["T"].bound then  single_value();  l13 = l1 else  l13 = n.bound end l12 = l13 end l11 = l12 end l10 = l11 end l9 = l10 end l8 = l9 end l6 = l8 end return l6 end, 1, 1, false, false)); tmp = CL_LIB["SETHASH"](CL["-"], CL_LIB["*COMPILER-MACROS*"].bound, CL_LIB["ALLOC-FUNCTION"]({CL_LIB["W"],{CL["&OPTIONAL"],{LCL["NIL"]["G78838"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = n if n ~= CL["EVERY"](CL["NUMBERP"].fbound, l(l5)) then  l6 = CL["APPLY"](CL["-"].fbound, l5, l()) else  local l7 = CL["LENGTH"](l5); single_value();  local l8 = n if n ~= CL["EQL"](l7, 0) then  single_value();  l8 = 0 else  local l9 = n if n ~= CL["EQL"](l7, 1) then  single_value();  l9 = CL["CONS"](CL_LIB["LUA"], CL["CONS"]("- ", CL["CONS"]((l5)[1], n))) else  local l10 = n if n ~= CL["EQL"](l7, 2) then  single_value();  l10 = CL["CONS"](CL_LIB["LUA"], CL["CONS"]("(", CL["CONS"]((l5)[1], CL["CONS"](" - ", CL["CONS"](CL["SECOND"](l5), CL["CONS"](")", n)))))) else  local l11 = n if n ~= CL["EQL"](l7, 3) then  single_value();  l11 = CL["CONS"](CL_LIB["LUA"], CL["CONS"]("(", CL["CONS"](CL["FIRST"](l5), CL["CONS"](" - ", CL["CONS"](CL["SECOND"](l5), CL["CONS"](" - ", CL["CONS"](CL["THIRD"](l5), CL["CONS"](")", n)))))))) else  local l12 = n if n ~= CL["EQL"](l7, 4) then  single_value();  l12 = CL["CONS"](CL_LIB["LUA"], CL["CONS"]("(", CL["CONS"](CL["FIRST"](l5), CL["CONS"](" - ", CL["CONS"](CL["SECOND"](l5), CL["CONS"](" - ", CL["CONS"](CL["THIRD"](l5), CL["CONS"](" - ", CL["CONS"](CL["FOURTH"](l5), CL["CONS"](")", n)))))))))) else  local l13 = n if n ~= CL["T"].bound then  single_value();  l13 = l1 else  l13 = n.bound end l12 = l13 end l11 = l12 end l10 = l11 end l9 = l10 end l8 = l9 end l6 = l8 end return l6 end, 1, 1, false, false)); tmp = CL_LIB["SETHASH"](CL["CAR"], CL_LIB["*COMPILER-MACROS*"].bound, CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&OPTIONAL"],{LCL["NIL"]["G78932"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  single_value();  local l9 = n if n ~= l5 then  l9 = CL["CONS"](CL_LIB["LUA"], CL["CONS"]("(", CL["CONS"](l5, CL["CONS"](")[1]", n)))) else  l9 = n.bound end return l9 end, 1, 1, false, false)); tmp = CL_LIB["SETHASH"](CL["CDR"], CL_LIB["*COMPILER-MACROS*"].bound, CL_LIB["ALLOC-FUNCTION"]({CL_LIB["C"],{CL["&OPTIONAL"],{LCL["NIL"]["G78982"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  single_value();  local l9 = n if n ~= l5 then  l9 = CL["CONS"](CL_LIB["LUA"], CL["CONS"]("(", CL["CONS"](l5, CL["CONS"](")[2]", n)))) else  l9 = n.bound end return l9 end, 1, 1, false, false)); tmp = CL_LIB["SETHASH"](CL["="], CL_LIB["*COMPILER-MACROS*"].bound, CL_LIB["ALLOC-FUNCTION"]({CL_LIB["W"],{CL["&OPTIONAL"],{LCL["NIL"]["G79032"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = n if n ~= CL["EVERY"](CL["NUMBERP"].fbound, l(l5)) then  l6 = CL["APPLY"](CL["="].fbound, l5, l()) else  local l7 = CL["LENGTH"](l5); single_value();  local l8 = n if n ~= CL["EQL"](l7, 2) then  single_value();  l8 = CL["CONS"](CL["EQ"], CL["CONS"]((l5)[1], CL["CONS"](CL["SECOND"](l5), n))) else  local l9 = n if n ~= CL["T"].bound then  single_value();  l9 = l1 else  l9 = n.bound end l8 = l9 end l6 = l8 end return l6 end, 1, 1, false, false)); tmp = CL_LIB["SETHASH"](CL["<"], CL_LIB["*COMPILER-MACROS*"].bound, CL_LIB["ALLOC-FUNCTION"]({CL_LIB["W"],{CL["&OPTIONAL"],{LCL["NIL"]["G79079"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = n if n ~= CL["EVERY"](CL["NUMBERP"].fbound, l(l5)) then  l6 = CL["APPLY"](CL["<"].fbound, l5, l()) else  local l7 = CL["LENGTH"](l5); single_value();  local l8 = n if n ~= CL["EQL"](l7, 2) then  single_value();  l8 = CL["CONS"](CL_LIB["%<"], CL["CONS"]((l5)[1], CL["CONS"](CL["SECOND"](l5), n))) else  local l9 = n if n ~= CL["T"].bound then  single_value();  l9 = l1 else  l9 = n.bound end l8 = l9 end l6 = l8 end return l6 end, 1, 1, false, false)); tmp = CL_LIB["SETHASH"](CL["FUNCALL"], CL_LIB["*COMPILER-MACROS*"].bound, CL_LIB["ALLOC-FUNCTION"]({CL_LIB["W"],{CL["&OPTIONAL"],{LCL["NIL"]["G79126"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = n if n ~= CL["SYMBOLP"](l5) then  l10 = CL["CONS"](CL_LIB["LUA"], CL["CONS"]("CL_LIB['FUNCALL-LUA'](", CL["CONS"](l5, CL["CONS"](",", CL["CONS"](CL["CONS"](CL_LIB["LUA-ARRAY"], CL["APPEND"](l(l9,n))), CL["CONS"](")", n)))))) else  l10 = l1 end return l10 end, 1, 1, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["FUNCTION-SETQ"](CL["EVAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FORMS"],n},function (l1,  ...)   single_value();  return CL["FUNCALL"](load, l(CL_LIB["COMPILE-TO-LUA"](l1, false, false, false)))() end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["PROGV-DECLARE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["VAR"],{CL_LIB["UNBOUND"],{CL["&AUX"],{{CL_LIB["RET"],{CL_LIB["UNBOUND"],n}},n}}}},function (l1, l2,  ...)  l3 = l2  local l4 = n if n ~= CL["BOUNDP"](l1) then  single_value();  l3 = CL["SYMBOL-VALUE"](l1) l4 = l3 else  l4 = n.bound end i( l4 );
 single_value();  return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["PROGV-DECLARE-ALL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["VARS"],{CL_LIB["UNBOUND"],n}},function (l1, l2,  ...)   single_value();  return CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["VAR"],n},function (l3,  ...)   single_value();  return CL_LIB["PROGV-DECLARE"](l3, l2) end, 1, 0, false, false), l(l1)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["PROGV-RESTORE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["VARS"],{CL_LIB["RESTORE"],{CL_LIB["UNBOUND"],n}}},function (l1, l2, l3,  ...)   single_value();  return CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["VAR"],{CL_LIB["R"],n}},function (l4, l5,  ...)   single_value();  local l6 = n if n ~= CL["EQ"](l5, l3) then  l6 = CL["MAKUNBOUND"](l4) else  l6 = CL["SET"](l4, l5) end return l6 end, 2, 0, false, false), l(l1,l2)) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["PROGV-SET-ALL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["VARS"],{CL["VALUES"],n}},function (l1, l2,  ...)   single_value();  return CL["MAPCAR"](CL["SET"].fbound, l(l1,l2)) end, 2, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["PROGV"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G81803"],{CL["&OPTIONAL"],{LCL["NIL"]["G81804"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  single_value();  local l14 = CL["GENSYM"](false); local l15 = CL["GENSYM"](false); local l16 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["LET*"], CL["CONS"](CL["CONS"](CL["CONS"](l16, CL["CONS"](CL["CONS"](CL["GENSYM"], n), n)), CL["CONS"](CL["CONS"](l14, CL["CONS"](l5, n)), CL["CONS"](CL["CONS"](l15, CL["CONS"](CL["CONS"](CL_LIB["PROGV-DECLARE-ALL"], CL["CONS"](l14, CL["CONS"](l16, n))), n)), n))), CL["CONS"](CL["CONS"](CL["UNWIND-PROTECT"], CL["CONS"](CL["CONS"](CL["PROGN"], CL["CONS"](CL["CONS"](CL_LIB["PROGV-SET-ALL"], CL["CONS"](l14, CL["CONS"](l9, n))), CL["APPEND"](l(l13,n)))), CL["CONS"](CL["CONS"](CL_LIB["PROGV-RESTORE"], CL["CONS"](l14, CL["CONS"](l15, CL["CONS"](l16, n)))), n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); local l1 = CL["MAKE-HASH-TABLE"](k()); single_value();  tmp = CL_LIB.DEF(CL_LIB["*SETF-EXPANDER*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%REGISTER-SETF-EXPANDER"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["KEY"],{CL["FUNCTION"],n}},function (l1, l2,  ...)   single_value();  return CL_LIB["SETHASH"](l1, CL_LIB["*SETF-EXPANDER*"].bound, l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%GET-SETF-EXPANSION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL["&OPTIONAL"],{CL_LIB["ENV"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = n if n ~= CL["SYMBOLP"](l1) then  single_value();  local l4 = CL["GENSYM"](false); single_value();  l3 = CL["VALUES"](l(n.bound,n.bound,CL["LIST"](l(l4)),CL["LIST"](l(CL["SETQ"],l1,l4)),l1)) else  local l6 = n if n ~= CL["LISTP"](l1) then  l6 = CL["GETHASH"]((l1)[1], CL_LIB["*SETF-EXPANDER*"].bound, false) else  l6 = n.bound end local l5 = n if n ~= l6 then  single_value();  l5 = CL["APPLY"](CL["GETHASH"]((l1)[1], CL_LIB["*SETF-EXPANDER*"].bound, false), (l1)[2], l()) else  local l8 = n if n ~= CL["LISTP"](l1) then  local l9 = n if n ~= CL["NOT"](CL["LISTP"]((l1)[1])) then  l9 = CL["FBOUNDP"](CL["CONS"](CL["SETF"], CL["CONS"]((l1)[1], n))) else  l9 = n.bound end l8 = l9 else  l8 = n.bound end local l7 = n if n ~= l8 then  single_value();  local l10 = CL["GENSYM"](false); local l11 = CL["GENSYM"](false); single_value();  l7 = CL["VALUES"](l(CL["LIST"](l(l10)),CL["LIST"](l(CL["CADR"](l1))),CL["LIST"](l(l11)),CL["CONS"](CL["FUNCALL"], CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](CL["CONS"](CL["SETF"], CL["CONS"]((l1)[1], n)), n)), CL["CONS"](l11, CL["CONS"](l10, CL["APPEND"](l(CL["CDDR"](l1),n)))))),CL["CONS"]((l1)[1], CL["CONS"](l10, CL["APPEND"](l(CL["CDDR"](l1),n)))))) else  local l12 = n if n ~= CL["T"].bound then  single_value();  l12 = CL["ERROR"]("Invalid place ~S, could not %GET-SETF-EXPANSION", l(l1)) else  l12 = n.bound end l7 = l12 end l5 = l7 end l3 = l5 end return l3 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["GET-SETF-EXPANSION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL["&OPTIONAL"],{CL_LIB["ENV"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  return CL_LIB["%GET-SETF-EXPANSION"](l1, l2) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["GET-SETF-EXPANSION-OR-EVAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL["&OPTIONAL"],{CL_LIB["ENV"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = n if n ~= CL["SYMBOLP"](l1) then  single_value();  local l4 = CL["GENSYM"](false); single_value();  l3 = CL["VALUES"](l(n.bound,n.bound,CL["LIST"](l(l4)),CL["LIST"](l(CL["SETQ"],l1,l4)),l1)) else  local l6 = n if n ~= CL["LISTP"](l1) then  l6 = CL["GETHASH"]((l1)[1], CL_LIB["*SETF-EXPANDER*"].bound, false) else  l6 = n.bound end local l5 = n if n ~= l6 then  single_value();  l5 = CL["APPLY"](CL["GETHASH"]((l1)[1], CL_LIB["*SETF-EXPANDER*"].bound, false), (l1)[2], l()) else  local l7 = n if n ~= CL["T"].bound then  single_value();  l7 = CL["VALUES"](l(n.bound,n.bound,n.bound,n.bound,l1)) else  l7 = n.bound end l5 = l7 end l3 = l5 end return l3 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["GET-SETF-ALL-EXPANSION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACES"],{CL["&OPTIONAL"],{CL_LIB["ENV"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = n.bound; local l8 = l1; single_value();  local l9 = (l8)[1]; single_value();  single_value();  local l10 = CL["GENSYM"](false); single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l12 = n if n ~= CL["NOT"](l8) then  single_value(); do break end; l12 = n.bound else  l12 = n.bound end i( l12 );
 local l13 = n.bound; local l14 = n.bound; local l15 = n.bound; local l16 = n.bound; local l17 = n.bound; local l18 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l19 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l21 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l20 = l21; single_value();  single_value();  l13,l14,l15,l16,l17= unpack_mv(CL_LIB["GET-SETF-EXPANSION-OR-EVAL"](l9, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l18 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l19.error ~= n and true then if l19.error == KEYWORD.TAG then  error(l19) else error(l19[1]) end end i( CL["VALUES-LIST"](list_r(l19)) );
 l3 = CL["APPEND"](l(l13,l3)) i( l3 );
 l4 = CL["APPEND"](l(l14,l4)) i( l4 );
 l5 = CL["APPEND"](l(l15,l5)) i( l5 );
 l6 = CL["APPEND"](l(CL["LIST"](l(l16)),l6)) i( l6 );
 single_value();  l7 = CL["APPEND"](l(CL["LIST"](l(l17)),l7)) i( l7 );
 single_value();  single_value();  local l22 = (l8)[2]; single_value();  l8 = l22 i( l8 );
 single_value();  single_value();  single_value();  local l23 = (l8)[1]; single_value();  l9 = l23 local tmpres = l9 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l11.error ~= n and (l11.error ~= KEYWORD.TAG or l11.tag ~= l10) then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end i( CL["VALUES-LIST"](list_r(l11)) );
 single_value();  return CL["VALUES"](l(l3,l4,l5,l6,l7)) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["GEN-SYM-ALL-GETTERS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["GETTERS"],{CL_LIB["DUMMIES"],{CL_LIB["VALS"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = n.bound; local l5 = l1; single_value();  local l6 = (l5)[1]; single_value();  single_value();  local l7 = CL["GENSYM"](false); single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l9 = n if n ~= CL["NOT"](l5) then  single_value(); do break end; l9 = n.bound else  l9 = n.bound end i( l9 );
 local l10 = CL["GENSYM"](false); single_value();  single_value();  local l11 = CL["CONS"](l10, l4); single_value();  l4 = l11 i( l4 );
 single_value();  single_value();  local l12 = CL["CONS"](l10, l2); single_value();  l2 = l12 i( l2 );
 single_value();  single_value();  single_value();  local l13 = CL["CONS"](l6, l3); single_value();  l3 = l13 i( l3 );
 single_value();  single_value();  local l14 = (l5)[2]; single_value();  l5 = l14 i( l5 );
 single_value();  single_value();  single_value();  local l15 = (l5)[1]; single_value();  l6 = l15 local tmpres = l6 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l8.error ~= n and (l8.error ~= KEYWORD.TAG or l8.tag ~= l7) then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  return CL["VALUES"](l(l4,l2,l3)) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FDEFINITION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FUNCTION-NAME"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["SYMBOLP"](l1) then  single_value();  local l3 = "fbound"; local l4 = n.bound; single_value();  l2 = ((l1)[l3] or l4) else  local l6 = n if n ~= CL["CONSP"](l1) then  l6 = CL["EQ"](CL["SETF"], (l1)[1]) else  l6 = n.bound end local l5 = n if n ~= l6 then  single_value();  local l7 = "setfbound"; local l8 = n.bound; single_value();  l5 = ((CL["CADR"](l1))[l7] or l8) else  local l9 = n if n ~= CL["T"].bound then  single_value();  l9 = CL["ERROR"]("Invalid argument to fdefinition ~S", l(l1)) else  l9 = n.bound end l5 = l9 end l2 = l5 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DEFINE-SETF-EXPANDER"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G84834"],{CL["&OPTIONAL"],{LCL["NIL"]["G84835"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  i( CL_LIB["%REGISTER-SETF-EXPANDER"](l5, CL["EVAL"](CL["CONS"](CL["LAMBDA"], CL["CONS"](l9, CL["APPEND"](l(l13,n)))))) );
 single_value();  return CL["CONS"](CL_LIB["%REGISTER-SETF-EXPANDER"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](l9, CL["APPEND"](l(l13,n)))), n))) end, 1, 1, false, false)); single_value();  tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["GEN-PARAMS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["LL"],{CL["&OPTIONAL"],{CL_LIB["KEY"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = n if n ~= CL["NULL"](l1) then  single_value();  l3 = CL["LIST"](l(n.bound)) else  local l4 = n if n ~= CL["EQ"]((l1)[1], CL["&AUX"]) then  single_value();  l4 = CL["LIST"](l(n.bound)) else  local l5 = n if n ~= CL["EQ"]((l1)[1], CL["&OPTIONAL"]) then  single_value();  l5 = CL_LIB["GEN-PARAMS"]((l1)[2], l2) else  local l6 = n if n ~= CL["EQ"]((l1)[1], CL["&ALLOW-OTHER-KEYS"]) then  single_value();  l6 = CL_LIB["GEN-PARAMS"]((l1)[2], l2) else  local l7 = n if n ~= CL["EQ"]((l1)[1], CL["&KEY"]) then  single_value();  l7 = CL_LIB["GEN-PARAMS"]((l1)[2], CL["T"].bound) else  local l8 = n if n ~= CL["EQ"]((l1)[1], CL["&REST"]) then  single_value();  l8 = CL["LIST"](l(CL["CADR"](l1))) else  local l9 = n if n ~= CL["LISTP"]((l1)[1]) then  single_value();  local l10 = n if n ~= l2 then  l10 = CL["LIST"](l(CL["INTERN"](CL["SYMBOL-NAME"](CL["CAAR"](l1)), LCL["KEYWORD"]["KEYWORD"]))) else  l10 = n.bound end l9 = CL["APPEND"](l(l10,CL["CONS"](CL["CAAR"](l1), CL["APPEND"](l(CL_LIB["GEN-PARAMS"]((l1)[2], l2),n))))) else  local l11 = n if n ~= CL["ATOM"]((l1)[1]) then  single_value();  local l12 = n if n ~= l2 then  l12 = CL["LIST"](l(CL["INTERN"](CL["SYMBOL-NAME"]((l1)[1]), LCL["KEYWORD"]["KEYWORD"]))) else  l12 = n.bound end l11 = CL["APPEND"](l(l12,CL["CONS"]((l1)[1], CL["APPEND"](l(CL_LIB["GEN-PARAMS"]((l1)[2], l2),n))))) else  local l13 = n if n ~= CL["T"].bound then  single_value();  l13 = CL["ERROR"]("Unsupported lambda list ~S in define-modify-macro", l(CL_LIB["LAMBDA-LIST"].bound)) else  l13 = n.bound end l11 = l13 end l9 = l11 end l8 = l9 end l7 = l8 end l6 = l7 end l5 = l6 end l4 = l5 end l3 = l4 end return l3 end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DEFSETF"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G85075"],{CL["&OPTIONAL"],{LCL["NIL"]["G85076"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  single_value();  local l14 = n if n ~= l13 then  local l15 = (l13)[1]; local l16 = (l13)[2]; local l17 = CL["GENSYM"](false); single_value();  l14 = CL["CONS"](CL["DEFINE-SETF-EXPANDER"], CL["CONS"](l5, CL["CONS"](CL["CONS"](CL["&REST"], CL["CONS"](l17, n)), CL["CONS"](CL["CONS"](CL["MULTIPLE-VALUE-BIND"], CL["CONS"](CL["CONS"](CL_LIB["DUMMIES"], CL["CONS"](CL_LIB["VALS"], CL["CONS"](CL_LIB["NEWVAL"], CL["CONS"](CL_LIB["SETTERS"], CL["CONS"](CL_LIB["GETTER"], n))))), CL["CONS"](CL["CONS"](CL_LIB["GET-SETF-ALL-EXPANSION"], CL["CONS"](l17, n)), CL["CONS"](CL["CONS"](CL["DESTRUCTURING-BIND"], CL["CONS"](l9, CL["CONS"](CL_LIB["GETTER"], CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["S"],n},function (l18,  ...)   single_value();  return CL["LIST"](l(l18,{CL["GENSYM"],n})) end, 1, 0, false, false), l(l15)), CL["CONS"](CL["CONS"](CL["VALUES"], CL["CONS"](CL_LIB["DUMMIES"], CL["CONS"](CL_LIB["VALS"], CL["CONS"](CL["CONS"](CL["LIST"], CL["APPEND"](l(l15,n))), CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(l16,n))), CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["APPLY"], n)), CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["FUNCTION"], n)), CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), n))), CL["APPEND"](l(CL_LIB["GEN-PARAMS"](l9, false),n))))), n)))))), n))), n)))), n)))), n)))) else  l14 = CL["CONS"](CL["DEFINE-SETF-EXPANDER"], CL["CONS"](l5, CL["CONS"](CL["CONS"](CL["&REST"], CL["CONS"](CL_LIB["X"], n)), CL["CONS"](CL["CONS"](CL["MULTIPLE-VALUE-BIND"], CL["CONS"](CL["CONS"](CL_LIB["DUMMIES"], CL["CONS"](CL_LIB["VALS"], CL["CONS"](CL_LIB["NEWVAL"], CL["CONS"](CL_LIB["SETTERS"], CL["CONS"](CL_LIB["GETTER"], n))))), CL["CONS"](CL["CONS"](CL_LIB["GET-SETF-ALL-EXPANSION"], CL["CONS"](CL_LIB["X"], n)), CL["CONS"](CL["CONS"](CL["MULTIPLE-VALUE-BIND"], CL["CONS"](CL["CONS"](CL_LIB["SYMS"], CL["CONS"](CL_LIB["DUMMIES-GET"], CL["CONS"](CL_LIB["VALS-GET"], n))), CL["CONS"](CL["CONS"](CL_LIB["GEN-SYM-ALL-GETTERS"], CL["CONS"](CL_LIB["GETTER"], CL["CONS"](CL_LIB["DUMMIES"], CL["CONS"](CL_LIB["VALS"], n)))), CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](CL_LIB["STORE"], CL["CONS"](CL["CONS"](CL["GENSYM"], n), n)), n), CL["CONS"](CL["CONS"](CL["VALUES"], CL["CONS"](CL_LIB["DUMMIES-GET"], CL["CONS"](CL_LIB["VALS-GET"], CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL_LIB["STORE"], n)), CL["CONS"](CL["CONS"](CL["APPEND"], CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l9, n)), n)), CL["CONS"](CL_LIB["SYMS"], CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL_LIB["STORE"], n)), n)))), CL["CONS"](CL["CONS"](CL["APPEND"], CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), n)), CL["CONS"](CL_LIB["SYMS"], n))), n)))))), n))), n)))), n)))), n)))) end return l14 end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DEFINE-MODIFY-MACRO"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G85271"],{CL["&OPTIONAL"],{LCL["NIL"]["G85272"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l14 = l4; single_value();  local l15 = (l14)[1]; single_value();  single_value();  local l16 = (l14)[2]; single_value();  l4 = l16 i( l4 );
 single_value();  local l13 = l15; single_value();  local l18 = n if n ~= l4 then  local l19 = l4; single_value();  local l20 = (l19)[1]; single_value();  single_value();  local l21 = (l19)[2]; single_value();  l4 = l21 i( l4 );
 single_value();  l18 = l20 else  l18 = n.bound end local l17 = l18; single_value();  single_value();  local l22 = CL["GENSYM"](false); local l23 = CL["GENSYM"](false); single_value();  local l24 = n if n ~= l17 then  l24 = CL["LIST"](l(l17)) else  l24 = n.bound end return CL["CONS"](CL["EVAL-WHEN"], CL["CONS"](CL["CONS"](LCL["KEYWORD"]["COMPILE-TOPLEVEL"], CL["CONS"](LCL["KEYWORD"]["EXECUTE"], n)), CL["CONS"](CL["CONS"](CL["DEFMACRO"], CL["CONS"](l5, CL["CONS"](CL["CONS"](l22, CL["CONS"](CL["&REST"], CL["CONS"](l23, n))), CL["APPEND"](l(l24,CL["CONS"](CL["CONS"](CL["MULTIPLE-VALUE-BIND"], CL["CONS"](CL["CONS"](CL_LIB["DUMMIES"], CL["CONS"](CL_LIB["VALS"], CL["CONS"](CL_LIB["NEWVAL"], CL["CONS"](CL_LIB["SETTER"], CL["CONS"](CL_LIB["GETTER"], n))))), CL["CONS"](CL["CONS"](CL_LIB["%GET-SETF-EXPANSION"], CL["CONS"](l22, n)), CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["LET"], n)), CL["CONS"](CL["CONS"](CL["MAPCAR"], CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](CL["LIST"], n)), CL["CONS"](CL_LIB["DUMMIES"], CL["CONS"](CL_LIB["VALS"], n)))), CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["DESTRUCTURING-BIND"], n)), CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l9, n)), CL["CONS"](CL["CONS"](CL["CONS"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["LIST"], n)), CL["CONS"](l23, n))), CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["LET"], n)), CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL["CONS"](CL["CAR"], CL["CONS"](CL_LIB["NEWVAL"], n)), CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["APPLY"], n)), CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["FUNCTION"], n)), CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l13, n)), n))), CL["CONS"](CL_LIB["GETTER"], CL["APPEND"](l(CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l25,  ...)   single_value();  return CL["CONS"](CL["QUOTE"], CL["CONS"](l25, n)) end, 1, 0, false, false), l(CL_LIB["GEN-PARAMS"](l9, false))),n)))))), n))), n)), CL["CONS"](CL_LIB["SETTER"], n)))), n))))), n)))), n)))), n)))))), n))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%IS-SETF-FUNCTION-DEFINED"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["CONSP"](l1) then  l2 = CL["FBOUNDP"](CL["CONS"](CL["SETF"], CL["CONS"]((l1)[1], n))) else  l2 = n.bound end return l2 end, 1, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["%SETF-ONE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G85491"],{CL["&OPTIONAL"],{LCL["NIL"]["G85492"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  single_value();  local l13 = n if n ~= CL_LIB["%IS-SETF-FUNCTION-DEFINED"](l5) then  l13 = CL["CONS"](CL["FUNCALL"], CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](CL["CONS"](CL["SETF"], CL["CONS"]((l5)[1], n)), n)), CL["CONS"](l9, CL["APPEND"](l((l5)[2],n))))) else  local l14 = n.bound; local l15 = n.bound; local l16 = n.bound; local l17 = n.bound; local l18 = n.bound; local l19 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l20 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l22 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l21 = l22; single_value();  single_value();  l14,l15,l16,l17,l18= unpack_mv(CL_LIB["%GET-SETF-EXPANSION"](l5, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l19 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l20.error ~= n and true then if l20.error == KEYWORD.TAG then  error(l20) else error(l20[1]) end end i( CL["VALUES-LIST"](list_r(l20)) );
 single_value();  l13 = CL["CONS"](CL["LET*"], CL["CONS"](CL["REVERSE"](CL["MAPCAR"](CL["LIST"].fbound, l(l14,l15))), CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"]((l16)[1], CL["CONS"](l9, n)), n), CL["CONS"](l17, n))), n))) end return l13 end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["%DEFUN-SETF"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G85611"],{CL["&OPTIONAL"],{LCL["NIL"]["G85612"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  single_value();  return CL["CONS"](CL["DEFINE-SETF-EXPANDER"], CL["CONS"](l5, CL["CONS"](CL["CONS"](CL["&REST"], CL["CONS"](CL_LIB["X"], n)), CL["CONS"](CL["CONS"](CL["MULTIPLE-VALUE-BIND"], CL["CONS"](CL["CONS"](CL_LIB["DUMMIES"], CL["CONS"](CL_LIB["VALS"], CL["CONS"](CL_LIB["NEWVAL"], CL["CONS"](CL_LIB["SETTERS"], CL["CONS"](CL_LIB["GETTER"], n))))), CL["CONS"](CL["CONS"](CL_LIB["GET-SETF-ALL-EXPANSION"], CL["CONS"](CL_LIB["X"], n)), CL["CONS"](CL["CONS"](CL["MULTIPLE-VALUE-BIND"], CL["CONS"](CL["CONS"](CL_LIB["SYMS"], CL["CONS"](CL_LIB["DUMMIES-GET"], CL["CONS"](CL_LIB["VALS-GET"], n))), CL["CONS"](CL["CONS"](CL_LIB["GEN-SYM-ALL-GETTERS"], CL["CONS"](CL_LIB["GETTER"], CL["CONS"](CL_LIB["DUMMIES"], CL["CONS"](CL_LIB["VALS"], n)))), CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](CL_LIB["STORE"], CL["CONS"](CL["CONS"](CL["GENSYM"], n), n)), n), CL["CONS"](CL["CONS"](CL["VALUES"], CL["CONS"](CL_LIB["DUMMIES-GET"], CL["CONS"](CL_LIB["VALS-GET"], CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL_LIB["STORE"], n)), CL["CONS"](CL["CONS"](CL["APPEND"], CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["FUNCALL"], n)), CL["CONS"](CL["CONS"](CL["LIST*"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["LAMBDA"], n)), CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l9, n)), CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l13, n)), n)))), n))), CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL_LIB["STORE"], n)), CL["CONS"](CL_LIB["SYMS"], n)))), CL["CONS"](CL["CONS"](CL["APPEND"], CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), n)), CL["CONS"](CL_LIB["SYMS"], n))), n)))))), n))), n)))), n)))), n)))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DEFUN"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G85752"],{CL["&OPTIONAL"],{LCL["NIL"]["G85753"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  single_value();  return CL["CONS"](CL["SETQ"], CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](l5, n)), CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](CL["CONS"](CL_LIB["NLAMBDA"], CL["CONS"](l5, CL["CONS"](l9, CL["APPEND"](l(l13,n))))), n)), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["SETF"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G85834"],{CL["&OPTIONAL"],{LCL["NIL"]["G85835"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = (l5)[1]; local l7 = CL["CADR"](l5); local l8 = CL["CDDR"](l5); single_value();  local l9 = n if n ~= l8 then  l9 = CL["LIST"](l(CL["CONS"](CL["SETF"], CL["APPEND"](l(l8,n))))) else  l9 = n.bound end return CL["CONS"](CL["PROGN"], CL["CONS"](CL["CONS"](CL_LIB["%SETF-ONE"], CL["CONS"](l6, CL["CONS"](l7, n))), CL["APPEND"](l(l9,n)))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["PSETF"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G85879"],{CL["&OPTIONAL"],{LCL["NIL"]["G85880"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = n.bound; local l7 = n.bound; local l8 = CL_LIB["GROUP"](l5); single_value();  local l9 = (l8)[1]; single_value();  single_value();  local l10 = CL["GENSYM"](false); single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l12 = n if n ~= CL["NOT"](l8) then  single_value(); do break end; l12 = n.bound else  l12 = n.bound end i( l12 );
 local l13 = CL["GENSYM"](false); single_value();  single_value();  local l14 = CL["CONS"](CL["LIST"](l(l13,(l9)[2])), l6); single_value();  l6 = l14 i( l6 );
 single_value();  single_value();  local l15 = CL["CONS"](l13, l7); single_value();  l7 = l15 i( l7 );
 single_value();  single_value();  single_value();  local l16 = CL["CONS"]((l9)[1], l7); single_value();  l7 = l16 i( l7 );
 single_value();  single_value();  local l17 = (l8)[2]; single_value();  l8 = l17 i( l8 );
 single_value();  single_value();  single_value();  local l18 = (l8)[1]; single_value();  l9 = l18 local tmpres = l9 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l11.error ~= n and (l11.error ~= KEYWORD.TAG or l11.tag ~= l10) then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end i( CL["VALUES-LIST"](list_r(l11)) );
 single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["REVERSE"](l6), CL["CONS"](CL["CONS"](CL["SETF"], CL["APPEND"](l(l7,n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["PSETQ"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G86011"],{CL["&OPTIONAL"],{LCL["NIL"]["G86012"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  return CL["CONS"](CL["PSETF"], CL["APPEND"](l(l5,n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["INCF"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G86042"],{CL["&OPTIONAL"],{LCL["NIL"]["G86043"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = n if n ~= l4 then  local l11 = l4; single_value();  local l12 = (l11)[1]; single_value();  single_value();  local l13 = (l11)[2]; single_value();  l4 = l13 i( l4 );
 single_value();  l10 = l12 else  l10 = 1 end local l9 = l10; single_value();  single_value();  local l14 = n.bound; local l15 = n.bound; local l16 = n.bound; local l17 = n.bound; local l18 = n.bound; local l19 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l20 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l22 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l21 = l22; single_value();  single_value();  l14,l15,l16,l17,l18= unpack_mv(CL_LIB["%GET-SETF-EXPANSION"](l5, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l19 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l20.error ~= n and true then if l20.error == KEYWORD.TAG then  error(l20) else error(l20[1]) end end i( CL["VALUES-LIST"](list_r(l20)) );
 single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["MAPCAR"](CL["LIST"].fbound, l(l14,l15)), CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"]((l16)[1], CL["CONS"](CL["CONS"](CL["+"], CL["CONS"](l9, CL["CONS"](l18, n))), n)), n), CL["CONS"](l17, n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DECF"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G86155"],{CL["&OPTIONAL"],{LCL["NIL"]["G86156"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = n if n ~= l4 then  local l11 = l4; single_value();  local l12 = (l11)[1]; single_value();  single_value();  local l13 = (l11)[2]; single_value();  l4 = l13 i( l4 );
 single_value();  l10 = l12 else  l10 = 1 end local l9 = l10; single_value();  single_value();  return CL["CONS"](CL["INCF"], CL["CONS"](l5, CL["CONS"](CL["CONS"](CL["-"], CL["CONS"](l9, n)), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["ROTATEF"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G86229"],{CL["&OPTIONAL"],{LCL["NIL"]["G86230"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = n if n ~= l5 then  local l7 = n.bound; single_value();  local l8 = CL["REDUCE"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["CODE"],{CL_LIB["NEXT-PLACE"],n}},function (l9, l10,  ...)   single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = n.bound; local l15 = n.bound; local l16 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l17 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l19 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l18 = l19; single_value();  single_value();  l11,l12,l13,l14,l15= unpack_mv(CL_LIB["%GET-SETF-EXPANSION"](l10, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l16 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l17.error ~= n and true then if l17.error == KEYWORD.TAG then  error(l17) else error(l17[1]) end end i( CL["VALUES-LIST"](list_r(l17)) );
 l7 = CL["CONS"](CL["LIST"](l((l13)[1],l15,l14)), l7) i( l7 );
 single_value();  return CL_LIB["ALLOC-FUNCTION"]({CL_LIB["INSIDE"],n},function (l20,  ...)   single_value();  local l21 = CL["CONS"](CL["LET"], CL["CONS"](CL["MAPCAR"](CL["LIST"].fbound, l(l11,l12)), CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](l13, CL["CONS"](l20, n))), n))); single_value();  return CL_LIB['FUNCALL-LUA'](l9,{l21, }) end, 1, 0, false, false) end, 2, 0, false, false), l5, k(CL_LIB["INITIAL-VALUE"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l22,  ...)   single_value();  return l22 end, 1, 0, false, false))); single_value();  single_value();  local l24 = CL["MAPCAR"](CL["CAR"].fbound, l(l7)); single_value();  local l25 = CL["APPEND"](l((l24)[2],CL["LIST"](l((l24)[1])))); single_value();  local l26 = CL["MAPCAR"](CL["CADR"].fbound, l(l7)); single_value();  single_value();  local l23 = CL["CONS"](CL["PROGN"], CL["APPEND"](l(CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["VAR"],{CL_LIB["VAL"],n}},function (l27, l28,  ...)   single_value();  return CL["CONS"](CL["SETQ"], CL["CONS"](l27, CL["CONS"](l28, n))) end, 2, 0, false, false), l(l25,l26)),CL["APPEND"](l(CL["MAPCAR"](CL["CADDR"].fbound, l(l7)),CL["CONS"](n, n)))))); single_value();  l6 = CL_LIB['FUNCALL-LUA'](l8,{l23, }) else  l6 = n.bound end return l6 end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["SHIFTF"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G86376"],{CL["&OPTIONAL"],{LCL["NIL"]["G86377"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = n if n ~= CL_LIB["%<"](CL["LENGTH"](l5), 2) then  l6 = CL["ERROR"]("SHIFTF requires at least two arguments", l()) else  local l7 = CL["GENSYM"](false); single_value();  l6 = CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l7, CL["CONS"]((CL["LAST"](l5, false))[1], n)), n), CL["CONS"](CL["CONS"](CL["ROTATEF"], CL["APPEND"](l(CL["BUTLAST"](l5, false),CL["CONS"](l7, n)))), CL["CONS"](l7, n)))) end return l6 end, 1, 1, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["MACRO-SETQ"](CL["GO"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G88976"],{CL["&OPTIONAL"],{LCL["NIL"]["G88977"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  single_value();  local l9 = CL_LIB["GO-TO-TAGNAME"](l5); single_value();  return CL["CONS"](CL["THROW"], CL["CONS"](l9, CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](l9, n)), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["TAGBODY"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G89032"],{CL["&OPTIONAL"],{LCL["NIL"]["G89033"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = n if n ~= CL["SOME"](CL["SYMBOLP"].fbound, l(l5)) then  local l7 = CL["GENSYM"](false); single_value();  local l8 = CL["GENSYM"](false); single_value();  local l9 = CL["GENSYM"](false); single_value();  local l10 = CL["MAPCON"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SEQ"],n},function (l11,  ...)   single_value();  local l12 = (l11)[1]; local l13 = (l11)[2]; single_value();  local l14 = n if n ~= CL["ATOM"](l12) then  single_value();  local l15 = CL["POSITION-IF"](CL["ATOM"].fbound, l13, k()); single_value();  local l16 = l15; single_value();  local l17 = n if n ~= l16 then  l17 = l16 else  l17 = CL["LENGTH"](l13) end local l18 = n if n ~= l15 then  l18 = CL["CONS"](CL_LIB["GO-TO-TAGNAME"](CL["ELT"](l13, l15)), n) else  l18 = CL["CONS"](CL["THROW"], CL["CONS"](l9, CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](n, n)), n))) end l14 = CL["CONS"](CL["CONS"](CL_LIB["GO-TO-TAGNAME"](l12), CL["CONS"](n, CL["APPEND"](l(CL["SUBSEQ"](l13, 0, l17),CL["CONS"](l18, n))))), n) else  l14 = n.bound end return l14 end, 1, 0, false, false), l(CL["CONS"](l7, CL["APPEND"](l(l5,n))))); single_value();  single_value();  l6 = CL["CONS"](CL["LET*"], CL["CONS"](CL["CONS"](CL["CONS"](l8, CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](n, n)), n)), CL["CONS"](CL["CONS"](l9, CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](n, n)), n)), CL["APPEND"](l(CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["F"],n},function (l19,  ...)   single_value();  return CL["CONS"]((l19)[1], CL["CONS"](l8, n)) end, 1, 0, false, false), l(l10)),n)))), CL["CONS"](CL["CONS"](CL["CATCH"], CL["CONS"](l9, CL["CONS"](CL["CONS"](CL["LABELS"], CL["CONS"](l10, CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](CL_LIB["NXT-LABEL"], CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](CL["CAAR"](l10), n)), n)), n), CL["CONS"](CL["CONS"](CL_LIB["%LOOP"], CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](CL_LIB["NXT-LABEL"], CL["CONS"](CL["CONS"](CL["CATCH"], CL["CONS"](l8, CL["CONS"](CL["CONS"](CL["FUNCALL"], CL["CONS"](CL_LIB["NXT-LABEL"], n)), n))), n))), n)), n))), n))), n))), n))) else  l6 = CL["CONS"](CL["PROGN"], CL["APPEND"](l(l5,n))) end return l6 end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["DO-TYPE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G89179"],{CL["&OPTIONAL"],{LCL["NIL"]["G89180"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l14 = l4; single_value();  local l15 = (l14)[1]; single_value();  single_value();  local l16 = (l14)[2]; single_value();  l4 = l16 i( l4 );
 single_value();  local l13 = l15; single_value();  local l18 = l4; single_value();  local l19 = (l18)[1]; single_value();  single_value();  local l20 = (l18)[2]; single_value();  l4 = l20 i( l4 );
 single_value();  local l17 = l19; single_value();  local l21 = l4; single_value();  single_value();  local l22 = (l17)[1]; local l23 = (l17)[2]; local l24 = CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l25,  ...)   single_value();  return CL["LIST"](l((l25)[1],CL["CADR"](l25))) end, 1, 0, false, false), l(l13)); local l26 = n.bound; single_value();  single_value();  local l27 = CL["CONS"](l9, l26); single_value();  l26 = l27 i( l26 );
 local l28 = l13; single_value();  local l29 = (l28)[1]; single_value();  single_value();  local l30 = CL["GENSYM"](false); single_value();  local l31 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l32 = n if n ~= CL["NOT"](l28) then  single_value(); do break end; l32 = n.bound else  l32 = n.bound end i( l32 );
 single_value();  single_value();  local l33 = CL["CONS"]((l29)[1], l26); single_value();  l26 = l33 i( l26 );
 single_value();  single_value();  local l34 = CL["CONS"](CL["CADDR"](l29), l26); single_value();  l26 = l34 i( l26 );
 single_value();  single_value();  local l35 = (l28)[2]; single_value();  l28 = l35 i( l28 );
 single_value();  single_value();  single_value();  local l36 = (l28)[1]; single_value();  l29 = l36 local tmpres = l29 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l31.error ~= n and (l31.error ~= KEYWORD.TAG or l31.tag ~= l30) then if l31.error == KEYWORD.TAG then  error(l31) else error(l31[1]) end end i( CL["VALUES-LIST"](list_r(l31)) );
 single_value();  return CL["CONS"](l5, CL["CONS"](l24, CL["CONS"](CL["CONS"](CL["BLOCK"], CL["CONS"](n, CL["CONS"](CL["CONS"](CL_LIB["%LOOP"], CL["CONS"](CL["CONS"](CL["WHEN"], CL["CONS"](l22, CL["CONS"](CL["CONS"](CL_LIB["%BREAK"], n), n))), CL["APPEND"](l(l21,CL["CONS"](CL["REVERSE"](l26), n))))), CL["APPEND"](l(l23,n))))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DO"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G89412"],{CL["&OPTIONAL"],{LCL["NIL"]["G89413"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  single_value();  return CL["CONS"](CL_LIB["DO-TYPE"], CL["CONS"](CL["LET"], CL["CONS"](CL["PSETF"], CL["CONS"](l5, CL["CONS"](l9, CL["APPEND"](l(l13,n))))))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DO*"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G89489"],{CL["&OPTIONAL"],{LCL["NIL"]["G89490"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  single_value();  return CL["CONS"](CL_LIB["DO-TYPE"], CL["CONS"](CL["LET*"], CL["CONS"](CL["SETF"], CL["CONS"](l5, CL["CONS"](l9, CL["APPEND"](l(l13,n))))))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DOLIST"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G89566"],{CL["&OPTIONAL"],{LCL["NIL"]["G89567"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = CL["GENSYM"](false); local l11 = (l5)[1]; local l12 = CL["CADR"](l5); local l13 = CL["CADDR"](l5); single_value();  return CL["CONS"](CL["DO*"], CL["CONS"](CL["CONS"](CL["CONS"](l10, CL["CONS"](l12, CL["CONS"](CL["CONS"](CL["CDR"], CL["CONS"](l10, n)), n))), CL["CONS"](CL["CONS"](l11, CL["CONS"](CL["CONS"](CL["CAR"], CL["CONS"](l10, n)), CL["CONS"](CL["CONS"](CL["CAR"], CL["CONS"](l10, n)), n))), n)), CL["CONS"](CL["CONS"](CL["CONS"](CL["NOT"], CL["CONS"](l10, n)), CL["CONS"](l13, n)), CL["APPEND"](l(l9,n))))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DOTIMES"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G89644"],{CL["&OPTIONAL"],{LCL["NIL"]["G89645"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = (l5)[1]; local l11 = CL["CADR"](l5); local l12 = CL["CADDR"](l5); single_value();  return CL["CONS"](CL["DO"], CL["CONS"](CL["CONS"](CL["CONS"](l10, CL["CONS"](0, CL["CONS"](CL["CONS"](CL["+"], CL["CONS"](1, CL["CONS"](l10, n))), n))), n), CL["CONS"](CL["CONS"](CL["CONS"](CL[">="], CL["CONS"](l10, CL["CONS"](l11, n))), CL["CONS"](l12, n)), CL["APPEND"](l(l9,n))))) end, 1, 1, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%ADJUST-ARRAY"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],{CL_LIB["NEW-DIMENSIONS"],n}},function (l1, l2,  ...)   i( "Change the dimensions of an array" );
 single_value();  local l4 = n if n ~= CL["CONSP"](l2) then  l4 = l2 else  l4 = CL["LIST"](l(l2)) end local l3 = l4; single_value(); l1[CL["IDENTITY"]("dim")] = l3 return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ADJUST-ARRAY"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],{CL_LIB["NEW-DIMENSIONS"],{CL["&KEY"],{{CL_LIB["ELEMENT-TYPE"],{CL["T"],n}},{{CL_LIB["INITIAL-ELEMENT"],{0,n}},{CL_LIB["INITIAL-CONTENTS"],{CL["FILL-POINTER"],{CL_LIB["DISPLACED-TO"],{{CL_LIB["DISPLACED-INDEX-OFFSET"],{0,n}},n}}}}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["ELEMENT-TYPE"]] then  keys[CL_LIB["ELEMENT-TYPE"]] = CL["T"].bound end if not keys[CL_LIB["INITIAL-ELEMENT"]] then  keys[CL_LIB["INITIAL-ELEMENT"]] = 0 end if not keys[CL_LIB["INITIAL-CONTENTS"]] then  keys[CL_LIB["INITIAL-CONTENTS"]] = n.bound end if not keys[CL["FILL-POINTER"]] then  keys[CL["FILL-POINTER"]] = n.bound end if not keys[CL_LIB["DISPLACED-TO"]] then  keys[CL_LIB["DISPLACED-TO"]] = n.bound end if not keys[CL_LIB["DISPLACED-INDEX-OFFSET"]] then  keys[CL_LIB["DISPLACED-INDEX-OFFSET"]] = 0 end  i( CL_LIB["%ADJUST-ARRAY"](l1, l2) );
 local l3 = keys[CL_LIB["ELEMENT-TYPE"]]; single_value(); l1[CL["IDENTITY"]("type")] = l3 i( l3 );
 local l4 = keys[CL_LIB["INITIAL-ELEMENT"]]; single_value(); l1[CL["IDENTITY"]("default")] = l4 i( l4 );
 local l5 = keys[CL["FILL-POINTER"]]; single_value(); l1[CL["IDENTITY"]("fp")] = l5 i( l5 );
 local l6 = n if n ~= keys[CL_LIB["DISPLACED-TO"]] then  local l7 = n if n ~= CL["ARRAYP"](keys[CL_LIB["DISPLACED-TO"]]) then  l7 = n.bound else  single_value();  l7 = CL["ERROR"]("adjust-array", l()) end i( l7 );
 local l8 = keys[CL_LIB["DISPLACED-INDEX-OFFSET"]]; single_value(); l1[CL["IDENTITY"]("offset")] = l8 i( l8 );
 local l10 = "data"; local l11 = n.bound; single_value();  local l9 = ((keys[CL_LIB["DISPLACED-TO"]])[l10] or l11); single_value(); l1[CL["IDENTITY"]("data")] = l9 i( l9 );
 single_value();  local l12 = keys[CL_LIB["DISPLACED-TO"]]; single_value(); l1[CL["IDENTITY"]("disp")] = l12 l6 = l12 else  local l13 = n.bound; single_value(); l1[CL["IDENTITY"]("disp")] = l13 i( l13 );
 local l14 = 0; single_value(); l1[CL["IDENTITY"]("offset")] = l14 i( l14 );
 single_value();  local l15 = {}; single_value(); l1[CL["IDENTITY"]("data")] = l15 l6 = l15 end i( l6 );
 single_value();  return l1 end, 2, 0, false, {0 , [LCL["KEYWORD"]["ELEMENT-TYPE"]] = CL_LIB["ELEMENT-TYPE"], [LCL["KEYWORD"]["INITIAL-ELEMENT"]] = CL_LIB["INITIAL-ELEMENT"], [LCL["KEYWORD"]["INITIAL-CONTENTS"]] = CL_LIB["INITIAL-CONTENTS"], [LCL["KEYWORD"]["FILL-POINTER"]] = CL["FILL-POINTER"], [LCL["KEYWORD"]["DISPLACED-TO"]] = CL_LIB["DISPLACED-TO"], [LCL["KEYWORD"]["DISPLACED-INDEX-OFFSET"]] = CL_LIB["DISPLACED-INDEX-OFFSET"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAKE-ARRAY"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["DIMENSIONS"],{CL["&KEY"],{{CL_LIB["ELEMENT-TYPE"],{CL["T"],n}},{{CL_LIB["INITIAL-ELEMENT"],{0,n}},{CL_LIB["INITIAL-CONTENTS"],{CL_LIB["ADJUSTABLE"],{CL["FILL-POINTER"],{CL_LIB["DISPLACED-TO"],{{CL_LIB["DISPLACED-INDEX-OFFSET"],{0,n}},n}}}}}}}}},function (l1, keys,  ...)  if not keys[CL_LIB["ELEMENT-TYPE"]] then  keys[CL_LIB["ELEMENT-TYPE"]] = CL["T"].bound end if not keys[CL_LIB["INITIAL-ELEMENT"]] then  keys[CL_LIB["INITIAL-ELEMENT"]] = 0 end if not keys[CL_LIB["INITIAL-CONTENTS"]] then  keys[CL_LIB["INITIAL-CONTENTS"]] = n.bound end if not keys[CL_LIB["ADJUSTABLE"]] then  keys[CL_LIB["ADJUSTABLE"]] = n.bound end if not keys[CL["FILL-POINTER"]] then  keys[CL["FILL-POINTER"]] = n.bound end if not keys[CL_LIB["DISPLACED-TO"]] then  keys[CL_LIB["DISPLACED-TO"]] = n.bound end if not keys[CL_LIB["DISPLACED-INDEX-OFFSET"]] then  keys[CL_LIB["DISPLACED-INDEX-OFFSET"]] = 0 end  single_value();  local l2 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-ARRAY"].fbound, {}); i( CL["ADJUST-ARRAY"](l2, l1, k(CL_LIB["ELEMENT-TYPE"], keys[CL_LIB["ELEMENT-TYPE"]], CL_LIB["INITIAL-ELEMENT"], keys[CL_LIB["INITIAL-ELEMENT"]], CL_LIB["INITIAL-CONTENTS"], keys[CL_LIB["INITIAL-CONTENTS"]], CL["FILL-POINTER"], keys[CL["FILL-POINTER"]], CL_LIB["DISPLACED-TO"], keys[CL_LIB["DISPLACED-TO"]], CL_LIB["DISPLACED-INDEX-OFFSET"], keys[CL_LIB["DISPLACED-INDEX-OFFSET"]])) );
 single_value();  return l2 end, 1, 0, false, {0 , [LCL["KEYWORD"]["ELEMENT-TYPE"]] = CL_LIB["ELEMENT-TYPE"], [LCL["KEYWORD"]["INITIAL-ELEMENT"]] = CL_LIB["INITIAL-ELEMENT"], [LCL["KEYWORD"]["INITIAL-CONTENTS"]] = CL_LIB["INITIAL-CONTENTS"], [LCL["KEYWORD"]["ADJUSTABLE"]] = CL_LIB["ADJUSTABLE"], [LCL["KEYWORD"]["FILL-POINTER"]] = CL["FILL-POINTER"], [LCL["KEYWORD"]["DISPLACED-TO"]] = CL_LIB["DISPLACED-TO"], [LCL["KEYWORD"]["DISPLACED-INDEX-OFFSET"]] = CL_LIB["DISPLACED-INDEX-OFFSET"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["ARRAY-DIMENSION"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],{CL_LIB["N"],n}},function (l1, l2,  ...)   single_value();  return CL["NTH"](l2, CL["ARRAY-DIMENSIONS"](l1)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ARRAY-DIMENSIONS"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],n},function (l1,  ...)   local l2 = n if n ~= CL["TYPEP"](l1, CL["ARRAY"], false) then  l2 = n.bound else  single_value();  l2 = CL["ERROR"](CL["TYPE-ERROR"], l(LCL["KEYWORD"]["FORM"],CL["ARRAY"],LCL["KEYWORD"]["DATUM"],l1,LCL["KEYWORD"]["EXPECTED-TYPE"],CL["ARRAY"])) end i( l2 );
 single_value();  local l3 = n if n ~= CL_LIB["%STRINGP"](l1) then  l3 = CL["LIST"](l(CL_LIB["%LEN"](l1))) else  local l4 = "dim"; local l5 = n.bound; single_value();  l3 = ((l1)[l4] or l5) end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ARRAY-DISPLACEMENT"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["ARRAYP"](l1) then  local l3 = "disp"; local l4 = n.bound; single_value();  local l5 = "offset"; local l6 = n.bound; single_value();  l2 = CL["VALUES"](l(((l1)[l3] or l4),((l1)[l5] or l6))) else  l2 = CL["ERROR"]("array-displacement, not an array", l()) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ARRAY-ELEMENT-TYPE"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL_LIB["%STRINGP"](l1) then  l2 = CL["CHARACTER"] else  local l3 = "type"; local l4 = n.bound; single_value();  l2 = ((l1)[l3] or l4) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRINGP"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],n},function (l1,  ...)   single_value();  local l2 = CL_LIB["%STRINGP"](l1); single_value();  local l3 = n if n ~= l2 then  l3 = l2 else  local l4 = n if n ~= CL["ARRAYP"](l1) then  l4 = CL["EQ"](CL["CHARACTER"], CL["ARRAY-ELEMENT-TYPE"](l1)) else  l4 = n.bound end l3 = l4 end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ARRAY-RANK"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],n},function (l1,  ...)   single_value();  return CL["LENGTH"](CL["ARRAY-DIMENSIONS"](l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ARRAY-ROW-MAJOR-INDEX"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],{CL["&REST"],{CL_LIB["SUBSCRIPTS"],n}}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["APPLY"](CL_LIB["ARRAY-IN-BOUNDSP"].fbound, l1, l(l2)) then  local l4 = 1; local l5 = 0; local l6 = CL["REVERSE"](l2); local l7 = CL["REVERSE"](CL["ARRAY-DIMENSIONS"](l1)); single_value();  local l8 = (l7)[1]; single_value();  single_value();  local l9 = CL["GENSYM"](false); single_value();  local l10 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l11 = n if n ~= CL["NOT"](l7) then  single_value(); do break end; l11 = n.bound else  l11 = n.bound end i( l11 );
 single_value();  local l12 = (((l6)[1] * l4) + l5); single_value();  l5 = l12 i( l5 );
 l6 = (l6)[2] i( l6 );
 l4 = (l4 * l8) i( l4 );
 single_value();  single_value();  local l13 = (l7)[2]; single_value();  l7 = l13 i( l7 );
 single_value();  single_value();  single_value();  local l14 = (l7)[1]; single_value();  l8 = l14 local tmpres = l8 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l10.error ~= n and (l10.error ~= KEYWORD.TAG or l10.tag ~= l9) then if l10.error == KEYWORD.TAG then  error(l10) else error(l10[1]) end end i( CL["VALUES-LIST"](list_r(l10)) );
 single_value();  l3 = l5 else  l3 = CL["ERROR"]("array-row-major-index, not in bounds", l()) end return l3 end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ARRAY-FIT-REF"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],{CL_LIB["SUB"],n}},function (l1, l2,  ...)   i( "Check if the diven subscripts fit the rank of the array. " );
 local l3 = n if n ~= CL["EQ"](CL["LENGTH"](l2), CL["ARRAY-RANK"](l1)) then  l3 = n.bound else  single_value();  l3 = CL["ERROR"]("Invalid number of subscripts", l()) end i( l3 );
 single_value();  return CL["T"].bound end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ARRAY-IN-BOUNDSP"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],{CL["&REST"],{CL_LIB["SUBSCRIPTS"],n}}},function (l1, l2,  ...)   i( CL_LIB["ARRAY-FIT-REF"](l1, l2) );
 single_value();  return CL["EVERY"](CL["<"].fbound, l(l2,CL["ARRAY-DIMENSIONS"](l1))) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FILL-POINTER"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],n},function (l1,  ...)   single_value();  local l3 = n if n ~= CL["ARRAYP"](l1) then  l3 = CL["ARRAY-HAS-FILL-POINTER-P"](l1) else  l3 = n.bound end local l2 = n if n ~= l3 then  local l4 = "fp"; local l5 = n.bound; single_value();  l2 = ((l1)[l4] or l5) else  l2 = CL["ERROR"]("fill-pointer, array does not have a fill pointer", l()) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ARRAY-HAS-FILL-POINTER-P"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["ARRAYP"](l1) then  local l4 = "fp"; local l5 = n.bound; single_value();  local l3 = n if n ~= ((l1)[l4] or l5) then  l3 = CL["T"].bound else  l3 = n.bound end l2 = l3 else  l2 = CL["ERROR"]("array-has-fill-pointer-p, not an array", l()) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["SET-FILL-POINTER"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],{CL_LIB["FP"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["ARRAY-HAS-FILL-POINTER-P"](l1) then  single_value();  local l4 = l2; single_value(); l1[CL["IDENTITY"]("fp")] = l4 l3 = l4 else  l3 = n.bound end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ARRAY-TOTAL-SIZE"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],n},function (l1,  ...)   single_value();  return CL["APPLY"](CL["*"].fbound, CL["ARRAY-DIMENSIONS"](l1), l()) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ASET"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],{CL_LIB["VALUE"],{CL["&REST"],{CL_LIB["SUBSCRIPTS"],n}}}},function (l1, l2, l3,  ...)   single_value();  local l5 = "offset"; local l6 = n.bound; single_value();  local l4 = (CL["APPLY"](CL["ARRAY-ROW-MAJOR-INDEX"].fbound, l1, l(l3)) + ((l1)[l5] or l6)); single_value();  local l7 = l2; single_value();  local l8 = "data"; local l9 = n.bound; single_value(); ((l1)[l8] or l9)[CL["IDENTITY"](l4)] = l7 return l7 end, 2, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%RAW-AREF"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],{CL_LIB["IX"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL_LIB["%STRINGP"](l1) then  l3 = CL["CHAR"](l1, l2) else  local l4 = l2; local l6 = "default"; local l7 = n.bound; single_value();  local l5 = ((l1)[l6] or l7); single_value();  local l8 = "data"; local l9 = n.bound; single_value();  l3 = ((((l1)[l8] or l9))[l4] or l5) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["AREF"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],{CL["&REST"],{CL_LIB["SUBSCRIPTS"],n}}},function (l1, l2,  ...)   single_value();  local l4 = "offset"; local l5 = 0; single_value();  local l3 = (CL["APPLY"](CL["ARRAY-ROW-MAJOR-INDEX"].fbound, l1, l(l2)) + ((l1)[l4] or l5)); single_value();  return CL_LIB["%RAW-AREF"](l1, l3) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ROW-MAJOR-ASET"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],{CL_LIB["INDEX"],{CL_LIB["VALUE"],n}}},function (l1, l2, l3,  ...)   single_value();  local l5 = "offset"; local l6 = 0; single_value();  local l4 = (l2 + ((l1)[l5] or l6)); single_value();  local l7 = l3; single_value();  local l8 = "data"; local l9 = n.bound; single_value(); ((l1)[l8] or l9)[CL["IDENTITY"](l4)] = l7 return l7 end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ROW-MAJOR-AREF"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],{CL_LIB["INDEX"],n}},function (l1, l2,  ...)   single_value();  local l4 = "offset"; local l5 = 0; single_value();  local l3 = (l2 + ((l1)[l4] or l5)); single_value();  return CL_LIB["%RAW-AREF"](l1, l3) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["COPY-ARRAY"] , CL_LIB["ALLOC-FUNCTION"]({CL["ARRAY"],n},function (l1,  ...)   single_value();  local l3 = n if n ~= CL["ARRAY-HAS-FILL-POINTER-P"](l1) then  l3 = CL["FILL-POINTER"](l1) else  l3 = n.bound end local l2 = CL["MAKE-ARRAY"](CL["ARRAY-DIMENSIONS"](l1), k(CL_LIB["ELEMENT-TYPE"], CL["ARRAY-ELEMENT-TYPE"](l1), CL["FILL-POINTER"], l3)); local l4 = 0; local l5 = CL["ARRAY-TOTAL-SIZE"](l1); while true do  local l6 = n if n ~= CL_LIB["%<"](l4, l5) then  l6 = n.bound else  single_value(); do break end; l6 = n.bound end i( l6 );
 i( CL_LIB["ROW-MAJOR-ASET"](l2, l4, CL["ROW-MAJOR-AREF"](l1, l4)) );
 single_value();  l4 = (1 + l4) local tmpres = l4 end i( n );
 single_value();  return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL_LIB["INDEX"],n}},function (l1, l2,  ...)   local l3 = n if n ~= CL["TYPEP"](l1, CL["STRING"], false) then  l3 = n.bound else  single_value();  l3 = CL["ERROR"](CL["TYPE-ERROR"], l(LCL["KEYWORD"]["FORM"],CL["STRING"],LCL["KEYWORD"]["DATUM"],l1,LCL["KEYWORD"]["EXPECTED-TYPE"],CL["STRING"])) end i( l3 );
 single_value();  local l4 = n if n ~= CL_LIB["%STRINGP"](l1) then  l4 = CL_LIB["%CHAR"](l1, l2) else  l4 = CL["AREF"](l1, l(l2)) end return l4 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["VECTORP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["V"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["ARRAYP"](l1) then  l2 = CL["EQ"](1, CL["ARRAY-RANK"](l1)) else  l2 = n.bound end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["VECTOR-PUSH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-ELEMENT"],{CL["VECTOR"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["VECTORP"](l2) then  local l4 = CL["FILL-POINTER"](l2); single_value();  local l5 = n if n ~= CL_LIB["ARRAY-IN-BOUNDSP"](l2, l(l4)) then  i( CL_LIB["ASET"](l2, l1, l(l4)) );
 i( CL_LIB["SET-FILL-POINTER"](l2, (l4 + 1)) );
 single_value();  l5 = l4 else  l5 = n.bound end l3 = l5 else  l3 = CL["ERROR"]("vector-push, not a vector", l()) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["VECTOR-PUSH-EXTEND"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-ELEMENT"],{CL["VECTOR"],{CL["&OPTIONAL"],{{CL_LIB["EXTENSION"],{128,n}},n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = 128 end  local l5 = n if n ~= CL["VECTORP"](l2) then  l5 = CL["NOT"](CL_LIB["ARRAY-IN-BOUNDSP"](l2, l(CL["FILL-POINTER"](l2)))) else  l5 = n.bound end local l4 = n if n ~= l5 then  single_value();  l4 = CL_LIB["%ADJUST-ARRAY"](l2, CL["MAX"](l((1 + CL["FILL-POINTER"](l2)),(CL["ARRAY-TOTAL-SIZE"](l2) + l3)))) else  l4 = n.bound end i( l4 );
 single_value();  return CL["VECTOR-PUSH"](l1, l2) end, 2, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["VECTOR-POP"] , CL_LIB["ALLOC-FUNCTION"]({CL["VECTOR"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["VECTORP"](l1) then  local l3 = n if n ~= CL[">"](l(CL["FILL-POINTER"](l1),0)) then  i( CL_LIB["SET-FILL-POINTER"](l1, (CL["FILL-POINTER"](l1) - 1)) );
 single_value();  l3 = CL["AREF"](l1, l(CL["FILL-POINTER"](l1))) else  l3 = CL["ERROR"]("vector-pop, no elements left", l()) end l2 = l3 else  l2 = CL["ERROR"]("vector-pop, not a vector", l()) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAKE-STRING"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SIZE"],{CL["&KEY"],{{CL_LIB["INITIAL-ELEMENT"],{LCL['CL-LIB']['MAKE-CHAR'](" "),n}},{CL_LIB["ELEMENT-TYPE"],n}}}},function (l1, keys,  ...)  if not keys[CL_LIB["INITIAL-ELEMENT"]] then  keys[CL_LIB["INITIAL-ELEMENT"]] = LCL['CL-LIB']['MAKE-CHAR'](" ") end if not keys[CL_LIB["ELEMENT-TYPE"]] then  keys[CL_LIB["ELEMENT-TYPE"]] = n.bound end  single_value();  return CL["FUNCALL"](string.rep, l(CL["STRING"](keys[CL_LIB["INITIAL-ELEMENT"]]),l1)) end, 1, 0, false, {0 , [LCL["KEYWORD"]["INITIAL-ELEMENT"]] = CL_LIB["INITIAL-ELEMENT"], [LCL["KEYWORD"]["ELEMENT-TYPE"]] = CL_LIB["ELEMENT-TYPE"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%LISP-STRING"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],n},function (l1,  ...)   i( "Convert the string to a lisp-string. If the string is already a lisp string,\nthis is a no-op but this will convert to an array if the string is a raw lisp string." );
 single_value();  local l2 = n if n ~= CL_LIB["%STRINGP"](l1) then  single_value();  l2 = CL["COPY-SEQ"](l1) else  local l3 = n if n ~= CL["STRINGP"](l1) then  single_value();  l3 = l1 else  local l4 = n if n ~= CL["T"].bound then  single_value();  l4 = CL["ERROR"]("%lisp-string: ~A is not a string.", l(l1)) else  l4 = n.bound end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%LUA-STRING"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],n},function (l1,  ...)   i( "Convert the string to a lua-string. In most cases this will be a no-op, but\nthis will convert vectors of characters to printable strings." );
 single_value();  local l2 = n if n ~= CL_LIB["%STRINGP"](l1) then  single_value();  l2 = l1 else  local l3 = n if n ~= CL["STRINGP"](l1) then  single_value();  l3 = CL["REDUCE"](CL_LIB["CONCAT-STRING"].fbound, CL["MAP"](CL["LIST"], CL_LIB["CHAR-STRING"].fbound, l(l1)), k()) else  local l4 = n if n ~= CL["T"].bound then  single_value();  l4 = CL["ERROR"]("%lua-string: ~A is not a string", l(l1)) else  l4 = n.bound end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["FUNCTION-SETQ"](CL["SVREF"] , CL_LIB["ALLOC-FUNCTION"]({CL["VECTOR"],{CL_LIB["INDEX"],n}},function (l1, l2,  ...)   single_value();  return CL["AREF"](l1, l(l2)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SETSVREF"] , CL_LIB["ALLOC-FUNCTION"]({CL["VECTOR"],{CL_LIB["INDEX"],{CL_LIB["NEW-VALUE"],n}}},function (l1, l2, l3,  ...)   single_value();  return CL_LIB["ASET"](l1, l3, l(l2)) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ELT"] , CL_LIB["ALLOC-FUNCTION"]({CL["SEQUENCE"],{CL_LIB["INDEX"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["LISTP"](l1) then  single_value();  l3 = CL["NTH"](l2, l1) else  local l4 = n if n ~= CL["STRINGP"](l1) then  single_value();  l4 = CL["CHAR"](l1, l2) else  local l5 = n if n ~= CL["VECTORP"](l1) then  single_value();  l5 = CL["AREF"](l1, l(l2)) else  l5 = n.bound end l4 = l5 end l3 = l4 end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SETELT"] , CL_LIB["ALLOC-FUNCTION"]({CL["SEQUENCE"],{CL_LIB["INDEX"],{CL_LIB["NEW-VALUE"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = n if n ~= CL["LISTP"](l1) then  single_value();  local l5 = n if n ~= CL_LIB["%<"](l2, CL["LENGTH"](l1)) then  l5 = CL["RPLACA"](CL["NTHCDR"](l2, l1), l3) else  l5 = CL["ERROR"]("setting element, out of bounds", l()) end l4 = l5 else  local l6 = n if n ~= CL["VECTORP"](l1) then  single_value();  l6 = CL_LIB["ASET"](l1, l3, l(l2)) else  local l7 = n if n ~= CL["T"].bound then  single_value();  l7 = CL["ERROR"]("setting element, not a sequence", l()) else  l7 = n.bound end l6 = l7 end l4 = l6 end return l4 end, 3, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["DO-FROM-TO"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G95519"],{CL["&OPTIONAL"],{LCL["NIL"]["G95520"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = (l5)[1]; local l11 = CL["CADR"](l5); local l12 = CL["CADDR"](l5); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l10, CL["CONS"](l11, n)), n), CL["CONS"](CL["CONS"](CL_LIB["%LOOP"], CL["CONS"](CL["CONS"](CL["WHEN"], CL["CONS"](CL["CONS"](CL[">="], CL["CONS"](l10, CL["CONS"](l12, n))), CL["CONS"](CL["CONS"](CL_LIB["%BREAK"], n), n))), CL["APPEND"](l(l9,CL["CONS"](CL["CONS"](CL["INCF"], CL["CONS"](l10, n)), n))))), n))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FILL"] , CL_LIB["ALLOC-FUNCTION"]({CL["SEQUENCE"],{CL_LIB["ITEM"],{CL["&KEY"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],n}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end  local l3 = n if n ~= keys[CL_LIB["END"]] then  l3 = n.bound else  single_value();  single_value();  single_value();  local l4 = CL["LENGTH"](l1); single_value();  keys[CL_LIB["END"]] = l4 l3 = keys[CL_LIB["END"]] end i( l3 );
 local l5 = keys[CL_LIB["START"]]; single_value();  while true do  local l6 = n if n ~= CL[">="](l(l5,keys[CL_LIB["END"]])) then  single_value(); do break end; l6 = n.bound else  l6 = n.bound end i( l6 );
 i( CL_LIB["%SETELT"](l1, l5, l2) );
 single_value();  single_value();  local l7 = (1 + l5); single_value();  l5 = l7 local tmpres = l5 end i( n );
 single_value();  return l1 end, 2, 0, false, {0 , [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAP-INTO"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["RESULT-SEQUENCE"],{CL["FUNCTION"],{CL["&REST"],{CL_LIB["SEQUENCES"],n}}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL["APPLY"](CL["MIN"].fbound, CL["LENGTH"](l1), l(CL["MAPCAR"](CL["LENGTH"].fbound, l(l3)))); local l5 = 0; single_value();  while true do  local l6 = n if n ~= CL[">="](l(l5,l4)) then  single_value(); do break end; l6 = n.bound else  l6 = n.bound end i( l6 );
 i( CL_LIB["%SETELT"](l1, l5, CL["APPLY"](l2, CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SEQ"],n},function (l7,  ...)   single_value();  return CL["ELT"](l7, l5) end, 1, 0, false, false), l(l3)), l())) );
 single_value();  single_value();  local l8 = (1 + l5); single_value();  l5 = l8 local tmpres = l5 end i( n );
 single_value();  return l1 end, 2, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LIST-LENGTH"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],{CL["&AUX"],{{CL_LIB["ACC"],{0,n}},n}}},function (l1,  ...)  l2 = 0  single_value();  while true do  single_value();  local l3 = n if n ~= l1 then  l2 = (1 + l2) i( l2 );
 single_value();  l1 = (l1)[2] l3 = l1 else  local l4 = l2; single_value(); do return l4 end; l3 = n.bound end local tmpres = l3 end return n end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LENGTH"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["LISTP"](l1) then  single_value();  l2 = CL["LIST-LENGTH"](l1) else  local l3 = n if n ~= CL_LIB["%STRINGP"](l1) then  single_value();  l3 = CL_LIB["%LEN"](l1) else  local l4 = n if n ~= CL["VECTORP"](l1) then  single_value();  local l5 = n if n ~= CL["ARRAY-HAS-FILL-POINTER-P"](l1) then  l5 = CL["FILL-POINTER"](l1) else  l5 = CL["ARRAY-DIMENSION"](l1, 0) end l4 = l5 else  local l6 = n if n ~= CL["T"].bound then  single_value();  l6 = CL["ERROR"]("Not a valid sequence: ~S", l(l1)) else  l6 = n.bound end l4 = l6 end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SEQUENCE-TYPE"] , CL_LIB["ALLOC-FUNCTION"]({CL["SEQUENCE"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["LISTP"](l1) then  single_value();  l2 = CL["LIST"] else  local l3 = n if n ~= CL["STRINGP"](l1) then  single_value();  l3 = CL["STRING"] else  local l4 = n if n ~= CL["VECTORP"](l1) then  single_value();  l4 = CL["VECTOR"] else  local l5 = n if n ~= CL["T"].bound then  single_value();  l5 = CL["ERROR"]("Unknown sequence type: ~A", l(l1)) else  l5 = n.bound end l4 = l5 end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SUBSEQ"] , CL_LIB["ALLOC-FUNCTION"]({CL["SEQUENCE"],{CL_LIB["START"],{CL["&OPTIONAL"],{CL_LIB["END"],n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = n.bound end  single_value();  local l4 = n if n ~= CL["STRINGP"](l1) then  local l5 = l3; single_value();  local l6 = n if n ~= l5 then  l6 = l5 else  l6 = CL["LENGTH"](l1) end l4 = CL["FUNCALL"](string.sub, l(l1,(1 + l2),l6)) else  local l7 = CL["LENGTH"](l1); single_value();  local l9 = n if n ~= l3 then  l9 = CL["MIN"](l(l3,l7)) else  l9 = l7 end local l8 = (l9 - l2); single_value();  local l10 = CL["MAKE-SEQUENCE"](CL_LIB["%SEQUENCE-TYPE"](l1), l8, k()); single_value();  local l11 = 0; single_value();  local l12 = CL["GENSYM"](false); single_value();  local l13 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  local l14 = n if n ~= CL[">="](l(l11,l8)) then  single_value(); do break end; l14 = n.bound else  l14 = n.bound end i( l14 );
 i( CL_LIB["%SETELT"](l10, l11, CL["ELT"](l1, (l11 + l2))) );
 single_value();  local l15 = (l11 + 1); single_value();  single_value();  single_value();  local l16 = l15; single_value();  l11 = l16 local tmpres = l11 end return n end, 0, 0, false, false))); single_value(); if l13.error ~= n and (l13.error ~= KEYWORD.TAG or l13.tag ~= l12) then if l13.error == KEYWORD.TAG then  error(l13) else error(l13[1]) end end i( CL["VALUES-LIST"](list_r(l13)) );
 single_value();  l4 = l10 end return l4 end, 2, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["REPLACE"] , CL_LIB["ALLOC-FUNCTION"]({CL["SEQUENCE"],{CL_LIB["NEW-SUBSEQUENCE"],{CL["&KEY"],{{CL_LIB["START1"],{0,n}},{CL_LIB["END1"],{{CL_LIB["START2"],{0,n}},{CL_LIB["END2"],n}}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["START1"]] then  keys[CL_LIB["START1"]] = 0 end if not keys[CL_LIB["END1"]] then  keys[CL_LIB["END1"]] = n.bound end if not keys[CL_LIB["START2"]] then  keys[CL_LIB["START2"]] = 0 end if not keys[CL_LIB["END2"]] then  keys[CL_LIB["END2"]] = n.bound end  local l3 = n if n ~= keys[CL_LIB["END1"]] then  l3 = n.bound else  single_value();  keys[CL_LIB["END1"]] = CL["LENGTH"](l1) l3 = keys[CL_LIB["END1"]] end i( l3 );
 local l4 = n if n ~= keys[CL_LIB["END2"]] then  l4 = n.bound else  single_value();  keys[CL_LIB["END2"]] = CL["LENGTH"](l2) l4 = keys[CL_LIB["END2"]] end i( l4 );
 local l5 = n if n ~= CL["EQ"](l1, l2) then  single_value();  l2 = CL["COPY-SEQ"](l2) l5 = l2 else  l5 = n.bound end i( l5 );
 local l6 = n if n ~= CL_LIB["%STRINGP"](l1) then  single_value();  l1 = CL["COPY-SEQ"](l1) l6 = l1 else  l6 = n.bound end i( l6 );
 single_value();  local l7 = keys[CL_LIB["START1"]]; local l8 = keys[CL_LIB["START2"]]; single_value();  local l9 = CL["GENSYM"](false); single_value();  local l10 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l12 = CL[">="](l(l7,keys[CL_LIB["END1"]])); single_value();  local l13 = n if n ~= l12 then  l13 = l12 else  l13 = CL[">="](l(l8,keys[CL_LIB["END2"]])) end local l11 = n if n ~= l13 then  single_value(); do break end; l11 = n.bound else  l11 = n.bound end i( l11 );
 i( CL_LIB["%SETELT"](l1, l7, CL["ELT"](l2, l8)) );
 single_value();  local l14 = (l7 + 1); local l15 = (l8 + 1); single_value();  single_value();  local l16 = l15; single_value();  l8 = l16 i( l8 );
 single_value();  single_value();  single_value();  local l17 = l14; single_value();  l7 = l17 local tmpres = l7 end i( n );
 single_value();  return l1 end, 0, 0, false, false))); single_value(); if l10.error ~= n and (l10.error ~= KEYWORD.TAG or l10.tag ~= l9) then if l10.error == KEYWORD.TAG then  error(l10) else error(l10[1]) end end return CL["VALUES-LIST"](list_r(l10)) end, 2, 0, false, {0 , [LCL["KEYWORD"]["START1"]] = CL_LIB["START1"], [LCL["KEYWORD"]["END1"]] = CL_LIB["END1"], [LCL["KEYWORD"]["START2"]] = CL_LIB["START2"], [LCL["KEYWORD"]["END2"]] = CL_LIB["END2"]})); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["SUBSEQ"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-SUBSEQUENCE"],{CL["SEQUENCE"],{CL_LIB["START"],{CL["&OPTIONAL"],{CL_LIB["END"],n}}}}},function (l1, l2, l3, l4,  ...)  if not l4 then  l4 = n.bound end  single_value();  local l5 = CL["LENGTH"](l2); single_value();  local l7 = n if n ~= l4 then  l7 = CL["MIN"](l(l4,l5)) else  l7 = l5 end local l6 = CL["MIN"](l(CL["LENGTH"](l1),(l7 - l3))); single_value();  local l8 = 0; single_value();  local l9 = CL["GENSYM"](false); single_value();  local l10 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l11 = n if n ~= CL[">="](l(l8,l6)) then  single_value(); do break end; l11 = n.bound else  l11 = n.bound end i( l11 );
 i( CL_LIB["%SETELT"](l2, (l8 + l3), CL["ELT"](l1, l8)) );
 single_value();  local l12 = (1 + l8); single_value();  single_value();  single_value();  local l13 = l12; single_value();  l8 = l13 local tmpres = l8 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l10.error ~= n and (l10.error ~= KEYWORD.TAG or l10.tag ~= l9) then if l10.error == KEYWORD.TAG then  error(l10) else error(l10[1]) end end i( CL["VALUES-LIST"](list_r(l10)) );
 single_value();  return l2 end, 3, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["POSITION-IF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PREDICATE"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL_LIB["KEY"],n}}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  local l3 = n if n ~= keys[CL_LIB["END"]] then  l3 = n.bound else  single_value();  keys[CL_LIB["END"]] = CL["LENGTH"](l2) l3 = keys[CL_LIB["END"]] end i( l3 );
 single_value();  local l5 = n if n ~= keys[CL_LIB["FROM-END"]] then  l5 = (keys[CL_LIB["END"]] - 1) else  l5 = keys[CL_LIB["START"]] end local l4 = l5; single_value();  local l6 = CL["GENSYM"](false); single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  local l9 = CL_LIB["%<"](l4, 0); single_value();  local l10 = n if n ~= l9 then  l10 = l9 else  local l11 = CL[">="](l(l4,CL["LENGTH"](l2))); single_value();  local l12 = n if n ~= l11 then  l12 = l11 else  local l13 = n if n ~= keys[CL_LIB["FROM-END"]] then  l13 = CL_LIB["%<"](l4, keys[CL_LIB["START"]]) else  local l14 = n if n ~= keys[CL_LIB["END"]] then  l14 = CL[">="](l(l4,keys[CL_LIB["END"]])) else  l14 = n.bound end l13 = l14 end l12 = l13 end l10 = l12 end local l8 = n if n ~= l10 then  single_value(); do break end; l8 = n.bound else  l8 = n.bound end i( l8 );
 local l17 = keys[CL_LIB["KEY"]]; single_value();  local l18 = n if n ~= l17 then  l18 = l17 else  l18 = CL["IDENTITY"].fbound end local l16 = CL["FUNCALL"](l18, l(CL["ELT"](l2, l4))); single_value();  local l15 = n if n ~= CL_LIB['FUNCALL-LUA'](l1,{l16, }) then  single_value();  local l19 = l4; single_value(); do return l19 end; l15 = n.bound else  l15 = n.bound end i( l15 );
 single_value();  local l21 = n if n ~= keys[CL_LIB["FROM-END"]] then  l21 = (l4 - 1) else  l21 = (l4 + 1) end local l20 = l21; single_value();  single_value();  single_value();  local l22 = l20; single_value();  l4 = l22 local tmpres = l4 end return n end, 0, 0, false, false))); single_value(); if l7.error ~= n and (l7.error ~= KEYWORD.TAG or l7.tag ~= l6) then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end return CL["VALUES-LIST"](list_r(l7)) end, 2, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["POSITION-IF-NOT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PREDICATE"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL_LIB["KEY"],n}}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  return CL["POSITION-IF"](CL["COMPLEMENT"](l1), l2, k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]], CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["POSITION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ITEM"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL_LIB["KEY"],n}}}}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  local l4 = keys[CL_LIB["TEST"]]; single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  local l7 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l7 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l7 = n.bound end local l6 = l7; single_value();  local l8 = n if n ~= l6 then  l8 = l6 else  l8 = CL["EQ"].fbound end l5 = l8 end local l3 = l5; single_value();  return CL["POSITION-IF"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l9,  ...)   single_value();  local l10 = l1; single_value();  local l11 = l9; single_value();  return CL_LIB['FUNCALL-LUA'](l3,{l10, l11, }) end, 1, 0, false, false), l2, k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]], CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); local l1 = CL["GENSYM"](false); i( CL_LIB["FUNCTION-SETQ"](CL_LIB["%DELETE-SKIPS"] , CL_LIB["ALLOC-FUNCTION"]({CL["SEQUENCE"],n},function (l2,  ...)   single_value();  local l3 = n if n ~= CL["NULL"](l2) then  single_value();  l3 = n.bound else  local l4 = n if n ~= CL["LISTP"](l2) then  single_value();  local l5 = n if n ~= CL["EQ"](l1, (l2)[1]) then  l5 = CL_LIB["%DELETE-SKIPS"]((l2)[2]) else  l5 = CL["CONS"]((l2)[1], CL_LIB["%DELETE-SKIPS"]((l2)[2])) end l4 = l5 else  local l6 = n if n ~= CL["VECTORP"](l2) then  single_value();  local l7 = CL["MAKE-LIST"](CL["LENGTH"](l2), k()); i( CL["MAP-INTO"](l7, CL["IDENTITY"].fbound, l(l2)) );
 l7 = CL_LIB["%DELETE-SKIPS"](l7) i( l7 );
 single_value();  local l8 = CL["MAKE-ARRAY"](CL["LENGTH"](l7), k()); i( CL["MAP-INTO"](l8, CL["IDENTITY"].fbound, l(l7)) );
 single_value();  l6 = l8 else  local l9 = n if n ~= CL["T"].bound then  single_value();  l9 = CL["ERROR"]("delete/remove, not a sequence", l()) else  l9 = n.bound end l6 = l9 end l4 = l6 end l3 = l4 end return l3 end, 1, 0, false, false)) );
 i( CL_LIB["FUNCTION-SETQ"](CL["DELETE-IF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["TEST"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL["COUNT"],{CL_LIB["KEY"],n}}}}}}}},function (l10, l11, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL["COUNT"]] then  keys[CL["COUNT"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  local l12 = n if n ~= keys[CL_LIB["END"]] then  l12 = n.bound else  single_value();  keys[CL_LIB["END"]] = CL["LENGTH"](l11) l12 = keys[CL_LIB["END"]] end i( l12 );
 single_value();  local l13 = 0; local l15 = n if n ~= keys[CL_LIB["FROM-END"]] then  l15 = (keys[CL_LIB["END"]] - 1) else  l15 = keys[CL_LIB["START"]] end local l14 = l15; single_value();  local l16 = CL["GENSYM"](false); single_value();  local l17 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  local l20 = n if n ~= keys[CL["COUNT"]] then  l20 = CL[">="](l(l13,keys[CL["COUNT"]])) else  l20 = n.bound end local l19 = l20; single_value();  local l21 = n if n ~= l19 then  l21 = l19 else  local l22 = n if n ~= keys[CL_LIB["FROM-END"]] then  l22 = CL_LIB["%<"](l14, keys[CL_LIB["START"]]) else  l22 = CL[">="](l(l14,keys[CL_LIB["END"]])) end l21 = l22 end local l18 = n if n ~= l21 then  single_value(); do break end; l18 = n.bound else  l18 = n.bound end i( l18 );
 local l25 = keys[CL_LIB["KEY"]]; single_value();  local l26 = n if n ~= l25 then  l26 = l25 else  l26 = CL["IDENTITY"].fbound end local l24 = CL["FUNCALL"](l26, l(CL["ELT"](l11, l14))); single_value();  local l23 = n if n ~= CL_LIB['FUNCALL-LUA'](l10,{l24, }) then  l13 = (1 + l13) i( l13 );
 single_value();  l23 = CL_LIB["%SETELT"](l11, l14, l1) else  l23 = n.bound end i( l23 );
 single_value();  local l28 = n if n ~= keys[CL_LIB["FROM-END"]] then  l28 = (l14 - 1) else  l28 = (l14 + 1) end local l27 = l28; single_value();  single_value();  single_value();  local l29 = l27; single_value();  l14 = l29 local tmpres = l14 end return n end, 0, 0, false, false))); single_value(); if l17.error ~= n and (l17.error ~= KEYWORD.TAG or l17.tag ~= l16) then if l17.error == KEYWORD.TAG then  error(l17) else error(l17[1]) end end i( CL["VALUES-LIST"](list_r(l17)) );
 single_value();  return CL_LIB["%DELETE-SKIPS"](l11) end, 2, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["COUNT"]] = CL["COUNT"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})) );
 i( CL_LIB["FUNCTION-SETQ"](CL["DELETE-IF-NOT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["TEST"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL["COUNT"],{CL_LIB["KEY"],n}}}}}}}},function (l30, l31, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL["COUNT"]] then  keys[CL["COUNT"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  return CL["DELETE-IF"](CL["COMPLEMENT"](l30), l31, k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]], CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]], CL["COUNT"], keys[CL["COUNT"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["COUNT"]] = CL["COUNT"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})) );
 i( CL_LIB["FUNCTION-SETQ"](CL["DELETE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ITEM"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL["COUNT"],{CL_LIB["KEY"],n}}}}}}}}}},function (l32, l33, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL["COUNT"]] then  keys[CL["COUNT"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  local l35 = keys[CL_LIB["TEST"]]; single_value();  local l36 = n if n ~= l35 then  l36 = l35 else  local l38 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l38 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l38 = n.bound end local l37 = l38; single_value();  local l39 = n if n ~= l37 then  l39 = l37 else  l39 = CL["EQ"].fbound end l36 = l39 end local l34 = l36; single_value();  return CL["DELETE-IF"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l40,  ...)   single_value();  local l41 = l32; single_value();  local l42 = l40; single_value();  return CL_LIB['FUNCALL-LUA'](l34,{l41, l42, }) end, 1, 0, false, false), l33, k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]], CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["COUNT"]] = CL["COUNT"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})) );
 i( CL_LIB["FUNCTION-SETQ"](CL["REMOVE-IF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["TEST"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL["COUNT"],{CL_LIB["KEY"],n}}}}}}}},function (l43, l44, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL["COUNT"]] then  keys[CL["COUNT"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  return CL["DELETE-IF"](l43, CL["COPY-SEQ"](l44), k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]], CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]], CL["COUNT"], keys[CL["COUNT"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["COUNT"]] = CL["COUNT"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})) );
 i( CL_LIB["FUNCTION-SETQ"](CL["REMOVE-IF-NOT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["TEST"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL["COUNT"],{CL_LIB["KEY"],n}}}}}}}},function (l45, l46, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL["COUNT"]] then  keys[CL["COUNT"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  return CL["DELETE-IF-NOT"](l45, CL["COPY-SEQ"](l46), k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]], CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]], CL["COUNT"], keys[CL["COUNT"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["COUNT"]] = CL["COUNT"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})) );
 i( CL_LIB["FUNCTION-SETQ"](CL["REMOVE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ITEM"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL["COUNT"],{CL_LIB["KEY"],n}}}}}}}}}},function (l47, l48, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL["COUNT"]] then  keys[CL["COUNT"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  return CL["DELETE"](l47, CL["COPY-SEQ"](l48), k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]], CL_LIB["TEST"], keys[CL_LIB["TEST"]], CL_LIB["TEST-NOT"], keys[CL_LIB["TEST-NOT"]], CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]], CL["COUNT"], keys[CL["COUNT"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["COUNT"]] = CL["COUNT"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})) );
 i( CL_LIB["FUNCTION-SETQ"](CL["DELETE-DUPLICATES"] , CL_LIB["ALLOC-FUNCTION"]({CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL_LIB["KEY"],n}}}}}}}},function (l49, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  return CL["DELETE-IF"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l50,  ...)   single_value();  return CL[">"](l(CL["COUNT-IF"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OTHER"],n},function (l51,  ...)   single_value();  local l52 = keys[CL_LIB["TEST"]]; single_value();  local l53 = n if n ~= l52 then  l53 = l52 else  local l55 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l55 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l55 = n.bound end local l54 = l55; single_value();  local l56 = n if n ~= l54 then  l56 = l54 else  l56 = CL["EQL"].fbound end l53 = l56 end local l57 = n if n ~= keys[CL_LIB["KEY"]] then  local l58 = l50; single_value();  l57 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l58, }) else  l57 = l50 end local l59 = n if n ~= keys[CL_LIB["KEY"]] then  local l60 = l51; single_value();  l59 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l60, }) else  l59 = l51 end return CL["FUNCALL"](l53, l(l57,l59)) end, 1, 0, false, false), l49, k()),1)) end, 1, 0, false, false), l49, k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]])) end, 1, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})) );
 single_value();  tmp = CL_LIB["FUNCTION-SETQ"](CL["REMOVE-DUPLICATES"] , CL_LIB["ALLOC-FUNCTION"]({CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL_LIB["KEY"],n}}}}}}}},function (l61, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  return CL["DELETE-DUPLICATES"](CL["COPY-SEQ"](l61), k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]], CL_LIB["TEST"], keys[CL_LIB["TEST"]], CL_LIB["TEST-NOT"], keys[CL_LIB["TEST-NOT"]], CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 1, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["NSUBSTITUTE-IF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEWITEM"],{CL_LIB["PREDICATE"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL["COUNT"],{CL_LIB["KEY"],n}}}}}}}}},function (l1, l2, l3, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL["COUNT"]] then  keys[CL["COUNT"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  local l4 = CL["LENGTH"](l3); single_value();  local l5 = keys[CL_LIB["START"]]; single_value();  local l7 = keys[CL_LIB["END"]]; single_value();  local l8 = n if n ~= l7 then  l8 = l7 else  l8 = l4 end local l6 = l8; single_value();  local l9 = 0; single_value();  single_value();  local l11 = n if n ~= keys[CL_LIB["FROM-END"]] then  l11 = CL["1-"](l6) else  l11 = l5 end local l10 = l11; single_value();  local l12 = CL["GENSYM"](false); single_value();  local l13 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l16 = n if n ~= keys[CL["COUNT"]] then  l16 = CL[">="](l(l9,keys[CL["COUNT"]])) else  l16 = n.bound end local l15 = l16; single_value();  local l17 = n if n ~= l15 then  l17 = l15 else  local l18 = n if n ~= keys[CL_LIB["FROM-END"]] then  l18 = CL_LIB["%<"](l10, l5) else  l18 = CL[">="](l(l10,l6)) end l17 = l18 end local l14 = n if n ~= l17 then  single_value(); do break end; l14 = n.bound else  l14 = n.bound end i( l14 );
 local l21 = n if n ~= keys[CL_LIB["KEY"]] then  local l22 = CL["ELT"](l3, l10); single_value();  l21 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l22, }) else  l21 = CL["ELT"](l3, l10) end local l20 = l21; single_value();  local l19 = n if n ~= CL_LIB['FUNCALL-LUA'](l2,{l20, }) then  single_value();  local l23 = (1 + l9); single_value();  l9 = l23 i( l9 );
 single_value();  l19 = CL_LIB["%SETELT"](l3, l10, l1) else  l19 = n.bound end i( l19 );
 single_value();  local l25 = n if n ~= keys[CL_LIB["FROM-END"]] then  l25 = -1 else  l25 = 1 end local l24 = (l10 + l25); single_value();  single_value();  single_value();  local l26 = l24; single_value();  l10 = l26 local tmpres = l10 end i( n );
 single_value();  return l3 end, 0, 0, false, false))); single_value(); if l13.error ~= n and (l13.error ~= KEYWORD.TAG or l13.tag ~= l12) then if l13.error == KEYWORD.TAG then  error(l13) else error(l13[1]) end end return CL["VALUES-LIST"](list_r(l13)) end, 3, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["COUNT"]] = CL["COUNT"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["NSUBSTITUTE-IF-NOT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEWITEM"],{CL_LIB["PREDICATE"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL["COUNT"],{CL_LIB["KEY"],n}}}}}}}}},function (l1, l2, l3, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL["COUNT"]] then  keys[CL["COUNT"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  return CL["NSUBSTITUTE-IF"](l1, CL["COMPLEMENT"](l2), l3, k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]], CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]], CL["COUNT"], keys[CL["COUNT"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 3, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["COUNT"]] = CL["COUNT"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["NSUBSTITUTE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEWITEM"],{CL_LIB["OLDITEM"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL["COUNT"],{CL_LIB["KEY"],n}}}}}}}}}}},function (l1, l2, l3, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL["COUNT"]] then  keys[CL["COUNT"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  local l5 = keys[CL_LIB["TEST"]]; single_value();  local l6 = n if n ~= l5 then  l6 = l5 else  local l8 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l8 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l8 = n.bound end local l7 = l8; single_value();  local l9 = n if n ~= l7 then  l9 = l7 else  l9 = CL["EQ"].fbound end l6 = l9 end local l4 = l6; single_value();  return CL["NSUBSTITUTE-IF"](l1, CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l10,  ...)   single_value();  local l11 = l2; single_value();  local l12 = l10; single_value();  return CL_LIB['FUNCALL-LUA'](l4,{l11, l12, }) end, 1, 0, false, false), l3, k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]], CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]], CL["COUNT"], keys[CL["COUNT"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 3, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["COUNT"]] = CL["COUNT"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SORT-LIST"] , CL_LIB["ALLOC-FUNCTION"]({CL["LIST"],{CL_LIB["PREDICATE"],{CL_LIB["KEY"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = n if n ~= CL["NOT"](CL["ZEROP"](CL["LENGTH"](l1))) then  local l5 = CL["ELT"](l1, 0); single_value();  local l6 = CL["SUBSEQ"](l1, 1, false); single_value();  local l7 = CL_LIB["ALLOC-FUNCTION"]({CL_LIB["P"],n},function (l8,  ...)   single_value();  local l9 = l5; single_value();  local l10 = l8; single_value();  return CL_LIB['FUNCALL-LUA'](l2,{l9, l10, }) end, 1, 0, false, false); single_value();  local l11 = CL["REMOVE-IF"](l7, l6, k(CL_LIB["KEY"], l3)); single_value();  local l12 = CL["REMOVE-IF-NOT"](l7, l6, k(CL_LIB["KEY"], l3)); single_value();  single_value();  l4 = CL["APPEND"](l(CL_LIB["%SORT-LIST"](l11, l2, l3),CL["LIST"](l(l5)),CL_LIB["%SORT-LIST"](l12, l2, l3))) else  l4 = n.bound end return l4 end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SORT"] , CL_LIB["ALLOC-FUNCTION"]({CL["SEQUENCE"],{CL_LIB["PREDICATE"],{CL["&KEY"],{CL_LIB["KEY"],n}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  local l3 = n if n ~= CL["LISTP"](l1) then  l3 = CL_LIB["%SORT-LIST"](l1, l2, keys[CL_LIB["KEY"]]) else  l3 = CL["MAP-INTO"](l1, CL["IDENTITY"].fbound, l(CL_LIB["%SORT-LIST"](l1, l2, keys[CL_LIB["KEY"]]))) end return l3 end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["STABLE-SORT"] , CL_LIB["ALLOC-FUNCTION"]({CL["SEQUENCE"],{CL_LIB["PREDICATE"],{CL["&KEY"],{CL_LIB["KEY"],n}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  return CL["SORT"](l1, l2, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["FIND-IF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PREDICATE"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{{CL_LIB["KEY"],{{CL["FUNCTION"],{CL["IDENTITY"],n}},n}},n}}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound end  single_value();  local l4 = keys[CL_LIB["END"]]; single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  l5 = CL["LENGTH"](l2) end local l3 = l5; single_value();  local l6 = 0; single_value();  while true do  local l7 = n if n ~= CL[">="](l(l6,(l3 - keys[CL_LIB["START"]]))) then  single_value(); do break end; l7 = n.bound else  l7 = n.bound end i( l7 );
 local l9 = n if n ~= keys[CL_LIB["FROM-END"]] then  l9 = (l3 - l6 - 1) else  l9 = (keys[CL_LIB["START"]] + l6) end local l8 = l9; single_value();  local l10 = CL["ELT"](l2, l8); single_value();  single_value();  local l13 = l10; single_value();  local l12 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l13, }); single_value();  local l11 = n if n ~= CL_LIB['FUNCALL-LUA'](l1,{l12, }) then  single_value();  local l14 = l10; single_value(); do return l14 end; l11 = n.bound else  l11 = n.bound end i( l11 );
 single_value();  single_value();  local l15 = (1 + l6); single_value();  l6 = l15 local tmpres = l6 end return n end, 2, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["FIND-IF-NOT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PREDICATE"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{{CL_LIB["KEY"],{{CL["FUNCTION"],{CL["IDENTITY"],n}},n}},n}}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound end  single_value();  return CL["FIND-IF"](CL["COMPLEMENT"](l1), l2, k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]], CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["FIND"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ITEM"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{{CL_LIB["KEY"],{{CL["FUNCTION"],{CL["IDENTITY"],n}},n}},n}}}}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound end  single_value();  local l4 = keys[CL_LIB["TEST"]]; single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  local l7 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l7 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l7 = n.bound end local l6 = l7; single_value();  local l8 = n if n ~= l6 then  l8 = l6 else  l8 = CL["EQ"].fbound end l5 = l8 end local l3 = l5; single_value();  return CL["FIND-IF"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l9,  ...)   single_value();  local l10 = l1; single_value();  local l11 = l9; single_value();  return CL_LIB['FUNCALL-LUA'](l3,{l10, l11, }) end, 1, 0, false, false), l2, k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]], CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["MEMBER-IF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PREDICATE"],{CL["LIST"],{CL["&KEY"],{{CL_LIB["KEY"],{{CL["FUNCTION"],{CL["IDENTITY"],n}},n}},n}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound end  single_value();  local l3 = n if n ~= CL["NULL"](l2) then  single_value();  l3 = n.bound else  local l4 = n if n ~= CL["CONSP"](l2) then  single_value();  local l7 = n if n ~= keys[CL_LIB["KEY"]] then  local l8 = (l2)[1]; single_value();  l7 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l8, }) else  l7 = (l2)[1] end local l6 = l7; single_value();  local l5 = n if n ~= CL_LIB['FUNCALL-LUA'](l1,{l6, }) then  l5 = l2 else  l5 = CL["MEMBER-IF"](l1, (l2)[2], k(CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end l4 = l5 else  local l9 = n if n ~= CL_LIB["SEQUENCEP"](l2) then  single_value();  local l10 = n.bound; local l11 = 0; single_value();  local l12 = CL["GENSYM"](false); single_value();  local l13 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l14 = n if n ~= CL[">="](l(l11,CL["LENGTH"](l2))) then  single_value(); do break end; l14 = n.bound else  l14 = n.bound end i( l14 );
 local l17 = CL["ELT"](l2, l11); single_value();  local l16 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l17, }); single_value();  local l15 = n if n ~= CL_LIB['FUNCALL-LUA'](l1,{l16, }) then  l10 = CL["SUBSEQ"](l2, l11, false) i( l10 );
 single_value();  local l18 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l15 = error({tag=CL["IDENTITY"](l12),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l18)) end)()}) else  l15 = n.bound end i( l15 );
 single_value();  local l19 = (1 + l11); single_value();  single_value();  single_value();  local l20 = l19; single_value();  l11 = l20 local tmpres = l11 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l13.error ~= n and (l13.error ~= KEYWORD.TAG or l13.tag ~= l12) then if l13.error == KEYWORD.TAG then  error(l13) else error(l13[1]) end end i( CL["VALUES-LIST"](list_r(l13)) );
 single_value();  l9 = l10 else  l9 = n.bound end l4 = l9 end l3 = l4 end return l3 end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["MISMATCH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SEQUENCE-1"],{CL_LIB["SEQUENCE-2"],{CL["&KEY"],{CL_LIB["FROM-END"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],{CL_LIB["KEY"],{{CL_LIB["START1"],{0,n}},{{CL_LIB["START2"],{0,n}},{CL_LIB["END1"],{CL_LIB["END2"],n}}}}}}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end if not keys[CL_LIB["START1"]] then  keys[CL_LIB["START1"]] = 0 end if not keys[CL_LIB["START2"]] then  keys[CL_LIB["START2"]] = 0 end if not keys[CL_LIB["END1"]] then  keys[CL_LIB["END1"]] = n.bound end if not keys[CL_LIB["END2"]] then  keys[CL_LIB["END2"]] = n.bound end  single_value();  local l3 = CL["GENSYM"](false); single_value();  local l4 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l6 = keys[CL_LIB["TEST"]]; single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  local l9 = n if n ~= keys[CL_LIB["TEST-NOT"]] then  l9 = CL["COMPLEMENT"](keys[CL_LIB["TEST-NOT"]]) else  l9 = n.bound end local l8 = l9; single_value();  local l10 = n if n ~= l8 then  l10 = l8 else  l10 = CL["EQL"].fbound end l7 = l10 end local l5 = l7; local l11 = n if n ~= keys[CL_LIB["END1"]] then  l11 = n.bound else  single_value();  keys[CL_LIB["END1"]] = CL["LENGTH"](l1) l11 = keys[CL_LIB["END1"]] end i( l11 );
 local l12 = n if n ~= keys[CL_LIB["END2"]] then  l12 = n.bound else  single_value();  keys[CL_LIB["END2"]] = CL["LENGTH"](l2) l12 = keys[CL_LIB["END2"]] end i( l12 );
 single_value();  local l14 = n if n ~= keys[CL_LIB["FROM-END"]] then  l14 = CL["1-"](keys[CL_LIB["END1"]]) else  l14 = keys[CL_LIB["START1"]] end local l13 = l14; local l16 = n if n ~= keys[CL_LIB["FROM-END"]] then  l16 = CL["1-"](keys[CL_LIB["END2"]]) else  l16 = keys[CL_LIB["START2"]] end local l15 = l16; single_value();  local l17 = CL["GENSYM"](false); single_value();  local l18 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l20 = CL[">="](l(l13,keys[CL_LIB["END1"]])); single_value();  local l21 = n if n ~= l20 then  l21 = l20 else  local l22 = CL[">="](l(l15,keys[CL_LIB["END2"]])); single_value();  local l23 = n if n ~= l22 then  l23 = l22 else  local l24 = CL_LIB["%<"](l13, keys[CL_LIB["START1"]]); single_value();  local l25 = n if n ~= l24 then  l25 = l24 else  l25 = CL_LIB["%<"](l15, keys[CL_LIB["START2"]]) end l23 = l25 end l21 = l23 end local l19 = n if n ~= l21 then  single_value(); do break end; l19 = n.bound else  l19 = n.bound end i( l19 );
 local l27 = n if n ~= keys[CL_LIB["KEY"]] then  local l29 = CL["ELT"](l1, l13); single_value();  local l28 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l29, }); single_value();  local l31 = CL["ELT"](l2, l15); single_value();  local l30 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l31, }); single_value();  l27 = CL_LIB['FUNCALL-LUA'](l5,{l28, l30, }) else  local l32 = CL["ELT"](l1, l13); single_value();  local l33 = CL["ELT"](l2, l15); single_value();  l27 = CL_LIB['FUNCALL-LUA'](l5,{l32, l33, }) end local l26 = n if n ~= l27 then  l26 = n.bound else  single_value();  local l35 = n if n ~= keys[CL_LIB["FROM-END"]] then  l35 = (1 + l13) else  l35 = l13 end local l34 = CL["FUNCALL"](l, l(unpack_mv(l35))); single_value();  l26 = error({tag=CL["IDENTITY"](l3),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l34)) end)()}) end i( l26 );
 single_value();  local l37 = n if n ~= keys[CL_LIB["FROM-END"]] then  l37 = CL["1-"](l13) else  l37 = CL["1+"](l13) end local l36 = l37; local l39 = n if n ~= keys[CL_LIB["FROM-END"]] then  l39 = CL["1-"](l15) else  l39 = CL["1+"](l15) end local l38 = l39; single_value();  single_value();  local l40 = l38; single_value();  l15 = l40 i( l15 );
 single_value();  single_value();  single_value();  local l41 = l36; single_value();  l13 = l41 local tmpres = l13 end i( n );
 single_value();  local l44 = n if n ~= CL[">="](l(l13,keys[CL_LIB["END1"]])) then  l44 = CL[">="](l(l15,keys[CL_LIB["END2"]])) else  l44 = n.bound end local l43 = l44; single_value();  local l45 = n if n ~= l43 then  l45 = l43 else  local l46 = n if n ~= CL_LIB["%<"](l13, keys[CL_LIB["START1"]]) then  l46 = CL_LIB["%<"](l15, keys[CL_LIB["START2"]]) else  l46 = n.bound end l45 = l46 end local l42 = n if n ~= l45 then  l42 = n.bound else  local l47 = n if n ~= keys[CL_LIB["FROM-END"]] then  l47 = (1 + l13) else  l47 = l13 end l42 = l47 end return l42 end, 0, 0, false, false))); single_value(); if l18.error ~= n and (l18.error ~= KEYWORD.TAG or l18.tag ~= l17) then if l18.error == KEYWORD.TAG then  error(l18) else error(l18[1]) end end return CL["VALUES-LIST"](list_r(l18)) end, 0, 0, false, false))); single_value(); if l4.error ~= n and (l4.error ~= KEYWORD.TAG or l4.tag ~= l3) then if l4.error == KEYWORD.TAG then  error(l4) else error(l4[1]) end end return CL["VALUES-LIST"](list_r(l4)) end, 2, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["START1"]] = CL_LIB["START1"], [LCL["KEYWORD"]["START2"]] = CL_LIB["START2"], [LCL["KEYWORD"]["END1"]] = CL_LIB["END1"], [LCL["KEYWORD"]["END2"]] = CL_LIB["END2"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["SEARCH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SEQUENCE-1"],{CL_LIB["SEQUENCE-2"],{CL["&KEY"],{CL_LIB["FROM-END"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],{CL_LIB["KEY"],{{CL_LIB["START1"],{0,n}},{{CL_LIB["START2"],{0,n}},{CL_LIB["END1"],{CL_LIB["END2"],n}}}}}}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end if not keys[CL_LIB["START1"]] then  keys[CL_LIB["START1"]] = 0 end if not keys[CL_LIB["START2"]] then  keys[CL_LIB["START2"]] = 0 end if not keys[CL_LIB["END1"]] then  keys[CL_LIB["END1"]] = n.bound end if not keys[CL_LIB["END2"]] then  keys[CL_LIB["END2"]] = n.bound end  local l3 = n if n ~= keys[CL_LIB["END1"]] then  l3 = n.bound else  single_value();  keys[CL_LIB["END1"]] = CL["LENGTH"](l1) l3 = keys[CL_LIB["END1"]] end i( l3 );
 local l4 = n if n ~= keys[CL_LIB["END2"]] then  l4 = n.bound else  single_value();  keys[CL_LIB["END2"]] = CL["LENGTH"](l2) l4 = keys[CL_LIB["END2"]] end i( l4 );
 single_value();  local l5 = (keys[CL_LIB["END1"]] - keys[CL_LIB["START1"]]); single_value();  local l7 = n if n ~= keys[CL_LIB["FROM-END"]] then  local l8 = keys[CL_LIB["END2"]]; single_value();  local l9 = n if n ~= l8 then  l9 = l8 else  l9 = CL["LENGTH"](l2) end l7 = CL["1-"](l9) else  l7 = 0 end local l6 = l7; single_value();  local l10 = CL["GENSYM"](false); single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l13 = n if n ~= keys[CL_LIB["FROM-END"]] then  l13 = CL_LIB["%<"](l6, keys[CL_LIB["START2"]]) else  l13 = CL[">="](l(l6,keys[CL_LIB["END2"]])) end local l12 = n if n ~= l13 then  single_value(); do break end; l12 = n.bound else  l12 = n.bound end i( l12 );
 local l14 = n if n ~= keys[CL_LIB["FROM-END"]] then  local l15 = CL["1+"](l6); single_value();  local l16 = (l15 - l5); single_value();  single_value();  local l17 = n if n ~= CL["MISMATCH"](l1, l2, k(CL_LIB["TEST"], keys[CL_LIB["TEST"]], CL_LIB["TEST-NOT"], keys[CL_LIB["TEST-NOT"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]], CL_LIB["START1"], keys[CL_LIB["START1"]], CL_LIB["END1"], keys[CL_LIB["END1"]], CL_LIB["START2"], l16, CL_LIB["END2"], l15)) then  l17 = n.bound else  single_value();  local l18 = CL["FUNCALL"](l, l(unpack_mv(l16))); single_value();  l17 = error({tag=CL["IDENTITY"](l10),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l18)) end)()}) end l14 = l17 else  local l19 = l6; single_value();  local l20 = (l19 + l5); single_value();  single_value();  local l21 = n if n ~= CL["MISMATCH"](l1, l2, k(CL_LIB["TEST"], keys[CL_LIB["TEST"]], CL_LIB["TEST-NOT"], keys[CL_LIB["TEST-NOT"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]], CL_LIB["START1"], keys[CL_LIB["START1"]], CL_LIB["END1"], keys[CL_LIB["END1"]], CL_LIB["START2"], l19, CL_LIB["END2"], l20)) then  l21 = n.bound else  single_value();  local l22 = CL["FUNCALL"](l, l(unpack_mv(l19))); single_value();  l21 = error({tag=CL["IDENTITY"](l10),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l22)) end)()}) end l14 = l21 end i( l14 );
 single_value();  local l24 = n if n ~= keys[CL_LIB["FROM-END"]] then  l24 = CL["1-"](l6) else  l24 = CL["1+"](l6) end local l23 = l24; single_value();  single_value();  single_value();  local l25 = l23; single_value();  l6 = l25 local tmpres = l6 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l11.error ~= n and (l11.error ~= KEYWORD.TAG or l11.tag ~= l10) then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end return CL["VALUES-LIST"](list_r(l11)) end, 2, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["START1"]] = CL_LIB["START1"], [LCL["KEYWORD"]["START2"]] = CL_LIB["START2"], [LCL["KEYWORD"]["END1"]] = CL_LIB["END1"], [LCL["KEYWORD"]["END2"]] = CL_LIB["END2"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING-LEFT-TRIM"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["BAG"],{CL["STRING"],n}},function (l1, l2,  ...)   local l3 = n if n ~= CL["SYMBOLP"](l2) then  l2 = CL["STRING"](l2) l3 = l2 else  l3 = n.bound end i( l3 );
 single_value();  local l4 = CL["LENGTH"](l2); single_value();  local l5 = 0; single_value();  local l6 = CL["GENSYM"](false); single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l9 = CL[">="](l(l5,l4)); single_value();  local l10 = n if n ~= l9 then  l10 = l9 else  l10 = CL["NOT"](CL["MEMBER"](CL["CHAR"](l2, l5), l1, k(CL_LIB["TEST"], CL["CHAR="].fbound))) end local l8 = n if n ~= l10 then  single_value(); do break end; l8 = n.bound else  l8 = n.bound end i( l8 );
 single_value();  local l11 = CL["1+"](l5); single_value();  single_value();  single_value();  local l12 = l11; single_value();  l5 = l12 local tmpres = l5 end i( n );
 single_value();  return CL["SUBSEQ"](l2, l5, false) end, 0, 0, false, false))); single_value(); if l7.error ~= n and (l7.error ~= KEYWORD.TAG or l7.tag ~= l6) then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end return CL["VALUES-LIST"](list_r(l7)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING-RIGHT-TRIM"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["BAG"],{CL["STRING"],n}},function (l1, l2,  ...)   local l3 = n if n ~= CL["SYMBOLP"](l2) then  l2 = CL["STRING"](l2) l3 = l2 else  l3 = n.bound end i( l3 );
 single_value();  local l4 = CL["LENGTH"](l2); single_value();  local l5 = CL["1-"](l4); single_value();  local l6 = CL["GENSYM"](false); single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l9 = CL_LIB["%<"](l5, 0); single_value();  local l10 = n if n ~= l9 then  l10 = l9 else  l10 = CL["NOT"](CL["MEMBER"](CL["CHAR"](l2, l5), l1, k(CL_LIB["TEST"], CL["CHAR="].fbound))) end local l8 = n if n ~= l10 then  single_value(); do break end; l8 = n.bound else  l8 = n.bound end i( l8 );
 single_value();  local l11 = CL["1-"](l5); single_value();  single_value();  single_value();  local l12 = l11; single_value();  l5 = l12 local tmpres = l5 end i( n );
 single_value();  return CL["SUBSEQ"](l2, 0, CL["1+"](l5)) end, 0, 0, false, false))); single_value(); if l7.error ~= n and (l7.error ~= KEYWORD.TAG or l7.tag ~= l6) then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end return CL["VALUES-LIST"](list_r(l7)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STRING-TRIM"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["BAG"],{CL["STRING"],n}},function (l1, l2,  ...)   single_value();  return CL["STRING-LEFT-TRIM"](l1, CL["STRING-RIGHT-TRIM"](l1, l2)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["NSET-EXCLUSIVE-OR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["LIST-1"],{CL_LIB["LIST-2"],{CL["&KEY"],{CL_LIB["KEY"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  local l3 = n.bound; single_value();  local l4;l4 = CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FROM"],{CL_LIB["TO"],{CL_LIB["COLLECT"],n}}},function (l5, l6, l7,  ...)   single_value();  while true do  single_value();  local l8 = n if n ~= (l5)[2] then  local l10 = n if n ~= keys[CL_LIB["KEY"]] then  local l11 = CL["CADR"](l5); single_value();  l10 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l11, }) else  l10 = CL["CADR"](l5) end local l9 = n if n ~= CL["MEMBER"](l10, l6, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]], CL_LIB["TEST"], keys[CL_LIB["TEST"]], CL_LIB["TEST-NOT"], keys[CL_LIB["TEST-NOT"]])) then  local l12 = n if n ~= l7 then  single_value();  single_value();  local l13 = CL["CONS"](CL["CADR"](l5), l3); single_value();  l3 = l13 l12 = l3 else  l12 = n.bound end i( l12 );
 single_value();  l9 = CL["RPLACD"](l5, CL["CDDR"](l5)) else  l5 = (l5)[2] l9 = l5 end l8 = l9 else do break end; l8 = n.bound end local tmpres = l8 end return n end, 3, 0, false, false); i( CL_LIB["FUNCALL-LUA"]( l4, {l1, l2, CL["T"].bound, }) );
 local l15 = n if n ~= keys[CL_LIB["KEY"]] then  local l16 = (l1)[1]; single_value();  l15 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l16, }) else  l15 = (l1)[1] end local l14 = n if n ~= CL["MEMBER"](l15, l2, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]], CL_LIB["TEST"], keys[CL_LIB["TEST"]], CL_LIB["TEST-NOT"], keys[CL_LIB["TEST-NOT"]])) then  single_value();  single_value();  local l17 = CL["CONS"]((l1)[1], l3); single_value();  l3 = l17 i( l3 );
 single_value();  l1 = (l1)[2] l14 = l1 else  l14 = n.bound end i( l14 );
 i( CL_LIB["FUNCALL-LUA"]( l4, {l2, l3, n.bound, }) );
 local l19 = n if n ~= keys[CL_LIB["KEY"]] then  local l20 = (l2)[1]; single_value();  l19 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l20, }) else  l19 = (l2)[1] end local l18 = n if n ~= CL["MEMBER"](l19, l3, k(CL_LIB["KEY"], keys[CL_LIB["KEY"]], CL_LIB["TEST"], keys[CL_LIB["TEST"]], CL_LIB["TEST-NOT"], keys[CL_LIB["TEST-NOT"]])) then  single_value();  l2 = (l2)[2] l18 = l2 else  l18 = n.bound end i( l18 );
 single_value();  return CL["APPEND"](l(l1,l2)) end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["SET-EXCLUSIVE-OR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["LIST-1"],{CL_LIB["LIST-2"],{CL["&KEY"],{CL_LIB["KEY"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],n}}}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end  single_value();  return CL["NSET-EXCLUSIVE-OR"](CL["COPY-LIST"](l1), CL["COPY-LIST"](l2), k(CL_LIB["KEY"], keys[CL_LIB["KEY"]], CL_LIB["TEST"], keys[CL_LIB["TEST"]], CL_LIB["TEST-NOT"], keys[CL_LIB["TEST-NOT"]])) end, 2, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAKE-SEQUENCE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["RESULT-TYPE"],{CL_LIB["SIZE"],{CL["&KEY"],{CL_LIB["INITIAL-ELEMENT"],n}}}},function (l1, l2, keys,  ...)  if not keys[CL_LIB["INITIAL-ELEMENT"]] then  keys[CL_LIB["INITIAL-ELEMENT"]] = n.bound end  single_value();  local l3 = n if n ~= CL["SUBTYPEP"](l1, CL["LIST"], false) then  single_value();  l3 = CL["MAKE-LIST"](l2, k(CL_LIB["INITIAL-ELEMENT"], keys[CL_LIB["INITIAL-ELEMENT"]])) else  local l4 = n if n ~= CL["SUBTYPEP"](l1, CL["STRING"], false) then  single_value();  l4 = CL["MAKE-ARRAY"](l2, k(CL_LIB["INITIAL-ELEMENT"], keys[CL_LIB["INITIAL-ELEMENT"]], CL_LIB["ELEMENT-TYPE"], CL["CHARACTER"])) else  local l5 = n if n ~= CL["SUBTYPEP"](l1, CL["VECTOR"], false) then  single_value();  l5 = CL["MAKE-ARRAY"](l2, k(CL_LIB["INITIAL-ELEMENT"], keys[CL_LIB["INITIAL-ELEMENT"]])) else  local l6 = n if n ~= CL["T"].bound then  single_value();  l6 = CL["ERROR"]("Invalid sequence type ~A", l(l1)) else  l6 = n.bound end l5 = l6 end l4 = l5 end l3 = l4 end return l3 end, 2, 0, false, {0 , [LCL["KEYWORD"]["INITIAL-ELEMENT"]] = CL_LIB["INITIAL-ELEMENT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["COPY-SEQ"] , CL_LIB["ALLOC-FUNCTION"]({CL["SEQUENCE"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["TYPEP"](l1, CL["LIST"], false) then  single_value();  l2 = CL["COPY-LIST"](l1) else  local l3 = n if n ~= CL["TYPEP"](l1, CL["VECTOR"], false) then  single_value();  l3 = CL_LIB["COPY-ARRAY"](l1) else  l3 = n.bound end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["VECTOR"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL["LIST"],n}},function (l1,  ...)   single_value();  return CL["MAP-INTO"](CL["MAKE-ARRAY"](CL["LENGTH"](l1), k()), CL["IDENTITY"].fbound, l(l1)) end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["RESULT-TYPE"],{CL["FUNCTION"],{CL["&REST"],{CL_LIB["SEQUENCES"],n}}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL["APPLY"](CL["MIN"].fbound, CL["MAPCAR"](CL["LENGTH"].fbound, l(l3)), l()); single_value();  local l5 = CL["MAKE-SEQUENCE"](l1, l4, k()); single_value();  local l6 = 0; single_value();  local l7 = CL["GENSYM"](false); single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l9 = n if n ~= CL[">="](l(l6,l4)) then  single_value(); do break end; l9 = n.bound else  l9 = n.bound end i( l9 );
 i( CL_LIB["%SETELT"](l5, l6, CL["APPLY"](l2, CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["S"],n},function (l10,  ...)   single_value();  return CL["ELT"](l10, l6) end, 1, 0, false, false), l(l3)), l())) );
 single_value();  local l11 = (1 + l6); single_value();  single_value();  single_value();  local l12 = l11; single_value();  l6 = l12 local tmpres = l6 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l8.error ~= n and (l8.error ~= KEYWORD.TAG or l8.tag ~= l7) then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  return l5 end, 2, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CONCATENATE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["RESULT-TYPE"],{CL["&REST"],{CL_LIB["SEQUENCES"],n}}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["SUBTYPEP"](l1, CL["STRING"], false) then  l3 = CL["REDUCE"](CL_LIB["CONCAT-STRING"], CL["APPLY"](CL["CONCATENATE"].fbound, CL["LIST"], l(l2)), k(CL_LIB["KEY"], CL_LIB["CHAR-STRING"].fbound)) else  local l4 = CL["APPLY"](CL["+"].fbound, CL["MAPCAR"](CL["LENGTH"].fbound, l(l2)), l()); single_value();  local l5 = CL["MAKE-SEQUENCE"](l1, l4, k()); single_value();  local l6 = 0; single_value();  local l7 = l2; single_value();  local l8 = (l7)[1]; single_value();  single_value();  local l9 = CL["GENSYM"](false); single_value();  local l10 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l11 = n if n ~= CL["NOT"](l7) then  single_value(); do break end; l11 = n.bound else  l11 = n.bound end i( l11 );
 single_value();  i( CL["FUNCALL"](CL["SUBSEQ"].setfbound, l(l8,l5,l6)) );
 single_value();  local l12 = (CL["LENGTH"](l8) + l6); single_value();  l6 = l12 i( l6 );
 single_value();  single_value();  local l13 = (l7)[2]; single_value();  l7 = l13 i( l7 );
 single_value();  single_value();  single_value();  local l14 = (l7)[1]; single_value();  l8 = l14 local tmpres = l8 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l10.error ~= n and (l10.error ~= KEYWORD.TAG or l10.tag ~= l9) then if l10.error == KEYWORD.TAG then  error(l10) else error(l10[1]) end end i( CL["VALUES-LIST"](list_r(l10)) );
 single_value();  l3 = l5 end return l3 end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SUBSTITUTE-IF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEWITEM"],{CL_LIB["PREDICATE"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL["COUNT"],{CL_LIB["KEY"],n}}}}}}}}},function (l1, l2, l3, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL["COUNT"]] then  keys[CL["COUNT"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  return CL["NSUBSTITUTE-IF"](l1, l2, CL["COPY-SEQ"](l3), k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]], CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]], CL["COUNT"], keys[CL["COUNT"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 3, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["COUNT"]] = CL["COUNT"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["SUBSTITUTE-IF-NOT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEWITEM"],{CL_LIB["PREDICATE"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL["COUNT"],{CL_LIB["KEY"],n}}}}}}}}},function (l1, l2, l3, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL["COUNT"]] then  keys[CL["COUNT"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  return CL["NSUBSTITUTE-IF"](l1, CL["COMPLEMENT"](l2), CL["COPY-SEQ"](l3), k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]], CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]], CL["COUNT"], keys[CL["COUNT"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 3, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["COUNT"]] = CL["COUNT"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["SUBSTITUTE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEWITEM"],{CL_LIB["OLDITEM"],{CL["SEQUENCE"],{CL["&KEY"],{CL_LIB["FROM-END"],{CL_LIB["TEST"],{CL_LIB["TEST-NOT"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL["COUNT"],{CL_LIB["KEY"],n}}}}}}}}}}},function (l1, l2, l3, keys,  ...)  if not keys[CL_LIB["FROM-END"]] then  keys[CL_LIB["FROM-END"]] = n.bound end if not keys[CL_LIB["TEST"]] then  keys[CL_LIB["TEST"]] = n.bound end if not keys[CL_LIB["TEST-NOT"]] then  keys[CL_LIB["TEST-NOT"]] = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL["COUNT"]] then  keys[CL["COUNT"]] = n.bound end if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  return CL["NSUBSTITUTE"](l1, l2, CL["COPY-SEQ"](l3), k(CL_LIB["FROM-END"], keys[CL_LIB["FROM-END"]], CL_LIB["TEST"], keys[CL_LIB["TEST"]], CL_LIB["TEST-NOT"], keys[CL_LIB["TEST-NOT"]], CL_LIB["START"], keys[CL_LIB["START"]], CL_LIB["END"], keys[CL_LIB["END"]], CL["COUNT"], keys[CL["COUNT"]], CL_LIB["KEY"], keys[CL_LIB["KEY"]])) end, 3, 0, false, {0 , [LCL["KEYWORD"]["FROM-END"]] = CL_LIB["FROM-END"], [LCL["KEYWORD"]["TEST"]] = CL_LIB["TEST"], [LCL["KEYWORD"]["TEST-NOT"]] = CL_LIB["TEST-NOT"], [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["COUNT"]] = CL["COUNT"], [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["MERGE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["RESULT-TYPE"],{CL_LIB["SEQ1"],{CL_LIB["SEQ2"],{CL_LIB["PREDICATE"],{CL["&KEY"],{CL_LIB["KEY"],n}}}}}},function (l1, l2, l3, l4, keys,  ...)  if not keys[CL_LIB["KEY"]] then  keys[CL_LIB["KEY"]] = n.bound end  single_value();  local l5 = CL["LENGTH"](l2); single_value();  local l6 = CL["LENGTH"](l3); single_value();  local l7 = (l5 + l6); single_value();  local l8 = CL["MAKE-SEQUENCE"](l1, l7, k()); single_value();  local l9 = 0; single_value();  local l10 = 0; single_value();  local l11 = n if n ~= CL["NULL"](keys[CL_LIB["KEY"]]) then  keys[CL_LIB["KEY"]] = CL["IDENTITY"].fbound l11 = keys[CL_LIB["KEY"]] else  l11 = n.bound end i( l11 );
 single_value();  local l12 = 0; single_value();  local l13 = CL["GENSYM"](false); single_value();  local l14 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l15 = n if n ~= CL[">="](l(l12,l7)) then  single_value(); do break end; l15 = n.bound else  l15 = n.bound end i( l15 );
 local l17 = CL["ELT"](l2, l9); single_value();  local l16 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l17, }); single_value();  local l19 = CL["ELT"](l3, l10); single_value();  local l18 = CL_LIB['FUNCALL-LUA'](keys[CL_LIB["KEY"]],{l19, }); single_value();  local l21 = CL[">="](l(l10,l6)); single_value();  local l22 = n if n ~= l21 then  l22 = l21 else  local l23 = n if n ~= CL_LIB["%<"](l9, l5) then  local l25 = l16; single_value();  local l26 = l18; single_value();  local l24 = CL_LIB['FUNCALL-LUA'](l4,{l25, l26, }); single_value();  local l27 = n if n ~= l24 then  l27 = l24 else  local l28 = l18; single_value();  local l29 = l16; single_value();  l27 = CL["NOT"](CL_LIB['FUNCALL-LUA'](l4,{l28, l29, })) end l23 = l27 else  l23 = n.bound end l22 = l23 end local l20 = l22; single_value();  single_value();  local l30 = n if n ~= l20 then  i( CL_LIB["%SETELT"](l8, l12, CL["ELT"](l2, l9)) );
 single_value();  single_value();  local l31 = (1 + l9); single_value();  l9 = l31 l30 = l9 else  i( CL_LIB["%SETELT"](l8, l12, CL["ELT"](l3, l10)) );
 single_value();  single_value();  local l32 = (1 + l10); single_value();  l10 = l32 l30 = l10 end i( l30 );
 single_value();  local l33 = (1 + l12); single_value();  single_value();  single_value();  local l34 = l33; single_value();  l12 = l34 local tmpres = l12 end i( n );
 single_value();  return l8 end, 0, 0, false, false))); single_value(); if l14.error ~= n and (l14.error ~= KEYWORD.TAG or l14.tag ~= l13) then if l14.error == KEYWORD.TAG then  error(l14) else error(l14[1]) end end return CL["VALUES-LIST"](list_r(l14)) end, 4, 0, false, {0 , [LCL["KEYWORD"]["KEY"]] = CL_LIB["KEY"]})); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%CAR-UPDATE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW-VALUE"],n}},function (l1, l2,  ...)   i( CL["RPLACA"](l1, l2) );
 single_value();  return l2 end, 2, 0, false, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["CAR"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["%CAR-UPDATE"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["CAR"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%CDR-UPDATE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW-VALUE"],n}},function (l1, l2,  ...)   i( CL["RPLACD"](l1, l2) );
 single_value();  return l2 end, 2, 0, false, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["CDR"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["%CDR-UPDATE"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["CDR"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["REST"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["%CDR-UPDATE"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["REST"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["ELT"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["%SETELT"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["ELT"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["SVREF"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["%SETSVREF"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["SVREF"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%ASET-SETF"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL["&REST"],{CL_LIB["SUBSCRIPTS"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](CL_LIB["ASET"].fbound, l1, l((CL["LAST"](l2, false))[1],CL["BUTLAST"](l2, false))) end, 1, 0, true, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["AREF"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["%ASET-SETF"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["AREF"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["ROW-MAJOR-AREF"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["ROW-MAJOR-ASET"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["ROW-MAJOR-AREF"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["SYMBOL-VALUE"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL["SET"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["SYMBOL-VALUE"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["GETHASH"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["SETHASH"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["GETHASH"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SET-FDEFINITION"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],{CL_LIB["NEW-VALUE"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["SYMBOLP"](l1) then  single_value();  l3 = CL_LIB["FUNCTION-SETQ"](l1, l2) else  local l5 = n if n ~= CL["CONSP"](l1) then  l5 = CL["EQ"](CL["SETF"], (l1)[1]) else  l5 = n.bound end local l4 = n if n ~= l5 then  single_value();  l4 = CL_LIB["SETF-FUNCTION-SETQ"](CL["CADR"](l1), l2) else  local l6 = n if n ~= CL["T"].bound then  single_value();  l6 = CL["ERROR"]("Invalid function name ~A", l(l1)) else  l6 = n.bound end l4 = l6 end l3 = l4 end return l3 end, 2, 0, false, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["FDEFINITION"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["%SET-FDEFINITION"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["FDEFINITION"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["FIRST"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["%CAR-UPDATE"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["FIRST"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SET-SECOND"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW-VALUE"],n}},function (l1, l2,  ...)   i( CL["RPLACA"]((l1)[2], l2) );
 single_value();  return l2 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SET-THIRD"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW-VALUE"],n}},function (l1, l2,  ...)   i( CL["RPLACA"](CL["NTHCDR"](2, l1), l2) );
 single_value();  return l2 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SET-FOURTH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW-VALUE"],n}},function (l1, l2,  ...)   i( CL["RPLACA"](CL["NTHCDR"](3, l1), l2) );
 single_value();  return l2 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SET-FIFTH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW-VALUE"],n}},function (l1, l2,  ...)   i( CL["RPLACA"](CL["NTHCDR"](4, l1), l2) );
 single_value();  return l2 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SET-SIXTH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW-VALUE"],n}},function (l1, l2,  ...)   i( CL["RPLACA"](CL["NTHCDR"](5, l1), l2) );
 single_value();  return l2 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SET-SEVENTH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW-VALUE"],n}},function (l1, l2,  ...)   i( CL["RPLACA"](CL["NTHCDR"](6, l1), l2) );
 single_value();  return l2 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SET-EIGHTH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW-VALUE"],n}},function (l1, l2,  ...)   i( CL["RPLACA"](CL["NTHCDR"](7, l1), l2) );
 single_value();  return l2 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SET-NINTH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW-VALUE"],n}},function (l1, l2,  ...)   i( CL["RPLACA"](CL["NTHCDR"](8, l1), l2) );
 single_value();  return l2 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SET-TENTH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW-VALUE"],n}},function (l1, l2,  ...)   i( CL["RPLACA"](CL["NTHCDR"](9, l1), l2) );
 single_value();  return l2 end, 2, 0, false, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["SECOND"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["%SET-SECOND"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["SECOND"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["THIRD"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["%SET-THIRD"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["THIRD"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["FOURTH"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["%SET-FOURTH"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["FOURTH"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["FIFTH"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["%SET-FIFTH"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["FIFTH"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["SIXTH"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["%SET-SIXTH"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["SIXTH"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["SEVENTH"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["%SET-SEVENTH"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["SEVENTH"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["EIGHTH"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["%SET-EIGHTH"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["EIGHTH"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["NINTH"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["%SET-NINTH"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["NINTH"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["TENTH"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(CL_LIB["%SET-TENTH"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(CL["TENTH"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CAAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACA"]((l2)[1], l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CADR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACA"]((l2)[2], l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CDAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACD"]((l2)[1], l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CDDR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACD"]((l2)[2], l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CAAAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACA"](CL["CAAR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CADAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACA"](CL["CDAR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CDAAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACD"](CL["CAAR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CDDAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACD"](CL["CDAR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CAADR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACA"](CL["CADR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CADDR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACA"](CL["CDDR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CDADR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACD"](CL["CADR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CDDDR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACD"](CL["CDDR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CAAAAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACA"](CL["CAAAR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CADAAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACA"](CL["CDAAR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CDAAAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACD"](CL["CAAAR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CDDAAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACD"](CL["CDAAR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CAADAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACA"](CL["CADAR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CADDAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACA"](CL["CDDAR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CDADAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACD"](CL["CADAR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CDDDAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACD"](CL["CDDAR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CAAADR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACA"](CL["CAADR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CADADR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACA"](CL["CDADR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CDAADR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACD"](CL["CAADR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CDDADR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACD"](CL["CDADR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CAADDR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACA"](CL["CADDR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CADDDR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACA"](CL["CDDDR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CDADDR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACD"](CL["CADDR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["CDDDDR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL_LIB["PLACE"],n}},function (l1, l2,  ...)   single_value();  return CL["RPLACD"](CL["CDDDR"](l2), l1) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%TRAVERSE-REPLACE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["KEY"],{CL_LIB["NEW"],{CL["LIST"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = n if n ~= CL["NULL"](l3) then  single_value();  l4 = n.bound else  local l5 = n if n ~= CL["ATOM"](l3) then  single_value();  local l6 = n if n ~= CL["EQ"](l3, l1) then  l6 = l2 else  l6 = l3 end l5 = l6 else  local l7 = n if n ~= CL["T"].bound then  single_value();  l7 = CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l8,  ...)   single_value();  return CL_LIB["%TRAVERSE-REPLACE"](l1, l2, l8) end, 1, 0, false, false), l(l3)) else  l7 = n.bound end l5 = l7 end l4 = l5 end return l4 end, 3, 0, false, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["CHAR"], CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL_LIB["INDEX"],n}},function (l1, l2,  ...)   single_value();  local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = n.bound; local l8 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l9 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l11 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l10 = l11; single_value();  single_value();  l3,l4,l5,l6,l7= unpack_mv(CL_LIB["%GET-SETF-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l8 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l9.error ~= n and true then if l9.error == KEYWORD.TAG then  error(l9) else error(l9[1]) end end i( CL["VALUES-LIST"](list_r(l9)) );
 single_value();  local l12 = CL["GENSYM"](false); local l13 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(CL["APPEND"](l(l3,CL["LIST"](l(l13)))),CL["APPEND"](l(l4,CL["LIST"](l(l2)))),CL["LIST"](l(l12)),CL_LIB["%TRAVERSE-REPLACE"]((l5)[1], CL["CONS"](CL_LIB["%SET-CHAR"], CL["CONS"](l7, CL["CONS"](l13, CL["CONS"](l12, n)))), l6),CL["CONS"](CL["CHAR"], CL["CONS"](l7, CL["CONS"](l13, n))))) end, 2, 0, false, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["SCHAR"], CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL_LIB["INDEX"],n}},function (l1, l2,  ...)   single_value();  local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = n.bound; local l8 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l9 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l11 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l10 = l11; single_value();  single_value();  l3,l4,l5,l6,l7= unpack_mv(CL_LIB["%GET-SETF-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l8 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l9.error ~= n and true then if l9.error == KEYWORD.TAG then  error(l9) else error(l9[1]) end end i( CL["VALUES-LIST"](list_r(l9)) );
 single_value();  local l12 = CL["GENSYM"](false); local l13 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(CL["APPEND"](l(l3,CL["LIST"](l(l13)))),CL["APPEND"](l(l4,CL["LIST"](l(l2)))),CL["LIST"](l(l12)),CL_LIB["%TRAVERSE-REPLACE"]((l5)[1], CL["CONS"](CL_LIB["%SET-CHAR"], CL["CONS"](l7, CL["CONS"](l13, CL["CONS"](l12, n)))), l6),CL["CONS"](CL["SCHAR"], CL["CONS"](l7, CL["CONS"](l13, n))))) end, 2, 0, false, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["GETF"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLIST"],{CL_LIB["INDICATOR"],{CL["&OPTIONAL"],{CL_LIB["DEFAULT"],n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = n.bound end  single_value();  local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = n.bound; local l8 = n.bound; local l9 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l10 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l12 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l11 = l12; single_value();  single_value();  l4,l5,l6,l7,l8= unpack_mv(CL_LIB["%GET-SETF-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l9 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l10.error ~= n and true then if l10.error == KEYWORD.TAG then  error(l10) else error(l10[1]) end end i( CL["VALUES-LIST"](list_r(l10)) );
 single_value();  local l13 = CL["GENSYM"](false); local l14 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(CL["APPEND"](l(l4,CL["LIST"](l(l14)))),CL["APPEND"](l(l5,CL["LIST"](l(l2)))),CL["LIST"](l(l13)),CL_LIB["%TRAVERSE-REPLACE"]((l6)[1], CL["CONS"](CL_LIB["SETGETF"], CL["CONS"](l8, CL["CONS"](l14, CL["CONS"](l13, n)))), l7),CL["CONS"](CL["GETF"], CL["CONS"](l8, CL["CONS"](l2, n))))) end, 2, 1, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["COMPILER-MACRO-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-FUNCTION"],{CL_LIB["NAME"],{CL["&OPTIONAL"],{CL_LIB["ENVIRONMENT"],n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = n.bound end  single_value();  return CL_LIB["SETHASH"](l2, CL_LIB["*COMPILER-MACROS"].bound, l1) end, 2, 1, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["MACRO-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-MACROFUNCTION"],{CL_LIB["NAME"],n}},function (l1, l2,  ...)   single_value();  return CL_LIB["MACRO-SETQ"](l2,l1) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["DOCUMENTATION"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL["IGNORE"],n}},function (l1,  ...)   single_value();  return n.bound end, 0, 0, true, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["SYMBOL-PLIST"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL["SYMBOL"],n}},function (l1, l2,  ...)   single_value();  local l3 = l1; single_value(); l2[CL["IDENTITY"]("plist")] = l3 return l3 end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](CL["GET"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEW-VALUE"],{CL["SYMBOL"],{CL_LIB["INDICATOR"],{CL["&OPTIONAL"],{CL_LIB["DEFAULT"],n}}}}},function (l1, l2, l3, l4,  ...)  if not l4 then  l4 = n.bound end  local l5 = CL["GENSYM"](false); single_value();  local l6 = n if n ~= CL["EQ"](l5, CL["GETF"](CL["SYMBOL-PLIST"](l2), l3, l5)) then  single_value();  l6 = CL["FUNCALL"](CL["SYMBOL-PLIST"].setfbound, l(CL["CONS"](l3, CL["CONS"](l1, CL["SYMBOL-PLIST"](l2))),l2)) else  single_value();  local l7 = l3; single_value();  local l8 = l2; single_value();  single_value();  local l9 = l1; single_value();  l6 = CL["FUNCALL"](CL["SYMBOL-PLIST"].setfbound, l(CL_LIB["SETGETF"](CL["SYMBOL-PLIST"](l8), l7, l9),l8)) end i( l6 );
 single_value();  return l1 end, 3, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["REMOVE-FROM-PLIST!"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLIST"],{CL_LIB["INDICATOR"],{CL["&AUX"],{{CL_LIB["PTR"],{{CL["CDR"],{CL_LIB["PLIST"],n}},n}},n}}}},function (l1, l2,  ...)  l3 = (l1)[2]  single_value();  local l4 = n if n ~= CL["EQ"](l2, (l1)[1]) then  l4 = CL["VALUES"](l(CL["CDDR"](l1),CL["T"].bound)) else  while true do  local l5 = n if n ~= l3 then  l5 = n.bound else  single_value();  local l6 = CL["FUNCALL"](l, l(unpack_mv(CL["VALUES"](l(l1,n.bound))))); single_value();  l5 = error({tag=CL["IDENTITY"](LCL["%BR"]["COMMON-LISP*NIL"].bound),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l6)) end)()}) end i( l5 );
 local l7 = n if n ~= CL["EQ"](l2, CL["CADR"](l3)) then  i( CL["RPLACD"](l3, CL["CDDDR"](l3)) );
 single_value();  local l8 = CL["FUNCALL"](l, l(unpack_mv(CL["VALUES"](l(l1,CL["T"].bound))))); single_value();  l7 = error({tag=CL["IDENTITY"](LCL["%BR"]["COMMON-LISP*NIL"].bound),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l8)) end)()}) else  l7 = n.bound end i( l7 );
 single_value();  l3 = CL["CDDR"](l3) local tmpres = l3 end l4 = n end return l4 end, 2, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["REMF"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G104575"],{CL["&OPTIONAL"],{LCL["NIL"]["G104576"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  single_value();  local l13 = CL["GENSYM"](false); single_value();  local l14 = n.bound; local l15 = n.bound; local l16 = n.bound; local l17 = n.bound; local l18 = n.bound; local l19 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l20 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l22 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l21 = l22; single_value();  single_value();  l14,l15,l16,l17,l18= unpack_mv(CL_LIB["%GET-SETF-EXPANSION"](l5, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l19 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l20.error ~= n and true then if l20.error == KEYWORD.TAG then  error(l20) else error(l20[1]) end end i( CL["VALUES-LIST"](list_r(l20)) );
 single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["MAPCAR"](CL["LIST"].fbound, l(l14,l15)), CL["CONS"](CL["CONS"](CL["MULTIPLE-VALUE-BIND"], CL["CONS"](CL["CONS"]((l16)[1], CL["CONS"](l13, n)), CL["CONS"](CL["CONS"](CL_LIB["REMOVE-FROM-PLIST!"], CL["CONS"](l18, CL["CONS"](l9, n))), CL["CONS"](l17, CL["CONS"](l13, n))))), n))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["REMPROP"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],{CL_LIB["INDICATOR"],n}},function (l1, l2,  ...)   single_value();  local l3 = l1; single_value();  local l4 = n.bound; local l5 = n.bound; local l6 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l9 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l8 = l9; single_value();  single_value();  l4,l5= unpack_mv(CL_LIB["REMOVE-FROM-PLIST!"](CL["SYMBOL-PLIST"](l3), l2), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l6 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l7.error ~= n and true then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end i( CL["VALUES-LIST"](list_r(l7)) );
 i( CL["FUNCALL"](CL["SYMBOL-PLIST"].setfbound, l(l4,l3)) );
 single_value();  return l5 end, 2, 0, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["MAKE-BYTESPEC"] , CL_LIB["ALLOC-FUNCTION"]({CL["&KEY"],{{CL_LIB["SIZE"],{n,n}},{{CL["POSITION"],{n,n}},n}}},function (keys,  ...)  if not keys[CL_LIB["SIZE"]] then  keys[CL_LIB["SIZE"]] = n.bound end if not keys[CL["POSITION"]] then  keys[CL["POSITION"]] = n.bound end  single_value();  local l1 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-STRUCT"].fbound, {}); local l2 = CL_LIB["BYTESPEC"]; single_value(); l1[CL["IDENTITY"]("name")] = l2 i( l2 );
 local l3 = keys[CL_LIB["SIZE"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["SIZE"])] = l3 i( l3 );
 local l4 = keys[CL["POSITION"]]; single_value(); l1[CL["IDENTITY"](CL["POSITION"])] = l4 i( l4 );
 single_value();  return l1 end, 0, 0, false, {0 , [LCL["KEYWORD"]["SIZE"]] = CL_LIB["SIZE"], [LCL["KEYWORD"]["POSITION"]] = CL["POSITION"]})) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["COPY-BYTESPEC"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l5,  ...)   single_value();  return CL["COPY-STRUCTURE"](l5) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL_LIB["BYTESPEC"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l6,  ...)   single_value();  return CL_LIB["%CHECK-STRUCT-TYPE"](l6, CL_LIB["BYTESPEC"]) end, 1, 0, false, false), {CL["STRUCTURE-OBJECT"],{CL["T"],n}}) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["BYTESPEC-P"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l7,  ...)   single_value();  return CL["TYPEP"](l7, CL_LIB["BYTESPEC"], false) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL["BYTE-SIZE"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l8,  ...)   single_value();  local l9 = n.bound; local l10 = n.bound; local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l9,l10,l11,l12,l13= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l8, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = n.bound; local l19 = n.bound; local l20 = n.bound; local l21 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l22 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l24 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l23 = l24; single_value();  single_value();  l18,l19,l20= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l13, l9, l10), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l21 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l22.error ~= n and true then if l22.error == KEYWORD.TAG then  error(l22) else error(l22[1]) end end i( CL["VALUES-LIST"](list_r(l22)) );
 single_value();  local l25 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l19,l20,CL["LIST"](l(l25)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["SIZE"],n}},{CL_LIB["NEW"],n}}}},n}}})),l18,CL["LIST"](l(l25)))),CL["APPEND"](l(CL["LIST"](l(CL["BYTE-SIZE"])),l18)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL["BYTE-SIZE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l26,  ...)   single_value();  local l27 = CL_LIB["SIZE"]; local l28 = n.bound; single_value();  return ((l26)[l27] or l28) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL["BYTE-POSITION"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l29,  ...)   single_value();  local l30 = n.bound; local l31 = n.bound; local l32 = n.bound; local l33 = n.bound; local l34 = n.bound; local l35 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l36 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l38 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l37 = l38; single_value();  single_value();  l30,l31,l32,l33,l34= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l29, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l35 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l36.error ~= n and true then if l36.error == KEYWORD.TAG then  error(l36) else error(l36[1]) end end i( CL["VALUES-LIST"](list_r(l36)) );
 single_value();  local l39 = n.bound; local l40 = n.bound; local l41 = n.bound; local l42 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l43 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l45 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l44 = l45; single_value();  single_value();  l39,l40,l41= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l34, l30, l31), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l42 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l43.error ~= n and true then if l43.error == KEYWORD.TAG then  error(l43) else error(l43[1]) end end i( CL["VALUES-LIST"](list_r(l43)) );
 single_value();  local l46 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l40,l41,CL["LIST"](l(l46)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL["POSITION"],n}},{CL_LIB["NEW"],n}}}},n}}})),l39,CL["LIST"](l(l46)))),CL["APPEND"](l(CL["LIST"](l(CL["BYTE-POSITION"])),l39)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL["BYTE-POSITION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l47,  ...)   single_value();  local l48 = CL["POSITION"]; local l49 = n.bound; single_value();  return ((l47)[l48] or l49) end, 1, 0, false, false)) );
 single_value();  tmp = CL_LIB["BYTESPEC"]; tmp = CL_LIB["FUNCTION-SETQ"](CL["BYTE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SIZE"],{CL["POSITION"],n}},function (l1, l2,  ...)   local l3 = n if n ~= CL["TYPEP"](l1, CL["INTEGER"], false) then  l3 = n.bound else  single_value();  l3 = CL["ERROR"](CL["TYPE-ERROR"], l(LCL["KEYWORD"]["FORM"],CL_LIB["SIZE"],LCL["KEYWORD"]["DATUM"],l1,LCL["KEYWORD"]["EXPECTED-TYPE"],CL["INTEGER"])) end i( l3 );
 local l4 = n if n ~= CL["TYPEP"](l2, CL["INTEGER"], false) then  l4 = n.bound else  single_value();  l4 = CL["ERROR"](CL["TYPE-ERROR"], l(LCL["KEYWORD"]["FORM"],CL["POSITION"],LCL["KEYWORD"]["DATUM"],l2,LCL["KEYWORD"]["EXPECTED-TYPE"],CL["INTEGER"])) end i( l4 );
 single_value();  return CL_LIB["MAKE-BYTESPEC"](k(CL_LIB["SIZE"], l1, CL["POSITION"], l2)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["BYTE-MASK"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["BYTESPEC"],n},function (l1,  ...)   single_value();  return CL["ASH"](CL["1-"](CL["ASH"](1, CL["BYTE-SIZE"](l1))), CL["BYTE-POSITION"](l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MASK-FIELD"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["BYTESPEC"],{CL["INTEGER"],n}},function (l1, l2,  ...)   single_value();  return CL["LOGAND"](l(CL_LIB["BYTE-MASK"](l1),l2)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["DEPOSIT-FIELD"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NEWBYTE"],{CL_LIB["BYTESPEC"],{CL["INTEGER"],n}}},function (l1, l2, l3,  ...)   single_value();  return CL["LOGIOR"](l(CL["LOGANDC1"](CL_LIB["BYTE-MASK"](l2), l3),CL["MASK-FIELD"](l2, l1))) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LDB"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["BYTESPEC"],{CL["INTEGER"],n}},function (l1, l2,  ...)   single_value();  return CL["ASH"](CL["MASK-FIELD"](l1, l2), - CL["BYTE-POSITION"](l1)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LDB-TEST"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["BYTESPEC"],{CL["INTEGER"],n}},function (l1, l2,  ...)   single_value();  return CL["/="](0, CL["LDB"](l1, l2)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["DPB"] , CL_LIB["ALLOC-FUNCTION"]({CL["BYTE"],{CL_LIB["BYTESPEC"],{CL["INTEGER"],n}}},function (l1, l2, l3,  ...)   single_value();  return CL["DEPOSIT-FIELD"](CL["ASH"](l1, CL["BYTE-POSITION"](l2)), l2, l3) end, 3, 0, false, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["MASK-FIELD"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["BYTESPEC"],{CL["INTEGER"],n}},function (l1, l2,  ...)   single_value();  local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = n.bound; local l8 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l9 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l11 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l10 = l11; single_value();  single_value();  l3,l4,l5,l6,l7= unpack_mv(CL_LIB["%GET-SETF-EXPANSION"](l2, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l8 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l9.error ~= n and true then if l9.error == KEYWORD.TAG then  error(l9) else error(l9[1]) end end i( CL["VALUES-LIST"](list_r(l9)) );
 single_value();  local l12 = CL["GENSYM"](false); local l13 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(CL["APPEND"](l(l3,CL["LIST"](l(l13)))),CL["APPEND"](l(l4,CL["LIST"](l(l1)))),CL["LIST"](l(l12)),CL_LIB["%TRAVERSE-REPLACE"]((l5)[1], CL["CONS"](CL["DEPOSIT-FIELD"], CL["CONS"](l12, CL["CONS"](l13, CL["CONS"](l7, n)))), l6),CL["CONS"](CL["MASK-FIELD"], CL["CONS"](l13, CL["CONS"](l7, n))))) end, 2, 0, false, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](CL["LDB"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["BYTESPEC"],{CL["INTEGER"],n}},function (l1, l2,  ...)   single_value();  local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = n.bound; local l8 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l9 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l11 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l10 = l11; single_value();  single_value();  l3,l4,l5,l6,l7= unpack_mv(CL_LIB["%GET-SETF-EXPANSION"](l2, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l8 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l9.error ~= n and true then if l9.error == KEYWORD.TAG then  error(l9) else error(l9[1]) end end i( CL["VALUES-LIST"](list_r(l9)) );
 single_value();  local l12 = CL["GENSYM"](false); local l13 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(CL["APPEND"](l(l3,CL["LIST"](l(l13)))),CL["APPEND"](l(l4,CL["LIST"](l(l1)))),CL["LIST"](l(l12)),CL_LIB["%TRAVERSE-REPLACE"]((l5)[1], CL["CONS"](CL["DPB"], CL["CONS"](l12, CL["CONS"](l13, CL["CONS"](l7, n)))), l6),CL["CONS"](CL["LDB"], CL["CONS"](l13, CL["CONS"](l7, n))))) end, 2, 0, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["STRUCTURE-OBJECT"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l1,  ...)   single_value();  return CL["EQ"]((getmetatable(l1) or n), CL_LIB["STRUCT-METATABLE"].bound) end, 1, 0, false, false), {CL["T"],n}); local l1 = CL["MAKE-HASH-TABLE"](k()); single_value();  tmp = CL_LIB.DEF(CL_LIB["*STRUCTURE-SLOTS-TABLE*"],l1); local l1 = CL["MAKE-HASH-TABLE"](k()); single_value();  tmp = CL_LIB.DEF(CL_LIB["*STRUCTURE-SLOTS-TYPE*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%CHECK-STRUCT-TYPE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],{CL["TYPE"],n}},function (l1, l2,  ...)   single_value();  local l3 = CL["GETHASH"](l2, CL_LIB["*STRUCTURE-SLOTS-TYPE*"].bound, false); single_value();  local l4 = n if n ~= CL["TYPEP"](l1, l3, false) then  single_value();  l4 = CL["EQ"](l2, CL["ELT"](l1, 0)) else  local l6 = n if n ~= CL["NULL"](l3) then  l6 = CL["EQ"]((getmetatable(l1) or n), CL_LIB["STRUCT-METATABLE"].bound) else  l6 = n.bound end local l5 = n if n ~= l6 then  single_value();  local l8 = "name"; local l9 = n.bound; single_value();  local l7 = ((l1)[l8] or l9); single_value();  local l10 = CL["EQ"](l7, l2); single_value();  local l11 = n if n ~= l10 then  l11 = l10 else  l11 = CL["SUBTYPEP"](l7, l2, false) end l5 = l11 else  l5 = n.bound end l4 = l5 end return l4 end, 2, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DEFSTRUCT"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G111091"],{CL["&OPTIONAL"],{LCL["NIL"]["G111092"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l11 = n if n ~= CL["CONSP"](l5) then  l11 = (l5)[1] else  l11 = l5 end local l10 = l11; single_value();  local l13 = n if n ~= CL["CONSP"](l5) then  l13 = (l5)[2] else  l13 = n.bound end local l12 = l13; single_value();  local l14 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL["SYMBOL-NAME"](l10), "-", }); single_value();  local l15 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"MAKE-", CL["SYMBOL-NAME"](l10), }); single_value();  local l16 = n.bound; single_value();  local l17 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {"COPY-", CL["SYMBOL-NAME"](l10), }); single_value();  local l18 = n.bound; single_value();  local l19 = n.bound; single_value();  local l20 = 0; single_value();  local l21 = n.bound; single_value();  local l22 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL["SYMBOL-NAME"](l10), "-P", }); single_value();  local l23 = n.bound; single_value();  local l24 = l12; single_value();  local l25 = (l24)[1]; single_value();  single_value();  local l26 = CL["GENSYM"](false); single_value();  local l27 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l28 = n if n ~= CL["NOT"](l24) then  single_value(); do break end; l28 = n.bound else  l28 = n.bound end i( l28 );
 local l29 = n if n ~= CL["ATOM"](l25) then  single_value();  single_value();  single_value();  local l30 = CL["LIST"](l(l25)); single_value();  l25 = l30 l29 = l25 else  l29 = n.bound end i( l29 );
 local l31 = (l25)[1]; single_value();  local l32 = n if n ~= CL["EQL"](l31, LCL["KEYWORD"]["CONC-NAME"]) then  single_value();  local l33 = CL["CADR"](l25); single_value();  local l34 = n if n ~= CL["NULL"](l33) then  single_value();  l14 = "" l34 = l14 else  local l35 = n if n ~= CL["SYMBOLP"](l33) then  single_value();  l14 = CL["SYMBOL-NAME"](l33) l35 = l14 else  local l36 = n if n ~= CL["T"].bound then  single_value();  l14 = l33 l36 = l14 else  l36 = n.bound end l35 = l36 end l34 = l35 end l32 = l34 else  local l37 = n if n ~= CL["EQL"](l31, LCL["KEYWORD"]["CONSTRUCTOR"]) then  single_value();  local l38 = CL["CADR"](l25); local l39 = CL["CADDR"](l25); local l40 = n if n ~= CL["NULL"](l38) then  single_value();  l15 = l38 l40 = l15 else  local l41 = n if n ~= CL["SYMBOLP"](l38) then  single_value();  l15 = CL["SYMBOL-NAME"](l38) l41 = l15 else  local l42 = n if n ~= CL["T"].bound then  single_value();  l15 = l38 l42 = l15 else  l42 = n.bound end l41 = l42 end l40 = l41 end i( l40 );
 single_value();  l16 = l39 l37 = l16 else  local l43 = n if n ~= CL["EQL"](l31, LCL["KEYWORD"]["COPIER"]) then  single_value();  local l44 = CL["CADR"](l25); single_value();  local l45 = n if n ~= CL["NULL"](l44) then  single_value();  l17 = l44 l45 = l17 else  local l46 = n if n ~= CL["SYMBOLP"](l44) then  single_value();  l17 = CL["SYMBOL-NAME"](l44) l46 = l17 else  local l47 = n if n ~= CL["T"].bound then  single_value();  l17 = l44 l47 = l17 else  l47 = n.bound end l46 = l47 end l45 = l46 end l43 = l45 else  local l48 = n if n ~= CL["EQL"](l31, LCL["KEYWORD"]["PREDICATE"]) then  single_value();  local l49 = CL["CADR"](l25); single_value();  local l50 = n if n ~= CL["NULL"](l49) then  single_value();  l22 = l49 l50 = l22 else  local l51 = n if n ~= CL["SYMBOLP"](l49) then  single_value();  l22 = CL["SYMBOL-NAME"](l49) l51 = l22 else  local l52 = n if n ~= CL["T"].bound then  single_value();  l22 = l49 l52 = l22 else  l52 = n.bound end l51 = l52 end l50 = l51 end l48 = l50 else  local l53 = n if n ~= CL["EQL"](l31, LCL["KEYWORD"]["TYPE"]) then  single_value();  single_value();  single_value();  local l54 = CL["CADR"](l25); single_value();  l23 = l54 l53 = l23 else  local l55 = n if n ~= CL["EQL"](l31, LCL["KEYWORD"]["NAMED"]) then  single_value();  single_value();  single_value();  local l56 = CL["T"].bound; single_value();  l21 = l56 l55 = l21 else  local l57 = n if n ~= CL["EQL"](l31, LCL["KEYWORD"]["INCLUDE"]) then  single_value();  local l58 = CL["CADR"](l25); single_value();  local l59 = CL["CDDR"](l25); single_value();  local l60 = CL["GETHASH"](l58, CL_LIB["*STRUCTURE-SLOTS-TABLE*"].bound, CL["T"].bound); single_value();  l18 = l58 i( l18 );
 local l61 = n if n ~= CL["EQ"](CL["T"].bound, l60) then  l61 = CL["ERROR"]("Parent structure does not exist", l()) else  l61 = n.bound end i( l61 );
 single_value();  l19 = CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SLOT"],n},function (l62,  ...)   single_value();  local l63 = CL["ASSOC"]((l62)[1], l59, k()); local l64 = n if n ~= l63 then  single_value();  local l65 = l62; single_value();  local l66 = (l65)[2]; single_value();  single_value();  local l67 = (l63)[2]; single_value();  l64 = CL_LIB["%CAR-UPDATE"](l66, l67) else  l64 = n.bound end i( l64 );
 single_value();  return l62 end, 1, 0, false, false), l(CL["COPY-LIST"](l60))) l57 = l19 else  local l68 = n if n ~= CL["EQL"](l31, LCL["KEYWORD"]["INITIAL-OFFSET"]) then  single_value();  single_value();  single_value();  local l70 = CL["CADR"](l25); single_value();  local l71 = n if n ~= l70 then  l71 = l70 else  l71 = 0 end local l69 = l71; single_value();  l20 = l69 l68 = l20 else  l68 = n.bound end l57 = l68 end l55 = l57 end l53 = l55 end l48 = l53 end l43 = l48 end l37 = l43 end l32 = l37 end i( l32 );
 single_value();  single_value();  local l72 = (l24)[2]; single_value();  l24 = l72 i( l24 );
 single_value();  single_value();  single_value();  local l73 = (l24)[1]; single_value();  l25 = l73 local tmpres = l25 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l27.error ~= n and (l27.error ~= KEYWORD.TAG or l27.tag ~= l26) then if l27.error == KEYWORD.TAG then  error(l27) else error(l27[1]) end end i( CL["VALUES-LIST"](list_r(l27)) );
 l9 = CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l74,  ...)   single_value();  local l75 = n if n ~= CL["CONSP"](l74) then  l75 = l74 else  l75 = CL["LIST"](l(l74,n.bound)) end return l75 end, 1, 0, false, false), l(CL["APPEND"](l(l19,l9)))) i( l9 );
 i( CL_LIB["SETHASH"](l10, CL_LIB["*STRUCTURE-SLOTS-TABLE*"].bound, l9) );
 i( CL_LIB["SETHASH"](l10, CL_LIB["*STRUCTURE-SLOTS-TYPE*"].bound, l23) );
 single_value();  local l76 = n if n ~= l15 then  single_value();  local l77 = l16; single_value();  local l78 = n if n ~= l77 then  l78 = l77 else  l78 = CL["CONS"](CL["&KEY"], CL["APPEND"](l(CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l79,  ...)   single_value();  return CL["LIST"](l((l79)[1],CL["CADR"](l79))) end, 1, 0, false, false), l(l9)),n))) end local l80 = n if n ~= CL["EQ"](l23, CL["LIST"]) then  single_value();  local l81 = n if n ~= l21 then  l81 = CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l10, n)), n) else  l81 = n.bound end l80 = CL["CONS"](CL["LIST"], CL["APPEND"](l(CL["MAKE-LIST"](l20, k()),CL["APPEND"](l(l81,CL["APPEND"](l(CL["MAPCAR"](CL["CAR"].fbound, l(l9)),n))))))) else  local l83 = CL["EQ"](l23, CL["VECTOR"]); single_value();  local l84 = n if n ~= l83 then  l84 = l83 else  local l85 = n if n ~= CL["CONSP"](l23) then  l85 = CL["EQ"](CL["VECTOR"], (l23)[1]) else  l85 = n.bound end l84 = l85 end local l82 = n if n ~= l84 then  single_value();  local l86 = n if n ~= l21 then  l86 = CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l10, n)), n) else  l86 = n.bound end l82 = CL["CONS"](CL["VECTOR"], CL["APPEND"](l(CL["MAKE-LIST"](l20, k()),CL["APPEND"](l(l86,CL["APPEND"](l(CL["MAPCAR"](CL["CAR"].fbound, l(l9)),n))))))) else  local l87 = n if n ~= CL["NULL"](l23) then  single_value();  local l88 = CL["GENSYM"](false); single_value();  l87 = CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l88, CL["CONS"](CL["CONS"](CL_LIB["ALLOC-STRUCT"], n), n)), n), CL["CONS"](CL["CONS"](CL_LIB["LUA-SET-TABLE"], CL["CONS"](l88, CL["CONS"]("name", CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l10, n)), n)))), CL["APPEND"](l(CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l89,  ...)   single_value();  return CL["CONS"](CL_LIB["LUA-SET-TABLE"], CL["CONS"](l88, CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"]((l89)[1], n)), CL["CONS"]((l89)[1], n)))) end, 1, 0, false, false), l(l9)),CL["CONS"](l88, n)))))) else  l87 = n.bound end l82 = l87 end l80 = l82 end l76 = CL["CONS"](CL["DEFUN"], CL["CONS"](CL["INTERN"](l15, false), CL["CONS"](l78, CL["CONS"](l80, n)))) else  l76 = n.bound end local l90 = n if n ~= l17 then  single_value();  local l91 = n if n ~= l23 then  l91 = CL["CONS"](CL["COPY-SEQ"], CL["CONS"](CL_LIB["STRUCT"], n)) else  l91 = CL["CONS"](CL["COPY-STRUCTURE"], CL["CONS"](CL_LIB["STRUCT"], n)) end l90 = CL["CONS"](CL["DEFUN"], CL["CONS"](CL["INTERN"](l17, false), CL["CONS"](CL["CONS"](CL_LIB["STRUCT"], n), CL["CONS"](l91, n)))) else  l90 = n.bound end local l93 = CL["NULL"](l23); single_value();  local l94 = n if n ~= l93 then  l94 = l93 else  l94 = l21 end local l92 = n if n ~= l94 then  single_value();  local l95 = n if n ~= l18 then  l95 = CL["LIST"](l(l18)) else  l95 = n.bound end local l96 = n if n ~= CL["EQ"](l23, CL["LIST"]) then  l96 = {CL["LIST"],n} else  l96 = n.bound end local l98 = CL["EQ"](l23, CL["VECTOR"]); single_value();  local l99 = n if n ~= l98 then  l99 = l98 else  local l100 = n if n ~= CL["LISTP"](l23) then  l100 = CL["EQ"](CL["VECTOR"], (l23)[1]) else  l100 = n.bound end l99 = l100 end local l97 = n if n ~= l99 then  l97 = {CL["VECTOR"],n} else  l97 = n.bound end l92 = CL["CONS"](CL["CONS"](CL_LIB["%REGTYPE"], CL["CONS"](l10, CL["CONS"](CL["APPEND"](l(l95,CL["CONS"](CL["STRUCTURE-OBJECT"], CL["APPEND"](l(l96,CL["APPEND"](l(l97,CL["CONS"](CL["T"], n)))))))), CL["CONS"](CL["CONS"](CL_LIB["%CHECK-STRUCT-TYPE"], CL["CONS"](CL_LIB["EL"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l10, n)), n))), n)))), n) else  l92 = n.bound end local l102 = n if n ~= l22 then  local l103 = CL["NULL"](l23); single_value();  local l104 = n if n ~= l103 then  l104 = l103 else  l104 = l21 end l102 = l104 else  l102 = n.bound end local l101 = n if n ~= l102 then  single_value();  l101 = CL["CONS"](CL["CONS"](CL["DEFUN"], CL["CONS"](CL["INTERN"](l22, false), CL["CONS"](CL["CONS"](CL_LIB["STRUCT"], n), CL["CONS"](CL["CONS"](CL["TYPEP"], CL["CONS"](CL_LIB["STRUCT"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l10, n)), n))), n)))), n) else  l101 = n.bound end local l105 = -1; local l106 = n if n ~= l21 then  single_value();  single_value();  local l107 = (1 + l105); single_value();  l105 = l107 l106 = l105 else  l106 = n.bound end i( l106 );
 single_value();  return CL["CONS"](CL["PROGN"], CL["CONS"](l76, CL["CONS"](l90, CL["APPEND"](l(l92,CL["APPEND"](l(l101,CL["APPEND"](l(CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["S"],n},function (l108,  ...)   single_value();  local l109 = (l108)[1]; single_value();  local l110 = CL["CDDR"](l108); single_value();  local l111 = CL["INTERN"](CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l14, CL["SYMBOL-NAME"](l109), }), false); single_value();  single_value();  local l112 = (1 + l105); single_value();  l105 = l112 i( l105 );
 single_value();  local l113 = n if n ~= CL["GETF"](l110, LCL["KEYWORD"]["READ-ONLY"], false) then  l113 = n.bound else  single_value();  local l114 = n if n ~= l23 then  l114 = CL["CONS"](CL_LIB["%SETELT"], CL["CONS"](CL_LIB["PLACE"], CL["CONS"]((l20 + l105), CL["CONS"](CL_LIB["NEW"], n)))) else  l114 = CL["CONS"](CL_LIB["LUA-SET-TABLE"], CL["CONS"](CL_LIB["PLACE"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l109, n)), CL["CONS"](CL_LIB["NEW"], n)))) end l113 = CL["CONS"](CL["DEFSETF"], CL["CONS"](l111, CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](CL["CONS"](CL_LIB["PLACE"], CL["CONS"](CL_LIB["NEW"], n)), CL["CONS"](l114, n))), n))) end local l115 = n if n ~= l23 then  l115 = CL["CONS"](CL["ELT"], CL["CONS"](CL_LIB["STRUCT"], CL["CONS"]((l20 + l105), n))) else  l115 = CL["CONS"](CL_LIB["LUA-INDEX-TABLE"], CL["CONS"](CL_LIB["STRUCT"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l109, n)), n))) end return CL["CONS"](CL["PROGN"], CL["CONS"](l113, CL["CONS"](CL["CONS"](CL["DEFUN"], CL["CONS"](l111, CL["CONS"](CL["CONS"](CL_LIB["STRUCT"], n), CL["CONS"](l115, n)))), n))) end, 1, 0, false, false), l(l9)),CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l10, n)), n)))))))))) end, 1, 1, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); i( CL_LIB["FUNCTION-SETQ"](CL_LIB["MAKE-STREAM"] , CL_LIB["ALLOC-FUNCTION"]({CL["&KEY"],{{CL_LIB["STATE"],{CL["T"],n}},{{CL_LIB["COLUMN"],{0,n}},n}}},function (keys,  ...)  if not keys[CL_LIB["STATE"]] then  keys[CL_LIB["STATE"]] = CL["T"].bound end if not keys[CL_LIB["COLUMN"]] then  keys[CL_LIB["COLUMN"]] = 0 end  single_value();  local l1 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-STRUCT"].fbound, {}); local l2 = CL["STREAM"]; single_value(); l1[CL["IDENTITY"]("name")] = l2 i( l2 );
 local l3 = keys[CL_LIB["STATE"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["STATE"])] = l3 i( l3 );
 local l4 = keys[CL_LIB["COLUMN"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["COLUMN"])] = l4 i( l4 );
 single_value();  return l1 end, 0, 0, false, {0 , [LCL["KEYWORD"]["STATE"]] = CL_LIB["STATE"], [LCL["KEYWORD"]["COLUMN"]] = CL_LIB["COLUMN"]})) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["COPY-STREAM"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l5,  ...)   single_value();  return CL["COPY-STRUCTURE"](l5) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["STREAM"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l6,  ...)   single_value();  return CL_LIB["%CHECK-STRUCT-TYPE"](l6, CL["STREAM"]) end, 1, 0, false, false), {CL["STRUCTURE-OBJECT"],{CL["T"],n}}) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["STREAM-P"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l7,  ...)   single_value();  return CL["TYPEP"](l7, CL["STREAM"], false) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["STREAM-STATE"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l8,  ...)   single_value();  local l9 = n.bound; local l10 = n.bound; local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l9,l10,l11,l12,l13= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l8, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = n.bound; local l19 = n.bound; local l20 = n.bound; local l21 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l22 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l24 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l23 = l24; single_value();  single_value();  l18,l19,l20= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l13, l9, l10), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l21 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l22.error ~= n and true then if l22.error == KEYWORD.TAG then  error(l22) else error(l22[1]) end end i( CL["VALUES-LIST"](list_r(l22)) );
 single_value();  local l25 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l19,l20,CL["LIST"](l(l25)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["STATE"],n}},{CL_LIB["NEW"],n}}}},n}}})),l18,CL["LIST"](l(l25)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["STREAM-STATE"])),l18)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["STREAM-STATE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l26,  ...)   single_value();  local l27 = CL_LIB["STATE"]; local l28 = n.bound; single_value();  return ((l26)[l27] or l28) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["STREAM-COLUMN"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l29,  ...)   single_value();  local l30 = n.bound; local l31 = n.bound; local l32 = n.bound; local l33 = n.bound; local l34 = n.bound; local l35 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l36 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l38 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l37 = l38; single_value();  single_value();  l30,l31,l32,l33,l34= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l29, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l35 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l36.error ~= n and true then if l36.error == KEYWORD.TAG then  error(l36) else error(l36[1]) end end i( CL["VALUES-LIST"](list_r(l36)) );
 single_value();  local l39 = n.bound; local l40 = n.bound; local l41 = n.bound; local l42 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l43 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l45 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l44 = l45; single_value();  single_value();  l39,l40,l41= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l34, l30, l31), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l42 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l43.error ~= n and true then if l43.error == KEYWORD.TAG then  error(l43) else error(l43[1]) end end i( CL["VALUES-LIST"](list_r(l43)) );
 single_value();  local l46 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l40,l41,CL["LIST"](l(l46)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["COLUMN"],n}},{CL_LIB["NEW"],n}}}},n}}})),l39,CL["LIST"](l(l46)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["STREAM-COLUMN"])),l39)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["STREAM-COLUMN"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l47,  ...)   single_value();  local l48 = CL_LIB["COLUMN"]; local l49 = n.bound; single_value();  return ((l47)[l48] or l49) end, 1, 0, false, false)) );
 single_value();  tmp = CL["STREAM"]; i( CL_LIB["FUNCTION-SETQ"](CL["MAKE-TWO-WAY-STREAM"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["INPUT-STREAM"],{CL_LIB["OUTPUT-STREAM"],{CL["&AUX"],{{CL_LIB["STATE"],{CL["T"],n}},{{CL_LIB["COLUMN"],{0,n}},n}}}}},function (l1, l2,  ...)  l3 = CL["T"].bound l4 = 0  single_value();  local l5 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-STRUCT"].fbound, {}); local l6 = CL["TWO-WAY-STREAM"]; single_value(); l5[CL["IDENTITY"]("name")] = l6 i( l6 );
 local l7 = l3; single_value(); l5[CL["IDENTITY"](CL_LIB["STATE"])] = l7 i( l7 );
 local l8 = l4; single_value(); l5[CL["IDENTITY"](CL_LIB["COLUMN"])] = l8 i( l8 );
 local l9 = l1; single_value(); l5[CL["IDENTITY"](CL_LIB["INPUT-STREAM"])] = l9 i( l9 );
 local l10 = l2; single_value(); l5[CL["IDENTITY"](CL_LIB["OUTPUT-STREAM"])] = l10 i( l10 );
 single_value();  return l5 end, 2, 0, false, false)) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["COPY-TWO-WAY-STREAM"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l11,  ...)   single_value();  return CL["COPY-STRUCTURE"](l11) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["TWO-WAY-STREAM"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l12,  ...)   single_value();  return CL_LIB["%CHECK-STRUCT-TYPE"](l12, CL["TWO-WAY-STREAM"]) end, 1, 0, false, false), {CL["STREAM"],{CL["STRUCTURE-OBJECT"],{CL["T"],n}}}) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["TWO-WAY-STREAM-P"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l13,  ...)   single_value();  return CL["TYPEP"](l13, CL["TWO-WAY-STREAM"], false) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["TWO-WAY-STREAM-STATE"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l14,  ...)   single_value();  local l15 = n.bound; local l16 = n.bound; local l17 = n.bound; local l18 = n.bound; local l19 = n.bound; local l20 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l21 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l23 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l22 = l23; single_value();  single_value();  l15,l16,l17,l18,l19= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l14, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l20 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l21.error ~= n and true then if l21.error == KEYWORD.TAG then  error(l21) else error(l21[1]) end end i( CL["VALUES-LIST"](list_r(l21)) );
 single_value();  local l24 = n.bound; local l25 = n.bound; local l26 = n.bound; local l27 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l28 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l30 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l29 = l30; single_value();  single_value();  l24,l25,l26= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l19, l15, l16), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l27 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l28.error ~= n and true then if l28.error == KEYWORD.TAG then  error(l28) else error(l28[1]) end end i( CL["VALUES-LIST"](list_r(l28)) );
 single_value();  local l31 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l25,l26,CL["LIST"](l(l31)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["STATE"],n}},{CL_LIB["NEW"],n}}}},n}}})),l24,CL["LIST"](l(l31)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["TWO-WAY-STREAM-STATE"])),l24)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["TWO-WAY-STREAM-STATE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l32,  ...)   single_value();  local l33 = CL_LIB["STATE"]; local l34 = n.bound; single_value();  return ((l32)[l33] or l34) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["TWO-WAY-STREAM-COLUMN"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l35,  ...)   single_value();  local l36 = n.bound; local l37 = n.bound; local l38 = n.bound; local l39 = n.bound; local l40 = n.bound; local l41 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l42 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l44 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l43 = l44; single_value();  single_value();  l36,l37,l38,l39,l40= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l35, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l41 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l42.error ~= n and true then if l42.error == KEYWORD.TAG then  error(l42) else error(l42[1]) end end i( CL["VALUES-LIST"](list_r(l42)) );
 single_value();  local l45 = n.bound; local l46 = n.bound; local l47 = n.bound; local l48 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l49 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l51 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l50 = l51; single_value();  single_value();  l45,l46,l47= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l40, l36, l37), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l48 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l49.error ~= n and true then if l49.error == KEYWORD.TAG then  error(l49) else error(l49[1]) end end i( CL["VALUES-LIST"](list_r(l49)) );
 single_value();  local l52 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l46,l47,CL["LIST"](l(l52)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["COLUMN"],n}},{CL_LIB["NEW"],n}}}},n}}})),l45,CL["LIST"](l(l52)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["TWO-WAY-STREAM-COLUMN"])),l45)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["TWO-WAY-STREAM-COLUMN"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l53,  ...)   single_value();  local l54 = CL_LIB["COLUMN"]; local l55 = n.bound; single_value();  return ((l53)[l54] or l55) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL["TWO-WAY-STREAM-INPUT-STREAM"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l56,  ...)   single_value();  local l57 = n.bound; local l58 = n.bound; local l59 = n.bound; local l60 = n.bound; local l61 = n.bound; local l62 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l63 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l65 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l64 = l65; single_value();  single_value();  l57,l58,l59,l60,l61= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l56, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l62 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l63.error ~= n and true then if l63.error == KEYWORD.TAG then  error(l63) else error(l63[1]) end end i( CL["VALUES-LIST"](list_r(l63)) );
 single_value();  local l66 = n.bound; local l67 = n.bound; local l68 = n.bound; local l69 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l70 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l72 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l71 = l72; single_value();  single_value();  l66,l67,l68= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l61, l57, l58), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l69 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l70.error ~= n and true then if l70.error == KEYWORD.TAG then  error(l70) else error(l70[1]) end end i( CL["VALUES-LIST"](list_r(l70)) );
 single_value();  local l73 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l67,l68,CL["LIST"](l(l73)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["INPUT-STREAM"],n}},{CL_LIB["NEW"],n}}}},n}}})),l66,CL["LIST"](l(l73)))),CL["APPEND"](l(CL["LIST"](l(CL["TWO-WAY-STREAM-INPUT-STREAM"])),l66)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL["TWO-WAY-STREAM-INPUT-STREAM"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l74,  ...)   single_value();  local l75 = CL_LIB["INPUT-STREAM"]; local l76 = n.bound; single_value();  return ((l74)[l75] or l76) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL["TWO-WAY-STREAM-OUTPUT-STREAM"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l77,  ...)   single_value();  local l78 = n.bound; local l79 = n.bound; local l80 = n.bound; local l81 = n.bound; local l82 = n.bound; local l83 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l84 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l86 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l85 = l86; single_value();  single_value();  l78,l79,l80,l81,l82= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l77, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l83 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l84.error ~= n and true then if l84.error == KEYWORD.TAG then  error(l84) else error(l84[1]) end end i( CL["VALUES-LIST"](list_r(l84)) );
 single_value();  local l87 = n.bound; local l88 = n.bound; local l89 = n.bound; local l90 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l91 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l93 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l92 = l93; single_value();  single_value();  l87,l88,l89= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l82, l78, l79), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l90 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l91.error ~= n and true then if l91.error == KEYWORD.TAG then  error(l91) else error(l91[1]) end end i( CL["VALUES-LIST"](list_r(l91)) );
 single_value();  local l94 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l88,l89,CL["LIST"](l(l94)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["OUTPUT-STREAM"],n}},{CL_LIB["NEW"],n}}}},n}}})),l87,CL["LIST"](l(l94)))),CL["APPEND"](l(CL["LIST"](l(CL["TWO-WAY-STREAM-OUTPUT-STREAM"])),l87)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL["TWO-WAY-STREAM-OUTPUT-STREAM"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l95,  ...)   single_value();  local l96 = CL_LIB["OUTPUT-STREAM"]; local l97 = n.bound; single_value();  return ((l95)[l96] or l97) end, 1, 0, false, false)) );
 single_value();  tmp = CL["TWO-WAY-STREAM"]; i( CL_LIB["FUNCTION-SETQ"](CL_LIB["MAKE-FILE-STREAM"] , CL_LIB["ALLOC-FUNCTION"]({CL["&KEY"],{{CL_LIB["STATE"],{CL["T"],n}},{{CL_LIB["COLUMN"],{0,n}},{{CL_LIB["UNREAD"],{n,n}},{{CL["LAST"],{n,n}},{{CL_LIB["FILE"],{n,n}},{{CL["PATHNAME"],{n,n}},n}}}}}}},function (keys,  ...)  if not keys[CL_LIB["STATE"]] then  keys[CL_LIB["STATE"]] = CL["T"].bound end if not keys[CL_LIB["COLUMN"]] then  keys[CL_LIB["COLUMN"]] = 0 end if not keys[CL_LIB["UNREAD"]] then  keys[CL_LIB["UNREAD"]] = n.bound end if not keys[CL["LAST"]] then  keys[CL["LAST"]] = n.bound end if not keys[CL_LIB["FILE"]] then  keys[CL_LIB["FILE"]] = n.bound end if not keys[CL["PATHNAME"]] then  keys[CL["PATHNAME"]] = n.bound end  single_value();  local l1 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-STRUCT"].fbound, {}); local l2 = CL["FILE-STREAM"]; single_value(); l1[CL["IDENTITY"]("name")] = l2 i( l2 );
 local l3 = keys[CL_LIB["STATE"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["STATE"])] = l3 i( l3 );
 local l4 = keys[CL_LIB["COLUMN"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["COLUMN"])] = l4 i( l4 );
 local l5 = keys[CL_LIB["UNREAD"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["UNREAD"])] = l5 i( l5 );
 local l6 = keys[CL["LAST"]]; single_value(); l1[CL["IDENTITY"](CL["LAST"])] = l6 i( l6 );
 local l7 = keys[CL_LIB["FILE"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["FILE"])] = l7 i( l7 );
 local l8 = keys[CL["PATHNAME"]]; single_value(); l1[CL["IDENTITY"](CL["PATHNAME"])] = l8 i( l8 );
 single_value();  return l1 end, 0, 0, false, {0 , [LCL["KEYWORD"]["STATE"]] = CL_LIB["STATE"], [LCL["KEYWORD"]["COLUMN"]] = CL_LIB["COLUMN"], [LCL["KEYWORD"]["UNREAD"]] = CL_LIB["UNREAD"], [LCL["KEYWORD"]["LAST"]] = CL["LAST"], [LCL["KEYWORD"]["FILE"]] = CL_LIB["FILE"], [LCL["KEYWORD"]["PATHNAME"]] = CL["PATHNAME"]})) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["COPY-FILE-STREAM"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l9,  ...)   single_value();  return CL["COPY-STRUCTURE"](l9) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["FILE-STREAM"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l10,  ...)   single_value();  return CL_LIB["%CHECK-STRUCT-TYPE"](l10, CL["FILE-STREAM"]) end, 1, 0, false, false), {CL["STREAM"],{CL["STRUCTURE-OBJECT"],{CL["T"],n}}}) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["FILE-STREAM-P"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l11,  ...)   single_value();  return CL["TYPEP"](l11, CL["FILE-STREAM"], false) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["FILE-STREAM-STATE"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l12,  ...)   single_value();  local l13 = n.bound; local l14 = n.bound; local l15 = n.bound; local l16 = n.bound; local l17 = n.bound; local l18 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l19 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l21 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l20 = l21; single_value();  single_value();  l13,l14,l15,l16,l17= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l12, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l18 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l19.error ~= n and true then if l19.error == KEYWORD.TAG then  error(l19) else error(l19[1]) end end i( CL["VALUES-LIST"](list_r(l19)) );
 single_value();  local l22 = n.bound; local l23 = n.bound; local l24 = n.bound; local l25 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l26 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l28 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l27 = l28; single_value();  single_value();  l22,l23,l24= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l17, l13, l14), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l25 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l26.error ~= n and true then if l26.error == KEYWORD.TAG then  error(l26) else error(l26[1]) end end i( CL["VALUES-LIST"](list_r(l26)) );
 single_value();  local l29 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l23,l24,CL["LIST"](l(l29)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["STATE"],n}},{CL_LIB["NEW"],n}}}},n}}})),l22,CL["LIST"](l(l29)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["FILE-STREAM-STATE"])),l22)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["FILE-STREAM-STATE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l30,  ...)   single_value();  local l31 = CL_LIB["STATE"]; local l32 = n.bound; single_value();  return ((l30)[l31] or l32) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["FILE-STREAM-COLUMN"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l33,  ...)   single_value();  local l34 = n.bound; local l35 = n.bound; local l36 = n.bound; local l37 = n.bound; local l38 = n.bound; local l39 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l40 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l42 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l41 = l42; single_value();  single_value();  l34,l35,l36,l37,l38= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l33, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l39 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l40.error ~= n and true then if l40.error == KEYWORD.TAG then  error(l40) else error(l40[1]) end end i( CL["VALUES-LIST"](list_r(l40)) );
 single_value();  local l43 = n.bound; local l44 = n.bound; local l45 = n.bound; local l46 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l47 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l49 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l48 = l49; single_value();  single_value();  l43,l44,l45= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l38, l34, l35), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l46 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l47.error ~= n and true then if l47.error == KEYWORD.TAG then  error(l47) else error(l47[1]) end end i( CL["VALUES-LIST"](list_r(l47)) );
 single_value();  local l50 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l44,l45,CL["LIST"](l(l50)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["COLUMN"],n}},{CL_LIB["NEW"],n}}}},n}}})),l43,CL["LIST"](l(l50)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["FILE-STREAM-COLUMN"])),l43)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["FILE-STREAM-COLUMN"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l51,  ...)   single_value();  local l52 = CL_LIB["COLUMN"]; local l53 = n.bound; single_value();  return ((l51)[l52] or l53) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["FILE-STREAM-UNREAD"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l54,  ...)   single_value();  local l55 = n.bound; local l56 = n.bound; local l57 = n.bound; local l58 = n.bound; local l59 = n.bound; local l60 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l61 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l63 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l62 = l63; single_value();  single_value();  l55,l56,l57,l58,l59= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l54, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l60 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l61.error ~= n and true then if l61.error == KEYWORD.TAG then  error(l61) else error(l61[1]) end end i( CL["VALUES-LIST"](list_r(l61)) );
 single_value();  local l64 = n.bound; local l65 = n.bound; local l66 = n.bound; local l67 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l68 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l70 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l69 = l70; single_value();  single_value();  l64,l65,l66= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l59, l55, l56), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l67 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l68.error ~= n and true then if l68.error == KEYWORD.TAG then  error(l68) else error(l68[1]) end end i( CL["VALUES-LIST"](list_r(l68)) );
 single_value();  local l71 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l65,l66,CL["LIST"](l(l71)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["UNREAD"],n}},{CL_LIB["NEW"],n}}}},n}}})),l64,CL["LIST"](l(l71)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["FILE-STREAM-UNREAD"])),l64)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["FILE-STREAM-UNREAD"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l72,  ...)   single_value();  local l73 = CL_LIB["UNREAD"]; local l74 = n.bound; single_value();  return ((l72)[l73] or l74) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["FILE-STREAM-LAST"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l75,  ...)   single_value();  local l76 = n.bound; local l77 = n.bound; local l78 = n.bound; local l79 = n.bound; local l80 = n.bound; local l81 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l82 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l84 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l83 = l84; single_value();  single_value();  l76,l77,l78,l79,l80= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l75, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l81 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l82.error ~= n and true then if l82.error == KEYWORD.TAG then  error(l82) else error(l82[1]) end end i( CL["VALUES-LIST"](list_r(l82)) );
 single_value();  local l85 = n.bound; local l86 = n.bound; local l87 = n.bound; local l88 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l89 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l91 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l90 = l91; single_value();  single_value();  l85,l86,l87= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l80, l76, l77), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l88 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l89.error ~= n and true then if l89.error == KEYWORD.TAG then  error(l89) else error(l89[1]) end end i( CL["VALUES-LIST"](list_r(l89)) );
 single_value();  local l92 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l86,l87,CL["LIST"](l(l92)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL["LAST"],n}},{CL_LIB["NEW"],n}}}},n}}})),l85,CL["LIST"](l(l92)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["FILE-STREAM-LAST"])),l85)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["FILE-STREAM-LAST"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l93,  ...)   single_value();  local l94 = CL["LAST"]; local l95 = n.bound; single_value();  return ((l93)[l94] or l95) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["FILE-STREAM-FILE"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l96,  ...)   single_value();  local l97 = n.bound; local l98 = n.bound; local l99 = n.bound; local l100 = n.bound; local l101 = n.bound; local l102 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l103 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l105 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l104 = l105; single_value();  single_value();  l97,l98,l99,l100,l101= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l96, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l102 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l103.error ~= n and true then if l103.error == KEYWORD.TAG then  error(l103) else error(l103[1]) end end i( CL["VALUES-LIST"](list_r(l103)) );
 single_value();  local l106 = n.bound; local l107 = n.bound; local l108 = n.bound; local l109 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l110 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l112 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l111 = l112; single_value();  single_value();  l106,l107,l108= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l101, l97, l98), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l109 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l110.error ~= n and true then if l110.error == KEYWORD.TAG then  error(l110) else error(l110[1]) end end i( CL["VALUES-LIST"](list_r(l110)) );
 single_value();  local l113 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l107,l108,CL["LIST"](l(l113)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["FILE"],n}},{CL_LIB["NEW"],n}}}},n}}})),l106,CL["LIST"](l(l113)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["FILE-STREAM-FILE"])),l106)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["FILE-STREAM-FILE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l114,  ...)   single_value();  local l115 = CL_LIB["FILE"]; local l116 = n.bound; single_value();  return ((l114)[l115] or l116) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["FILE-STREAM-PATHNAME"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l117,  ...)   single_value();  local l118 = n.bound; local l119 = n.bound; local l120 = n.bound; local l121 = n.bound; local l122 = n.bound; local l123 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l124 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l126 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l125 = l126; single_value();  single_value();  l118,l119,l120,l121,l122= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l117, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l123 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l124.error ~= n and true then if l124.error == KEYWORD.TAG then  error(l124) else error(l124[1]) end end i( CL["VALUES-LIST"](list_r(l124)) );
 single_value();  local l127 = n.bound; local l128 = n.bound; local l129 = n.bound; local l130 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l131 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l133 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l132 = l133; single_value();  single_value();  l127,l128,l129= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l122, l118, l119), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l130 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l131.error ~= n and true then if l131.error == KEYWORD.TAG then  error(l131) else error(l131[1]) end end i( CL["VALUES-LIST"](list_r(l131)) );
 single_value();  local l134 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l128,l129,CL["LIST"](l(l134)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL["PATHNAME"],n}},{CL_LIB["NEW"],n}}}},n}}})),l127,CL["LIST"](l(l134)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["FILE-STREAM-PATHNAME"])),l127)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["FILE-STREAM-PATHNAME"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l135,  ...)   single_value();  local l136 = CL["PATHNAME"]; local l137 = n.bound; single_value();  return ((l135)[l136] or l137) end, 1, 0, false, false)) );
 single_value();  tmp = CL["FILE-STREAM"]; i( CL_LIB["FUNCTION-SETQ"](CL_LIB["MAKE-STRING-STREAM"] , CL_LIB["ALLOC-FUNCTION"]({CL["&KEY"],{{CL_LIB["STATE"],{CL["T"],n}},{{CL_LIB["COLUMN"],{0,n}},{{CL["STRING"],{"",n}},{{CL_LIB["POS"],{0,n}},n}}}}},function (keys,  ...)  if not keys[CL_LIB["STATE"]] then  keys[CL_LIB["STATE"]] = CL["T"].bound end if not keys[CL_LIB["COLUMN"]] then  keys[CL_LIB["COLUMN"]] = 0 end if not keys[CL["STRING"]] then  keys[CL["STRING"]] = "" end if not keys[CL_LIB["POS"]] then  keys[CL_LIB["POS"]] = 0 end  single_value();  local l1 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-STRUCT"].fbound, {}); local l2 = CL["STRING-STREAM"]; single_value(); l1[CL["IDENTITY"]("name")] = l2 i( l2 );
 local l3 = keys[CL_LIB["STATE"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["STATE"])] = l3 i( l3 );
 local l4 = keys[CL_LIB["COLUMN"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["COLUMN"])] = l4 i( l4 );
 local l5 = keys[CL["STRING"]]; single_value(); l1[CL["IDENTITY"](CL["STRING"])] = l5 i( l5 );
 local l6 = keys[CL_LIB["POS"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["POS"])] = l6 i( l6 );
 single_value();  return l1 end, 0, 0, false, {0 , [LCL["KEYWORD"]["STATE"]] = CL_LIB["STATE"], [LCL["KEYWORD"]["COLUMN"]] = CL_LIB["COLUMN"], [LCL["KEYWORD"]["STRING"]] = CL["STRING"], [LCL["KEYWORD"]["POS"]] = CL_LIB["POS"]})) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["COPY-STRING-STREAM"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l7,  ...)   single_value();  return CL["COPY-STRUCTURE"](l7) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["STRING-STREAM"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l8,  ...)   single_value();  return CL_LIB["%CHECK-STRUCT-TYPE"](l8, CL["STRING-STREAM"]) end, 1, 0, false, false), {CL["STREAM"],{CL["STRUCTURE-OBJECT"],{CL["T"],n}}}) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["STRING-STREAM-P"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l9,  ...)   single_value();  return CL["TYPEP"](l9, CL["STRING-STREAM"], false) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["STRING-STREAM-STATE"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l10,  ...)   single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = n.bound; local l15 = n.bound; local l16 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l17 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l19 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l18 = l19; single_value();  single_value();  l11,l12,l13,l14,l15= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l10, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l16 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l17.error ~= n and true then if l17.error == KEYWORD.TAG then  error(l17) else error(l17[1]) end end i( CL["VALUES-LIST"](list_r(l17)) );
 single_value();  local l20 = n.bound; local l21 = n.bound; local l22 = n.bound; local l23 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l24 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l26 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l25 = l26; single_value();  single_value();  l20,l21,l22= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l15, l11, l12), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l23 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l24.error ~= n and true then if l24.error == KEYWORD.TAG then  error(l24) else error(l24[1]) end end i( CL["VALUES-LIST"](list_r(l24)) );
 single_value();  local l27 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l21,l22,CL["LIST"](l(l27)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["STATE"],n}},{CL_LIB["NEW"],n}}}},n}}})),l20,CL["LIST"](l(l27)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["STRING-STREAM-STATE"])),l20)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["STRING-STREAM-STATE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l28,  ...)   single_value();  local l29 = CL_LIB["STATE"]; local l30 = n.bound; single_value();  return ((l28)[l29] or l30) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["STRING-STREAM-COLUMN"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l31,  ...)   single_value();  local l32 = n.bound; local l33 = n.bound; local l34 = n.bound; local l35 = n.bound; local l36 = n.bound; local l37 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l38 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l40 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l39 = l40; single_value();  single_value();  l32,l33,l34,l35,l36= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l31, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l37 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l38.error ~= n and true then if l38.error == KEYWORD.TAG then  error(l38) else error(l38[1]) end end i( CL["VALUES-LIST"](list_r(l38)) );
 single_value();  local l41 = n.bound; local l42 = n.bound; local l43 = n.bound; local l44 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l45 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l47 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l46 = l47; single_value();  single_value();  l41,l42,l43= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l36, l32, l33), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l44 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l45.error ~= n and true then if l45.error == KEYWORD.TAG then  error(l45) else error(l45[1]) end end i( CL["VALUES-LIST"](list_r(l45)) );
 single_value();  local l48 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l42,l43,CL["LIST"](l(l48)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["COLUMN"],n}},{CL_LIB["NEW"],n}}}},n}}})),l41,CL["LIST"](l(l48)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["STRING-STREAM-COLUMN"])),l41)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["STRING-STREAM-COLUMN"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l49,  ...)   single_value();  local l50 = CL_LIB["COLUMN"]; local l51 = n.bound; single_value();  return ((l49)[l50] or l51) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["STRING-STREAM-STRING"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l52,  ...)   single_value();  local l53 = n.bound; local l54 = n.bound; local l55 = n.bound; local l56 = n.bound; local l57 = n.bound; local l58 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l59 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l61 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l60 = l61; single_value();  single_value();  l53,l54,l55,l56,l57= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l52, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l58 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l59.error ~= n and true then if l59.error == KEYWORD.TAG then  error(l59) else error(l59[1]) end end i( CL["VALUES-LIST"](list_r(l59)) );
 single_value();  local l62 = n.bound; local l63 = n.bound; local l64 = n.bound; local l65 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l66 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l68 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l67 = l68; single_value();  single_value();  l62,l63,l64= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l57, l53, l54), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l65 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l66.error ~= n and true then if l66.error == KEYWORD.TAG then  error(l66) else error(l66[1]) end end i( CL["VALUES-LIST"](list_r(l66)) );
 single_value();  local l69 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l63,l64,CL["LIST"](l(l69)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL["STRING"],n}},{CL_LIB["NEW"],n}}}},n}}})),l62,CL["LIST"](l(l69)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["STRING-STREAM-STRING"])),l62)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["STRING-STREAM-STRING"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l70,  ...)   single_value();  local l71 = CL["STRING"]; local l72 = n.bound; single_value();  return ((l70)[l71] or l72) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["STRING-STREAM-POS"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l73,  ...)   single_value();  local l74 = n.bound; local l75 = n.bound; local l76 = n.bound; local l77 = n.bound; local l78 = n.bound; local l79 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l80 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l82 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l81 = l82; single_value();  single_value();  l74,l75,l76,l77,l78= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l73, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l79 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l80.error ~= n and true then if l80.error == KEYWORD.TAG then  error(l80) else error(l80[1]) end end i( CL["VALUES-LIST"](list_r(l80)) );
 single_value();  local l83 = n.bound; local l84 = n.bound; local l85 = n.bound; local l86 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l87 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l89 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l88 = l89; single_value();  single_value();  l83,l84,l85= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l78, l74, l75), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l86 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l87.error ~= n and true then if l87.error == KEYWORD.TAG then  error(l87) else error(l87[1]) end end i( CL["VALUES-LIST"](list_r(l87)) );
 single_value();  local l90 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l84,l85,CL["LIST"](l(l90)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["POS"],n}},{CL_LIB["NEW"],n}}}},n}}})),l83,CL["LIST"](l(l90)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["STRING-STREAM-POS"])),l83)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["STRING-STREAM-POS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l91,  ...)   single_value();  local l92 = CL_LIB["POS"]; local l93 = n.bound; single_value();  return ((l91)[l92] or l93) end, 1, 0, false, false)) );
 single_value();  tmp = CL["STRING-STREAM"]; tmp = CL_LIB["FUNCTION-SETQ"](CL["MAKE-STRING-INPUT-STREAM"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL["&OPTIONAL"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],n}}}},function (l1, l2, l3,  ...)  if not l2 then  l2 = 0 end if not l3 then  l3 = n.bound end  single_value();  return CL_LIB["MAKE-STRING-STREAM"](k(CL["STRING"], CL["SUBSEQ"](l1, l2, l3))) end, 1, 2, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAKE-STRING-OUTPUT-STREAM"] , CL_LIB["ALLOC-FUNCTION"]({CL["&KEY"],{CL_LIB["ELEMENT-TYPE"],n}},function (keys,  ...)  if not keys[CL_LIB["ELEMENT-TYPE"]] then  keys[CL_LIB["ELEMENT-TYPE"]] = n.bound end  single_value();  return CL_LIB["MAKE-STRING-STREAM"](k()) end, 0, 0, false, {0 , [LCL["KEYWORD"]["ELEMENT-TYPE"]] = CL_LIB["ELEMENT-TYPE"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["GET-OUTPUT-STREAM-STRING"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l1,  ...)   single_value();  return CL_LIB["STRING-STREAM-STRING"](l1) end, 1, 0, false, false)); local l1 = CL_LIB["MAKE-FILE-STREAM"](k(CL_LIB["FILE"], io.stdin)); single_value();  tmp = CL_LIB.DEF(CL_LIB["*LUA-STDIN*"],l1); local l1 = CL_LIB["MAKE-FILE-STREAM"](k(CL_LIB["FILE"], io.stdout)); single_value();  tmp = CL_LIB.DEF(CL_LIB["*LUA-STDOUT*"],l1); local l1 = CL_LIB["MAKE-FILE-STREAM"](k(CL_LIB["FILE"], io.stderr)); single_value();  tmp = CL_LIB.DEF(CL_LIB["*LUA-STDERR*"],l1); local l1 = CL["MAKE-TWO-WAY-STREAM"](CL_LIB["*LUA-STDIN*"].bound, CL_LIB["*LUA-STDOUT*"].bound); single_value();  tmp = CL_LIB.DEF(CL_LIB["*LUA-IO*"],l1); local l1 = CL_LIB["*LUA-IO*"].bound; single_value();  tmp = CL_LIB.DEF(CL["*DEBUG-IO*"],l1); local l1 = CL_LIB["*LUA-IO*"].bound; single_value();  tmp = CL_LIB.DEF(CL["*QUERY-IO*"],l1); local l1 = CL_LIB["*LUA-IO*"].bound; single_value();  tmp = CL_LIB.DEF(CL["*TERMINAL-IO*"],l1); local l1 = CL_LIB["*LUA-STDERR*"].bound; single_value();  tmp = CL_LIB.DEF(CL["*ERROR-OUTPUT*"],l1); local l1 = CL_LIB["*LUA-STDIN*"].bound; single_value();  tmp = CL_LIB.DEF(CL["*STANDARD-INPUT*"],l1); local l1 = CL_LIB["*LUA-STDOUT*"].bound; single_value();  tmp = CL_LIB.DEF(CL["*STANDARD-OUTPUT*"],l1); local l1 = CL_LIB["*LUA-STDOUT*"].bound; single_value();  tmp = CL_LIB.DEF(CL["*TRACE-OUTPUT*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL["STREAM-ELEMENT-TYPE"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l1,  ...)   single_value();  return CL["CHARACTER"] end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STREAMP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],n},function (l1,  ...)   single_value();  return CL["TYPEP"](l1, CL["STREAM"], false) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CLOSE"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["&KEY"],{CL["ABORT"],n}}},function (l1, keys,  ...)  if not keys[CL["ABORT"]] then  keys[CL["ABORT"]] = n.bound end  single_value();  local l2 = l1; single_value();  single_value();  local l3 = n.bound; single_value();  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l4, l5,  ...)   single_value();  local l6 = l5; single_value(); l4[CL["IDENTITY"](CL_LIB["STATE"])] = l6 return l6 end, 2, 0, false, false), {l2, l3, }) );
 single_value();  local l7 = l1; single_value();  local l8 = n if n ~= CL["TYPEP"](l7, CL["FILE-STREAM"], false) then  single_value();  local l9 = CL_LIB["FILE-STREAM-FILE"](l1); single_value();  l8 = CL["FUNCALL"](l9.close, l(l9)) else  local l10 = n if n ~= CL["TYPEP"](l7, CL["TWO-WAY-STREAM"], false) then  i( CL["CLOSE"](CL["TWO-WAY-STREAM-INPUT-STREAM"](l1), k()) );
 single_value();  l10 = CL["CLOSE"](CL["TWO-WAY-STREAM-OUTPUT-STREAM"](l1), k()) else  local l11 = n if n ~= CL["TYPEP"](l7, CL["T"], false) then  single_value();  l11 = CL["ERROR"]("etypecase, no matching branches", l()) else  l11 = n.bound end l10 = l11 end l8 = l10 end return l8 end, 1, 0, false, {0 , [LCL["KEYWORD"]["ABORT"]] = CL["ABORT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["INPUT-STREAM-P"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l1,  ...)   single_value();  local l2 = l1; single_value();  local l3 = n if n ~= CL["TYPEP"](l2, CL["FILE-STREAM"], false) then  single_value();  l3 = CL["T"].bound else  local l4 = n if n ~= CL["TYPEP"](l2, CL["TWO-WAY-STREAM"], false) then  single_value();  l4 = CL["T"].bound else  local l5 = n if n ~= CL["TYPEP"](l2, CL["STRING-STREAM"], false) then  single_value();  l5 = CL["T"].bound else  local l6 = n if n ~= CL["TYPEP"](l2, CL["T"], false) then  single_value();  l6 = n.bound else  l6 = n.bound end l5 = l6 end l4 = l5 end l3 = l4 end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["OUTPUT-STREAM-P"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l1,  ...)   single_value();  local l2 = l1; single_value();  local l3 = n if n ~= CL["TYPEP"](l2, CL["FILE-STREAM"], false) then  single_value();  l3 = CL["T"].bound else  local l4 = n if n ~= CL["TYPEP"](l2, CL["TWO-WAY-STREAM"], false) then  single_value();  l4 = CL["T"].bound else  local l5 = n if n ~= CL["TYPEP"](l2, CL["STRING-STREAM"], false) then  single_value();  l5 = CL["T"].bound else  local l6 = n if n ~= CL["TYPEP"](l2, CL["T"], false) then  single_value();  l6 = n.bound else  l6 = n.bound end l5 = l6 end l4 = l5 end l3 = l4 end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["INTERACTIVE-STREAM-P"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return n.bound end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["OPEN-STREAM-P"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l1,  ...)   single_value();  return CL_LIB["STREAM-STATE"](l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["CLEAR-INPUT-G"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l1,  ...)   single_value();  local l2 = l1; single_value();  local l3 = n if n ~= CL["TYPEP"](l2, CL["FILE-STREAM"], false) then  single_value();  local l4 = CL_LIB["FILE-STREAM-FILE"](l1); single_value();  l3 = CL["FUNCALL"](l4.read, l(l4,"*a")) else  local l5 = n if n ~= CL["TYPEP"](l2, CL["TWO-WAY-STREAM"], false) then  single_value();  l5 = CL_LIB["CLEAR-INPUT-G"](CL["TWO-WAY-STREAM-INPUT-STREAM"](l1)) else  local l6 = n if n ~= CL["TYPEP"](l2, CL["T"], false) then  single_value();  l6 = CL["ERROR"]("etypecase, no matching branches", l()) else  l6 = n.bound end l5 = l6 end l3 = l5 end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CLEAR-INPUT"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{{CL_LIB["INPUT-STREAM"],{CL["*STANDARD-INPUT*"],n}},n}},function (l1,  ...)  if not l1 then  l1 = CL["*STANDARD-INPUT*"].bound end  single_value();  return CL_LIB["CLEAR-INPUT-G"](l1) end, 0, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["TRY-READ-CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l1,  ...)   single_value();  local l2 = l1; single_value();  local l3 = n if n ~= CL["TYPEP"](l2, CL["FILE-STREAM"], false) then  single_value();  local l4 = CL_LIB["FILE-STREAM-UNREAD"](l1); single_value();  local l5 = n if n ~= l4 then  local l6 = l4; single_value();  local l7 = l1; single_value();  single_value();  local l8 = n.bound; single_value();  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l9, l10,  ...)   single_value();  local l11 = l10; single_value(); l9[CL["IDENTITY"](CL_LIB["UNREAD"])] = l11 return l11 end, 2, 0, false, false), {l7, l8, }) );
 single_value();  l5 = l6 else  local l13 = CL_LIB["FILE-STREAM-FILE"](l1); single_value();  local l12 = CL["FUNCALL"](l13.read, l(l13,1))or n; single_value();  local l14 = n if n ~= l12 then  l14 = CL["CHAR"](l12, 0) else  l14 = n.bound end l5 = l14 end l3 = l5 else  local l15 = n if n ~= CL["TYPEP"](l2, CL["TWO-WAY-STREAM"], false) then  single_value();  l15 = CL_LIB["TRY-READ-CHAR"](CL["TWO-WAY-STREAM-INPUT-STREAM"](l1)) else  local l16 = n if n ~= CL["TYPEP"](l2, CL["STRING-STREAM"], false) then  single_value();  local l17 = n if n ~= CL_LIB["%<"](CL_LIB["STRING-STREAM-POS"](l1), CL["LENGTH"](CL_LIB["STRING-STREAM-STRING"](l1))) then  local l18 = CL["CHAR"](CL_LIB["STRING-STREAM-STRING"](l1), CL_LIB["STRING-STREAM-POS"](l1)); local l19 = l1; single_value();  local l20 = (1 + CL_LIB["STRING-STREAM-POS"](l19)); single_value();  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l21, l22,  ...)   single_value();  local l23 = l22; single_value(); l21[CL["IDENTITY"](CL_LIB["POS"])] = l23 return l23 end, 2, 0, false, false), {l19, l20, }) );
 single_value();  l17 = l18 else  l17 = n.bound end l16 = l17 else  local l24 = n if n ~= CL["TYPEP"](l2, CL["T"], false) then  single_value();  l24 = CL["ERROR"]("etypecase, no matching branches", l()) else  l24 = n.bound end l16 = l24 end l15 = l16 end l3 = l15 end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["PUSH-UNREAD-CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL["STREAM"],n}},function (l1, l2,  ...)   single_value();  local l3 = l2; single_value();  local l4 = n if n ~= CL["TYPEP"](l3, CL["FILE-STREAM"], false) then  single_value();  single_value();  local l5 = l2; single_value();  single_value();  local l6 = l1; single_value();  l4 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l7, l8,  ...)   single_value();  local l9 = l8; single_value(); l7[CL["IDENTITY"](CL_LIB["UNREAD"])] = l9 return l9 end, 2, 0, false, false), {l5, l6, }) else  local l10 = n if n ~= CL["TYPEP"](l3, CL["TWO-WAY-STREAM"], false) then  single_value();  l10 = CL_LIB["PUSH-UNREAD-CHAR"](l1, CL["TWO-WAY-STREAM-INPUT-STREAM"](l2)) else  local l11 = n if n ~= CL["TYPEP"](l3, CL["STRING-STREAM"], false) then  single_value();  local l12 = l2; single_value();  local l13 = (-1 + CL_LIB["STRING-STREAM-POS"](l12)); single_value();  l11 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l14, l15,  ...)   single_value();  local l16 = l15; single_value(); l14[CL["IDENTITY"](CL_LIB["POS"])] = l16 return l16 end, 2, 0, false, false), {l12, l13, }) else  local l17 = n if n ~= CL["TYPEP"](l3, CL["T"], false) then  single_value();  l17 = CL["ERROR"]("etypecase, no matching branches", l()) else  l17 = n.bound end l11 = l17 end l10 = l11 end l4 = l10 end return l4 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["UNREAD-CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL["&OPTIONAL"],{{CL["STREAM"],{CL["*STANDARD-INPUT*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*STANDARD-INPUT*"].bound end  single_value();  return CL_LIB["PUSH-UNREAD-CHAR"](l1, l2) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["READ-CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{{CL_LIB["INPUT-STREAM"],{CL["*STANDARD-INPUT*"],n}},{{CL_LIB["EOF-ERROR-P"],{CL["T"],n}},{CL_LIB["EOF-VALUE"],{CL_LIB["RECURSIVE-P"],n}}}}},function (l1, l2, l3, l4,  ...)  if not l1 then  l1 = CL["*STANDARD-INPUT*"].bound end if not l2 then  l2 = CL["T"].bound end if not l3 then  l3 = n.bound end if not l4 then  l4 = n.bound end  single_value();  local l5 = CL_LIB["TRY-READ-CHAR"](l1); single_value();  local l6 = n if n ~= l5 then  l6 = l5 else  local l7 = n if n ~= l2 then  l7 = CL["ERROR"]("EOF", l()) else  l7 = l3 end l6 = l7 end return l6 end, 0, 4, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["READ-BYTE"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["&OPTIONAL"],{{CL_LIB["EOF-ERROR-P"],{CL["T"],n}},{CL_LIB["EOF-VALUE"],n}}}},function (l1, l2, l3,  ...)  if not l2 then  l2 = CL["T"].bound end if not l3 then  l3 = n.bound end  single_value();  return CL["CHAR-CODE"](CL["READ-CHAR"](l1, l2, l3, false)) end, 1, 2, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["READ-CHAR-NO-HANG"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{{CL_LIB["INPUT-STREAM"],{CL["*STANDARD-INPUT*"],n}},{{CL_LIB["EOF-ERROR-P"],{CL["T"],n}},{CL_LIB["EOF-VALUE"],{CL_LIB["RECURSIVE-P"],n}}}}},function (l1, l2, l3, l4,  ...)  if not l1 then  l1 = CL["*STANDARD-INPUT*"].bound end if not l2 then  l2 = CL["T"].bound end if not l3 then  l3 = n.bound end if not l4 then  l4 = n.bound end  single_value();  return CL["READ-CHAR"](l1, l2, l3, l4) end, 0, 4, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%PEEK-CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l1,  ...)   single_value();  local l2 = CL["READ-CHAR"](l1, false, false, false); i( CL["UNREAD-CHAR"](l2, false) );
 single_value();  return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FLUSH-OUTPUT"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l1,  ...)   single_value();  local l2 = l1; single_value();  local l3 = n if n ~= CL["TYPEP"](l2, CL["FILE-STREAM"], false) then  single_value();  local l4 = CL_LIB["FILE-STREAM-FILE"](l1); single_value();  l3 = CL["FUNCALL"](l4.flush, l(l4)) else  local l5 = n if n ~= CL["TYPEP"](l2, CL["TWO-WAY-STREAM"], false) then  single_value();  l5 = CL_LIB["FLUSH-OUTPUT"](CL["TWO-WAY-STREAM-OUTPUT-STREAM"](l1)) else  local l6 = n if n ~= CL["TYPEP"](l2, CL["T"], false) then  single_value();  l6 = CL["ERROR"]("etypecase, no matching branches", l()) else  l6 = n.bound end l5 = l6 end l3 = l5 end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FINISH-OUTPUT"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{{CL_LIB["OUTPUT-STREAM"],{CL["*STANDARD-OUTPUT*"],n}},n}},function (l1,  ...)  if not l1 then  l1 = CL["*STANDARD-OUTPUT*"].bound end  single_value();  return CL_LIB["FLUSH-OUTPUT"](l1) end, 0, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FORCE-OUTPUT"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{{CL_LIB["OUTPUT-STREAM"],{CL["*STANDARD-OUTPUT*"],n}},n}},function (l1,  ...)  if not l1 then  l1 = CL["*STANDARD-OUTPUT*"].bound end  single_value();  return CL_LIB["FLUSH-OUTPUT"](l1) end, 0, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CLEAR-OUTPUT"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{{CL_LIB["OUTPUT-STREAM"],{CL["*STANDARD-OUTPUT*"],n}},n}},function (l1,  ...)  if not l1 then  l1 = CL["*STANDARD-OUTPUT*"].bound end  single_value();  return n.bound end, 0, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["STREAM-CONSIDER-CHAR-COLUMN"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["CHAR"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["CHAR="](l2, l(LCL['CL-LIB']['MAKE-CHAR']("\n"))) then  single_value();  local l4 = l1; single_value();  single_value();  local l5 = 0; single_value();  l3 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l6, l7,  ...)   single_value();  local l8 = l7; single_value(); l6[CL["IDENTITY"](CL_LIB["COLUMN"])] = l8 return l8 end, 2, 0, false, false), {l4, l5, }) else  local l9 = l1; single_value();  local l10 = (1 + CL_LIB["STREAM-COLUMN"](l9)); single_value();  l3 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l11, l12,  ...)   single_value();  local l13 = l12; single_value(); l11[CL["IDENTITY"](CL_LIB["COLUMN"])] = l13 return l13 end, 2, 0, false, false), {l9, l10, }) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["TRY-WRITE-CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL["STREAM"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL_LIB["CHARP"](l1) then  i( CL_LIB["STREAM-CONSIDER-CHAR-COLUMN"](l2, l1) );
 single_value();  local l4 = l2; single_value();  local l5 = n if n ~= CL["TYPEP"](l4, CL["FILE-STREAM"], false) then  single_value();  local l6 = l2; single_value();  single_value();  local l7 = l1; single_value();  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l8, l9,  ...)   single_value();  local l10 = l9; single_value(); l8[CL["IDENTITY"](CL["LAST"])] = l10 return l10 end, 2, 0, false, false), {l6, l7, }) );
 single_value();  local l11 = CL_LIB["FILE-STREAM-FILE"](l2); single_value();  l5 = CL["FUNCALL"](l11.write, l(l11,CL_LIB["CHAR-STRING"](l1))) else  local l12 = n if n ~= CL["TYPEP"](l4, CL_LIB["TRY-WRITE-CHAR"], false) then  single_value();  l12 = CL_LIB["TRY-WRITE-CHAR"](l1, CL["TWO-WAY-STREAM-OUTPUT-STREAM"](l2)) else  local l13 = n if n ~= CL["TYPEP"](l4, CL["STRING-STREAM"], false) then  single_value();  single_value();  local l14 = l2; single_value();  single_value();  local l15 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL_LIB["STRING-STREAM-STRING"](l2), CL_LIB["CHAR-STRING"](l1), }); single_value();  l13 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l16, l17,  ...)   single_value();  local l18 = l17; single_value(); l16[CL["IDENTITY"](CL["STRING"])] = l18 return l18 end, 2, 0, false, false), {l14, l15, }) else  local l19 = n if n ~= CL["TYPEP"](l4, CL["T"], false) then  single_value();  l19 = CL["ERROR"]("etypecase, no matching branches", l()) else  l19 = n.bound end l13 = l19 end l12 = l13 end l5 = l12 end l3 = l5 else  l3 = CL["ERROR"]("try-write-char, ~S not a char", l(l1)) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["TRY-WRITE-STRING"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL["STREAM"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["STRINGP"](l1) then  local l4 = ({string.find(l1, ".*\n")})[2] or n; single_value();  local l5 = n if n ~= l4 then  single_value();  local l6 = l2; single_value();  single_value();  local l7 = (CL["LENGTH"](l1) - l4); single_value();  l5 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l8, l9,  ...)   single_value();  local l10 = l9; single_value(); l8[CL["IDENTITY"](CL_LIB["COLUMN"])] = l10 return l10 end, 2, 0, false, false), {l6, l7, }) else  local l11 = l2; single_value();  local l12 = (CL["LENGTH"](l1) + CL_LIB["STREAM-COLUMN"](l11)); single_value();  l5 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l13, l14,  ...)   single_value();  local l15 = l14; single_value(); l13[CL["IDENTITY"](CL_LIB["COLUMN"])] = l15 return l15 end, 2, 0, false, false), {l11, l12, }) end i( l5 );
 single_value();  local l16 = l2; single_value();  local l17 = n if n ~= CL["TYPEP"](l16, CL["FILE-STREAM"], false) then  single_value();  local l18 = l2; single_value();  single_value();  local l19 = CL["CHAR"](l1, (CL["LENGTH"](l1) - 1)); single_value();  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l20, l21,  ...)   single_value();  local l22 = l21; single_value(); l20[CL["IDENTITY"](CL["LAST"])] = l22 return l22 end, 2, 0, false, false), {l18, l19, }) );
 single_value();  local l23 = CL_LIB["FILE-STREAM-FILE"](l2); single_value();  l17 = CL["FUNCALL"](l23.write, l(l23,l1)) else  local l24 = n if n ~= CL["TYPEP"](l16, CL["TWO-WAY-STREAM"], false) then  single_value();  l24 = CL_LIB["TRY-WRITE-STRING"](l1, CL["TWO-WAY-STREAM-OUTPUT-STREAM"](l2)) else  local l25 = n if n ~= CL["TYPEP"](l16, CL["STRING-STREAM"], false) then  single_value();  single_value();  local l26 = l2; single_value();  single_value();  local l27 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL_LIB["STRING-STREAM-STRING"](l2), l1, }); single_value();  l25 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l28, l29,  ...)   single_value();  local l30 = l29; single_value(); l28[CL["IDENTITY"](CL["STRING"])] = l30 return l30 end, 2, 0, false, false), {l26, l27, }) else  local l31 = n if n ~= CL["TYPEP"](l16, CL["T"], false) then  single_value();  l31 = CL["ERROR"]("etypecase, no matching branches", l()) else  l31 = n.bound end l25 = l31 end l24 = l25 end l17 = l24 end l3 = l17 else  l3 = CL["ERROR"]("try-write-string, ~S not a string", l(l1)) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FRESH-LINE-G"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l1,  ...)   single_value();  local l2 = l1; single_value();  local l3 = n if n ~= CL["TYPEP"](l2, CL["FILE-STREAM"], false) then  single_value();  local l4 = n if n ~= CL["EQ"](10, CL["CHAR-CODE"](CL_LIB["FILE-STREAM-LAST"](l1))) then  l4 = n.bound else  i( CL["TERPRI"](l1) );
 single_value();  l4 = CL["T"].bound end l3 = l4 else  local l5 = n if n ~= CL["TYPEP"](l2, CL["TWO-WAY-STREAM"], false) then  single_value();  l5 = CL_LIB["FRESH-LINE-G"](CL["TWO-WAY-STREAM-OUTPUT-STREAM"](l1)) else  local l6 = n if n ~= CL["TYPEP"](l2, CL["STRING-STREAM"], false) then  single_value();  local l7 = CL_LIB["STRING-STREAM-STRING"](l1); single_value();  local l8 = n if n ~= CL["EQ"](10, CL["CHAR-CODE"](CL["CHAR"](l7, (CL["LENGTH"](l7) - 1)))) then  l8 = n.bound else  i( CL["TERPRI"](l1) );
 single_value();  l8 = CL["T"].bound end l6 = l8 else  local l9 = n if n ~= CL["TYPEP"](l2, CL["T"], false) then  single_value();  l9 = CL["ERROR"]("etypecase, no matching branches", l()) else  l9 = n.bound end l6 = l9 end l5 = l6 end l3 = l5 end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["WRITE-CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL["&OPTIONAL"],{{CL_LIB["OUTPUT-STREAM"],{CL["*STANDARD-OUTPUT*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*STANDARD-OUTPUT*"].bound end  single_value();  return CL_LIB["TRY-WRITE-CHAR"](l1, l2) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["WRITE-BYTE"] , CL_LIB["ALLOC-FUNCTION"]({CL["BYTE"],{CL["&OPTIONAL"],{{CL_LIB["OUTPUT-STREAM"],{CL["*STANDARD-OUTPUT*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*STANDARD-OUTPUT*"].bound end  single_value();  return CL_LIB["TRY-WRITE-CHAR"](CL["CODE-CHAR"](l1), l2) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["TERPRI"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{{CL_LIB["OUTPUT-STREAM"],{CL["*STANDARD-OUTPUT*"],n}},n}},function (l1,  ...)  if not l1 then  l1 = CL["*STANDARD-OUTPUT*"].bound end  i( CL["WRITE-CHAR"](CL["CODE-CHAR"](10), l1) );
 single_value();  return n.bound end, 0, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["WRITE-STRING"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL["&OPTIONAL"],{{CL_LIB["OUTPUT-STREAM"],{CL["*STANDARD-OUTPUT*"],n}},{CL["&KEY"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],n}}}}}},function (l1, l2, keys,  ...)  if not l2 then  l2 = CL["*STANDARD-OUTPUT*"].bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end  single_value();  local l4 = keys[CL_LIB["END"]]; single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  l5 = CL["/="](keys[CL_LIB["START"]], 0) end local l3 = n if n ~= l5 then  l3 = CL["SUBSEQ"](l1, keys[CL_LIB["START"]], keys[CL_LIB["END"]]) else  l3 = l1 end return CL_LIB["TRY-WRITE-STRING"](l3, l2) end, 1, 1, false, {0 , [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["WRITE-LINE"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL["&OPTIONAL"],{{CL_LIB["OUTPUT-STREAM"],{CL["*STANDARD-OUTPUT*"],n}},{CL["&KEY"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],n}}}}}},function (l1, l2, keys,  ...)  if not l2 then  l2 = CL["*STANDARD-OUTPUT*"].bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end  local l4 = keys[CL_LIB["END"]]; single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  l5 = CL["/="](keys[CL_LIB["START"]], 0) end local l3 = n if n ~= l5 then  l3 = CL["SUBSEQ"](l1, keys[CL_LIB["START"]], keys[CL_LIB["END"]]) else  l3 = l1 end i( CL["WRITE-STRING"](l3, l2, k()) );
 single_value();  return CL["TERPRI"](l2) end, 1, 1, false, {0 , [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["FRESH-LINE"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{{CL_LIB["OUTPUT-STREAM"],{CL["*STANDARD-OUTPUT*"],n}},n}},function (l1,  ...)  if not l1 then  l1 = CL["*STANDARD-OUTPUT*"].bound end  single_value();  return CL_LIB["FRESH-LINE-G"](l1) end, 0, 1, false, false)); i( CL_LIB["FUNCTION-SETQ"](CL_LIB["%MAKE-PATHNAME"] , CL_LIB["ALLOC-FUNCTION"]({CL["&KEY"],{{CL_LIB["HOST"],{n,n}},{{CL_LIB["DEVICE"],{n,n}},{{CL["DIRECTORY"],{n,n}},{{CL_LIB["NAME"],{n,n}},{{CL["TYPE"],{n,n}},{{CL_LIB["VERSION"],{n,n}},n}}}}}}},function (keys,  ...)  if not keys[CL_LIB["HOST"]] then  keys[CL_LIB["HOST"]] = n.bound end if not keys[CL_LIB["DEVICE"]] then  keys[CL_LIB["DEVICE"]] = n.bound end if not keys[CL["DIRECTORY"]] then  keys[CL["DIRECTORY"]] = n.bound end if not keys[CL_LIB["NAME"]] then  keys[CL_LIB["NAME"]] = n.bound end if not keys[CL["TYPE"]] then  keys[CL["TYPE"]] = n.bound end if not keys[CL_LIB["VERSION"]] then  keys[CL_LIB["VERSION"]] = n.bound end  single_value();  local l1 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-STRUCT"].fbound, {}); local l2 = CL["PATHNAME"]; single_value(); l1[CL["IDENTITY"]("name")] = l2 i( l2 );
 local l3 = keys[CL_LIB["HOST"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["HOST"])] = l3 i( l3 );
 local l4 = keys[CL_LIB["DEVICE"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["DEVICE"])] = l4 i( l4 );
 local l5 = keys[CL["DIRECTORY"]]; single_value(); l1[CL["IDENTITY"](CL["DIRECTORY"])] = l5 i( l5 );
 local l6 = keys[CL_LIB["NAME"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["NAME"])] = l6 i( l6 );
 local l7 = keys[CL["TYPE"]]; single_value(); l1[CL["IDENTITY"](CL["TYPE"])] = l7 i( l7 );
 local l8 = keys[CL_LIB["VERSION"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["VERSION"])] = l8 i( l8 );
 single_value();  return l1 end, 0, 0, false, {0 , [LCL["KEYWORD"]["HOST"]] = CL_LIB["HOST"], [LCL["KEYWORD"]["DEVICE"]] = CL_LIB["DEVICE"], [LCL["KEYWORD"]["DIRECTORY"]] = CL["DIRECTORY"], [LCL["KEYWORD"]["NAME"]] = CL_LIB["NAME"], [LCL["KEYWORD"]["TYPE"]] = CL["TYPE"], [LCL["KEYWORD"]["VERSION"]] = CL_LIB["VERSION"]})) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["COPY-PATHNAME"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l9,  ...)   single_value();  return CL["COPY-STRUCTURE"](l9) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["PATHNAME"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l10,  ...)   single_value();  return CL_LIB["%CHECK-STRUCT-TYPE"](l10, CL["PATHNAME"]) end, 1, 0, false, false), {CL["STRUCTURE-OBJECT"],{CL["T"],n}}) );
 i( CL_LIB["FUNCTION-SETQ"](CL["PATHNAMEP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l11,  ...)   single_value();  return CL["TYPEP"](l11, CL["PATHNAME"], false) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL["PATHNAME-HOST"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l12,  ...)   single_value();  local l13 = n.bound; local l14 = n.bound; local l15 = n.bound; local l16 = n.bound; local l17 = n.bound; local l18 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l19 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l21 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l20 = l21; single_value();  single_value();  l13,l14,l15,l16,l17= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l12, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l18 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l19.error ~= n and true then if l19.error == KEYWORD.TAG then  error(l19) else error(l19[1]) end end i( CL["VALUES-LIST"](list_r(l19)) );
 single_value();  local l22 = n.bound; local l23 = n.bound; local l24 = n.bound; local l25 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l26 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l28 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l27 = l28; single_value();  single_value();  l22,l23,l24= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l17, l13, l14), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l25 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l26.error ~= n and true then if l26.error == KEYWORD.TAG then  error(l26) else error(l26[1]) end end i( CL["VALUES-LIST"](list_r(l26)) );
 single_value();  local l29 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l23,l24,CL["LIST"](l(l29)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["HOST"],n}},{CL_LIB["NEW"],n}}}},n}}})),l22,CL["LIST"](l(l29)))),CL["APPEND"](l(CL["LIST"](l(CL["PATHNAME-HOST"])),l22)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL["PATHNAME-HOST"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l30,  ...)   single_value();  local l31 = CL_LIB["HOST"]; local l32 = n.bound; single_value();  return ((l30)[l31] or l32) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL["PATHNAME-DEVICE"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l33,  ...)   single_value();  local l34 = n.bound; local l35 = n.bound; local l36 = n.bound; local l37 = n.bound; local l38 = n.bound; local l39 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l40 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l42 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l41 = l42; single_value();  single_value();  l34,l35,l36,l37,l38= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l33, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l39 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l40.error ~= n and true then if l40.error == KEYWORD.TAG then  error(l40) else error(l40[1]) end end i( CL["VALUES-LIST"](list_r(l40)) );
 single_value();  local l43 = n.bound; local l44 = n.bound; local l45 = n.bound; local l46 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l47 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l49 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l48 = l49; single_value();  single_value();  l43,l44,l45= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l38, l34, l35), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l46 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l47.error ~= n and true then if l47.error == KEYWORD.TAG then  error(l47) else error(l47[1]) end end i( CL["VALUES-LIST"](list_r(l47)) );
 single_value();  local l50 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l44,l45,CL["LIST"](l(l50)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["DEVICE"],n}},{CL_LIB["NEW"],n}}}},n}}})),l43,CL["LIST"](l(l50)))),CL["APPEND"](l(CL["LIST"](l(CL["PATHNAME-DEVICE"])),l43)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL["PATHNAME-DEVICE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l51,  ...)   single_value();  local l52 = CL_LIB["DEVICE"]; local l53 = n.bound; single_value();  return ((l51)[l52] or l53) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL["PATHNAME-DIRECTORY"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l54,  ...)   single_value();  local l55 = n.bound; local l56 = n.bound; local l57 = n.bound; local l58 = n.bound; local l59 = n.bound; local l60 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l61 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l63 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l62 = l63; single_value();  single_value();  l55,l56,l57,l58,l59= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l54, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l60 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l61.error ~= n and true then if l61.error == KEYWORD.TAG then  error(l61) else error(l61[1]) end end i( CL["VALUES-LIST"](list_r(l61)) );
 single_value();  local l64 = n.bound; local l65 = n.bound; local l66 = n.bound; local l67 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l68 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l70 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l69 = l70; single_value();  single_value();  l64,l65,l66= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l59, l55, l56), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l67 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l68.error ~= n and true then if l68.error == KEYWORD.TAG then  error(l68) else error(l68[1]) end end i( CL["VALUES-LIST"](list_r(l68)) );
 single_value();  local l71 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l65,l66,CL["LIST"](l(l71)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL["DIRECTORY"],n}},{CL_LIB["NEW"],n}}}},n}}})),l64,CL["LIST"](l(l71)))),CL["APPEND"](l(CL["LIST"](l(CL["PATHNAME-DIRECTORY"])),l64)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL["PATHNAME-DIRECTORY"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l72,  ...)   single_value();  local l73 = CL["DIRECTORY"]; local l74 = n.bound; single_value();  return ((l72)[l73] or l74) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL["PATHNAME-NAME"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l75,  ...)   single_value();  local l76 = n.bound; local l77 = n.bound; local l78 = n.bound; local l79 = n.bound; local l80 = n.bound; local l81 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l82 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l84 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l83 = l84; single_value();  single_value();  l76,l77,l78,l79,l80= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l75, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l81 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l82.error ~= n and true then if l82.error == KEYWORD.TAG then  error(l82) else error(l82[1]) end end i( CL["VALUES-LIST"](list_r(l82)) );
 single_value();  local l85 = n.bound; local l86 = n.bound; local l87 = n.bound; local l88 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l89 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l91 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l90 = l91; single_value();  single_value();  l85,l86,l87= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l80, l76, l77), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l88 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l89.error ~= n and true then if l89.error == KEYWORD.TAG then  error(l89) else error(l89[1]) end end i( CL["VALUES-LIST"](list_r(l89)) );
 single_value();  local l92 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l86,l87,CL["LIST"](l(l92)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["NAME"],n}},{CL_LIB["NEW"],n}}}},n}}})),l85,CL["LIST"](l(l92)))),CL["APPEND"](l(CL["LIST"](l(CL["PATHNAME-NAME"])),l85)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL["PATHNAME-NAME"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l93,  ...)   single_value();  local l94 = CL_LIB["NAME"]; local l95 = n.bound; single_value();  return ((l93)[l94] or l95) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL["PATHNAME-TYPE"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l96,  ...)   single_value();  local l97 = n.bound; local l98 = n.bound; local l99 = n.bound; local l100 = n.bound; local l101 = n.bound; local l102 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l103 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l105 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l104 = l105; single_value();  single_value();  l97,l98,l99,l100,l101= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l96, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l102 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l103.error ~= n and true then if l103.error == KEYWORD.TAG then  error(l103) else error(l103[1]) end end i( CL["VALUES-LIST"](list_r(l103)) );
 single_value();  local l106 = n.bound; local l107 = n.bound; local l108 = n.bound; local l109 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l110 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l112 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l111 = l112; single_value();  single_value();  l106,l107,l108= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l101, l97, l98), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l109 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l110.error ~= n and true then if l110.error == KEYWORD.TAG then  error(l110) else error(l110[1]) end end i( CL["VALUES-LIST"](list_r(l110)) );
 single_value();  local l113 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l107,l108,CL["LIST"](l(l113)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL["TYPE"],n}},{CL_LIB["NEW"],n}}}},n}}})),l106,CL["LIST"](l(l113)))),CL["APPEND"](l(CL["LIST"](l(CL["PATHNAME-TYPE"])),l106)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL["PATHNAME-TYPE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l114,  ...)   single_value();  local l115 = CL["TYPE"]; local l116 = n.bound; single_value();  return ((l114)[l115] or l116) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL["PATHNAME-VERSION"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l117,  ...)   single_value();  local l118 = n.bound; local l119 = n.bound; local l120 = n.bound; local l121 = n.bound; local l122 = n.bound; local l123 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l124 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l126 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l125 = l126; single_value();  single_value();  l118,l119,l120,l121,l122= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l117, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l123 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l124.error ~= n and true then if l124.error == KEYWORD.TAG then  error(l124) else error(l124[1]) end end i( CL["VALUES-LIST"](list_r(l124)) );
 single_value();  local l127 = n.bound; local l128 = n.bound; local l129 = n.bound; local l130 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l131 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l133 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l132 = l133; single_value();  single_value();  l127,l128,l129= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l122, l118, l119), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l130 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l131.error ~= n and true then if l131.error == KEYWORD.TAG then  error(l131) else error(l131[1]) end end i( CL["VALUES-LIST"](list_r(l131)) );
 single_value();  local l134 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l128,l129,CL["LIST"](l(l134)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["VERSION"],n}},{CL_LIB["NEW"],n}}}},n}}})),l127,CL["LIST"](l(l134)))),CL["APPEND"](l(CL["LIST"](l(CL["PATHNAME-VERSION"])),l127)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL["PATHNAME-VERSION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l135,  ...)   single_value();  local l136 = CL_LIB["VERSION"]; local l137 = n.bound; single_value();  return ((l135)[l136] or l137) end, 1, 0, false, false)) );
 single_value();  tmp = CL["PATHNAME"]; tmp = CL_LIB["FUNCTION-SETQ"](CL["MAKE-PATHNAME"] , CL_LIB["ALLOC-FUNCTION"]({CL["&KEY"],{CL_LIB["HOST"],{CL_LIB["DEVICE"],{CL["DIRECTORY"],{CL_LIB["NAME"],{CL["TYPE"],{CL_LIB["VERSION"],{CL_LIB["DEFAULTS"],{{CL["CASE"],{LCL["KEYWORD"]["LOCAL"],n}},n}}}}}}}}},function (keys,  ...)  if not keys[CL_LIB["HOST"]] then  keys[CL_LIB["HOST"]] = n.bound end if not keys[CL_LIB["DEVICE"]] then  keys[CL_LIB["DEVICE"]] = n.bound end if not keys[CL["DIRECTORY"]] then  keys[CL["DIRECTORY"]] = n.bound end if not keys[CL_LIB["NAME"]] then  keys[CL_LIB["NAME"]] = n.bound end if not keys[CL["TYPE"]] then  keys[CL["TYPE"]] = n.bound end if not keys[CL_LIB["VERSION"]] then  keys[CL_LIB["VERSION"]] = n.bound end if not keys[CL_LIB["DEFAULTS"]] then  keys[CL_LIB["DEFAULTS"]] = n.bound end if not keys[CL["CASE"]] then  keys[CL["CASE"]] = LCL["KEYWORD"]["LOCAL"] end  single_value();  return CL_LIB["%MAKE-PATHNAME"](k(CL_LIB["HOST"], keys[CL_LIB["HOST"]], CL_LIB["DEVICE"], keys[CL_LIB["DEVICE"]], CL["DIRECTORY"], keys[CL["DIRECTORY"]], CL_LIB["NAME"], keys[CL_LIB["NAME"]], CL["TYPE"], keys[CL["TYPE"]], CL_LIB["VERSION"], keys[CL_LIB["VERSION"]])) end, 0, 0, false, {0 , [LCL["KEYWORD"]["HOST"]] = CL_LIB["HOST"], [LCL["KEYWORD"]["DEVICE"]] = CL_LIB["DEVICE"], [LCL["KEYWORD"]["DIRECTORY"]] = CL["DIRECTORY"], [LCL["KEYWORD"]["NAME"]] = CL_LIB["NAME"], [LCL["KEYWORD"]["TYPE"]] = CL["TYPE"], [LCL["KEYWORD"]["VERSION"]] = CL_LIB["VERSION"], [LCL["KEYWORD"]["DEFAULTS"]] = CL_LIB["DEFAULTS"], [LCL["KEYWORD"]["CASE"]] = CL["CASE"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["USER-HOMEDIR-PATHNAME"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{CL_LIB["HOST"],n}},function (l1,  ...)  if not l1 then  l1 = n.bound end  single_value();  local l2 = n if n ~= l1 then  l2 = n.bound else  l2 = CL["MAKE-PATHNAME"](k(CL["DIRECTORY"], CL["LIST"](l(LCL["KEYWORD"]["ABSOLUTE"])))) end return l2 end, 0, 1, false, false)); local l1 = CL["USER-HOMEDIR-PATHNAME"](false); single_value();  tmp = CL_LIB.DEF(CL["*DEFAULT-PATHNAME-DEFAULTS*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL["PARSE-NAMESTRING"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["THING"],{CL["&OPTIONAL"],{CL_LIB["HOST"],{CL_LIB["DEFAULT-PATHNAME"],{CL["&KEY"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL_LIB["JUNK-ALLOWED"],n}}}}}}}},function (l1, l2, l3, keys,  ...)  if not l2 then  l2 = n.bound end if not l3 then  l3 = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL_LIB["JUNK-ALLOWED"]] then  keys[CL_LIB["JUNK-ALLOWED"]] = n.bound end  local l4 = n if n ~= CL_LIB["FILE-STREAM-P"](l1) then  l1 = CL_LIB["FILE-STREAM-PATHNAME"](l1) l4 = l1 else  l4 = n.bound end i( l4 );
 single_value();  local l5 = n if n ~= CL["PATHNAMEP"](l1) then  single_value();  l5 = l1 else  local l6 = n if n ~= CL["STRINGP"](l1) then  local l8 = keys[CL_LIB["END"]]; single_value();  local l9 = n if n ~= l8 then  l9 = l8 else  local l10 = CL["/="](keys[CL_LIB["START"]], 0); single_value();  local l11 = n if n ~= l10 then  l11 = l10 else  l1 = CL["SUBSEQ"](l1, keys[CL_LIB["START"]], keys[CL_LIB["END"]]) l11 = l1 end l9 = l11 end local l7 = n if n ~= l9 then  l7 = n.bound else  l7 = n.bound end i( l7 );
 local l12 = keys[CL_LIB["END"]]; single_value();  local l13 = n if n ~= l12 then  l13 = l12 else  l13 = CL["LENGTH"](l1) end keys[CL_LIB["END"]] = (l13 - keys[CL_LIB["START"]]) i( keys[CL_LIB["END"]] );
 single_value();  local l14 = n.bound; local l15 = 0; local l16 = 0; local l17 = n if n ~= CL["CHAR="](LCL['CL-LIB']['MAKE-CHAR']("/"), l(CL["CHAR"](l1, 0))) then  single_value();  single_value();  local l18 = CL["CONS"](LCL["KEYWORD"]["ABSOLUTE"], l14); single_value();  l14 = l18 i( l14 );
 single_value();  local l19 = (1 + l15); single_value();  l15 = l19 i( l15 );
 single_value();  single_value();  local l20 = (1 + l16); single_value();  l16 = l20 l17 = l16 else  single_value();  single_value();  local l21 = CL["CONS"](LCL["KEYWORD"]["RELATIVE"], l14); single_value();  l14 = l21 l17 = l14 end i( l17 );
 while true do  local l22 = n if n ~= CL["EQ"](l16, keys[CL_LIB["END"]]) then  single_value();  single_value();  local l23 = CL["CONS"](CL["SUBSEQ"](l1, l15, l16), l14); single_value();  l14 = l23 i( l14 );
 single_value(); do break end; l22 = n.bound else  local l24 = n if n ~= CL["CHAR="](LCL['CL-LIB']['MAKE-CHAR']("/"), l(CL["CHAR"](l1, l16))) then  single_value();  single_value();  local l25 = CL["CONS"](CL["SUBSEQ"](l1, l15, l16), l14); single_value();  l14 = l25 i( l14 );
 single_value();  l15 = (1 + l16) l24 = l15 else  l24 = n.bound end l22 = l24 end i( l22 );
 single_value();  single_value();  local l26 = (1 + l16); single_value();  l16 = l26 local tmpres = l16 end i( n );
 single_value();  local l27 = n if n ~= CL["STRING="]("", l((l14)[1])) then  l27 = CL["MAKE-PATHNAME"](k(CL["DIRECTORY"], CL["REVERSE"]((l14)[2]))) else  local l28 = ({string.find((l14)[1], '.*%.')}) [2] or n; single_value();  local l30 = n if n ~= CL["STRING="]("", l((l14)[1])) then  l30 = n.bound else  local l31 = n if n ~= l28 then  l31 = CL["SUBSEQ"]((l14)[1], 0, (l28 - 1)) else  l31 = (l14)[1] end l30 = l31 end local l29 = l30; single_value();  local l33 = n if n ~= CL["STRING="]("", l((l14)[1])) then  l33 = n.bound else  local l34 = n if n ~= l28 then  l34 = CL["SUBSEQ"]((l14)[1], l28, false) else  l34 = n.bound end l33 = l34 end local l32 = l33; single_value();  single_value();  l27 = CL["MAKE-PATHNAME"](k(CL["DIRECTORY"], CL["REVERSE"]((l14)[2]), CL_LIB["NAME"], l29, CL["TYPE"], l32)) end l6 = l27 else  local l35 = n if n ~= CL["T"].bound then  single_value();  l35 = CL["ERROR"]("Can't convert ~S to pathname", l(l1)) else  l35 = n.bound end l6 = l35 end l5 = l6 end return l5 end, 1, 2, false, {0 , [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["JUNK-ALLOWED"]] = CL_LIB["JUNK-ALLOWED"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["MERGE-PATHNAMES"] , CL_LIB["ALLOC-FUNCTION"]({CL["PATHNAME"],{CL["&OPTIONAL"],{{CL_LIB["DEFAULT-PATHNAME"],{CL["*DEFAULT-PATHNAME-DEFAULTS*"],n}},{{CL_LIB["DEFAULT-VERSION"],{LCL["KEYWORD"]["NEWEST"],n}},n}}}},function (l1, l2, l3,  ...)  if not l2 then  l2 = CL["*DEFAULT-PATHNAME-DEFAULTS*"].bound end if not l3 then  l3 = LCL["KEYWORD"]["NEWEST"] end  local l4 = n if n ~= CL["STRINGP"](l1) then  l1 = CL["PARSE-NAMESTRING"](l1, false, false, k()) l4 = l1 else  l4 = n.bound end i( l4 );
 local l5 = n if n ~= CL["STRINGP"](l2) then  l2 = CL["PARSE-NAMESTRING"](l2, false, false, k()) l5 = l2 else  l5 = n.bound end i( l5 );
 single_value();  local l6 = CL["PATHNAME-HOST"](l1); single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  l7 = CL["PATHNAME-HOST"](l2) end local l8 = CL["PATHNAME-DEVICE"](l1); single_value();  local l9 = n if n ~= l8 then  l9 = l8 else  l9 = CL["PATHNAME-DEVICE"](l2) end local l10 = CL["PATHNAME-NAME"](l1); single_value();  local l11 = n if n ~= l10 then  l11 = l10 else  l11 = CL["PATHNAME-NAME"](l2) end local l12 = CL["PATHNAME-VERSION"](l1); single_value();  local l13 = n if n ~= l12 then  l13 = l12 else  local l14 = CL["PATHNAME-VERSION"](l2); single_value();  local l15 = n if n ~= l14 then  l15 = l14 else  l15 = l3 end l13 = l15 end local l16 = CL["PATHNAME-TYPE"](l1); single_value();  local l17 = n if n ~= l16 then  l17 = l16 else  l17 = CL["PATHNAME-TYPE"](l2) end local l19 = n if n ~= CL["LISTP"](CL["PATHNAME-DIRECTORY"](l1)) then  l19 = CL["EQ"](LCL["KEYWORD"]["RELATIVE"], (CL["PATHNAME-DIRECTORY"](l1))[1]) else  l19 = n.bound end local l18 = n if n ~= l19 then  l18 = CL["APPEND"](l(CL["PATHNAME-DIRECTORY"](l2),(CL["PATHNAME-DIRECTORY"](l1))[2])) else  local l20 = CL["PATHNAME-DIRECTORY"](l1); single_value();  local l21 = n if n ~= l20 then  l21 = l20 else  l21 = CL["PATHNAME-DIRECTORY"](l2) end l18 = l21 end return CL["MAKE-PATHNAME"](k(CL_LIB["HOST"], l7, CL_LIB["DEVICE"], l9, CL_LIB["NAME"], l11, CL_LIB["VERSION"], l13, CL["TYPE"], l17, CL["DIRECTORY"], l18)) end, 1, 2, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["HOST-NAMESTRING"] , CL_LIB["ALLOC-FUNCTION"]({CL["PATHNAME"],n},function (l1,  ...)   local l2 = n if n ~= CL["STRINGP"](l1) then  l1 = CL["PARSE-NAMESTRING"](l1, false, false, k()) l2 = l1 else  l2 = n.bound end i( l2 );
 single_value();  return CL["PATHNAME-HOST"](l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FILE-NAMESTRING"] , CL_LIB["ALLOC-FUNCTION"]({CL["PATHNAME"],n},function (l1,  ...)   local l2 = n if n ~= CL["STRINGP"](l1) then  l1 = CL["PARSE-NAMESTRING"](l1, false, false, k()) l2 = l1 else  l2 = n.bound end i( l2 );
 single_value();  local l3 = CL["MAKE-STRING-OUTPUT-STREAM"](k()); i( CL["WRITE-STRING"](CL["PATHNAME-NAME"](l1), l3, k()) );
 local l4 = n if n ~= CL["PATHNAME-TYPE"](l1) then  i( CL["WRITE-STRING"](".", l3, k()) );
 single_value();  l4 = CL["WRITE-STRING"](CL["PATHNAME-TYPE"](l1), l3, k()) else  l4 = n.bound end i( l4 );
 single_value();  return CL["GET-OUTPUT-STREAM-STRING"](l3) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["DIRECTORY-NAMESTRING"] , CL_LIB["ALLOC-FUNCTION"]({CL["PATHNAME"],n},function (l1,  ...)   local l2 = n if n ~= CL["STRINGP"](l1) then  l1 = CL["PARSE-NAMESTRING"](l1, false, false, k()) l2 = l1 else  l2 = n.bound end i( l2 );
 single_value();  local l3 = CL["MAKE-STRING-OUTPUT-STREAM"](k()); local l4 = CL["PATHNAME-DIRECTORY"](l1); single_value();  while true do  single_value();  local l5 = (l4)[1]; local l6 = CL["CADR"](l4); local l7 = n if n ~= CL["EQ"](l5, LCL["KEYWORD"]["RELATIVE"]) then  single_value();  l7 = n.bound else  local l8 = n if n ~= CL["EQ"](l5, LCL["KEYWORD"]["ABSOLUTE"]) then  local l9 = CL["PATHNAME-DEVICE"](l1); single_value();  local l10 = n if n ~= l9 then  single_value();  l10 = CL["WRITE-STRING"](l9, l3, k()) else  l10 = n.bound end i( l10 );
 single_value();  l8 = CL["WRITE-STRING"]("/", l3, k()) else  local l11 = n if n ~= CL["STRING="]("..", l(l6)) then  single_value();  l4 = (l4)[2] l11 = l4 else  local l12 = n if n ~= CL["STRING="](".", l(l6)) then  single_value();  l12 = n.bound else  local l13 = n if n ~= CL["NULL"](l5) then  single_value(); do break end; l13 = n.bound else  local l14 = n if n ~= CL["T"].bound then  i( CL["WRITE-STRING"](l5, l3, k()) );
 single_value();  l14 = CL["WRITE-STRING"]("/", l3, k()) else  l14 = n.bound end l13 = l14 end l12 = l13 end l11 = l12 end l8 = l11 end l7 = l8 end i( l7 );
 single_value();  l4 = (l4)[2] local tmpres = l4 end i( n );
 single_value();  return CL["GET-OUTPUT-STREAM-STRING"](l3) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["NAMESTRING"] , CL_LIB["ALLOC-FUNCTION"]({CL["PATHNAME"],n},function (l1,  ...)   local l2 = n if n ~= CL["STRINGP"](l1) then  l1 = CL["PARSE-NAMESTRING"](l1, false, false, k()) l2 = l1 else  l2 = n.bound end i( l2 );
 single_value();  local l3 = CL["MAKE-STRING-OUTPUT-STREAM"](k()); i( CL["WRITE-STRING"](CL["DIRECTORY-NAMESTRING"](l1), l3, k()) );
 local l4 = n if n ~= CL["PATHNAME-NAME"](l1) then  l4 = CL["WRITE-STRING"](CL["FILE-NAMESTRING"](l1), l3, k()) else  l4 = n.bound end i( l4 );
 single_value();  return CL["GET-OUTPUT-STREAM-STRING"](l3) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ENOUGH-NAMESTRING"] , CL_LIB["ALLOC-FUNCTION"]({CL["PATHNAME"],n},function (l1,  ...)   single_value();  return CL["NAMESTRING"](l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["TRUENAME"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FILESPEC"],n},function (l1,  ...)   single_value();  local l2 = l1; single_value();  local l3 = n if n ~= CL["TYPEP"](l2, CL["STRING"], false) then  single_value();  l3 = CL["PARSE-NAMESTRING"](l1, false, false, k()) else  local l4 = n if n ~= CL["TYPEP"](l2, CL["PATHNAME"], false) then  single_value();  l4 = l1 else  local l5 = n if n ~= CL["TYPEP"](l2, CL["STREAM"], false) then  single_value();  l5 = CL_LIB["FILE-STREAM-PATHNAME"](l1) else  local l6 = n if n ~= CL["TYPEP"](l2, CL["T"], false) then  single_value();  l6 = CL["ERROR"]("etypecase, no matching branches", l()) else  l6 = n.bound end l5 = l6 end l4 = l5 end l3 = l4 end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PATHNAME"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PATHSPEC"],n},function (l1,  ...)   single_value();  local l2 = l1; single_value();  local l3 = n if n ~= CL["TYPEP"](l2, CL["STRING"], false) then  single_value();  l3 = CL["PARSE-NAMESTRING"](l1, false, false, k()) else  local l4 = n if n ~= CL["TYPEP"](l2, CL["PATHNAME"], false) then  single_value();  l4 = l1 else  local l5 = n if n ~= CL["TYPEP"](l2, CL["STREAM"], false) then  single_value();  l5 = CL_LIB["FILE-STREAM-PATHNAME"](l1) else  local l6 = n if n ~= CL["TYPEP"](l2, CL["T"], false) then  single_value();  l6 = CL["ERROR"]("etypecase, no matching branches", l()) else  l6 = n.bound end l5 = l6 end l4 = l5 end l3 = l4 end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["OPEN"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FILESPEC"],{CL["&KEY"],{{CL_LIB["DIRECTION"],{LCL["KEYWORD"]["INPUT"],n}},{CL_LIB["ELEMENT-TYPE"],{{CL_LIB["IF-EXISTS"],{LCL["KEYWORD"]["DEFAULT"],n}},{{CL_LIB["IF-DOES-NOT-EXIST"],{LCL["KEYWORD"]["DEFAULT"],n}},{{CL_LIB["EXTERNAL-FORMAT"],{LCL["KEYWORD"]["DEFAULT"],n}},n}}}}}}},function (l1, keys,  ...)  if not keys[CL_LIB["DIRECTION"]] then  keys[CL_LIB["DIRECTION"]] = LCL["KEYWORD"]["INPUT"] end if not keys[CL_LIB["ELEMENT-TYPE"]] then  keys[CL_LIB["ELEMENT-TYPE"]] = n.bound end if not keys[CL_LIB["IF-EXISTS"]] then  keys[CL_LIB["IF-EXISTS"]] = LCL["KEYWORD"]["DEFAULT"] end if not keys[CL_LIB["IF-DOES-NOT-EXIST"]] then  keys[CL_LIB["IF-DOES-NOT-EXIST"]] = LCL["KEYWORD"]["DEFAULT"] end if not keys[CL_LIB["EXTERNAL-FORMAT"]] then  keys[CL_LIB["EXTERNAL-FORMAT"]] = LCL["KEYWORD"]["DEFAULT"] end  single_value();  local l3 = keys[CL_LIB["DIRECTION"]]; single_value();  local l4 = n if n ~= CL["EQL"](l3, LCL["KEYWORD"]["INPUT"]) then  single_value();  l4 = "r" else  local l5 = n if n ~= CL["EQL"](l3, LCL["KEYWORD"]["OUTPUT"]) then  single_value();  l5 = "w" else  local l6 = n if n ~= CL["EQL"](l3, LCL["KEYWORD"]["IO"]) then  single_value();  l6 = "rw" else  local l7 = n if n ~= CL["EQL"](l3, LCL["KEYWORD"]["PROBE"]) then  single_value();  l7 = "r" else  local l8 = n if n ~= CL["T"].bound then  single_value();  l8 = CL["ERROR"]("ECASE", l()) else  l8 = n.bound end l7 = l8 end l6 = l7 end l5 = l6 end l4 = l5 end local l2 = l4; single_value();  local l9 = io.open(CL["NAMESTRING"](CL["TRUENAME"](l1)), l2) or n; single_value();  single_value();  local l10 = n if n ~= l9 then  l10 = CL_LIB["MAKE-FILE-STREAM"](k(CL_LIB["FILE"], l9, CL["PATHNAME"], l1)) else  l10 = CL["ERROR"]("Could not open file ~S", l(l1)) end return l10 end, 1, 0, false, {0 , [LCL["KEYWORD"]["DIRECTION"]] = CL_LIB["DIRECTION"], [LCL["KEYWORD"]["ELEMENT-TYPE"]] = CL_LIB["ELEMENT-TYPE"], [LCL["KEYWORD"]["IF-EXISTS"]] = CL_LIB["IF-EXISTS"], [LCL["KEYWORD"]["IF-DOES-NOT-EXIST"]] = CL_LIB["IF-DOES-NOT-EXIST"], [LCL["KEYWORD"]["EXTERNAL-FORMAT"]] = CL_LIB["EXTERNAL-FORMAT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["FILE-POSITION"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["&OPTIONAL"],{CL["POSITION"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  local l3 = n if n ~= CL["TYPEP"](l1, CL["FILE-STREAM"], false) then  l3 = n.bound else  single_value();  l3 = CL["ERROR"](CL["TYPE-ERROR"], l(LCL["KEYWORD"]["FORM"],CL["STREAM"],LCL["KEYWORD"]["DATUM"],l1,LCL["KEYWORD"]["EXPECTED-TYPE"],CL["FILE-STREAM"])) end i( l3 );
 single_value();  local l4 = n if n ~= l2 then  local l5 = CL_LIB["FILE-STREAM-FILE"](l1); single_value();  l4 = CL["FUNCALL"](l5.seek, l(l5,"set",l2)) else  local l6 = n if n ~= CL_LIB["FILE-STREAM-UNREAD"](l1) then  l6 = -1 else  l6 = 0 end local l7 = CL_LIB["FILE-STREAM-FILE"](l1); single_value();  l4 = (l6 + CL["FUNCALL"](l7.seek, l(l7))) end return l4 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FILE-STRING-LENGTH"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["OBJECT"],n}},function (l1, l2,  ...)   single_value();  local l3 = l2; single_value();  local l4 = n if n ~= CL["TYPEP"](l3, CL["CHARACTER"], false) then  single_value();  l4 = 1 else  local l5 = n if n ~= CL["TYPEP"](l3, CL["STRING"], false) then  single_value();  l5 = CL["LENGTH"](l2) else  local l6 = n if n ~= CL["TYPEP"](l3, CL["T"], false) then  single_value();  l6 = CL["ERROR"]("etypecase, no matching branches", l()) else  l6 = n.bound end l5 = l6 end l4 = l5 end return (CL["FILE-POSITION"](l1, false) + l4) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FILE-AUTHOR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PATHSPEC"],n},function (l1,  ...)   single_value();  return n.bound end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FILE-STRING-LENGTH"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["OBJECT"],n}},function (l1, l2,  ...)   single_value();  return n.bound end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FILE-WRITE-DATE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PATHSPEC"],n},function (l1,  ...)   single_value();  return n.bound end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FILE-LENGTH"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l1,  ...)   single_value();  local l3 = CL_LIB["FILE-STREAM-FILE"](l1); single_value();  local l2 = CL["FUNCALL"](l3.seek, l(l3)); single_value();  local l4 = "end"; single_value();  local l6 = CL_LIB["FILE-STREAM-FILE"](l1); single_value();  local l5 = CL["FUNCALL"](l6.seek, l(l6,l4)); single_value();  local l7 = "set"; single_value();  local l8 = CL_LIB["FILE-STREAM-FILE"](l1); single_value();  i( CL["FUNCALL"](l8.seek, l(l8,l7,l2)) );
 single_value();  return l5 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PROBE-FILE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PATHSPEC"],n},function (l1,  ...)   single_value();  local l2 = io.open(CL["NAMESTRING"](CL["TRUENAME"](l1)), "r") or n; single_value();  local l3 = n if n ~= l2 then  local l4 = l2; single_value();  i( CL["FUNCALL"](l4.close, l(l4)) );
 single_value();  l3 = CL["TRUENAME"](l1) else  l3 = n.bound end return l3 end, 1, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["WITH-OPEN-FILE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G120391"],{CL["&OPTIONAL"],{LCL["NIL"]["G120392"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"]((l5)[1], CL["CONS"](CL["CONS"](CL["OPEN"], CL["APPEND"](l((l5)[2],n))), n)), n), CL["CONS"](CL["CONS"](CL["UNWIND-PROTECT"], CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(l9,n))), CL["CONS"](CL["CONS"](CL["CLOSE"], CL["CONS"]((l5)[1], n)), n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["WITH-OPEN-STREAM"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G120457"],{CL["&OPTIONAL"],{LCL["NIL"]["G120458"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](l5, n), CL["CONS"](CL["CONS"](CL["UNWIND-PROTECT"], CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(l9,n))), CL["CONS"](CL["CONS"](CL["CLOSE"], CL["CONS"]((l5)[1], n)), n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["WITH-OUTPUT-TO-STRING"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G120518"],{CL["&OPTIONAL"],{LCL["NIL"]["G120519"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = n if n ~= CL["SECOND"](l5) then  local l11 = CL["GENSYM"](false); single_value();  l10 = CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](l11, n), CL["CONS"](CL["CONS"](CL["SETF"], CL["CONS"](CL["SECOND"](l5), CL["CONS"](CL["CONS"](CL_LIB["CONCAT-STRING"], CL["CONS"](CL["SECOND"](l5), CL["CONS"](CL["CONS"](CL["WITH-OUTPUT-TO-STRING"], CL["CONS"](CL["CONS"]((l5)[1], n), CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](l11, CL["CONS"](CL["CONS"](CL["MULTIPLE-VALUE-LIST"], CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(l9,n))), n)), n))), n))), n))), n))), CL["CONS"](CL["CONS"](CL["VALUES-LIST"], CL["CONS"](l11, n)), n)))) else  l10 = CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"]((l5)[1], CL["CONS"](CL["CONS"](CL["MAKE-STRING-OUTPUT-STREAM"], n), n)), n), CL["APPEND"](l(l9,CL["CONS"](CL["CONS"](CL["GET-OUTPUT-STREAM-STRING"], CL["CONS"]((l5)[1], n)), n))))) end return l10 end, 1, 1, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); i( CL_LIB["FUNCTION-SETQ"](CL_LIB["MAKE-READTABLE"] , CL_LIB["ALLOC-FUNCTION"]({CL["&KEY"],{{CL_LIB["TABLE"],{{CL["MAKE-HASH-TABLE"],n},n}},{{CL_LIB["MACROS"],{{CL["MAKE-HASH-TABLE"],n},n}},{{CL_LIB["DISPATCH"],{{CL["MAKE-HASH-TABLE"],n},n}},{{CL["CASE"],{LCL["KEYWORD"]["UPCASE"],n}},n}}}}},function (keys,  ...)  if not keys[CL_LIB["TABLE"]] then  keys[CL_LIB["TABLE"]] = CL["MAKE-HASH-TABLE"](k()) end if not keys[CL_LIB["MACROS"]] then  keys[CL_LIB["MACROS"]] = CL["MAKE-HASH-TABLE"](k()) end if not keys[CL_LIB["DISPATCH"]] then  keys[CL_LIB["DISPATCH"]] = CL["MAKE-HASH-TABLE"](k()) end if not keys[CL["CASE"]] then  keys[CL["CASE"]] = LCL["KEYWORD"]["UPCASE"] end  single_value();  local l1 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-STRUCT"].fbound, {}); local l2 = CL["READTABLE"]; single_value(); l1[CL["IDENTITY"]("name")] = l2 i( l2 );
 local l3 = keys[CL_LIB["TABLE"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["TABLE"])] = l3 i( l3 );
 local l4 = keys[CL_LIB["MACROS"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["MACROS"])] = l4 i( l4 );
 local l5 = keys[CL_LIB["DISPATCH"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["DISPATCH"])] = l5 i( l5 );
 local l6 = keys[CL["CASE"]]; single_value(); l1[CL["IDENTITY"](CL["CASE"])] = l6 i( l6 );
 single_value();  return l1 end, 0, 0, false, {0 , [LCL["KEYWORD"]["TABLE"]] = CL_LIB["TABLE"], [LCL["KEYWORD"]["MACROS"]] = CL_LIB["MACROS"], [LCL["KEYWORD"]["DISPATCH"]] = CL_LIB["DISPATCH"], [LCL["KEYWORD"]["CASE"]] = CL["CASE"]})) );
 i( CL_LIB["FUNCTION-SETQ"](CL["COPY-READTABLE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l7,  ...)   single_value();  return CL["COPY-STRUCTURE"](l7) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["READTABLE"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l8,  ...)   single_value();  return CL_LIB["%CHECK-STRUCT-TYPE"](l8, CL["READTABLE"]) end, 1, 0, false, false), {CL["STRUCTURE-OBJECT"],{CL["T"],n}}) );
 i( CL_LIB["FUNCTION-SETQ"](CL["READTABLEP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l9,  ...)   single_value();  return CL["TYPEP"](l9, CL["READTABLE"], false) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["READTABLE-TABLE"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l10,  ...)   single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = n.bound; local l15 = n.bound; local l16 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l17 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l19 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l18 = l19; single_value();  single_value();  l11,l12,l13,l14,l15= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l10, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l16 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l17.error ~= n and true then if l17.error == KEYWORD.TAG then  error(l17) else error(l17[1]) end end i( CL["VALUES-LIST"](list_r(l17)) );
 single_value();  local l20 = n.bound; local l21 = n.bound; local l22 = n.bound; local l23 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l24 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l26 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l25 = l26; single_value();  single_value();  l20,l21,l22= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l15, l11, l12), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l23 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l24.error ~= n and true then if l24.error == KEYWORD.TAG then  error(l24) else error(l24[1]) end end i( CL["VALUES-LIST"](list_r(l24)) );
 single_value();  local l27 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l21,l22,CL["LIST"](l(l27)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["TABLE"],n}},{CL_LIB["NEW"],n}}}},n}}})),l20,CL["LIST"](l(l27)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["READTABLE-TABLE"])),l20)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["READTABLE-TABLE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l28,  ...)   single_value();  local l29 = CL_LIB["TABLE"]; local l30 = n.bound; single_value();  return ((l28)[l29] or l30) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["READTABLE-MACROS"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l31,  ...)   single_value();  local l32 = n.bound; local l33 = n.bound; local l34 = n.bound; local l35 = n.bound; local l36 = n.bound; local l37 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l38 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l40 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l39 = l40; single_value();  single_value();  l32,l33,l34,l35,l36= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l31, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l37 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l38.error ~= n and true then if l38.error == KEYWORD.TAG then  error(l38) else error(l38[1]) end end i( CL["VALUES-LIST"](list_r(l38)) );
 single_value();  local l41 = n.bound; local l42 = n.bound; local l43 = n.bound; local l44 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l45 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l47 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l46 = l47; single_value();  single_value();  l41,l42,l43= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l36, l32, l33), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l44 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l45.error ~= n and true then if l45.error == KEYWORD.TAG then  error(l45) else error(l45[1]) end end i( CL["VALUES-LIST"](list_r(l45)) );
 single_value();  local l48 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l42,l43,CL["LIST"](l(l48)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["MACROS"],n}},{CL_LIB["NEW"],n}}}},n}}})),l41,CL["LIST"](l(l48)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["READTABLE-MACROS"])),l41)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["READTABLE-MACROS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l49,  ...)   single_value();  local l50 = CL_LIB["MACROS"]; local l51 = n.bound; single_value();  return ((l49)[l50] or l51) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["READTABLE-DISPATCH"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l52,  ...)   single_value();  local l53 = n.bound; local l54 = n.bound; local l55 = n.bound; local l56 = n.bound; local l57 = n.bound; local l58 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l59 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l61 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l60 = l61; single_value();  single_value();  l53,l54,l55,l56,l57= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l52, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l58 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l59.error ~= n and true then if l59.error == KEYWORD.TAG then  error(l59) else error(l59[1]) end end i( CL["VALUES-LIST"](list_r(l59)) );
 single_value();  local l62 = n.bound; local l63 = n.bound; local l64 = n.bound; local l65 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l66 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l68 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l67 = l68; single_value();  single_value();  l62,l63,l64= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l57, l53, l54), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l65 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l66.error ~= n and true then if l66.error == KEYWORD.TAG then  error(l66) else error(l66[1]) end end i( CL["VALUES-LIST"](list_r(l66)) );
 single_value();  local l69 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l63,l64,CL["LIST"](l(l69)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["DISPATCH"],n}},{CL_LIB["NEW"],n}}}},n}}})),l62,CL["LIST"](l(l69)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["READTABLE-DISPATCH"])),l62)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["READTABLE-DISPATCH"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l70,  ...)   single_value();  local l71 = CL_LIB["DISPATCH"]; local l72 = n.bound; single_value();  return ((l70)[l71] or l72) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL["READTABLE-CASE"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l73,  ...)   single_value();  local l74 = n.bound; local l75 = n.bound; local l76 = n.bound; local l77 = n.bound; local l78 = n.bound; local l79 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l80 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l82 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l81 = l82; single_value();  single_value();  l74,l75,l76,l77,l78= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l73, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l79 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l80.error ~= n and true then if l80.error == KEYWORD.TAG then  error(l80) else error(l80[1]) end end i( CL["VALUES-LIST"](list_r(l80)) );
 single_value();  local l83 = n.bound; local l84 = n.bound; local l85 = n.bound; local l86 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l87 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l89 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l88 = l89; single_value();  single_value();  l83,l84,l85= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l78, l74, l75), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l86 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l87.error ~= n and true then if l87.error == KEYWORD.TAG then  error(l87) else error(l87[1]) end end i( CL["VALUES-LIST"](list_r(l87)) );
 single_value();  local l90 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l84,l85,CL["LIST"](l(l90)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL["CASE"],n}},{CL_LIB["NEW"],n}}}},n}}})),l83,CL["LIST"](l(l90)))),CL["APPEND"](l(CL["LIST"](l(CL["READTABLE-CASE"])),l83)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL["READTABLE-CASE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l91,  ...)   single_value();  local l92 = CL["CASE"]; local l93 = n.bound; single_value();  return ((l91)[l92] or l93) end, 1, 0, false, false)) );
 single_value();  tmp = CL["READTABLE"]; local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*READTABLE*"],l1); local l1 = 10; single_value();  tmp = CL_LIB.DEF(CL["*READ-BASE*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*READ-SUPPRESS*"],l1); local l1 = CL_LIB["MAKE-READTABLE"](k()); single_value();  tmp = CL_LIB.DEF(CL_LIB["*STANDARD-SYNTAX-READTABLE*"],l1); local l1 = CL["T"].bound; single_value();  tmp = CL_LIB.DEF(CL["*READ-EVAL*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["READTABLE-WHITESPACEP"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL["&OPTIONAL"],{{CL["READTABLE"],{CL["*READTABLE*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*READTABLE*"].bound end  single_value();  return CL["EQ"](LCL["KEYWORD"]["WHITE-SPACE"], CL["GETHASH"](CL["CHAR-CODE"](l1), CL_LIB["READTABLE-TABLE"](l2), LCL["KEYWORD"]["INVALID"])) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["READTABLE-CONSTITUENTP"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL["&OPTIONAL"],{{CL["READTABLE"],{CL["*READTABLE*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*READTABLE*"].bound end  single_value();  return CL["EQ"](LCL["KEYWORD"]["CONSTITUENT"], CL["GETHASH"](CL["CHAR-CODE"](l1), CL_LIB["READTABLE-TABLE"](l2), LCL["KEYWORD"]["INVALID"])) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["READTABLE-SINGLEESCAPEP"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL["&OPTIONAL"],{{CL["READTABLE"],{CL["*READTABLE*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*READTABLE*"].bound end  single_value();  return CL["EQ"](LCL["KEYWORD"]["SINGLE-ESCAPE"], CL["GETHASH"](CL["CHAR-CODE"](l1), CL_LIB["READTABLE-TABLE"](l2), LCL["KEYWORD"]["INVALID"])) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["READTABLE-TERMINATINGMACROP"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL["&OPTIONAL"],{{CL["READTABLE"],{CL["*READTABLE*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*READTABLE*"].bound end  single_value();  return CL["EQ"](LCL["KEYWORD"]["TERMINATING-MACRO-CHARACTER"], CL["GETHASH"](CL["CHAR-CODE"](l1), CL_LIB["READTABLE-TABLE"](l2), LCL["KEYWORD"]["INVALID"])) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["READTABLE-APPLY-CASE"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL["&OPTIONAL"],{{CL["READTABLE"],{CL["*READTABLE*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*READTABLE*"].bound end  single_value();  local l3 = CL["READTABLE-CASE"](l2); single_value();  local l4 = n if n ~= CL["EQL"](l3, LCL["KEYWORD"]["UPCASE"]) then  single_value();  l4 = CL["FUNCALL"](string.upper, l(CL_LIB["CHAR-STRING"](l1))) else  local l5 = n if n ~= CL["EQL"](l3, LCL["KEYWORD"]["DOWNCASE"]) then  single_value();  l5 = CL["FUNCALL"](string.lower, l(CL_LIB["CHAR-STRING"](l1))) else  local l6 = n if n ~= CL["EQL"](l3, LCL["KEYWORD"]["PRESERVE"]) then  single_value();  l6 = CL_LIB["CHAR-STRING"](l1) else  local l7 = n if n ~= CL["T"].bound then  single_value();  l7 = CL["ERROR"]("ECASE", l()) else  l7 = n.bound end l6 = l7 end l5 = l6 end l4 = l5 end return l4 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["READ-NUMBER"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["TOKEN"],{CL["&OPTIONAL"],{{CL_LIB["BASE"],{CL["*READ-BASE*"],n}},{CL["ERROR"],{CL_LIB["ERROR-VALUE"],{CL["&AUX"],{{CL_LIB["ACC"],{0,n}},{{CL_LIB["FACTOR"],{1,n}},n}}}}}}}},function (l1, l2, l3, l4,  ...)  if not l2 then  l2 = CL["*READ-BASE*"].bound end if not l3 then  l3 = n.bound end if not l4 then  l4 = n.bound end l5 = 0 l6 = 1  local l7 = n if n ~= CL["EQ"](CL["ELT"](l1, 0), LCL['CL-LIB']['MAKE-CHAR']("-")) then  single_value();  single_value();  local l8 = -1; single_value();  l6 = l8 i( l6 );
 single_value();  single_value();  single_value();  local l9 = CL["SUBSEQ"](l1, 1, false); single_value();  l1 = l9 l7 = l1 else  local l10 = n if n ~= CL["EQ"](CL["ELT"](l1, 0), LCL['CL-LIB']['MAKE-CHAR']("+")) then  single_value();  single_value();  local l11 = 1; single_value();  l6 = l11 i( l6 );
 single_value();  single_value();  single_value();  local l12 = CL["SUBSEQ"](l1, 1, false); single_value();  l1 = l12 l10 = l1 else  l10 = n.bound end l7 = l10 end i( l7 );
 single_value();  local l13 = 0; single_value();  local l14 = CL["GENSYM"](false); single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l16 = n if n ~= CL[">="](l(l13,CL["LENGTH"](l1))) then  single_value(); do break end; l16 = n.bound else  l16 = n.bound end i( l16 );
 local l17 = CL_LIB["CHAR-DIGIT"](CL["ELT"](l1, l13), l2); single_value();  local l18 = n if n ~= l17 then  l5 = ((l2 * l5) + l17) l18 = l5 else  local l19 = n if n ~= l3 then  l19 = CL["ERROR"]("Number ~A is invalid in base ~S", l(l1,l2)) else  local l20 = l4; single_value(); do return l20 end; l19 = n.bound end l18 = l19 end i( l18 );
 single_value();  local l21 = (1 + l13); single_value();  single_value();  single_value();  local l22 = l21; single_value();  l13 = l22 local tmpres = l13 end i( n );
 single_value();  return (l6 * l5) end, 0, 0, false, false))); single_value(); if l15.error ~= n and (l15.error ~= KEYWORD.TAG or l15.tag ~= l14) then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end return CL["VALUES-LIST"](list_r(l15)) end, 1, 3, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PARSE-INTEGER"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL["&KEY"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{{CL_LIB["RADIX"],{10,n}},{CL_LIB["JUNK-ALLOWED"],n}}}}}},function (l1, keys,  ...)  if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL_LIB["RADIX"]] then  keys[CL_LIB["RADIX"]] = 10 end if not keys[CL_LIB["JUNK-ALLOWED"]] then  keys[CL_LIB["JUNK-ALLOWED"]] = n.bound end  single_value();  return CL_LIB["READ-NUMBER"](CL["SUBSEQ"](l1, keys[CL_LIB["START"]], keys[CL_LIB["END"]]), keys[CL_LIB["RADIX"]], CL["T"].bound, false) end, 1, 0, false, {0 , [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["RADIX"]] = CL_LIB["RADIX"], [LCL["KEYWORD"]["JUNK-ALLOWED"]] = CL_LIB["JUNK-ALLOWED"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FINALIZE-TOKEN"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["TOKEN"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["*READ-SUPPRESS*"].bound then  l2 = n.bound else  local l3 = tonumber(l1) or n; single_value();  local l4 = n if n ~= l3 then  l4 = l3 else  local l5 = {string.find(l1, '::?')}; single_value();  local l6 = l5[1] or n; single_value();  local l7 = l5[2] or n; single_value();  single_value();  local l8 = n if n ~= CL["EQ"](LCL['CL-LIB']['MAKE-CHAR'](":"), CL["CHAR"](l1, 0)) then  l8 = CL["INTERN"](CL["SUBSEQ"](l1, 1, false), CL["KEYWORD"]) else  local l9 = n if n ~= l6 then  l9 = CL["INTERN"](CL["SUBSEQ"](l1, l7, false), CL["SUBSEQ"](l1, 0, (l6 - 1))) else  l9 = CL["INTERN"](l1, false) end l8 = l9 end l4 = l8 end l2 = l4 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%READ-TOKEN"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FINALIZE"],{CL["STREAM"],{CL_LIB["TOKEN"],{CL["&OPTIONAL"],{CL_LIB["ESCAPING"],n}}}}},function (l1, l2, l3, l4,  ...)  if not l4 then  l4 = n.bound end  single_value();  local l5 = n if n ~= l4 then  local l6 = CL["READ-CHAR"](l2, CL["T"].bound, n.bound, CL["T"].bound); single_value();  local l7 = CL["GETHASH"](CL["CHAR-CODE"](l6), CL_LIB["READTABLE-TABLE"](CL["*READTABLE*"].bound), LCL["KEYWORD"]["INVALID"]); single_value();  single_value();  local l8 = n if n ~= CL["EQ"](LCL["KEYWORD"]["INVALID"], l7) then  single_value();  l8 = CL["ERROR"]("Char ~A (~A) is invalid ", l(l6,CL["CHAR-CODE"](l6))) else  local l9 = n if n ~= CL["EQ"](LCL["KEYWORD"]["SINGLE-ESCAPE"], l7) then  single_value();  l9 = CL_LIB["%READ-TOKEN"](l1, l2, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l3, CL_LIB["CHAR-STRING"](CL["READ-CHAR"](l2, CL["T"].bound, n.bound, CL["T"].bound)), }), CL["T"].bound) else  local l10 = n if n ~= CL["EQ"](LCL["KEYWORD"]["MULTIPLE-ESCAPE"], l7) then  single_value();  l10 = CL_LIB["%READ-TOKEN"](l1, l2, l3, n.bound) else  local l11 = n if n ~= CL["T"].bound then  single_value();  l11 = CL_LIB["%READ-TOKEN"](l1, l2, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l3, CL_LIB["CHAR-STRING"](l6), }), CL["T"].bound) else  l11 = n.bound end l10 = l11 end l9 = l10 end l8 = l9 end l5 = l8 else  local l12 = CL["READ-CHAR"](l2, n.bound, n.bound, CL["T"].bound); single_value();  local l13 = CL["GETHASH"](CL["CHAR-CODE"](l12), CL_LIB["READTABLE-TABLE"](CL["*READTABLE*"].bound), LCL["KEYWORD"]["INVALID"]); single_value();  single_value();  local l14 = n if n ~= l12 then  local l15 = n if n ~= CL["EQ"](LCL["KEYWORD"]["INVALID"], l13) then  single_value();  l15 = CL["ERROR"]("Char ~A (~A) is invalid", l(l12,CL["CHAR-CODE"](l12))) else  local l16 = n if n ~= CL["EQ"](LCL["KEYWORD"]["SINGLE-ESCAPE"], l13) then  single_value();  l16 = CL_LIB["%READ-TOKEN"](l1, l2, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l3, CL_LIB["CHAR-STRING"](CL["READ-CHAR"](l2, CL["T"].bound, n.bound, CL["T"].bound)), }), false) else  local l17 = n if n ~= CL["EQ"](LCL["KEYWORD"]["MULTIPLE-ESCAPE"], l13) then  single_value();  l17 = CL_LIB["%READ-TOKEN"](l1, l2, l3, CL["T"].bound) else  local l18 = n if n ~= CL["EQ"](LCL["KEYWORD"]["TERMINATING-MACRO-CHARACTER"], l13) then  i( CL["UNREAD-CHAR"](l12, l2) );
 single_value();  local l19 = l3; single_value();  l18 = CL_LIB['FUNCALL-LUA'](l1,{l19, }) else  local l20 = n if n ~= CL["EQ"](LCL["KEYWORD"]["WHITE-SPACE"], l13) then  single_value();  local l21 = l3; single_value();  l20 = CL_LIB['FUNCALL-LUA'](l1,{l21, }) else  local l22 = n if n ~= CL["T"].bound then  single_value();  l22 = CL_LIB["%READ-TOKEN"](l1, l2, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l3, CL_LIB["READTABLE-APPLY-CASE"](l12, false), }), false) else  l22 = n.bound end l20 = l22 end l18 = l20 end l17 = l18 end l16 = l17 end l15 = l16 end l14 = l15 else  local l23 = l3; single_value();  l14 = CL_LIB['FUNCALL-LUA'](l1,{l23, }) end l5 = l14 end return l5 end, 3, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["READ-TOKEN"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["TOKEN"],{CL["&OPTIONAL"],{CL_LIB["ESCAPING"],n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = n.bound end  single_value();  return CL_LIB["%READ-TOKEN"](CL_LIB["FINALIZE-TOKEN"].fbound, l1, l2, l3) end, 2, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%READ"] , CL_LIB["ALLOC-FUNCTION"]({CL["LOOP"],{CL["&OPTIONAL"],{{CL["STREAM"],{CL["*STANDARD-INPUT*"],n}},{{CL_LIB["EOF-ERROR-P"],{CL["T"],n}},{CL_LIB["EOF-VALUE"],{CL_LIB["RECURSIVE-P"],n}}}}}},function (l1, l2, l3, l4, l5,  ...)  if not l2 then  l2 = CL["*STANDARD-INPUT*"].bound end if not l3 then  l3 = CL["T"].bound end if not l4 then  l4 = n.bound end if not l5 then  l5 = n.bound end  single_value();  local l6 = CL["READ-CHAR"](l2, n.bound, n.bound, l5); single_value();  local l7 = n if n ~= l6 then  local l8 = CL["GETHASH"](CL["CHAR-CODE"](l6), CL_LIB["READTABLE-TABLE"](CL["*READTABLE*"].bound), LCL["KEYWORD"]["INVALID"]); single_value();  local l9 = n if n ~= CL["EQ"](LCL["KEYWORD"]["INVALID"], l8) then  single_value();  l9 = CL["ERROR"]("Char ~A (~A) is invalid", l(l6,CL["CHAR-CODE"](l6))) else  local l10 = n if n ~= CL["EQ"](LCL["KEYWORD"]["WHITE-SPACE"], l8) then  single_value();  l10 = CL["READ"](l2, l3, l4, l5) else  local l12 = CL["EQ"](LCL["KEYWORD"]["TERMINATING-MACRO-CHARACTER"], l8); single_value();  local l13 = n if n ~= l12 then  l13 = l12 else  l13 = CL["EQ"](LCL["KEYWORD"]["NON-TERMINATING-MACRO-CHARACTER"], l8) end local l11 = n if n ~= l13 then  single_value();  local l14 = CL["FUNCALL"](l, l(unpack_mv(CL["FUNCALL"](CL["GETHASH"](CL["CHAR-CODE"](l6), CL_LIB["READTABLE-MACROS"](CL["*READTABLE*"].bound), LCL["KEYWORD"]["NO-READTABLE-MACRO"]), l(l2,l6))))); single_value();  local l15 = n if n ~= l14 then  l15 = (l14)[1] else  local l16 = n if n ~= l1 then  l16 = l1 else  l16 = CL["READ"](l2, l3, l4, l5) end l15 = l16 end l11 = l15 else  local l17 = n if n ~= CL["EQ"](LCL["KEYWORD"]["SINGLE-ESCAPE"], l8) then  single_value();  l17 = CL_LIB["READ-TOKEN"](l2, CL_LIB["CHAR-STRING"](CL["READ-CHAR"](l2, CL["T"].bound, n.bound, CL["T"].bound)), false) else  local l18 = n if n ~= CL["EQ"](LCL["KEYWORD"]["MULTIPLE-ESCAPE"], l8) then  single_value();  l18 = CL_LIB["READ-TOKEN"](l2, "", CL["T"].bound) else  local l19 = n if n ~= CL["EQ"](LCL["KEYWORD"]["CONSTITUENT"], l8) then  single_value();  l19 = CL_LIB["READ-TOKEN"](l2, CL_LIB["READTABLE-APPLY-CASE"](l6, false), false) else  local l20 = n if n ~= CL["T"].bound then  single_value();  l20 = CL["ERROR"]("Invalid chartype ~A ~A", l(l6,l8)) else  l20 = n.bound end l19 = l20 end l18 = l19 end l17 = l18 end l11 = l17 end l10 = l11 end l9 = l10 end l7 = l9 else  local l21 = n if n ~= l3 then  l21 = CL["ERROR"]("EOF", l()) else  l21 = l4 end l7 = l21 end return l7 end, 1, 4, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["READ"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{{CL["STREAM"],{CL["*STANDARD-INPUT*"],n}},{{CL_LIB["EOF-ERROR-P"],{CL["T"],n}},{CL_LIB["EOF-VALUE"],{CL_LIB["RECURSIVE-P"],n}}}}},function (l1, l2, l3, l4,  ...)  if not l1 then  l1 = CL["*STANDARD-INPUT*"].bound end if not l2 then  l2 = CL["T"].bound end if not l3 then  l3 = n.bound end if not l4 then  l4 = n.bound end  single_value();  return CL_LIB["%READ"](n.bound, l1, l2, l3, l4) end, 0, 4, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["READ-PRESERVING-WHITESPACE"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{{CL["STREAM"],{CL["*STANDARD-INPUT*"],n}},{{CL_LIB["EOF-ERROR-P"],{CL["T"],n}},{CL_LIB["EOF-VALUE"],{CL_LIB["RECURSIVE-P"],n}}}}},function (l1, l2, l3, l4,  ...)  if not l1 then  l1 = CL["*STANDARD-INPUT*"].bound end if not l2 then  l2 = CL["T"].bound end if not l3 then  l3 = n.bound end if not l4 then  l4 = n.bound end  single_value();  return CL["READ"](l1, l2, l3, l4) end, 0, 4, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PEEK-CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{CL_LIB["PEEK-TYPE"],{{CL_LIB["INPUT-STREAM"],{CL["*STANDARD-INPUT*"],n}},{{CL_LIB["EOF-ERROR-P"],{CL["T"],n}},{CL_LIB["EOF-VALUE"],{CL_LIB["RECURSIVE-P"],n}}}}}},function (l1, l2, l3, l4, l5,  ...)  if not l1 then  l1 = n.bound end if not l2 then  l2 = CL["*STANDARD-INPUT*"].bound end if not l3 then  l3 = CL["T"].bound end if not l4 then  l4 = n.bound end if not l5 then  l5 = n.bound end  single_value();  local l6 = CL["GENSYM"](false); single_value();  local l7 = CL["READ-CHAR"](l2, l3, l6, CL["T"].bound); single_value();  local l8 = n if n ~= CL["EQ"](l7, l6) then  l8 = l4 else  local l9 = n if n ~= CL["EQ"](CL["T"].bound, l1) then  single_value();  local l10 = n if n ~= CL_LIB["READTABLE-WHITESPACEP"](l7, false) then  l10 = CL["PEEK-CHAR"](l1, l2, l3, l4, l5) else  i( CL["UNREAD-CHAR"](l7, l2) );
 single_value();  l10 = l7 end l9 = l10 else  l9 = n.bound end l8 = l9 end return l8 end, 0, 5, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["READ-LINE"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{{CL["STREAM"],{CL["*STANDARD-INPUT*"],{{CL_LIB["EOF-ERROR-P"],{CL["T"],n}},{CL_LIB["EOF-VALUE"],{CL_LIB["RECURSIVE-P"],n}}}}},n}},function (l1,  ...)  local l2 = l1 and CL.T or n if not l1 then  l1 = CL["*STANDARD-INPUT*"].bound end  single_value();  local l3 = ""; single_value();  local l4;l4 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l5 = CL["READ-CHAR"](l1, n.bound, n.bound, CL["T"].bound); single_value();  local l7 = n if n ~= l5 then  l7 = CL["NOT"](CL["EQ"](10, CL["CHAR-CODE"](l5))) else  l7 = n.bound end local l6 = n if n ~= l7 then  l3 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l3, CL_LIB["CHAR-STRING"](l5), }) i( l3 );
 single_value();  l6 = CL_LIB["FUNCALL-LUA"]( l4[1], {}) else  l6 = n.bound end return l6 end, 0, 0, false, false)}; i( CL_LIB["FUNCALL-LUA"]( l4[1], {}) );
 single_value();  return l3 end, 0, 1, false, false)); local l1 = CL["GENSYM"](false); single_value();  tmp = CL_LIB["FUNCTION-SETQ"](CL["READ-DELIMITED-LIST"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["END"],{CL["&OPTIONAL"],{{CL["STREAM"],{CL["*STANDARD-INPUT*"],n}},{CL_LIB["RECURSIVE-P"],n}}}},function (l2, l3, l4,  ...)  if not l3 then  l3 = CL["*STANDARD-INPUT*"].bound end if not l4 then  l4 = n.bound end  single_value();  local l5;l5 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l6 = CL["READ-CHAR"](l3, CL["T"].bound, n.bound, CL["T"].bound); single_value();  local l7 = n if n ~= CL["EQ"](l2, l6) then  single_value();  l7 = n.bound else  local l8 = n if n ~= CL_LIB["READTABLE-WHITESPACEP"](l6, false) then  single_value();  l8 = CL_LIB["FUNCALL-LUA"]( l5[1], {}) else  local l9 = n if n ~= CL["T"].bound then  i( CL["UNREAD-CHAR"](l6, l3) );
 single_value();  local l10 = CL_LIB["%READ"](l1, l3, CL["T"].bound, n.bound, CL["T"].bound); single_value();  local l11 = n if n ~= CL["EQ"](l10, l1) then  l11 = CL_LIB["FUNCALL-LUA"]( l5[1], {}) else  l11 = CL["CONS"](l10, CL_LIB["FUNCALL-LUA"]( l5[1], {})) end l9 = l11 else  l9 = n.bound end l8 = l9 end l7 = l8 end return l7 end, 0, 0, false, false)}; single_value();  return CL_LIB["FUNCALL-LUA"]( l5[1], {}) end, 1, 2, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["READ-FROM-STRING"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL["&OPTIONAL"],{{CL_LIB["EOF-ERROR-P"],{CL["T"],n}},{CL_LIB["EOF-VALUE"],{CL["&KEY"],{{CL_LIB["START"],{0,n}},{CL_LIB["END"],{CL_LIB["PRESERVE-WHITESPACE"],n}}}}}}}},function (l1, l2, l3, keys,  ...)  if not l2 then  l2 = CL["T"].bound end if not l3 then  l3 = n.bound end if not keys[CL_LIB["START"]] then  keys[CL_LIB["START"]] = 0 end if not keys[CL_LIB["END"]] then  keys[CL_LIB["END"]] = n.bound end if not keys[CL_LIB["PRESERVE-WHITESPACE"]] then  keys[CL_LIB["PRESERVE-WHITESPACE"]] = n.bound end  single_value();  local l4 = CL["MAKE-STRING-INPUT-STREAM"](l1, keys[CL_LIB["START"]], keys[CL_LIB["END"]]); single_value();  local l5 = n if n ~= keys[CL_LIB["PRESERVE-WHITESPACE"]] then  l5 = CL["READ-PRESERVING-WHITESPACE"].fbound else  l5 = CL["READ"].fbound end return CL["FUNCALL"](l5, l(l4,l2,l3)) end, 1, 2, false, {0 , [LCL["KEYWORD"]["START"]] = CL_LIB["START"], [LCL["KEYWORD"]["END"]] = CL_LIB["END"], [LCL["KEYWORD"]["PRESERVE-WHITESPACE"]] = CL_LIB["PRESERVE-WHITESPACE"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SET-CHAR-SYNTAX"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL_LIB["CHARTYPE"],{CL["&OPTIONAL"],{{CL["READTABLE"],{CL["*READTABLE*"],n}},n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = CL["*READTABLE*"].bound end  single_value();  return CL_LIB["SETHASH"](CL["CHAR-CODE"](l1), CL_LIB["READTABLE-TABLE"](l3), l2) end, 2, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["%SET-ALL-SYNTAX"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G124565"],{CL["&OPTIONAL"],{LCL["NIL"]["G124566"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10;l10 = {CL_LIB["ALLOC-FUNCTION"]({CL["READTABLE"],{CL_LIB["SYNTAX"],n}},function (l11, l12,  ...)   single_value();  local l13 = n if n ~= l12 then  l13 = CL["CONS"](CL["CONS"](CL_LIB["%SET-CHAR-SYNTAX"], CL["CONS"]((l12)[1], CL["CONS"](CL["CADR"](l12), CL["CONS"](l11, n)))), CL["APPEND"](l(CL_LIB["FUNCALL-LUA"]( l10[1], {l11, CL["CDDR"](l12), }),n))) else  l13 = n.bound end return l13 end, 2, 0, false, false)}; single_value();  local l14 = n if n ~= l9 then  l14 = CL["CONS"](CL["PROGN"], CL["APPEND"](l(CL_LIB["FUNCALL-LUA"]( l10[1], {l5, l9, }),n))) else  l14 = n.bound end return l14 end, 1, 1, false, false)); i( CL_LIB["%SET-CHAR-SYNTAX"](CL["CHAR"]("	", 0), LCL["KEYWORD"]["WHITE-SPACE"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](CL["CHAR"]("\n", 0), LCL["KEYWORD"]["WHITE-SPACE"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("\n"), LCL["KEYWORD"]["WHITE-SPACE"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](CL["CHAR"]("", 0), LCL["KEYWORD"]["WHITE-SPACE"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](CL["CHAR"](" ", 0), LCL["KEYWORD"]["WHITE-SPACE"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("!"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("$"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("%"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("&"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("*"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("+"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("-"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("."), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("/"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("0"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("1"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("2"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("3"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("4"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("5"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("6"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("7"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("8"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("9"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR'](":"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("<"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("="), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR'](">"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("?"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("@"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("A"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("B"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("C"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("D"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("E"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("F"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("G"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("H"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("I"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("J"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("K"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("L"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("M"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("N"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("O"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("P"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("Q"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("R"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("S"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("T"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("U"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("V"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("W"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("X"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("Y"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("Z"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("["), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("\\"), LCL["KEYWORD"]["SINGLE-ESCAPE"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("]"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("^"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("_"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("a"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("b"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("c"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("d"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("e"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("f"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("g"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("h"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("i"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("j"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("k"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("l"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("m"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("n"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("o"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("p"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("q"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("r"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("s"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("t"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("u"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("v"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("w"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("x"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("y"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("z"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("{"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("|"), LCL["KEYWORD"]["MULTIPLE-ESCAPE"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 i( CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("}"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) );
 single_value();  tmp = CL_LIB["%SET-CHAR-SYNTAX"](LCL['CL-LIB']['MAKE-CHAR']("~"), LCL["KEYWORD"]["CONSTITUENT"], CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL_LIB["FUNCTION-SETQ"](CL["GET-MACRO-CHARACTER"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL["&OPTIONAL"],{{CL["READTABLE"],{CL["*READTABLE*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*READTABLE*"].bound end  single_value();  local l3 = CL["GETHASH"](CL["CHAR-CODE"](l1), CL_LIB["READTABLE-TABLE"](l2), LCL["KEYWORD"]["INVALID"]); single_value();  local l5 = CL["EQ"](l3, LCL["KEYWORD"]["TERMINATING-MACRO-CHARACTER"]); single_value();  local l6 = n if n ~= l5 then  l6 = l5 else  l6 = CL["EQ"](l3, LCL["KEYWORD"]["NON-TERMINATING-MACRO-CHARACTER"]) end local l4 = n if n ~= l6 then  l4 = CL["VALUES"](l(CL["GETHASH"](CL["CHAR-CODE"](l1), CL_LIB["READTABLE-MACROS"](l2), false),CL["EQ"](l3, LCL["KEYWORD"]["NON-TERMINATING-MACRO-CHARACTER"]))) else  l4 = CL["VALUES"](l(n.bound,n.bound)) end return l4 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SET-MACRO-CHARACTER"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL_LIB["FN"],{CL["&OPTIONAL"],{CL_LIB["NON-TERMINATING-P"],{{CL["READTABLE"],{CL["*READTABLE*"],n}},n}}}}},function (l1, l2, l3, l4,  ...)  if not l3 then  l3 = n.bound end if not l4 then  l4 = CL["*READTABLE*"].bound end  single_value();  local l5 = l4; single_value();  local l6 = CL_LIB["READTABLE-TABLE"](l5); single_value();  local l7 = CL["CHAR-CODE"](l1); single_value();  single_value();  local l9 = n if n ~= l3 then  l9 = LCL["KEYWORD"]["NON-TERMINATING-MACRO-CHARACTER"] else  l9 = LCL["KEYWORD"]["TERMINATING-MACRO-CHARACTER"] end local l8 = l9; single_value();  i( CL_LIB["SETHASH"](l7, l6, l8) );
 single_value();  local l10 = l4; single_value();  local l11 = CL_LIB["READTABLE-MACROS"](l10); single_value();  local l12 = CL["CHAR-CODE"](l1); single_value();  single_value();  local l13 = l2; single_value();  i( CL_LIB["SETHASH"](l12, l11, l13) );
 single_value();  return CL["T"].bound end, 2, 2, false, false)); tmp = CL["SET-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("\""), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["UNUSED-CHAR"],n}},function (l1, l2,  ...)   single_value();  local l3 = ""; single_value();  local l4;l4 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l5 = CL["READ-CHAR"](l1, CL["T"].bound, n.bound, CL["T"].bound); single_value();  local l6 = n if n ~= CL["EQL"](LCL['CL-LIB']['MAKE-CHAR']("\""), l5) then  single_value();  l6 = l3 else  local l7 = n if n ~= CL_LIB["READTABLE-SINGLEESCAPEP"](l5, false) then  l3 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l3, CL_LIB["CHAR-STRING"](CL["READ-CHAR"](l1, CL["T"].bound, n.bound, CL["T"].bound)), }) i( l3 );
 single_value();  l7 = CL_LIB["FUNCALL-LUA"]( l4[1], {}) else  local l8 = n if n ~= CL["T"].bound then  l3 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l3, CL_LIB["CHAR-STRING"](l5), }) i( l3 );
 single_value();  l8 = CL_LIB["FUNCALL-LUA"]( l4[1], {}) else  l8 = n.bound end l7 = l8 end l6 = l7 end return l6 end, 0, 0, false, false)}; single_value();  return CL_LIB["FUNCALL-LUA"]( l4[1], {}) end, 2, 0, false, false), n.bound, CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL["SET-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR'](")"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["UNUSED-CHAR"],n}},function (l1, l2,  ...)   single_value();  return CL["ERROR"]("Unmatched closing parens", l()) end, 2, 0, false, false), n.bound, CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); local l1 = CL["GENSYM"](false); single_value();  tmp = CL["SET-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("("), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["UNUSED-CHAR"],n}},function (l2, l3,  ...)   single_value();  local l4;l4 = {CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{CL_LIB["DOT"],n}},function (l5,  ...)  if not l5 then  l5 = n.bound end  single_value();  local l6 = CL["READ-CHAR"](l2, CL["T"].bound, n.bound, CL["T"].bound); single_value();  local l7 = n if n ~= CL["EQ"](LCL['CL-LIB']['MAKE-CHAR'](")"), l6) then  single_value();  l7 = n.bound else  local l8 = n if n ~= CL["EQ"](LCL['CL-LIB']['MAKE-CHAR']("."), l6) then  local l9 = n if n ~= l5 then  l9 = CL["ERROR"]("Multiple elements after dot", l()) else  l9 = n.bound end i( l9 );
 single_value();  local l10 = CL["READ"](l2, CL["T"].bound, n.bound, CL["T"].bound); i( CL_LIB["FUNCALL-LUA"]( l4[1], {CL["T"].bound, }) );
 single_value();  l8 = l10 else  local l11 = n if n ~= CL_LIB["READTABLE-WHITESPACEP"](l6, false) then  single_value();  l11 = CL_LIB["FUNCALL-LUA"]( l4[1], {l5, }) else  local l12 = n if n ~= CL["T"].bound then  i( CL["UNREAD-CHAR"](l6, l2) );
 single_value();  local l13 = CL_LIB["%READ"](l1, l2, CL["T"].bound, n.bound, CL["T"].bound); single_value();  local l14 = n if n ~= CL["EQ"](l13, l1) then  l14 = CL_LIB["FUNCALL-LUA"]( l4[1], {l5, }) else  local l15 = n if n ~= l5 then  l15 = CL["ERROR"]("Multiple elements after dot", l()) else  l15 = CL["CONS"](l13, CL_LIB["FUNCALL-LUA"]( l4[1], {l5, })) end l14 = l15 end l12 = l14 else  l12 = n.bound end l11 = l12 end l8 = l11 end l7 = l8 end return l7 end, 0, 1, false, false)}; single_value();  return CL_LIB["FUNCALL-LUA"]( l4[1], {}) end, 2, 0, false, false), n.bound, CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL["SET-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("'"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["CHAR"],n}},function (l1, l2,  ...)   single_value();  return CL["LIST"](l(CL["QUOTE"],CL["READ"](l1, CL["T"].bound, n.bound, CL["T"].bound))) end, 2, 0, false, false), n.bound, CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL["SET-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("`"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["CHAR"],n}},function (l1, l2,  ...)   single_value();  return CL["LIST"](l(CL_LIB["QUASIQUOTE"],CL["READ"](l1, CL["T"].bound, n.bound, CL["T"].bound))) end, 2, 0, false, false), n.bound, CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL["SET-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR'](","), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["CHAR"],n}},function (l1, l2,  ...)   single_value();  local l3 = CL["READ-CHAR"](l1, CL["T"].bound, n.bound, CL["T"].bound); single_value();  local l4 = n if n ~= CL["EQ"](LCL['CL-LIB']['MAKE-CHAR']("@"), l3) then  l4 = CL_LIB["UNQUOTE-LIST"] else  i( CL["UNREAD-CHAR"](l3, l1) );
 single_value();  l4 = CL_LIB["UNQUOTE"] end return CL["LIST"](l(l4,CL["READ"](l1, CL["T"].bound, n.bound, CL["T"].bound))) end, 2, 0, false, false), n.bound, CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL["SET-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR'](";"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["UNUSED-CHAR"],n}},function (l1, l2,  ...)   single_value();  local l3;l3 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l4 = CL["READ-CHAR"](l1, n.bound, n.bound, CL["T"].bound); single_value();  local l6 = n if n ~= l4 then  l6 = CL["NOT"](CL["EQ"](10, CL["CHAR-CODE"](l4))) else  l6 = n.bound end local l5 = n if n ~= l6 then  l5 = CL_LIB["FUNCALL-LUA"]( l3[1], {}) else  l5 = n.bound end return l5 end, 0, 0, false, false)}; i( CL_LIB["FUNCALL-LUA"]( l3[1], {}) );
 single_value();  return CL["VALUES"](l()) end, 2, 0, false, false), n.bound, CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["READ-DIGITS"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l1,  ...)   single_value();  local l2 = n.bound; single_value();  local l3;l3 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l4 = CL["READ-CHAR"](l1, CL["T"].bound, n.bound, CL["T"].bound); single_value();  local l5 = n if n ~= CL["DIGIT-CHAR-P"](l4, false) then  local l6 = n if n ~= l2 then  l6 = n.bound else  single_value();  l2 = 0 l6 = l2 end i( l6 );
 l2 = ((10 * l2) + (CL["CHAR-CODE"](l4) - 48)) i( l2 );
 single_value();  l5 = CL_LIB["FUNCALL-LUA"]( l3[1], {}) else  l5 = CL["UNREAD-CHAR"](l4, l1) end return l5 end, 0, 0, false, false)}; i( CL_LIB["FUNCALL-LUA"]( l3[1], {}) );
 single_value();  return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["DISPATCH-MACRO-CHARACTER-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["DISP-CHAR"],n}},function (l1, l2,  ...)   single_value();  local l3 = CL_LIB["READ-DIGITS"](l1); single_value();  local l4 = CL["READ-CHAR"](l1, CL["T"].bound, n.bound, CL["T"].bound); single_value();  local l5 = CL["GET-DISPATCH-MACRO-CHARACTER"](l2, l4, false); single_value();  single_value();  local l6 = n if n ~= l5 then  local l7 = l1; single_value();  local l8 = l4; single_value();  local l9 = l3; single_value();  l6 = CL_LIB['FUNCALL-LUA'](l5,{l7, l8, l9, }) else  l6 = CL["ERROR"]("Dispatch macro ~C~C, does not exist", l(l2,l4)) end return l6 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAKE-DISPATCH-MACRO-CHARACTER"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL["&OPTIONAL"],{CL_LIB["NON-TERMINATING-P"],{{CL["READTABLE"],{CL["*READTABLE*"],n}},n}}}},function (l1, l2, l3,  ...)  if not l2 then  l2 = n.bound end if not l3 then  l3 = CL["*READTABLE*"].bound end  i( CL["SET-MACRO-CHARACTER"](l1, CL_LIB["DISPATCH-MACRO-CHARACTER-FUNCTION"].fbound, l2, l3) );
 single_value();  single_value();  local l4 = l3; single_value();  local l5 = CL_LIB["READTABLE-DISPATCH"](l4); single_value();  local l6 = CL["CHAR-CODE"](l1); single_value();  single_value();  local l7 = CL["MAKE-HASH-TABLE"](k()); single_value();  return CL_LIB["SETHASH"](l6, l5, l7) end, 1, 2, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SET-DISPATCH-MACRO-CHARACTER"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["DISP-CHAR"],{CL_LIB["SUB-CHAR"],{CL_LIB["FN"],{CL["&OPTIONAL"],{{CL["READTABLE"],{CL["*READTABLE*"],n}},n}}}}},function (l1, l2, l3, l4,  ...)  if not l4 then  l4 = CL["*READTABLE*"].bound end  single_value();  local l6 = n if n ~= CL["LOWER-CASE-P"](l2) then  l6 = (CL["CHAR-CODE"](l2) - 32) else  l6 = CL["CHAR-CODE"](l2) end local l5 = l6; single_value();  single_value();  local l7 = l4; single_value();  local l8 = CL_LIB["READTABLE-DISPATCH"](l7); single_value();  local l9 = CL["CHAR-CODE"](l1); single_value();  local l10 = CL["GETHASH"](l9, l8, false); single_value();  local l11 = l5; single_value();  single_value();  local l12 = l3; single_value();  return CL_LIB["SETHASH"](l11, l10, l12) end, 3, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["GET-DISPATCH-MACRO-CHARACTER"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["DISP-CHAR"],{CL_LIB["SUB-CHAR"],{CL["&OPTIONAL"],{{CL["READTABLE"],{CL["*READTABLE*"],n}},n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = CL["*READTABLE*"].bound end  single_value();  local l5 = n if n ~= CL["LOWER-CASE-P"](l2) then  l5 = (CL["CHAR-CODE"](l2) - 32) else  l5 = CL["CHAR-CODE"](l2) end local l4 = l5; single_value();  return CL["GETHASH"](l4, CL["GETHASH"](CL["CHAR-CODE"](l1), CL_LIB["READTABLE-DISPATCH"](l3), false), false) end, 2, 1, false, false)); tmp = CL["MAKE-DISPATCH-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("#"), CL["T"].bound, CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL["SET-DISPATCH-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("#"), LCL['CL-LIB']['MAKE-CHAR']("'"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["CHAR"],{CL_LIB["N"],n}}},function (l1, l2, l3,  ...)   single_value();  return CL["LIST"](l(CL["FUNCTION"],CL["READ"](l1, CL["T"].bound, n.bound, CL["T"].bound))) end, 3, 0, false, false), CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%READ-CHAR-NAME-OR-CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["&OPTIONAL"],{CL_LIB["TOK"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = n if n ~= l2 then  local l4 = CL["READ-CHAR"](l1, CL["T"].bound, n.bound, CL["T"].bound); single_value();  local l6 = CL_LIB["READTABLE-WHITESPACEP"](l4, false); single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  l7 = CL_LIB["READTABLE-TERMINATINGMACROP"](l4, false) end local l5 = n if n ~= l7 then  i( CL["UNREAD-CHAR"](l4, l1) );
 single_value();  local l8 = n if n ~= CL["EQ"](CL["LENGTH"](l2), 1) then  l8 = CL["CHAR"](l2, 0) else  l8 = CL["NAME-CHAR"](l2) end l5 = l8 else  l5 = CL_LIB["%READ-CHAR-NAME-OR-CHAR"](l1, CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l2, CL_LIB["CHAR-STRING"](l4), })) end l3 = l5 else  l3 = CL_LIB["%READ-CHAR-NAME-OR-CHAR"](l1, CL_LIB["CHAR-STRING"](CL["READ-CHAR"](l1, CL["T"].bound, n.bound, CL["T"].bound))) end return l3 end, 1, 1, false, false)); tmp = CL["SET-DISPATCH-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("#"), LCL['CL-LIB']['MAKE-CHAR']("\\"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["CHAR"],{CL_LIB["N"],n}}},function (l1, l2, l3,  ...)   single_value();  return CL_LIB["%READ-CHAR-NAME-OR-CHAR"](l1, false) end, 3, 0, false, false), CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL["SET-DISPATCH-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("#"), LCL['CL-LIB']['MAKE-CHAR']("("), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["UNUSED-CHAR"],{CL_LIB["N"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL["READ-DELIMITED-LIST"](LCL['CL-LIB']['MAKE-CHAR'](")"), l1, CL["T"].bound); single_value();  return CL["CONS"](CL["VECTOR"], CL["APPEND"](l(l4,n))) end, 3, 0, false, false), CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL["SET-DISPATCH-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("#"), LCL['CL-LIB']['MAKE-CHAR']("C"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["UNUSED-CHAR"],{CL_LIB["N"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL["READ"](l1, CL["T"].bound, n.bound, CL["T"].bound); single_value();  local l6 = n if n ~= CL["LISTP"](l4) then  l6 = CL["EQ"](2, CL["LENGTH"](l4)) else  l6 = n.bound end local l5 = n if n ~= l6 then  l5 = CL["EVAL"](CL["CONS"](CL["COMPLEX"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["FIRST"](l4), n)), CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["SECOND"](l4), n)), n)))) else  l5 = CL["ERROR"]("#C argument is not a list of length 2", l()) end return l5 end, 3, 0, false, false), CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL["SET-DISPATCH-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("#"), LCL['CL-LIB']['MAKE-CHAR']("P"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["UNUSED-CHAR"],{CL_LIB["N"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL["READ"](l1, CL["T"].bound, n.bound, CL["T"].bound); single_value();  local l5 = n if n ~= CL["STRINGP"](l4) then  l5 = CL["EVAL"](CL["CONS"](CL["PARSE-NAMESTRING"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l4, n)), n))) else  l5 = CL["ERROR"]("#P argument is not a string", l()) end return l5 end, 3, 0, false, false), CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL["SET-DISPATCH-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("#"), LCL['CL-LIB']['MAKE-CHAR']("."), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["CHAR"],{CL_LIB["N"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = n if n ~= CL["*READ-SUPPRESS*"].bound then  l4 = n.bound else  single_value();  local l5 = n if n ~= CL["*READ-EVAL*"].bound then  l5 = CL["EVAL"](CL["READ"](l1, CL["T"].bound, n.bound, CL["T"].bound)) else  l5 = CL["ERROR"]("Can't run #\\. when *read-eval* is nil", l()) end l4 = l5 end return l4 end, 3, 0, false, false), CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%INTERPRET-FEATURE-EXPRESSION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FEXP"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["*READ-SUPPRESS*"].bound then  single_value();  l2 = n.bound else  local l3 = n if n ~= CL["SYMBOLP"](l1) then  single_value();  l3 = CL["MEMBER"](CL["INTERN"](CL["SYMBOL-NAME"](l1), LCL["KEYWORD"]["KEYWORD"]), CL["*FEATURES*"].bound, k()) else  local l4 = n if n ~= CL["NOT"](CL["LISTP"](l1)) then  single_value();  l4 = CL["ERROR"]("Invalid feature expression ~S", l(l1)) else  local l5 = n if n ~= CL["EQ"]((l1)[1], CL["NOT"]) then  single_value();  l5 = CL["NOT"](CL_LIB["%INTERPRET-FEATURE-EXPRESSION"](l1)) else  local l6 = n if n ~= CL["EQ"]((l1)[1], CL["AND"]) then  single_value();  l6 = CL["EVERY"](CL_LIB["%INTERPRET-FEATURE-EXPRESSION"].fbound, l((l1)[2])) else  local l7 = n if n ~= CL["EQ"]((l1)[1], CL["OR"]) then  single_value();  l7 = CL["SOME"](CL_LIB["%INTERPRET-FEATURE-EXPRESSION"].fbound, l((l1)[2])) else  local l8 = n if n ~= CL["T"].bound then  single_value();  l8 = CL["ERROR"]("Invalid feature expression ~S", l(l1)) else  l8 = n.bound end l7 = l8 end l6 = l7 end l5 = l6 end l4 = l5 end l3 = l4 end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL["SET-DISPATCH-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("#"), LCL['CL-LIB']['MAKE-CHAR']("+"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["CHAR"],{CL_LIB["N"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = n if n ~= CL_LIB["%INTERPRET-FEATURE-EXPRESSION"](CL["READ"](l1, CL["T"].bound, n.bound, CL["T"].bound)) then  l4 = CL["READ"](l1, CL["T"].bound, n.bound, CL["T"].bound) else  local l5 = CL["*READ-SUPPRESS*"].bound; single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l8 = CL["*READ-SUPPRESS*"].bound; CL["*READ-SUPPRESS*"].bound = CL["T"].bound i( CL["*READ-SUPPRESS*"].bound );
 single_value();  local l7 = l8; single_value();  i( CL["READ"](l1, CL["T"].bound, n.bound, CL["T"].bound) );
 single_value();  return CL["VALUES"](l()) end, 0, 0, false, false))); CL["*READ-SUPPRESS*"].bound = l5 i( CL["*READ-SUPPRESS*"].bound );
 single_value(); if l6.error ~= n and true then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end l4 = CL["VALUES-LIST"](list_r(l6)) end return l4 end, 3, 0, false, false), CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL["SET-DISPATCH-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("#"), LCL['CL-LIB']['MAKE-CHAR']("-"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["CHAR"],{CL_LIB["N"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = n if n ~= CL["NOT"](CL_LIB["%INTERPRET-FEATURE-EXPRESSION"](CL["READ"](l1, CL["T"].bound, n.bound, CL["T"].bound))) then  l4 = CL["READ"](l1, CL["T"].bound, n.bound, CL["T"].bound) else  local l5 = CL["*READ-SUPPRESS*"].bound; single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l8 = CL["*READ-SUPPRESS*"].bound; CL["*READ-SUPPRESS*"].bound = CL["T"].bound i( CL["*READ-SUPPRESS*"].bound );
 single_value();  local l7 = l8; single_value();  i( CL["READ"](l1, CL["T"].bound, n.bound, CL["T"].bound) );
 single_value();  return CL["VALUES"](l()) end, 0, 0, false, false))); CL["*READ-SUPPRESS*"].bound = l5 i( CL["*READ-SUPPRESS*"].bound );
 single_value(); if l6.error ~= n and true then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end l4 = CL["VALUES-LIST"](list_r(l6)) end return l4 end, 3, 0, false, false), CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["READ-NUMBER-IN-BASE"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["N"],n}},function (l1, l2,  ...)   single_value();  return CL_LIB["%READ-TOKEN"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NAME"],n},function (l3,  ...)   single_value();  return CL_LIB["READ-NUMBER"](l3, l2, CL["T"].bound, false) end, 1, 0, false, false), l1, "", false) end, 2, 0, false, false)); tmp = CL["SET-DISPATCH-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("#"), LCL['CL-LIB']['MAKE-CHAR']("b"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["CHAR"],{CL_LIB["N"],n}}},function (l1, l2, l3,  ...)   single_value();  return CL_LIB["READ-NUMBER-IN-BASE"](l1, 2) end, 3, 0, false, false), CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL["SET-DISPATCH-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("#"), LCL['CL-LIB']['MAKE-CHAR']("o"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["CHAR"],{CL_LIB["N"],n}}},function (l1, l2, l3,  ...)   single_value();  return CL_LIB["READ-NUMBER-IN-BASE"](l1, 8) end, 3, 0, false, false), CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL["SET-DISPATCH-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("#"), LCL['CL-LIB']['MAKE-CHAR']("x"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["CHAR"],{CL_LIB["N"],n}}},function (l1, l2, l3,  ...)   single_value();  return CL_LIB["READ-NUMBER-IN-BASE"](l1, 16) end, 3, 0, false, false), CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL["SET-DISPATCH-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("#"), LCL['CL-LIB']['MAKE-CHAR']("r"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["CHAR"],{CL_LIB["N"],n}}},function (l1, l2, l3,  ...)   single_value();  return CL_LIB["READ-NUMBER-IN-BASE"](l1, l3) end, 3, 0, false, false), CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL["SET-DISPATCH-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("#"), LCL['CL-LIB']['MAKE-CHAR'](":"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["CHAR"],{CL_LIB["N"],n}}},function (l1, l2, l3,  ...)   single_value();  return CL_LIB["%READ-TOKEN"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NAME"],n},function (l4,  ...)   single_value();  return CL_LIB['ALLOC-SYMBOL'](n.bound,l4) end, 1, 0, false, false), l1, "", false) end, 3, 0, false, false), CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL["SET-DISPATCH-MACRO-CHARACTER"](LCL['CL-LIB']['MAKE-CHAR']("#"), LCL['CL-LIB']['MAKE-CHAR']("|"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["CHAR"],{CL_LIB["N"],n}}},function (l1, l2, l3,  ...)   local l4 = 1; single_value();  local l5 = CL["READ-CHAR"](l1, CL["T"].bound, n.bound, CL["T"].bound); local l6 = CL["READ-CHAR"](l1, CL["T"].bound, n.bound, CL["T"].bound); single_value();  local l7 = CL["GENSYM"](false); single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  local l9 = n if n ~= CL["EQ"](l4, 0) then  single_value(); do break end; l9 = n.bound else  l9 = n.bound end i( l9 );
 local l11 = n if n ~= CL["CHAR="](l5, l(LCL['CL-LIB']['MAKE-CHAR']("#"))) then  l11 = CL["CHAR="](l6, l(LCL['CL-LIB']['MAKE-CHAR']("|"))) else  l11 = n.bound end local l10 = n if n ~= l11 then  single_value();  single_value();  local l12 = (1 + l4); single_value();  l4 = l12 l10 = l4 else  l10 = n.bound end i( l10 );
 local l14 = n if n ~= CL["CHAR="](l5, l(LCL['CL-LIB']['MAKE-CHAR']("|"))) then  l14 = CL["CHAR="](l6, l(LCL['CL-LIB']['MAKE-CHAR']("#"))) else  l14 = n.bound end local l13 = n if n ~= l14 then  single_value();  local l15 = (-1 + l4); single_value();  l4 = l15 i( l4 );
 single_value();  local l16 = n if n ~= CL["EQ"](l4, 0) then  local l17 = CL["FUNCALL"](l, l(unpack_mv(CL["VALUES"](l())))); single_value();  l16 = error({tag=CL["IDENTITY"](l7),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l17)) end)()}) else  l16 = n.bound end l13 = l16 else  l13 = n.bound end i( l13 );
 single_value();  local l18 = l6; local l19 = CL["READ-CHAR"](l1, CL["T"].bound, n.bound, CL["T"].bound); single_value();  single_value();  local l20 = l19; single_value();  l6 = l20 i( l6 );
 single_value();  single_value();  single_value();  local l21 = l18; single_value();  l5 = l21 local tmpres = l5 end return n end, 0, 0, false, false))); single_value(); if l8.error ~= n and (l8.error ~= KEYWORD.TAG or l8.tag ~= l7) then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  return CL["VALUES"](l()) end, 3, 0, false, false), CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound); tmp = CL_LIB["MACRO-SETQ"](CL["WITH-STANDARD-IO-SYNTAX"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G125643"],{CL["&OPTIONAL"],{LCL["NIL"]["G125644"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  return CL["CONS"](CL["PROGN"], CL["APPEND"](l(l5,n))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SET-SYNTAX-FROM-CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["TO-CHAR"],{CL_LIB["FROM-CHAR"],{CL["&OPTIONAL"],{{CL_LIB["TO-READTABLE"],{CL["*READTABLE*"],n}},{CL_LIB["FROM-READTABLE"],n}}}}},function (l1, l2, l3, l4,  ...)  if not l3 then  l3 = CL["*READTABLE*"].bound end if not l4 then  l4 = n.bound end  single_value();  return n.bound end, 2, 2, false, false)); CL["*READTABLE*"].bound = CL["COPY-READTABLE"](CL_LIB["*STANDARD-SYNTAX-READTABLE*"].bound) tmp = CL["*READTABLE*"].bound; tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*PRINT-READABLY*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*PRINT-RADIX*"],l1); local l1 = 10; single_value();  tmp = CL_LIB.DEF(CL["*PRINT-BASE*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*PRINT-CIRCLE*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*PRINT-PRETTY*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*PRINT-LEVEL*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*PRINT-LINES*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*PRINT-LENGTH*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*PRINT-MISER-WIDTH*"],l1); local l1 = LCL["KEYWORD"]["UPCASE"]; single_value();  tmp = CL_LIB.DEF(CL["*PRINT-CASE*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*PRINT-PPRINT-DISPATCH*"],l1); local l1 = CL["T"].bound; single_value();  tmp = CL_LIB.DEF(CL["*PRINT-GENSYM*"],l1); local l1 = CL["T"].bound; single_value();  tmp = CL_LIB.DEF(CL["*PRINT-ESCAPE*"],l1); local l1 = CL["T"].bound; single_value();  tmp = CL_LIB.DEF(CL["*PRINT-ARRAY*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*PRINT-RIGHT-MARGIN*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%PRINT-OBJECT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],{CL["STREAM"],n}},function (l1, l2,  ...)   single_value();  return n.bound end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PRINT-OBJECT"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL["REST"],n}},function (l1,  ...)   i( CL_LIB["%PRINT-OBJECT"](CL["FIRST"](l1), CL["SECOND"](l1)) );
 single_value();  return CL["FIRST"](l1) end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["PRINT-SYMBOL-NAME"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["EQ"](CL["SYMBOL-PACKAGE"](LCL["KEYWORD"]["KEYWORD"]), CL["SYMBOL-PACKAGE"](l1)) then  l2 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {":", CL["SYMBOL-NAME"](l1), }) else  l2 = CL["SYMBOL-NAME"](l1) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["PRINT-APPLY-CASE"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL["&OPTIONAL"],{{CL_LIB["PRINT-CASE"],{CL["*PRINT-CASE*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*PRINT-CASE*"].bound end  single_value();  return l1 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%PRINT-LUA-TABLE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],{CL["&OPTIONAL"],{{CL["STREAM"],{CL["*STANDARD-OUTPUT*"],n}},{CL["&AUX"],{CL_LIB["F"],n}}}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*STANDARD-OUTPUT*"].bound end l3 = n.bound  i( CL["WRITE-STRING"]("#<{", l2, k()) );
 for __k, __v in pairs(l1) do  local l4 = __k; local l5 = __v; local l6 = n if n ~= l3 then  single_value();  l6 = CL["WRITE-STRING"](", ", l2, k()) else  l6 = n.bound end i( l6 );
 l3 = CL["T"].bound i( l3 );
 i( CL["PRINT-OBJECT"](l(l4,l2)) );
 i( CL["WRITE-STRING"](" = ", l2, k()) );
 single_value();  local tmpres = CL["PRINT-OBJECT"](l(l5,l2)) end i( n );
 i( CL["WRITE-STRING"]("}>", l2, k()) );
 single_value();  return l1 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%PRINT-STRING-ESCAPE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],{CL["STREAM"],n}},function (l1, l2,  ...)   i( CL["WRITE-STRING"]("\"", l2, k()) );
 local l3 = 0; single_value();  local l4 = CL["GENSYM"](false); single_value();  local l5 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l6 = n if n ~= CL[">="](l(l3,CL["LENGTH"](l1))) then  single_value(); do break end; l6 = n.bound else  l6 = n.bound end i( l6 );
 local l7 = CL["CHAR"](l1, l3); local l9 = CL["EQ"](LCL['CL-LIB']['MAKE-CHAR']("\""), l7); single_value();  local l10 = n if n ~= l9 then  l10 = l9 else  l10 = CL_LIB["READTABLE-SINGLEESCAPEP"](l7, false) end local l8 = n if n ~= l10 then  single_value();  l8 = CL["WRITE-STRING"]("\\", l2, k()) else  l8 = n.bound end i( l8 );
 single_value();  i( CL["WRITE-CHAR"](l7, l2) );
 single_value();  local l11 = (1 + l3); single_value();  single_value();  single_value();  local l12 = l11; single_value();  l3 = l12 local tmpres = l3 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l5.error ~= n and (l5.error ~= KEYWORD.TAG or l5.tag ~= l4) then if l5.error == KEYWORD.TAG then  error(l5) else error(l5[1]) end end i( CL["VALUES-LIST"](list_r(l5)) );
 single_value();  return CL["WRITE-STRING"]("\"", l2, k()) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%PRINT-INT-RADIX"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],{CL["STREAM"],{CL["&OPTIONAL"],{{CL_LIB["RADIX"],{CL["*PRINT-BASE*"],n}},n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = CL["*PRINT-BASE*"].bound end  local l4 = n if n ~= CL["*PRINT-RADIX*"].bound then  single_value();  local l5 = l3; single_value();  local l6 = n if n ~= CL["EQL"](l5, 10) then  single_value();  l6 = n.bound else  local l7 = n if n ~= CL["EQL"](l5, 2) then  single_value();  l7 = CL["WRITE-STRING"]("#b", l2, k()) else  local l8 = n if n ~= CL["EQL"](l5, 8) then  single_value();  l8 = CL["WRITE-STRING"]("#o", l2, k()) else  local l9 = n if n ~= CL["EQL"](l5, 16) then  single_value();  l9 = CL["WRITE-STRING"]("#x", l2, k()) else  local l10 = n if n ~= CL["T"].bound then  i( CL["WRITE-STRING"]("#", l2, k()) );
 i( CL["WRITE-STRING"](CL_LIB["TOSTRING"](l3), l2, k()) );
 single_value();  l10 = CL["WRITE-STRING"]("r", l2, k()) else  l10 = n.bound end l9 = l10 end l8 = l9 end l7 = l8 end l6 = l7 end l4 = l6 else  l4 = n.bound end i( l4 );
 local l11 = n if n ~= CL["EQ"](l3, 10) then  l11 = CL["WRITE-STRING"](CL_LIB["TOSTRING"](l1), l2, k()) else  local l12 = n if n ~= CL["EQ"](0, l1) then  l12 = CL["WRITE-STRING"]("0", l2, k()) else  local l13 = ""; while true do  local l14 = n if n ~= CL["EQ"](0, l1) then do break end; l14 = n.bound else  l14 = n.bound end i( l14 );
 single_value();  local l15 = n.bound; local l16 = n.bound; local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l18 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l20 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l19 = l20; single_value();  single_value();  l15,l16= unpack_mv(CL["FLOOR"](l1, l3), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l17 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l18.error ~= n and true then if l18.error == KEYWORD.TAG then  error(l18) else error(l18[1]) end end i( CL["VALUES-LIST"](list_r(l18)) );
 l13 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL_LIB["CHAR-STRING"](CL["DIGIT-CHAR"](l16, l3)), l13, }) i( l13 );
 single_value();  l1 = l15 local tmpres = l1 end i( n );
 single_value();  l12 = CL["WRITE-STRING"](l13, l2, k()) end l11 = l12 end i( l11 );
 local l22 = n if n ~= CL["*PRINT-RADIX*"].bound then  l22 = CL["EQ"](10, l3) else  l22 = n.bound end local l21 = n if n ~= l22 then  single_value();  l21 = CL["WRITE-STRING"](".", l2, k()) else  l21 = n.bound end i( l21 );
 single_value();  return l1 end, 2, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%PRINT-OBJECT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],{CL["STREAM"],n}},function (l1, l2,  ...)   single_value();  local l4 = CL["*PRINT-READABLY*"].bound; single_value();  local l5 = n if n ~= l4 then  l5 = l4 else  l5 = CL["*PRINT-ESCAPE*"].bound end local l3 = l5; single_value();  local l6 = l1; single_value();  local l7 = n if n ~= CL["TYPEP"](l6, CL["INTEGER"], false) then  single_value();  l7 = CL_LIB["%PRINT-INT-RADIX"](l1, l2, false) else  local l8 = n if n ~= CL["TYPEP"](l6, CL["RATIO"], false) then  i( CL["PRINT-OBJECT"](l(CL["NUMERATOR"](l1),l2)) );
 i( CL["WRITE-STRING"]("/", l2, k()) );
 single_value();  l8 = CL["PRINT-OBJECT"](l(CL["DENOMINATOR"](l1),l2)) else  local l9 = n if n ~= CL["TYPEP"](l6, CL["FLOAT"], false) then  single_value();  l9 = CL["WRITE-STRING"](CL_LIB["TOSTRING"](l1), l2, k()) else  local l10 = n if n ~= CL["TYPEP"](l6, CL["COMPLEX"], false) then  i( CL["WRITE-STRING"]("#C(", l2, k()) );
 i( CL["PRINT-OBJECT"](l(CL["REALPART"](l1),l2)) );
 i( CL["WRITE-STRING"](" ", l2, k()) );
 i( CL["PRINT-OBJECT"](l(CL["IMAGPART"](l1),l2)) );
 single_value();  l10 = CL["WRITE-STRING"](")", l2, k()) else  local l11 = n if n ~= CL["TYPEP"](l6, CL["CHARACTER"], false) then  single_value();  local l12 = n if n ~= l3 then  i( CL["WRITE-STRING"]("#\\", l2, k()) );
 single_value();  local l13 = n if n ~= CL_LIB["READTABLE-CONSTITUENTP"](l1, false) then  l13 = CL["WRITE-CHAR"](l1, l2) else  l13 = CL["WRITE-STRING"](CL["CHAR-NAME"](l1), l2, k()) end l12 = l13 else  l12 = CL["WRITE-CHAR"](l1, l2) end l11 = l12 else  local l14 = n if n ~= CL["TYPEP"](l6, CL["SYMBOL"], false) then  single_value();  l14 = CL["WRITE-STRING"](CL_LIB["PRINT-SYMBOL-NAME"](l1), l2, k()) else  local l15 = n if n ~= CL["TYPEP"](l6, CL_LIB["NATIVE-STRING"], false) then  single_value();  local l16 = n if n ~= l3 then  l16 = CL_LIB["%PRINT-STRING-ESCAPE"](l1, l2) else  l16 = CL["WRITE-STRING"](l1, l2, k()) end l15 = l16 else  local l17 = n if n ~= CL["TYPEP"](l6, CL["STRING"], false) then  single_value();  l17 = CL_LIB["%PRINT-OBJECT"](CL_LIB["%LUA-STRING"](l1), l2) else  local l18 = n if n ~= CL["TYPEP"](l6, CL["CONS"], false) then  single_value();  local l19 = n if n ~= CL_LIB["%CONSP"](l1) then  i( CL["WRITE-STRING"]("(", l2, k()) );
 local l20 = l1; single_value();  while true do  i( CL["PRINT-OBJECT"](l((l20)[1],l2)) );
 single_value();  local l21 = n if n ~= CL["CONSP"]((l20)[2]) then  single_value();  l20 = (l20)[2] i( l20 );
 single_value();  l21 = CL["WRITE-STRING"](" ", l2, k()) else  local l22 = n if n ~= CL["NULL"]((l20)[2]) then  single_value(); do break end; l22 = n.bound else  local l23 = n if n ~= CL["T"].bound then  i( CL["WRITE-STRING"](" . ", l2, k()) );
 i( CL["PRINT-OBJECT"](l((l20)[2],l2)) );
 single_value(); do break end; l23 = n.bound else  l23 = n.bound end l22 = l23 end l21 = l22 end local tmpres = l21 end i( n );
 single_value();  l19 = CL["WRITE-STRING"](")", l2, k()) else  l19 = CL_LIB["%PRINT-LUA-TABLE"](l1, l2) end l18 = l19 else  local l24 = n if n ~= CL["TYPEP"](l6, CL["VECTOR"], false) then  single_value();  local l25 = n if n ~= CL["*PRINT-ARRAY*"].bound then  i( CL["WRITE-STRING"]("#(", l2, k()) );
 local l26 = 0; single_value();  local l27 = CL["GENSYM"](false); single_value();  local l28 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l29 = n if n ~= CL[">="](l(l26,CL["LENGTH"](l1))) then  single_value(); do break end; l29 = n.bound else  l29 = n.bound end i( l29 );
 local l30 = n if n ~= CL[">"](l(l26,0)) then  l30 = CL["WRITE-STRING"](" ", l2, k()) else  l30 = n.bound end i( l30 );
 i( CL["PRINT-OBJECT"](l(CL["AREF"](l1, l(l26)),l2)) );
 single_value();  local l31 = (1 + l26); single_value();  single_value();  single_value();  local l32 = l31; single_value();  l26 = l32 local tmpres = l26 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l28.error ~= n and (l28.error ~= KEYWORD.TAG or l28.tag ~= l27) then if l28.error == KEYWORD.TAG then  error(l28) else error(l28[1]) end end i( CL["VALUES-LIST"](list_r(l28)) );
 single_value();  l25 = CL["WRITE-STRING"](")", l2, k()) else  i( CL["WRITE-STRING"]("#<ARRAY (", l2, k()) );
 i( CL["PRINT-OBJECT"](l(CL["LENGTH"](l1),l2)) );
 single_value();  l25 = CL["WRITE-STRING"](">", l2, k()) end l24 = l25 else  local l33 = n if n ~= CL["TYPEP"](l6, CL["ARRAY"], false) then  single_value();  local l34 = n if n ~= CL["*PRINT-ARRAY*"].bound then  i( CL["WRITE-STRING"]("#", l2, k()) );
 i( CL["WRITE-STRING"](CL_LIB["TOSTRING"](CL["ARRAY-RANK"](l1)), l2, k()) );
 single_value();  l34 = CL["WRITE-STRING"]("A(...)", l2, k()) else  i( CL["WRITE-STRING"]("#<ARRAY (", l2, k()) );
 i( CL["PRINT-OBJECT"](l(CL["ARRAY-DIMENSIONS"](l1),l2)) );
 single_value();  l34 = CL["WRITE-STRING"](">", l2, k()) end l33 = l34 else  local l35 = n if n ~= CL["TYPEP"](l6, CL["PATHNAME"], false) then  i( CL["WRITE-STRING"]("#P", l2, k()) );
 single_value();  l35 = CL_LIB["%PRINT-STRING-ESCAPE"](CL["NAMESTRING"](l1), l2) else  local l36 = n if n ~= CL["TYPEP"](l6, CL["STRUCTURE-OBJECT"], false) then  single_value();  l36 = CL_LIB["FUNCALL-LUA"]( CL_LIB["WRITE-STRUCT-TOSTRING"].fbound, {l1, l2, }) else  local l37 = n if n ~= CL["TYPEP"](l6, CL["T"], false) then  i( CL["WRITE-STRING"]("#<", l2, k()) );
 i( CL["WRITE-STRING"](CL_LIB["TOSTRING"](l1), l2, k()) );
 single_value();  l37 = CL["WRITE-STRING"](">", l2, k()) else  l37 = n.bound end l36 = l37 end l35 = l36 end l33 = l35 end l24 = l33 end l18 = l24 end l17 = l18 end l15 = l17 end l14 = l15 end l11 = l14 end l10 = l11 end l9 = l10 end l8 = l9 end l7 = l8 end return l7 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["WRITE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],{CL["&KEY"],{{CL["ARRAY"],{n,{CL["ARRAYP"],n}}},{{CL_LIB["BASE"],{n,{CL_LIB["BASEP"],n}}},{{CL["CASE"],{n,{CL_LIB["CASEP"],n}}},{{CL_LIB["CIRCLE"],{n,{CL_LIB["CIRCLEP"],n}}},{{CL_LIB["ESCAPE"],{n,{CL_LIB["ESCAPEP"],n}}},{{CL["GENSYM"],{n,{CL_LIB["GENSYMP"],n}}},{{CL["LENGTH"],{n,{CL_LIB["LENGTHP"],n}}},{{CL_LIB["LEVEL"],{n,{CL_LIB["LEVELP"],n}}},{{CL_LIB["LINES"],{n,{CL_LIB["LINESP"],n}}},{{CL_LIB["MISER-WIDTH"],{n,{CL_LIB["WIDTHP"],n}}},{{CL["PPRINT-DISPATCH"],{n,{CL_LIB["DISPATCHP"],n}}},{{CL_LIB["PRETTY"],{n,{CL_LIB["PRETTYP"],n}}},{{CL_LIB["RADIX"],{n,{CL_LIB["RADIXP"],n}}},{{CL_LIB["READABLY"],{n,{CL_LIB["READABLYP"],n}}},{{CL_LIB["RIGHT-MARGIN"],{n,{CL_LIB["MARGINP"],n}}},{{CL["STREAM"],{CL["*STANDARD-OUTPUT*"],n}},n}}}}}}}}}}}}}}}}}},function (l1, keys,  ...)  local l2 = keys[CL["ARRAY"]] and CL.T or n if not keys[CL["ARRAY"]] then  keys[CL["ARRAY"]] = n.bound end local l3 = keys[CL_LIB["BASE"]] and CL.T or n if not keys[CL_LIB["BASE"]] then  keys[CL_LIB["BASE"]] = n.bound end local l4 = keys[CL["CASE"]] and CL.T or n if not keys[CL["CASE"]] then  keys[CL["CASE"]] = n.bound end local l5 = keys[CL_LIB["CIRCLE"]] and CL.T or n if not keys[CL_LIB["CIRCLE"]] then  keys[CL_LIB["CIRCLE"]] = n.bound end local l6 = keys[CL_LIB["ESCAPE"]] and CL.T or n if not keys[CL_LIB["ESCAPE"]] then  keys[CL_LIB["ESCAPE"]] = n.bound end local l7 = keys[CL["GENSYM"]] and CL.T or n if not keys[CL["GENSYM"]] then  keys[CL["GENSYM"]] = n.bound end local l8 = keys[CL["LENGTH"]] and CL.T or n if not keys[CL["LENGTH"]] then  keys[CL["LENGTH"]] = n.bound end local l9 = keys[CL_LIB["LEVEL"]] and CL.T or n if not keys[CL_LIB["LEVEL"]] then  keys[CL_LIB["LEVEL"]] = n.bound end local l10 = keys[CL_LIB["LINES"]] and CL.T or n if not keys[CL_LIB["LINES"]] then  keys[CL_LIB["LINES"]] = n.bound end local l11 = keys[CL_LIB["MISER-WIDTH"]] and CL.T or n if not keys[CL_LIB["MISER-WIDTH"]] then  keys[CL_LIB["MISER-WIDTH"]] = n.bound end local l12 = keys[CL["PPRINT-DISPATCH"]] and CL.T or n if not keys[CL["PPRINT-DISPATCH"]] then  keys[CL["PPRINT-DISPATCH"]] = n.bound end local l13 = keys[CL_LIB["PRETTY"]] and CL.T or n if not keys[CL_LIB["PRETTY"]] then  keys[CL_LIB["PRETTY"]] = n.bound end local l14 = keys[CL_LIB["RADIX"]] and CL.T or n if not keys[CL_LIB["RADIX"]] then  keys[CL_LIB["RADIX"]] = n.bound end local l15 = keys[CL_LIB["READABLY"]] and CL.T or n if not keys[CL_LIB["READABLY"]] then  keys[CL_LIB["READABLY"]] = n.bound end local l16 = keys[CL_LIB["RIGHT-MARGIN"]] and CL.T or n if not keys[CL_LIB["RIGHT-MARGIN"]] then  keys[CL_LIB["RIGHT-MARGIN"]] = n.bound end if not keys[CL["STREAM"]] then  keys[CL["STREAM"]] = CL["*STANDARD-OUTPUT*"].bound end  single_value();  local l17 = CL["*PRINT-ARRAY*"].bound; local l18 = CL["*PRINT-BASE*"].bound; local l19 = CL["*PRINT-CASE*"].bound; local l20 = CL["*PRINT-CIRCLE*"].bound; local l21 = CL["*PRINT-ESCAPE*"].bound; local l22 = CL["*PRINT-GENSYM*"].bound; local l23 = CL["*PRINT-LENGTH*"].bound; local l24 = CL["*PRINT-LEVEL*"].bound; local l25 = CL["*PRINT-LINES*"].bound; local l26 = CL["*PRINT-MISER-WIDTH*"].bound; local l27 = CL["*PRINT-PPRINT-DISPATCH*"].bound; local l28 = CL["*PRINT-PRETTY*"].bound; local l29 = CL["*PRINT-RADIX*"].bound; local l30 = CL["*PRINT-READABLY*"].bound; local l31 = CL["*PRINT-RIGHT-MARGIN*"].bound; local l32 = n if n ~= l2 then  CL["*PRINT-ARRAY*"].bound = keys[CL["ARRAY"]] l32 = CL["*PRINT-ARRAY*"].bound else  l32 = n.bound end i( l32 );
 local l33 = n if n ~= l3 then  CL["*PRINT-BASE*"].bound = keys[CL_LIB["BASE"]] l33 = CL["*PRINT-BASE*"].bound else  l33 = n.bound end i( l33 );
 local l34 = n if n ~= l4 then  CL["*PRINT-CASE*"].bound = keys[CL["CASE"]] l34 = CL["*PRINT-CASE*"].bound else  l34 = n.bound end i( l34 );
 local l35 = n if n ~= l5 then  CL["*PRINT-CIRCLE*"].bound = keys[CL_LIB["CIRCLE"]] l35 = CL["*PRINT-CIRCLE*"].bound else  l35 = n.bound end i( l35 );
 local l36 = n if n ~= l6 then  CL["*PRINT-ESCAPE*"].bound = keys[CL_LIB["ESCAPE"]] l36 = CL["*PRINT-ESCAPE*"].bound else  l36 = n.bound end i( l36 );
 local l37 = n if n ~= l7 then  CL["*PRINT-GENSYM*"].bound = keys[CL["GENSYM"]] l37 = CL["*PRINT-GENSYM*"].bound else  l37 = n.bound end i( l37 );
 local l38 = n if n ~= l8 then  CL["*PRINT-LENGTH*"].bound = keys[CL["LENGTH"]] l38 = CL["*PRINT-LENGTH*"].bound else  l38 = n.bound end i( l38 );
 local l39 = n if n ~= l9 then  CL["*PRINT-LEVEL*"].bound = keys[CL_LIB["LEVEL"]] l39 = CL["*PRINT-LEVEL*"].bound else  l39 = n.bound end i( l39 );
 local l40 = n if n ~= l10 then  CL["*PRINT-LINES*"].bound = keys[CL_LIB["LINES"]] l40 = CL["*PRINT-LINES*"].bound else  l40 = n.bound end i( l40 );
 local l41 = n if n ~= l11 then  CL["*PRINT-MISER-WIDTH*"].bound = keys[CL_LIB["MISER-WIDTH"]] l41 = CL["*PRINT-MISER-WIDTH*"].bound else  l41 = n.bound end i( l41 );
 local l42 = n if n ~= l12 then  CL["*PRINT-PPRINT-DISPATCH*"].bound = keys[CL["PPRINT-DISPATCH"]] l42 = CL["*PRINT-PPRINT-DISPATCH*"].bound else  l42 = n.bound end i( l42 );
 local l43 = n if n ~= l13 then  CL["*PRINT-PRETTY*"].bound = keys[CL_LIB["PRETTY"]] l43 = CL["*PRINT-PRETTY*"].bound else  l43 = n.bound end i( l43 );
 local l44 = n if n ~= l14 then  CL["*PRINT-RADIX*"].bound = keys[CL_LIB["RADIX"]] l44 = CL["*PRINT-RADIX*"].bound else  l44 = n.bound end i( l44 );
 local l45 = n if n ~= l15 then  CL["*PRINT-READABLY*"].bound = keys[CL_LIB["READABLY"]] l45 = CL["*PRINT-READABLY*"].bound else  l45 = n.bound end i( l45 );
 local l46 = n if n ~= l16 then  CL["*PRINT-RIGHT-MARGIN*"].bound = keys[CL_LIB["RIGHT-MARGIN"]] l46 = CL["*PRINT-RIGHT-MARGIN*"].bound else  l46 = n.bound end i( l46 );
 single_value();  local l47 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL["PRINT-OBJECT"](l(l1,keys[CL["STREAM"]])) end, 0, 0, false, false))); local l48 = n if n ~= l2 then  CL["*PRINT-ARRAY*"].bound = l17 l48 = CL["*PRINT-ARRAY*"].bound else  l48 = n.bound end i( l48 );
 local l49 = n if n ~= l3 then  CL["*PRINT-BASE*"].bound = l18 l49 = CL["*PRINT-BASE*"].bound else  l49 = n.bound end i( l49 );
 local l50 = n if n ~= l4 then  CL["*PRINT-CASE*"].bound = l19 l50 = CL["*PRINT-CASE*"].bound else  l50 = n.bound end i( l50 );
 local l51 = n if n ~= l5 then  CL["*PRINT-CIRCLE*"].bound = l20 l51 = CL["*PRINT-CIRCLE*"].bound else  l51 = n.bound end i( l51 );
 local l52 = n if n ~= l6 then  CL["*PRINT-ESCAPE*"].bound = l21 l52 = CL["*PRINT-ESCAPE*"].bound else  l52 = n.bound end i( l52 );
 local l53 = n if n ~= l7 then  CL["*PRINT-GENSYM*"].bound = l22 l53 = CL["*PRINT-GENSYM*"].bound else  l53 = n.bound end i( l53 );
 local l54 = n if n ~= l8 then  CL["*PRINT-LENGTH*"].bound = l23 l54 = CL["*PRINT-LENGTH*"].bound else  l54 = n.bound end i( l54 );
 local l55 = n if n ~= l9 then  CL["*PRINT-LEVEL*"].bound = l24 l55 = CL["*PRINT-LEVEL*"].bound else  l55 = n.bound end i( l55 );
 local l56 = n if n ~= l10 then  CL["*PRINT-LINES*"].bound = l25 l56 = CL["*PRINT-LINES*"].bound else  l56 = n.bound end i( l56 );
 local l57 = n if n ~= l11 then  CL["*PRINT-MISER-WIDTH*"].bound = l26 l57 = CL["*PRINT-MISER-WIDTH*"].bound else  l57 = n.bound end i( l57 );
 local l58 = n if n ~= l12 then  CL["*PRINT-PPRINT-DISPATCH*"].bound = l27 l58 = CL["*PRINT-PPRINT-DISPATCH*"].bound else  l58 = n.bound end i( l58 );
 local l59 = n if n ~= l13 then  CL["*PRINT-PRETTY*"].bound = l28 l59 = CL["*PRINT-PRETTY*"].bound else  l59 = n.bound end i( l59 );
 local l60 = n if n ~= l14 then  CL["*PRINT-RADIX*"].bound = l29 l60 = CL["*PRINT-RADIX*"].bound else  l60 = n.bound end i( l60 );
 local l61 = n if n ~= l15 then  CL["*PRINT-READABLY*"].bound = l30 l61 = CL["*PRINT-READABLY*"].bound else  l61 = n.bound end i( l61 );
 local l62 = n if n ~= l16 then  CL["*PRINT-RIGHT-MARGIN*"].bound = l31 l62 = CL["*PRINT-RIGHT-MARGIN*"].bound else  l62 = n.bound end i( l62 );
 single_value(); if l47.error ~= n and true then if l47.error == KEYWORD.TAG then  error(l47) else error(l47[1]) end end return CL["VALUES-LIST"](list_r(l47)) end, 1, 0, false, {0 , [LCL["KEYWORD"]["ARRAY"]] = CL["ARRAY"], [LCL["KEYWORD"]["BASE"]] = CL_LIB["BASE"], [LCL["KEYWORD"]["CASE"]] = CL["CASE"], [LCL["KEYWORD"]["CIRCLE"]] = CL_LIB["CIRCLE"], [LCL["KEYWORD"]["ESCAPE"]] = CL_LIB["ESCAPE"], [LCL["KEYWORD"]["GENSYM"]] = CL["GENSYM"], [LCL["KEYWORD"]["LENGTH"]] = CL["LENGTH"], [LCL["KEYWORD"]["LEVEL"]] = CL_LIB["LEVEL"], [LCL["KEYWORD"]["LINES"]] = CL_LIB["LINES"], [LCL["KEYWORD"]["MISER-WIDTH"]] = CL_LIB["MISER-WIDTH"], [LCL["KEYWORD"]["PPRINT-DISPATCH"]] = CL["PPRINT-DISPATCH"], [LCL["KEYWORD"]["PRETTY"]] = CL_LIB["PRETTY"], [LCL["KEYWORD"]["RADIX"]] = CL_LIB["RADIX"], [LCL["KEYWORD"]["READABLY"]] = CL_LIB["READABLY"], [LCL["KEYWORD"]["RIGHT-MARGIN"]] = CL_LIB["RIGHT-MARGIN"], [LCL["KEYWORD"]["STREAM"]] = CL["STREAM"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["PRIN1"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],{CL["&OPTIONAL"],{{CL_LIB["OUTPUT-STREAM"],{CL["*STANDARD-OUTPUT*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*STANDARD-OUTPUT*"].bound end  single_value();  return CL["WRITE"](l1, k(CL["STREAM"], l2, CL_LIB["ESCAPE"], CL["T"].bound)) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PRINC"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],{CL["&OPTIONAL"],{{CL_LIB["OUTPUT-STREAM"],{CL["*STANDARD-OUTPUT*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*STANDARD-OUTPUT*"].bound end  single_value();  return CL["WRITE"](l1, k(CL["STREAM"], l2, CL_LIB["ESCAPE"], n.bound, CL_LIB["READABLY"], n.bound)) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PRINT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],{CL["&OPTIONAL"],{{CL_LIB["OUTPUT-STREAM"],{CL["*STANDARD-OUTPUT*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*STANDARD-OUTPUT*"].bound end  i( CL["WRITE-STRING"]("\n", l2, k()) );
 i( CL["WRITE"](l1, k(CL["STREAM"], l2)) );
 i( CL["WRITE-STRING"](" ", l2, k()) );
 single_value();  return l1 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PPRINT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],{CL["&OPTIONAL"],{{CL_LIB["OUTPUT-STREAM"],{CL["*STANDARD-OUTPUT*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*STANDARD-OUTPUT*"].bound end  i( CL["WRITE-STRING"]("\n", l2, k()) );
 single_value();  return CL["WRITE"](l1, k(CL["STREAM"], l2, CL_LIB["PRETTY"], CL["T"].bound)) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PRIN1-TO-STRING"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],n},function (l1,  ...)   single_value();  local l2 = CL["MAKE-STRING-OUTPUT-STREAM"](k()); i( CL["PRIN1"](l1, l2) );
 single_value();  return CL["GET-OUTPUT-STREAM-STRING"](l2) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PRINC-TO-STRING"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],n},function (l1,  ...)   single_value();  local l2 = CL["MAKE-STRING-OUTPUT-STREAM"](k()); i( CL["PRINC"](l1, l2) );
 single_value();  return CL["GET-OUTPUT-STREAM-STRING"](l2) end, 1, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["WRITE-TO-STRING"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G128878"],{CL["&OPTIONAL"],{LCL["NIL"]["G128879"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l6, CL["CONS"](CL["CONS"](CL["MAKE-STRING-OUTPUT-STREAM"], n), n)), n), CL["CONS"](CL["CONS"](CL["WRITE"], CL["APPEND"](l(l5,CL["CONS"](LCL["KEYWORD"]["STREAM"], CL["CONS"](l6, n))))), CL["CONS"](CL["CONS"](CL["GET-OUTPUT-STREAM-STRING"], CL["CONS"](l6, n)), n)))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FORMAT"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["FMT"],{CL["&REST"],{CL_LIB["ARGS"],n}}}},function (l1, l2, l3,  ...)   local l4 = n if n ~= CL["EQ"](l1, CL["T"].bound) then  l1 = CL["*STANDARD-OUTPUT*"].bound l4 = l1 else  l4 = n.bound end i( l4 );
 single_value();  local l5 = n if n ~= l1 then  i( CL["WRITE-STRING"](l2, l1, k()) );
 single_value();  local l6 = l3; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = CL["GENSYM"](false); single_value();  local l9 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l10 = n if n ~= CL["NOT"](l6) then  single_value(); do break end; l10 = n.bound else  l10 = n.bound end i( l10 );
 i( CL["WRITE-STRING"](" ", false, k()) );
 i( CL["PRINT-OBJECT"](l(l7,l1)) );
 single_value();  single_value();  local l11 = (l6)[2]; single_value();  l6 = l11 i( l6 );
 single_value();  single_value();  single_value();  local l12 = (l6)[1]; single_value();  l7 = l12 local tmpres = l7 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l9.error ~= n and (l9.error ~= KEYWORD.TAG or l9.tag ~= l8) then if l9.error == KEYWORD.TAG then  error(l9) else error(l9[1]) end end l5 = CL["VALUES-LIST"](list_r(l9)) else  l5 = CL["APPLY"](CL_LIB["CONCAT-STRING"], l2, l(CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["A"],n},function (l13,  ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {" ", CL["PRINC-TO-STRING"](l13), }) end, 1, 0, false, false), l(l3)))) end return l5 end, 2, 0, true, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*COMPILE-FILE-PATHNAME*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*COMPILE-FILE-TRUENAME*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*COMPILE-PRINT*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*COMPILE-VERBOSE*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*LOAD-PATHNAME*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*LOAD-TRUENAME*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*LOAD-PRINT*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*LOAD-VERBOSE*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%WRITE-COMPILE-FORM"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["FORM"],n}},function (l1, l2,  ...)   i( CL["WRITE-STRING"](CL_LIB["COMPILE-TO-LUA"](l2, n.bound, n.bound, "tmp = "), l1, k()) );
 single_value();  return CL["WRITE-STRING"](";", l1, k()) end, 2, 0, false, false)); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL_LIB["*EVAL-WHEN-ENABLE-COMPILE*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL_LIB["*EVAL-WHEN-ENABLE-LOAD*"],l1); tmp = CL_LIB["MACRO-SETQ"](CL["EVAL-WHEN"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G131612"],{CL["&OPTIONAL"],{LCL["NIL"]["G131613"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  local l11 = n if n ~= CL_LIB["*EVAL-WHEN-ENABLE-COMPILE*"].bound then  local l12 = CL["MEMBER"](LCL["KEYWORD"]["COMPILE-TOPLEVEL"], l5, k()); single_value();  local l13 = n if n ~= l12 then  l13 = l12 else  l13 = CL["MEMBER"]("COMPILE", l5, k(CL_LIB["KEY"], CL["SYMBOL-NAME"].fbound)) end l11 = l13 else  l11 = n.bound end local l10 = n if n ~= l11 then  single_value();  local l14 = l9; single_value();  local l15 = (l14)[1]; single_value();  single_value();  local l16 = CL["GENSYM"](false); single_value();  local l17 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l18 = n if n ~= CL["NOT"](l14) then  single_value(); do break end; l18 = n.bound else  l18 = n.bound end i( l18 );
 i( CL["EVAL"](l15) );
 single_value();  single_value();  local l19 = (l14)[2]; single_value();  l14 = l19 i( l14 );
 single_value();  single_value();  single_value();  local l20 = (l14)[1]; single_value();  l15 = l20 local tmpres = l15 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l17.error ~= n and (l17.error ~= KEYWORD.TAG or l17.tag ~= l16) then if l17.error == KEYWORD.TAG then  error(l17) else error(l17[1]) end end l10 = CL["VALUES-LIST"](list_r(l17)) else  l10 = n.bound end i( l10 );
 local l22 = n if n ~= CL_LIB["*EVAL-WHEN-ENABLE-LOAD*"].bound then  local l23 = CL["MEMBER"](LCL["KEYWORD"]["LOAD-TOPLEVEL"], l5, k()); single_value();  local l24 = n if n ~= l23 then  l24 = l23 else  l24 = CL["MEMBER"]("LOAD", l5, k(CL_LIB["KEY"], CL["SYMBOL-NAME"].fbound)) end l22 = l24 else  l22 = n.bound end local l21 = n if n ~= l22 then  single_value();  local l25 = l9; single_value();  local l26 = (l25)[1]; single_value();  single_value();  local l27 = CL["GENSYM"](false); single_value();  local l28 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l29 = n if n ~= CL["NOT"](l25) then  single_value(); do break end; l29 = n.bound else  l29 = n.bound end i( l29 );
 i( CL["EVAL"](l26) );
 single_value();  single_value();  local l30 = (l25)[2]; single_value();  l25 = l30 i( l25 );
 single_value();  single_value();  single_value();  local l31 = (l25)[1]; single_value();  l26 = l31 local tmpres = l26 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l28.error ~= n and (l28.error ~= KEYWORD.TAG or l28.tag ~= l27) then if l28.error == KEYWORD.TAG then  error(l28) else error(l28[1]) end end l21 = CL["VALUES-LIST"](list_r(l28)) else  l21 = n.bound end i( l21 );
 single_value();  local l33 = CL["MEMBER"](LCL["KEYWORD"]["EXECUTE"], l5, k()); single_value();  local l34 = n if n ~= l33 then  l34 = l33 else  l34 = CL["MEMBER"](CL["EVAL"], l5, k()) end local l32 = n if n ~= l34 then  l32 = CL["CONS"](CL["PROGN"], CL["APPEND"](l(l9,n))) else  l32 = n.bound end return l32 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["COMPILE-FILE-PATHNAME"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["INPUT-FILE"],{CL["&KEY"],{CL_LIB["OUTPUT-FILE"],{CL["&ALLOW-OTHER-KEYS"],n}}}},function (l1, keys,  ...)  if not keys[CL_LIB["OUTPUT-FILE"]] then  keys[CL_LIB["OUTPUT-FILE"]] = n.bound end  single_value();  local l2 = keys[CL_LIB["OUTPUT-FILE"]]; single_value();  local l3 = n if n ~= l2 then  l3 = l2 else  l3 = CL["MERGE-PATHNAMES"](CL["MAKE-PATHNAME"](k(CL["TYPE"], "lua")), l1, false) end return l3 end, 1, 0, false, {0 , [LCL["KEYWORD"]["OUTPUT-FILE"]] = CL_LIB["OUTPUT-FILE"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["COMPILE-FILE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["INPUT-FILE"],{CL["&KEY"],{CL_LIB["OUTPUT-FILE"],{{CL_LIB["VERBOSE"],{CL["*COMPILE-VERBOSE*"],n}},{{CL["PRINT"],{CL["*COMPILE-PRINT*"],n}},{CL_LIB["EXTERNAL-FORMAT"],n}}}}}},function (l1, keys,  ...)  if not keys[CL_LIB["OUTPUT-FILE"]] then  keys[CL_LIB["OUTPUT-FILE"]] = n.bound end if not keys[CL_LIB["VERBOSE"]] then  keys[CL_LIB["VERBOSE"]] = CL["*COMPILE-VERBOSE*"].bound end if not keys[CL["PRINT"]] then  keys[CL["PRINT"]] = CL["*COMPILE-PRINT*"].bound end if not keys[CL_LIB["EXTERNAL-FORMAT"]] then  keys[CL_LIB["EXTERNAL-FORMAT"]] = n.bound end  local l2 = n if n ~= keys[CL_LIB["OUTPUT-FILE"]] then  l2 = n.bound else  single_value();  keys[CL_LIB["OUTPUT-FILE"]] = CL["MERGE-PATHNAMES"](CL["MAKE-PATHNAME"](k(CL["TYPE"], "lua")), l1, false) l2 = keys[CL_LIB["OUTPUT-FILE"]] end i( l2 );
 local l3 = n if n ~= CL["STRINGP"](l1) then  l1 = CL["PARSE-NAMESTRING"](l1, false, false, k()) l3 = l1 else  l3 = n.bound end i( l3 );
 single_value();  local l4 = CL["*COMPILE-FILE-PATHNAME*"].bound; local l5 = CL["*COMPILE-FILE-TRUENAME*"].bound; local l6 = CL["*READTABLE*"].bound; local l7 = CL["*PACKAGE*"].bound; CL["*COMPILE-FILE-PATHNAME*"].bound = l1 i( CL["*COMPILE-FILE-PATHNAME*"].bound );
 CL["*COMPILE-FILE-TRUENAME*"].bound = CL["TRUENAME"](l1) i( CL["*COMPILE-FILE-TRUENAME*"].bound );
 local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l9 = CL["GENSYM"](false); single_value();  local l10 = CL["OPEN"](l1, k()); single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  local l12 = CL["OPEN"](keys[CL_LIB["OUTPUT-FILE"]], k(CL_LIB["DIRECTION"], LCL["KEYWORD"]["OUTPUT"])); single_value();  local l13 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  local l14 = CL["READ"](l10, n.bound, l9, false); single_value();  local l15 = CL["GENSYM"](false); single_value();  local l16 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  local l17 = n if n ~= CL["EQ"](l14, l9) then  single_value(); do break end; l17 = n.bound else  l17 = n.bound end i( l17 );
 local l18 = CL_LIB["*EVAL-WHEN-ENABLE-COMPILE*"].bound; single_value();  local l19 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l21 = CL_LIB["*EVAL-WHEN-ENABLE-COMPILE*"].bound; CL_LIB["*EVAL-WHEN-ENABLE-COMPILE*"].bound = CL["T"].bound i( CL_LIB["*EVAL-WHEN-ENABLE-COMPILE*"].bound );
 single_value();  local l20 = l21; single_value();  single_value();  l14 = CL["NTH"](0, CL["FUNCALL"](l, l(unpack_mv(CL["MACROEXPAND"](l14, false))))) return l14 end, 0, 0, false, false))); CL_LIB["*EVAL-WHEN-ENABLE-COMPILE*"].bound = l18 i( CL_LIB["*EVAL-WHEN-ENABLE-COMPILE*"].bound );
 single_value(); if l19.error ~= n and true then if l19.error == KEYWORD.TAG then  error(l19) else error(l19[1]) end end i( CL["VALUES-LIST"](list_r(l19)) );
 i( CL_LIB["%WRITE-COMPILE-FORM"](l12, l14) );
 single_value();  local l22 = CL["READ"](l10, n.bound, l9, false); single_value();  single_value();  single_value();  local l23 = l22; single_value();  l14 = l23 local tmpres = l14 end return n end, 0, 0, false, false))); single_value(); if l16.error ~= n and (l16.error ~= KEYWORD.TAG or l16.tag ~= l15) then if l16.error == KEYWORD.TAG then  error(l16) else error(l16[1]) end end return CL["VALUES-LIST"](list_r(l16)) end, 0, 0, false, false))); i( CL["CLOSE"](l12, k()) );
 single_value(); if l13.error ~= n and true then if l13.error == KEYWORD.TAG then  error(l13) else error(l13[1]) end end return CL["VALUES-LIST"](list_r(l13)) end, 0, 0, false, false))); i( CL["CLOSE"](l10, k()) );
 single_value(); if l11.error ~= n and true then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end return CL["VALUES-LIST"](list_r(l11)) end, 0, 0, false, false))); CL["*COMPILE-FILE-PATHNAME*"].bound = l4 i( CL["*COMPILE-FILE-PATHNAME*"].bound );
 CL["*COMPILE-FILE-TRUENAME*"].bound = l5 i( CL["*COMPILE-FILE-TRUENAME*"].bound );
 CL["*READTABLE*"].bound = l6 i( CL["*READTABLE*"].bound );
 CL["*PACKAGE*"].bound = l7 i( CL["*PACKAGE*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  return CL["TRUENAME"](keys[CL_LIB["OUTPUT-FILE"]]) end, 1, 0, false, {0 , [LCL["KEYWORD"]["OUTPUT-FILE"]] = CL_LIB["OUTPUT-FILE"], [LCL["KEYWORD"]["VERBOSE"]] = CL_LIB["VERBOSE"], [LCL["KEYWORD"]["PRINT"]] = CL["PRINT"], [LCL["KEYWORD"]["EXTERNAL-FORMAT"]] = CL_LIB["EXTERNAL-FORMAT"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["LOAD"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FILESPEC"],{CL["&KEY"],{{CL_LIB["VERBOSE"],{CL["*LOAD-VERBOSE*"],n}},{{CL["PRINT"],{CL["*LOAD-PRINT*"],n}},{CL_LIB["IF-DOES-NOT-EXIST"],{CL_LIB["EXTERNAL-FORMAT"],n}}}}}},function (l1, keys,  ...)  if not keys[CL_LIB["VERBOSE"]] then  keys[CL_LIB["VERBOSE"]] = CL["*LOAD-VERBOSE*"].bound end if not keys[CL["PRINT"]] then  keys[CL["PRINT"]] = CL["*LOAD-PRINT*"].bound end if not keys[CL_LIB["IF-DOES-NOT-EXIST"]] then  keys[CL_LIB["IF-DOES-NOT-EXIST"]] = n.bound end if not keys[CL_LIB["EXTERNAL-FORMAT"]] then  keys[CL_LIB["EXTERNAL-FORMAT"]] = n.bound end  local l2 = n if n ~= CL["STRINGP"](l1) then  l1 = CL["PARSE-NAMESTRING"](l1, false, false, k()) l2 = l1 else  l2 = n.bound end i( l2 );
 single_value();  local l3;l3 = CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l4,  ...)   single_value();  local l5 = CL["GENSYM"](false); single_value();  local l6 = CL["READ"](l4, n.bound, l5, false); single_value();  local l7 = CL["GENSYM"](false); single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  local l9 = n if n ~= CL["EQ"](l5, l6) then  single_value(); do break end; l9 = n.bound else  l9 = n.bound end i( l9 );
 local l10 = CL_LIB["*EVAL-WHEN-ENABLE-LOAD*"].bound; single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l13 = CL_LIB["*EVAL-WHEN-ENABLE-LOAD*"].bound; CL_LIB["*EVAL-WHEN-ENABLE-LOAD*"].bound = CL["T"].bound i( CL_LIB["*EVAL-WHEN-ENABLE-LOAD*"].bound );
 single_value();  local l12 = l13; single_value();  single_value();  l6 = CL["NTH"](0, CL["FUNCALL"](l, l(unpack_mv(CL["MACROEXPAND"](l6, false))))) return l6 end, 0, 0, false, false))); CL_LIB["*EVAL-WHEN-ENABLE-LOAD*"].bound = l10 i( CL_LIB["*EVAL-WHEN-ENABLE-LOAD*"].bound );
 single_value(); if l11.error ~= n and true then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end i( CL["VALUES-LIST"](list_r(l11)) );
 i( CL["EVAL"](l6) );
 single_value();  local l14 = CL["READ"](l4, n.bound, l5, false); single_value();  single_value();  single_value();  local l15 = l14; single_value();  l6 = l15 local tmpres = l6 end return n end, 0, 0, false, false))); single_value(); if l8.error ~= n and (l8.error ~= KEYWORD.TAG or l8.tag ~= l7) then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end return CL["VALUES-LIST"](list_r(l8)) end, 1, 0, false, false); single_value();  local l16 = CL["*READTABLE*"].bound; local l17 = CL["*PACKAGE*"].bound; local l18 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l19 = l1; single_value();  local l20 = n if n ~= CL["TYPEP"](l19, CL["PATHNAME"], false) then  single_value();  local l21 = CL["*LOAD-PATHNAME*"].bound; local l22 = CL["*LOAD-TRUENAME*"].bound; CL["*LOAD-PATHNAME*"].bound = l1 i( CL["*LOAD-PATHNAME*"].bound );
 CL["*LOAD-TRUENAME*"].bound = CL["TRUENAME"](l1) i( CL["*LOAD-TRUENAME*"].bound );
 local l23 = n if n ~= CL["STRING="]("lua", l(CL["PATHNAME-TYPE"](l1))) then  l23 = dofile(CL["NAMESTRING"](l1)) else  local l24 = CL["OPEN"](l1, k()); single_value();  local l25 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  return CL_LIB["FUNCALL-LUA"]( l3, {l24, }) end, 0, 0, false, false))); i( CL["CLOSE"](l24, k()) );
 single_value(); if l25.error ~= n and true then if l25.error == KEYWORD.TAG then  error(l25) else error(l25[1]) end end l23 = CL["VALUES-LIST"](list_r(l25)) end i( l23 );
 CL["*LOAD-PATHNAME*"].bound = l21 i( CL["*LOAD-PATHNAME*"].bound );
 single_value();  CL["*LOAD-TRUENAME*"].bound = l22 l20 = CL["*LOAD-TRUENAME*"].bound else  local l26 = n if n ~= CL["TYPEP"](l19, CL["STREAM"], false) then  single_value();  l26 = CL_LIB["FUNCALL-LUA"]( l3, {l1, }) else  local l27 = n if n ~= CL["TYPEP"](l19, CL["T"], false) then  single_value();  l27 = CL["ERROR"]("etypecase, no matching branches", l()) else  l27 = n.bound end l26 = l27 end l20 = l26 end return l20 end, 0, 0, false, false))); CL["*READTABLE*"].bound = l16 i( CL["*READTABLE*"].bound );
 CL["*PACKAGE*"].bound = l17 i( CL["*PACKAGE*"].bound );
 single_value(); if l18.error ~= n and true then if l18.error == KEYWORD.TAG then  error(l18) else error(l18[1]) end end i( CL["VALUES-LIST"](list_r(l18)) );
 single_value();  return CL["T"].bound end, 1, 0, false, {0 , [LCL["KEYWORD"]["VERBOSE"]] = CL_LIB["VERBOSE"], [LCL["KEYWORD"]["PRINT"]] = CL["PRINT"], [LCL["KEYWORD"]["IF-DOES-NOT-EXIST"]] = CL_LIB["IF-DOES-NOT-EXIST"], [LCL["KEYWORD"]["EXTERNAL-FORMAT"]] = CL_LIB["EXTERNAL-FORMAT"]})); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); i( CL_LIB["FUNCTION-SETQ"](CL["PACKAGEP"] , CL_LIB["ALLOC-FUNCTION"]({CL["PACKAGE"],n},function (l1,  ...)   single_value();  return CL["EQ"](CL_LIB["PACKAGE-METATABLE"].bound, (getmetatable(l1) or n)) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["PACKAGE"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l2,  ...)   single_value();  return CL["PACKAGEP"](l2) end, 1, 0, false, false), n) );
 i( CL_LIB["FUNCTION-SETQ"](CL["FIND-PACKAGE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NAME"],n},function (l3,  ...)   local l4 = n if n ~= CL["SYMBOLP"](l3) then  l3 = CL["SYMBOL-NAME"](l3) l4 = l3 else  l4 = n.bound end i( l4 );
 single_value();  local l5 = n if n ~= CL["PACKAGEP"](l3) then  l5 = l3 else  local l6 = l3; local l7 = n.bound; single_value();  l5 = ((LCL)[l6] or l7) end return l5 end, 1, 0, false, false)) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["%FIND-PACKAGE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NAME"],n},function (l8,  ...)   single_value();  local l9 = CL["FIND-PACKAGE"](l8); single_value();  local l10 = n if n ~= l9 then  l10 = l9 else  l10 = CL["ERROR"]("Package ~S (~A) does not exist", l(l8,CL_LIB["TOSTRING"](l8))) end return l10 end, 1, 0, false, false)) );
 single_value();  tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%IN-PACKAGE"] , CL_LIB["ALLOC-FUNCTION"]({CL["PACKAGE"],n},function (l11,  ...)   single_value();  CL["*PACKAGE*"].bound = CL_LIB["%FIND-PACKAGE"](l11) return CL["*PACKAGE*"].bound end, 1, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["IN-PACKAGE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G134802"],{CL["&OPTIONAL"],{LCL["NIL"]["G134803"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  single_value();  local l9 = CL["FIND-PACKAGE"](l5); single_value();  local l10 = n if n ~= l9 then  CL["*PACKAGE*"].bound = l9 i( CL["*PACKAGE*"].bound );
 single_value();  l10 = CL["CONS"](CL_LIB["%IN-PACKAGE"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), n)) else  l10 = CL["ERROR"]("Can't switch to package ~S, package does not exist", l(l5)) end return l10 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["LIST-ALL-PACKAGES"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l1 = n.bound; for __k, __v in pairs(LCL) do  local l2 = __k; local l3 = __v; single_value();  local l4 = n if n ~= CL["STRING="](l2, l(CL["PACKAGE-NAME"](l3))) then  single_value();  single_value();  local l5 = CL["CONS"](l3, l1); single_value();  l1 = l5 l4 = l1 else  l4 = n.bound end local tmpres = l4 end i( n );
 single_value();  return l1 end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PACKAGE-NAME"] , CL_LIB["ALLOC-FUNCTION"]({CL["PACKAGE"],n},function (l1,  ...)   single_value();  local l2 = "name"; local l3 = n.bound; single_value();  return ((CL_LIB["%FIND-PACKAGE"](l1))[l2] or l3) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PACKAGE-NICKNAMES"] , CL_LIB["ALLOC-FUNCTION"]({CL["PACKAGE"],n},function (l1,  ...)   single_value();  local l2 = "nicknames"; local l3 = n.bound; single_value();  return ((CL_LIB["%FIND-PACKAGE"](l1))[l2] or l3) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PACKAGE-USE-LIST"] , CL_LIB["ALLOC-FUNCTION"]({CL["PACKAGE"],n},function (l1,  ...)   single_value();  local l2 = "used"; local l3 = n.bound; single_value();  return ((CL_LIB["%FIND-PACKAGE"](l1))[l2] or l3) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PACKAGE-USED-BY-LIST"] , CL_LIB["ALLOC-FUNCTION"]({CL["PACKAGE"],n},function (l1,  ...)   single_value();  local l2 = "used_by"; local l3 = n.bound; single_value();  return ((CL_LIB["%FIND-PACKAGE"](l1))[l2] or l3) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["PACKAGE-SHADOWING-SYMBOLS"] , CL_LIB["ALLOC-FUNCTION"]({CL["PACKAGE"],n},function (l1,  ...)   single_value();  local l2 = "shadowing"; local l3 = n.bound; single_value();  return ((CL_LIB["%FIND-PACKAGE"](l1))[l2] or l3) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["PACKAGE-EXTERNAL-SYMBOLS"] , CL_LIB["ALLOC-FUNCTION"]({CL["PACKAGE"],n},function (l1,  ...)   single_value();  local l2 = "external"; local l3 = n.bound; single_value();  return CL_LIB["%PAIRS-VALUE-LIST"](((CL_LIB["%FIND-PACKAGE"](l1))[l2] or l3), k(CL_LIB["TEST"], CL["SYMBOLP"].fbound)) end, 1, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DO-SYMBOLS"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G134969"],{CL["&OPTIONAL"],{LCL["NIL"]["G134970"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = CL["CADR"](l5); single_value();  local l11 = n if n ~= l10 then  l11 = l10 else  l11 = CL["*PACKAGE*"].bound end return CL["CONS"](CL["BLOCK"], CL["CONS"](n, CL["CONS"](CL["CONS"](CL_LIB["%PAIRS"], CL["CONS"](CL["GENSYM"](false), CL["CONS"]((l5)[1], CL["CONS"](CL["CONS"](CL_LIB["%FIND-PACKAGE"], CL["CONS"](l11, n)), CL["CONS"](CL["CONS"](CL["WHEN"], CL["CONS"](CL["CONS"](CL["SYMBOLP"], CL["CONS"]((l5)[1], n)), CL["APPEND"](l(l9,n)))), n))))), CL["CONS"](CL["CADDR"](l5), n)))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DO-EXTERNAL-SYMBOLS"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G135042"],{CL["&OPTIONAL"],{LCL["NIL"]["G135043"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = CL["CADR"](l5); single_value();  local l11 = n if n ~= l10 then  l11 = l10 else  l11 = CL["*PACKAGE*"] end return CL["CONS"](CL["BLOCK"], CL["CONS"](n, CL["CONS"](CL["CONS"](CL_LIB["%PAIRS"], CL["CONS"](CL["GENSYM"](false), CL["CONS"]((l5)[1], CL["CONS"](CL["CONS"](CL_LIB["LUA-INDEX-TABLE"], CL["CONS"](CL["CONS"](CL_LIB["%FIND-PACKAGE"], CL["CONS"](l11, n)), CL["CONS"]("external", n))), CL["CONS"](CL["CONS"](CL["WHEN"], CL["CONS"](CL["CONS"](CL["SYMBOLP"], CL["CONS"]((l5)[1], n)), CL["APPEND"](l(l9,n)))), n))))), CL["CONS"](CL["CADDR"](l5), n)))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DO-ALL-SYMBOLS"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G135118"],{CL["&OPTIONAL"],{LCL["NIL"]["G135119"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["PROGN"], CL["CONS"](CL["CONS"](CL["DOLIST"], CL["CONS"](CL["CONS"](l10, CL["CONS"](CL["CONS"](CL["LIST-ALL-PACKAGES"], n), CL["CONS"](CL["CADR"](l5), n))), CL["CONS"](CL["CONS"](CL["DO-SYMBOLS"], CL["CONS"](CL["CONS"]((l5)[1], CL["CONS"](l10, n)), CL["CONS"](CL["CONS"](CL["WHEN"], CL["CONS"](CL["CONS"](CL["SYMBOLP"], CL["CONS"]((l5)[1], n)), CL["APPEND"](l(l9,n)))), n))), n))), n)) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["RENAME-PACKAGE"] , CL_LIB["ALLOC-FUNCTION"]({CL["PACKAGE"],{CL_LIB["NEW-NAME"],{CL["&OPTIONAL"],{CL_LIB["NEW-NICKNAMES"],n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = n.bound end  single_value();  local l4 = CL_LIB["%FIND-PACKAGE"](l1); single_value();  local l5 = CL["PACKAGE-NAME"](l4); single_value();  local l6 = l2; single_value(); l4[CL["IDENTITY"]("name")] = l6 i( l6 );
 local l7 = nil; single_value(); LCL[CL["IDENTITY"](l5)] = l7 i( l7 );
 local l8 = CL["PACKAGE-NICKNAMES"](l4); single_value();  local l9 = (l8)[1]; single_value();  single_value();  local l10 = CL["GENSYM"](false); single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l12 = n if n ~= CL["NOT"](l8) then  single_value(); do break end; l12 = n.bound else  l12 = n.bound end i( l12 );
 local l13 = nil; single_value(); LCL[CL["IDENTITY"](l9)] = l13 i( l13 );
 single_value();  single_value();  local l14 = (l8)[2]; single_value();  l8 = l14 i( l8 );
 single_value();  single_value();  single_value();  local l15 = (l8)[1]; single_value();  l9 = l15 local tmpres = l9 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l11.error ~= n and (l11.error ~= KEYWORD.TAG or l11.tag ~= l10) then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end i( CL["VALUES-LIST"](list_r(l11)) );
 local l16 = l3; single_value(); l4[CL["IDENTITY"]("nicknames")] = l16 i( l16 );
 single_value();  local l17 = CL["CONS"](l2, CL["PACKAGE-NICKNAMES"](l4)); single_value();  local l18 = (l17)[1]; single_value();  single_value();  local l19 = CL["GENSYM"](false); single_value();  local l20 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l21 = n if n ~= CL["NOT"](l17) then  single_value(); do break end; l21 = n.bound else  l21 = n.bound end i( l21 );
 local l23 = l18; local l24 = n.bound; single_value();  local l22 = n if n ~= ((LCL)[l23] or l24) then  l22 = CL["ERROR"]("Can't rename-package, package ~S already exist", l(l18)) else  local l25 = l4; single_value(); LCL[CL["IDENTITY"](l18)] = l25 l22 = l25 end i( l22 );
 single_value();  single_value();  local l26 = (l17)[2]; single_value();  l17 = l26 i( l17 );
 single_value();  single_value();  single_value();  local l27 = (l17)[1]; single_value();  l18 = l27 local tmpres = l18 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l20.error ~= n and (l20.error ~= KEYWORD.TAG or l20.tag ~= l19) then if l20.error == KEYWORD.TAG then  error(l20) else error(l20[1]) end end return CL["VALUES-LIST"](list_r(l20)) end, 2, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%FIND-SYMBOL-EXTERNAL"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL["PACKAGE"],n}},function (l1, l2,  ...)   single_value();  local l5 = n if n ~= CL["SYMBOLP"](l1) then  l5 = CL["SYMBOL-NAME"](l1) else  l5 = l1 end local l4 = l5; local l6 = LCL["KEYWORD"]["NONE"]; single_value();  local l7 = "external"; local l8 = n.bound; single_value();  local l3 = n if n ~= CL["EQ"](LCL["KEYWORD"]["NONE"], ((((l2)[l7] or l8))[l4] or l6)) then  l3 = LCL["KEYWORD"]["INTERNAL"] else  l3 = LCL["KEYWORD"]["EXTERNAL"] end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%FIND-SYMBOL-INHERITED"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL_LIB["PACKS"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= l2 then  l3 = rawget(CL_LIB["%FIND-PACKAGE"]((l2)[1]).external, l1) or CL_LIB["%FIND-SYMBOL-INHERITED"](l1, (l2)[2]) else  l3 = CL["VALUES"](l(n.bound,CL["T"].bound)) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FIND-SYMBOL"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL["&OPTIONAL"],{{CL["PACKAGE"],{CL["*PACKAGE*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*PACKAGE*"].bound end  l1 = CL["STRING"](l1) i( l1 );
 single_value();  local l3 = CL_LIB["%FIND-PACKAGE"](l2); single_value();  local l4 = CL["FIND"](l1, CL["PACKAGE-SHADOWING-SYMBOLS"](l3), k(CL_LIB["KEY"], CL["SYMBOL-NAME"].fbound)); single_value();  single_value();  local l5 = n if n ~= l4 then  l5 = CL["VALUES"](l(l4,CL_LIB["%FIND-SYMBOL-EXTERNAL"](l4, l3))) else  local l6 = rawget(l3, l1) or true; single_value();  local l7 = n if n ~= CL["EQ"](true, l6) then  local l8 = n.bound; local l9 = n.bound; local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l13 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l12 = l13; single_value();  single_value();  l8,l9= unpack_mv(CL_LIB["%FIND-SYMBOL-INHERITED"](l1, CL["PACKAGE-USE-LIST"](l3)), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l10 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l11.error ~= n and true then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end i( CL["VALUES-LIST"](list_r(l11)) );
 single_value();  local l14 = n if n ~= l9 then  l14 = CL["VALUES"](l(n.bound,n.bound)) else  l14 = CL["VALUES"](l(l8,LCL["KEYWORD"]["INHERITED"])) end l7 = l14 else  l7 = CL["VALUES"](l(l6,CL_LIB["%FIND-SYMBOL-EXTERNAL"](l6, l3))) end l5 = l7 end return l5 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FIND-ALL-SYMBOLS"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],n},function (l1,  ...)   single_value();  local l2 = n.bound; single_value();  local l3 = CL_LIB["FUNCALL-LUA"]( CL["LIST-ALL-PACKAGES"].fbound, {}); single_value();  local l4 = (l3)[1]; single_value();  single_value();  local l5 = CL["GENSYM"](false); single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l7 = n if n ~= CL["NOT"](l3) then  single_value(); do break end; l7 = n.bound else  l7 = n.bound end i( l7 );
 local l8 = n.bound; local l9 = n.bound; local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l13 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l12 = l13; single_value();  single_value();  l8,l9= unpack_mv(CL["FIND-SYMBOL"](l1, l4), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l10 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l11.error ~= n and true then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end i( CL["VALUES-LIST"](list_r(l11)) );
 single_value();  local l15 = n if n ~= l9 then  l15 = CL["NOT"](CL["EQ"](l9, LCL["KEYWORD"]["INHERITED"])) else  l15 = n.bound end local l14 = n if n ~= l15 then  local l16 = l8; local l17 = l2; single_value();  local l18 = n if n ~= CL["MEMBER"](l16, l17, k()) then  l18 = l17 else  single_value();  single_value();  local l19 = CL["CONS"](l16, l2); single_value();  l2 = l19 l18 = l2 end l14 = l18 else  l14 = n.bound end i( l14 );
 single_value();  single_value();  local l20 = (l3)[2]; single_value();  l3 = l20 i( l3 );
 single_value();  single_value();  single_value();  local l21 = (l3)[1]; single_value();  l4 = l21 local tmpres = l4 end i( n );
 single_value();  return l2 end, 0, 0, false, false))); single_value(); if l6.error ~= n and (l6.error ~= KEYWORD.TAG or l6.tag ~= l5) then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end return CL["VALUES-LIST"](list_r(l6)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%DEFPACKAGE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NAME"],{CL_LIB["OPTIONS"],n}},function (l1, l2,  ...)   single_value();  local l4 = n if n ~= CL["SYMBOLP"](l1) then  l4 = CL["SYMBOL-NAME"](l1) else  l4 = l1 end local l3 = l4; single_value();  local l5 = n.bound; single_value();  local l6 = n.bound; single_value();  local l7 = n.bound; single_value();  local l8 = n.bound; single_value();  local l9 = n.bound; single_value();  local l11 = CL["FIND-PACKAGE"](l3); single_value();  local l12 = n if n ~= l11 then  l12 = l11 else  l12 = CL["MAKE-PACKAGE"](l3, k()) end local l10 = l12; single_value();  local l13 = l2; single_value();  local l14 = (l13)[1]; single_value();  single_value();  local l15 = CL["GENSYM"](false); single_value();  local l16 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l17 = n if n ~= CL["NOT"](l13) then  single_value(); do break end; l17 = n.bound else  l17 = n.bound end i( l17 );
 local l18 = (l14)[1]; single_value();  local l19 = n if n ~= CL["EQL"](l18, LCL["KEYWORD"]["NICKNAMES"]) then  single_value();  l5 = CL["APPEND"](l(l5,CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["O"],n},function (l20,  ...)   single_value();  local l21 = n if n ~= CL["SYMBOLP"](l20) then  l21 = CL["SYMBOL-NAME"](l20) else  l21 = l20 end return l21 end, 1, 0, false, false), l((l14)[2])))) l19 = l5 else  local l22 = n if n ~= CL["EQL"](l18, LCL["KEYWORD"]["USE"]) then  single_value();  l6 = CL["APPEND"](l(l6,(l14)[2])) l22 = l6 else  local l23 = n if n ~= CL["EQL"](l18, LCL["KEYWORD"]["EXPORT"]) then  single_value();  l8 = CL["APPEND"](l(l8,(l14)[2])) l23 = l8 else  local l24 = n if n ~= CL["EQL"](l18, LCL["KEYWORD"]["INTERN"]) then  single_value();  l9 = CL["APPEND"](l(l9,(l14)[2])) l24 = l9 else  local l25 = n if n ~= CL["EQL"](l18, LCL["KEYWORD"]["IMPORT-FROM"]) then  single_value();  single_value();  single_value();  local l26 = CL["CONS"]((l14)[2], l7); single_value();  l7 = l26 l25 = l7 else  local l27 = n if n ~= CL["EQL"](l18, LCL["KEYWORD"]["SHADOW"]) then  single_value();  l27 = CL["WARN"]("defpackage: :SHADOW not supported", l()) else  local l28 = n if n ~= CL["EQL"](l18, LCL["KEYWORD"]["SHADOWING-IMPORT-FROM"]) then  single_value();  l28 = CL["WARN"]("defpackage: :SHADOWING-IMPORT-FROM not supported", l()) else  local l29 = n if n ~= CL["EQL"](l18, LCL["KEYWORD"]["DOCUMENTATION"]) then  single_value();  l29 = n.bound else  local l30 = n if n ~= CL["EQL"](l18, LCL["KEYWORD"]["SIZE"]) then  single_value();  l30 = n.bound else  local l31 = n if n ~= CL["T"].bound then  single_value();  l31 = CL["ERROR"]("defpackage: Invalid option ~S", l(l14)) else  l31 = n.bound end l30 = l31 end l29 = l30 end l28 = l29 end l27 = l28 end l25 = l27 end l24 = l25 end l23 = l24 end l22 = l23 end l19 = l22 end i( l19 );
 single_value();  single_value();  local l32 = (l13)[2]; single_value();  l13 = l32 i( l13 );
 single_value();  single_value();  single_value();  local l33 = (l13)[1]; single_value();  l14 = l33 local tmpres = l14 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l16.error ~= n and (l16.error ~= KEYWORD.TAG or l16.tag ~= l15) then if l16.error == KEYWORD.TAG then  error(l16) else error(l16[1]) end end i( CL["VALUES-LIST"](list_r(l16)) );
 i( CL["RENAME-PACKAGE"](l10, l3, l5) );
 i( CL["USE-PACKAGE"](l6, l10) );
 local l34 = l7; single_value();  local l35 = (l34)[1]; single_value();  single_value();  local l36 = CL["GENSYM"](false); single_value();  local l37 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l38 = n if n ~= CL["NOT"](l34) then  single_value(); do break end; l38 = n.bound else  l38 = n.bound end i( l38 );
 i( CL["IMPORT"](CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["S"],n},function (l39,  ...)   single_value();  return CL["FIND-SYMBOL"](l39, (l35)[1]) end, 1, 0, false, false), l((l35)[2])), l10) );
 single_value();  single_value();  local l40 = (l34)[2]; single_value();  l34 = l40 i( l34 );
 single_value();  single_value();  single_value();  local l41 = (l34)[1]; single_value();  l35 = l41 local tmpres = l35 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l37.error ~= n and (l37.error ~= KEYWORD.TAG or l37.tag ~= l36) then if l37.error == KEYWORD.TAG then  error(l37) else error(l37[1]) end end i( CL["VALUES-LIST"](list_r(l37)) );
 local l42 = l9; single_value();  local l43 = (l42)[1]; single_value();  single_value();  local l44 = CL["GENSYM"](false); single_value();  local l45 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l46 = n if n ~= CL["NOT"](l42) then  single_value(); do break end; l46 = n.bound else  l46 = n.bound end i( l46 );
 i( CL["INTERN"](l43, l10) );
 single_value();  single_value();  local l47 = (l42)[2]; single_value();  l42 = l47 i( l42 );
 single_value();  single_value();  single_value();  local l48 = (l42)[1]; single_value();  l43 = l48 local tmpres = l43 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l45.error ~= n and (l45.error ~= KEYWORD.TAG or l45.tag ~= l44) then if l45.error == KEYWORD.TAG then  error(l45) else error(l45[1]) end end i( CL["VALUES-LIST"](list_r(l45)) );
 i( CL["EXPORT"](l8, l10) );
 single_value();  return l10 end, 2, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["DEFPACKAGE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G135861"],{CL["&OPTIONAL"],{LCL["NIL"]["G135862"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  i( CL_LIB["%DEFPACKAGE"](l5, l9) );
 single_value();  return CL["CONS"](CL_LIB["%DEFPACKAGE"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l9, n)), n))) end, 1, 1, false, false)); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*MODULES*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL["PROVIDE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["MODULE-NAME"],n},function (l1,  ...)   single_value();  local l2 = l1; local l3 = CL["*MODULES*"].bound; single_value();  local l4 = n if n ~= CL["MEMBER"](l2, l3, k()) then  l4 = l3 else  single_value();  single_value();  local l5 = CL["CONS"](l2, CL["*MODULES*"].bound); single_value();  CL["*MODULES*"].bound = l5 l4 = CL["*MODULES*"].bound end return l4 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["REQUIRE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["MODULE-NAME"],{CL["&OPTIONAL"],{CL_LIB["PATHNAME-LIST"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = n if n ~= CL["MEMBER"](l1, CL["*MODULES*"].bound, k()) then  l3 = CL["T"].bound else  l3 = CL["ERROR"]("Can't require module ~A, module not found", l(l1)) end return l3 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["EXPORT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SYMBOLS"],{CL["&OPTIONAL"],{{CL["PACKAGE"],{CL["*PACKAGE*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*PACKAGE*"].bound end  local l3 = n if n ~= CL["LISTP"](l1) then  l3 = n.bound else  single_value();  l1 = CL["LIST"](l(l1)) l3 = l1 end i( l3 );
 l2 = CL_LIB["%FIND-PACKAGE"](l2) i( l2 );
 local l4 = l1; single_value();  local l5 = (l4)[1]; single_value();  single_value();  local l6 = CL["GENSYM"](false); single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l8 = n if n ~= CL["NOT"](l4) then  single_value(); do break end; l8 = n.bound else  l8 = n.bound end i( l8 );
 local l9 = n if n ~= CL["MEMBER"](l5, CL_LIB["PACKAGE-EXTERNAL-SYMBOLS"](l2), k()) then  l9 = n.bound else  local l10 = CL["PACKAGE-USED-BY-LIST"](l2); single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = CL["GENSYM"](false); single_value();  local l13 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l14 = n if n ~= CL["NOT"](l10) then  single_value(); do break end; l14 = n.bound else  l14 = n.bound end i( l14 );
 local l15 = n if n ~= CL["NTH"](0, CL["FUNCALL"](l, l(unpack_mv(CL["FIND-SYMBOL"](CL["SYMBOL-NAME"](l5), l11))))) then  single_value();  l15 = CL["WARN"]("export conflict for symbol ~S in package ~S", l(l5,l11)) else  l15 = n.bound end i( l15 );
 single_value();  single_value();  local l16 = (l10)[2]; single_value();  l10 = l16 i( l10 );
 single_value();  single_value();  single_value();  local l17 = (l10)[1]; single_value();  l11 = l17 local tmpres = l11 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l13.error ~= n and (l13.error ~= KEYWORD.TAG or l13.tag ~= l12) then if l13.error == KEYWORD.TAG then  error(l13) else error(l13[1]) end end i( CL["VALUES-LIST"](list_r(l13)) );
 single_value();  local l19 = CL["SYMBOL-PACKAGE"](l5); single_value();  local l21 = CL["EQ"](CL["FIND-PACKAGE"](LCL["KEYWORD"]["NIL"]), l19); single_value();  local l22 = n if n ~= l21 then  l22 = l21 else  l22 = CL["EQ"](CL["FIND-PACKAGE"](LCL["KEYWORD"]["KEYWORD"]), l19) end local l20 = n if n ~= l22 then  local l23 = CL["SYMBOL-NAME"](l5); local l24 = n.bound; single_value();  l20 = ((l2)[l23] or l24) else  l20 = l5 end local l18 = l20; single_value();  local l25 = "external"; local l26 = n.bound; single_value(); ((l2)[l25] or l26)[CL["IDENTITY"](CL["SYMBOL-NAME"](l5))] = l18 l9 = l18 end i( l9 );
 single_value();  single_value();  local l27 = (l4)[2]; single_value();  l4 = l27 i( l4 );
 single_value();  single_value();  single_value();  local l28 = (l4)[1]; single_value();  l5 = l28 local tmpres = l5 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l7.error ~= n and (l7.error ~= KEYWORD.TAG or l7.tag ~= l6) then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end i( CL["VALUES-LIST"](list_r(l7)) );
 single_value();  return CL["T"].bound end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["UNEXPORT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SYMBOLS"],{CL["&OPTIONAL"],{{CL["PACKAGE"],{CL["*PACKAGE*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*PACKAGE*"].bound end  local l3 = n if n ~= CL["LISTP"](l1) then  l3 = n.bound else  single_value();  l1 = CL["LIST"](l(l1)) l3 = l1 end i( l3 );
 l2 = CL_LIB["%FIND-PACKAGE"](l2) i( l2 );
 local l4 = l1; single_value();  local l5 = (l4)[1]; single_value();  single_value();  local l6 = CL["GENSYM"](false); single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l8 = n if n ~= CL["NOT"](l4) then  single_value(); do break end; l8 = n.bound else  l8 = n.bound end i( l8 );
 local l9 = CL["NTH"](1, CL["FUNCALL"](l, l(unpack_mv(CL["FIND-SYMBOL"](CL["SYMBOL-NAME"](l5), l2))))); single_value();  local l10 = l9; single_value();  local l11 = n if n ~= CL["EQL"](l10, LCL["KEYWORD"]["EXTERNAL"]) then  single_value();  local l12 = nil; single_value();  local l13 = "external"; local l14 = n.bound; single_value(); ((l2)[l13] or l14)[CL["IDENTITY"](CL["SYMBOL-NAME"](l5))] = l12 l11 = l12 else  local l15 = n if n ~= CL["EQL"](l10, LCL["KEYWORD"]["INTERNAL"]) then  single_value();  l15 = CL["WARN"]("Symbol ~S was already internal to package ~S", l(l5,l2)) else  local l16 = n if n ~= CL["EQL"](l10, LCL["KEYWORD"]["INHERITED"]) then  single_value();  l16 = CL["ERROR"]("Can't unexport symbol ~S, not present in package ~S", l(l5,l2)) else  local l17 = n if n ~= CL["MEMBER"](l10, n, k()) then  single_value();  l17 = CL["ERROR"]("Can't unexport symbol ~S, not present in package ~S", l(l5,l2)) else  local l18 = n if n ~= CL["T"].bound then  single_value();  l18 = CL["ERROR"]("ECASE", l()) else  l18 = n.bound end l17 = l18 end l16 = l17 end l15 = l16 end l11 = l15 end i( l11 );
 single_value();  single_value();  local l19 = (l4)[2]; single_value();  l4 = l19 i( l4 );
 single_value();  single_value();  single_value();  local l20 = (l4)[1]; single_value();  l5 = l20 local tmpres = l5 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l7.error ~= n and (l7.error ~= KEYWORD.TAG or l7.tag ~= l6) then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end i( CL["VALUES-LIST"](list_r(l7)) );
 single_value();  return CL["T"].bound end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SHADOW"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SYMBOLS"],{CL["&OPTIONAL"],{{CL["PACKAGE"],{CL["*PACKAGE*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*PACKAGE*"].bound end  local l3 = n if n ~= CL["LISTP"](l1) then  l3 = n.bound else  single_value();  l1 = CL["LIST"](l(l1)) l3 = l1 end i( l3 );
 l2 = CL_LIB["%FIND-PACKAGE"](l2) i( l2 );
 local l4 = l1; single_value();  local l5 = (l4)[1]; single_value();  single_value();  local l6 = CL["GENSYM"](false); single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l8 = n if n ~= CL["NOT"](l4) then  single_value(); do break end; l8 = n.bound else  l8 = n.bound end i( l8 );
 local l9 = n.bound; local l10 = n.bound; local l11 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l12 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l13 = l14; single_value();  single_value();  l9,l10= unpack_mv(CL["FIND-SYMBOL"](l5, l2), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l11 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l12.error ~= n and true then if l12.error == KEYWORD.TAG then  error(l12) else error(l12[1]) end end i( CL["VALUES-LIST"](list_r(l12)) );
 single_value();  local l15 = n if n ~= CL["EQ"](l10, LCL["KEYWORD"]["INHERIT"]) then  single_value();  local l16 = CL["FUNCALL"](CL_LIB["ALLOC-SYMBOL"].fbound, l(l2,CL["SYMBOL-NAME"](l5))); i( rawset(l2,CL["SYMBOL-NAME"](l5),l16) );
 single_value();  local l17 = CL["ADJOIN"](l16, CL["PACKAGE-SHADOWING-SYMBOLS"](l2), k(CL_LIB["TEST"], CL["EQUAL"].fbound, CL_LIB["KEY"], CL["SYMBOL-NAME"].fbound)); single_value(); l2[CL["IDENTITY"]("shadowing")] = l17 l15 = l17 else  local l18 = n if n ~= l9 then  single_value();  local l19 = CL["ADJOIN"](l9, CL["PACKAGE-SHADOWING-SYMBOLS"](l2), k(CL_LIB["TEST"], CL["EQUAL"].fbound, CL_LIB["KEY"], CL["SYMBOL-NAME"].fbound)); single_value(); l2[CL["IDENTITY"]("shadowing")] = l19 l18 = l19 else  l18 = n.bound end l15 = l18 end i( l15 );
 single_value();  single_value();  local l20 = (l4)[2]; single_value();  l4 = l20 i( l4 );
 single_value();  single_value();  single_value();  local l21 = (l4)[1]; single_value();  l5 = l21 local tmpres = l5 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l7.error ~= n and (l7.error ~= KEYWORD.TAG or l7.tag ~= l6) then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end i( CL["VALUES-LIST"](list_r(l7)) );
 single_value();  return CL["T"].bound end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["USE-PACKAGE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PACKAGES-TO-USE"],{CL["&OPTIONAL"],{{CL["PACKAGE"],{CL["*PACKAGE*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*PACKAGE*"].bound end  local l3 = n if n ~= CL["LISTP"](l1) then  l3 = n.bound else  single_value();  l1 = CL["LIST"](l(l1)) l3 = l1 end i( l3 );
 l2 = CL_LIB["%FIND-PACKAGE"](l2) i( l2 );
 local l4 = l1; single_value();  local l5 = (l4)[1]; single_value();  single_value();  local l6 = CL["GENSYM"](false); single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l8 = n if n ~= CL["NOT"](l4) then  single_value(); do break end; l8 = n.bound else  l8 = n.bound end i( l8 );
 l5 = CL_LIB["%FIND-PACKAGE"](l5) i( l5 );
 local l9 = CL["PACKAGE-USE-LIST"](l2); local l10 = l5; local l11 = l9; single_value();  local l12 = n if n ~= CL["MEMBER"](l10, l11, k()) then  l12 = l11 else  single_value();  single_value();  local l13 = CL["CONS"](l10, l9); single_value();  l9 = l13 l12 = l9 end i( l12 );
 single_value();  local l14 = l9; single_value(); l2[CL["IDENTITY"]("used")] = l14 i( l14 );
 local l15 = CL["PACKAGE-USED-BY-LIST"](l5); local l16 = l2; local l17 = l15; single_value();  local l18 = n if n ~= CL["MEMBER"](l16, l17, k()) then  l18 = l17 else  single_value();  single_value();  local l19 = CL["CONS"](l16, l15); single_value();  l15 = l19 l18 = l15 end i( l18 );
 single_value();  local l20 = l15; single_value(); l5[CL["IDENTITY"]("used_by")] = l20 i( l20 );
 single_value();  single_value();  local l21 = (l4)[2]; single_value();  l4 = l21 i( l4 );
 single_value();  single_value();  single_value();  local l22 = (l4)[1]; single_value();  l5 = l22 local tmpres = l5 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l7.error ~= n and (l7.error ~= KEYWORD.TAG or l7.tag ~= l6) then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end i( CL["VALUES-LIST"](list_r(l7)) );
 single_value();  return CL["T"].bound end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["UNUSE-PACKAGE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PACKAGES-TO-UNUSE"],{CL["&OPTIONAL"],{{CL["PACKAGE"],{CL["*PACKAGE*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*PACKAGE*"].bound end  local l3 = n if n ~= CL["LISTP"](l1) then  l3 = n.bound else  single_value();  l1 = CL["LIST"](l(l1)) l3 = l1 end i( l3 );
 l2 = CL_LIB["%FIND-PACKAGE"](l2) i( l2 );
 local l4 = l1; single_value();  local l5 = (l4)[1]; single_value();  single_value();  local l6 = CL["GENSYM"](false); single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l8 = n if n ~= CL["NOT"](l4) then  single_value(); do break end; l8 = n.bound else  l8 = n.bound end i( l8 );
 l5 = CL_LIB["%FIND-PACKAGE"](l5) i( l5 );
 local l9 = CL["REMOVE"](l5, CL["PACKAGE-USE-LIST"](l2), k()); single_value(); l2[CL["IDENTITY"]("used")] = l9 i( l9 );
 local l10 = CL["REMOVE"](l2, CL["PACKAGE-USED-BY-LIST"](l5), k()); single_value(); l5[CL["IDENTITY"]("used_by")] = l10 i( l10 );
 single_value();  single_value();  local l11 = (l4)[2]; single_value();  l4 = l11 i( l4 );
 single_value();  single_value();  single_value();  local l12 = (l4)[1]; single_value();  l5 = l12 local tmpres = l5 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l7.error ~= n and (l7.error ~= KEYWORD.TAG or l7.tag ~= l6) then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end i( CL["VALUES-LIST"](list_r(l7)) );
 single_value();  return CL["T"].bound end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["IMPORT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SYMBOLS"],{CL["&OPTIONAL"],{{CL["PACKAGE"],{CL["*PACKAGE*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*PACKAGE*"].bound end  local l3 = n if n ~= CL["LISTP"](l1) then  l3 = n.bound else  single_value();  l1 = CL["LIST"](l(l1)) l3 = l1 end i( l3 );
 l2 = CL_LIB["%FIND-PACKAGE"](l2) i( l2 );
 single_value();  local l4 = l1; single_value();  local l5 = (l4)[1]; single_value();  single_value();  local l6 = CL["GENSYM"](false); single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l8 = n if n ~= CL["NOT"](l4) then  single_value(); do break end; l8 = n.bound else  l8 = n.bound end i( l8 );
 local l9 = CL["NTH"](1, CL["FUNCALL"](l, l(unpack_mv(CL["FIND-SYMBOL"](CL["SYMBOL-NAME"](l5), l2))))); single_value();  local l10 = n if n ~= l9 then  l10 = CL["ERROR"]("Can't import symbol ~S, a symbol of the same name is already accessible from package ~S", l(l5,l2)) else  local l11 = l5; single_value(); l2[CL["IDENTITY"](CL["SYMBOL-NAME"](l5))] = l11 l10 = l11 end i( l10 );
 single_value();  single_value();  local l12 = (l4)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  single_value();  single_value();  local l13 = (l4)[1]; single_value();  l5 = l13 local tmpres = l5 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l7.error ~= n and (l7.error ~= KEYWORD.TAG or l7.tag ~= l6) then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end return CL["VALUES-LIST"](list_r(l7)) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["INTERN"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL["&OPTIONAL"],{{CL["PACKAGE"],{CL["*PACKAGE*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*PACKAGE*"].bound end  single_value();  local l3 = n if n ~= CL["STRINGP"](l1) then  local l4 = n.bound; local l5 = n.bound; local l6 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l9 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l8 = l9; single_value();  single_value();  l4,l5= unpack_mv(CL["FIND-SYMBOL"](l1, l2), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l6 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l7.error ~= n and true then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end i( CL["VALUES-LIST"](list_r(l7)) );
 single_value();  local l10 = n if n ~= l5 then  l10 = l4 else  local l11 = l1; local l12 = n.bound; single_value();  l10 = ((CL_LIB["%FIND-PACKAGE"](l2))[l11] or l12) end l3 = l10 else  l3 = CL["ERROR"]("Argument to intern must be a string, got ~S instead", l(l1)) end return l3 end, 1, 1, false, false)); local l1 = 0; single_value();  tmp = CL_LIB.DEF(CL_LIB["*GENTEMP-COUNTER*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL["GENTEMP"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{{CL_LIB["PREFIX"],{"T",n}},{{CL["PACKAGE"],{CL["*PACKAGE*"],n}},n}}},function (l1, l2,  ...)  if not l1 then  l1 = "T" end if not l2 then  l2 = CL["*PACKAGE*"].bound end  while true do  single_value();  local l3 = n if n ~= CL["NTH"](1, CL["FUNCALL"](l, l(unpack_mv(CL["FIND-SYMBOL"](CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l1, CL_LIB["*GENTEMP-COUNTER*"].bound, }), l2))))) then  single_value();  local l4 = (1 + CL_LIB["*GENTEMP-COUNTER*"].bound); single_value();  CL_LIB["*GENTEMP-COUNTER*"].bound = l4 l3 = CL_LIB["*GENTEMP-COUNTER*"].bound else do break end; l3 = n.bound end local tmpres = l3 end i( n );
 single_value();  return CL["INTERN"](CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {l1, CL_LIB["*GENTEMP-COUNTER*"].bound, }), l2) end, 0, 2, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["UNINTERN"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],{CL["&OPTIONAL"],{{CL["PACKAGE"],{CL["*PACKAGE*"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["*PACKAGE*"].bound end  local l3 = n if n ~= CL["EQ"](l2, CL["SYMBOL-PACKAGE"](l1)) then  single_value();  local l4 = nil; single_value(); l1[CL["IDENTITY"]("package")] = l4 l3 = l4 else  l3 = n.bound end i( l3 );
 single_value();  local l5 = nil; single_value(); l2[CL["IDENTITY"](CL["SYMBOL-NAME"](l1))] = l5 return l5 end, 1, 1, false, false)); local l1 = CL; single_value(); CL[CL["IDENTITY"]("external")] = l1 tmp = l1; tmp = CL_LIB["FUNCTION-SETQ"](CL["DELETE-PACKAGE"] , CL_LIB["ALLOC-FUNCTION"]({CL["PACKAGE"],n},function (l1,  ...)   l1 = CL_LIB["%FIND-PACKAGE"](l1) i( l1 );
 local l2 = CL["PACKAGE-USED-BY-LIST"](l1); single_value();  local l3 = (l2)[1]; single_value();  single_value();  local l4 = CL["GENSYM"](false); single_value();  local l5 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l6 = n if n ~= CL["NOT"](l2) then  single_value(); do break end; l6 = n.bound else  l6 = n.bound end i( l6 );
 i( CL["UNUSE-PACKAGE"](l1, l3) );
 single_value();  single_value();  local l7 = (l2)[2]; single_value();  l2 = l7 i( l2 );
 single_value();  single_value();  single_value();  local l8 = (l2)[1]; single_value();  l3 = l8 local tmpres = l3 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l5.error ~= n and (l5.error ~= KEYWORD.TAG or l5.tag ~= l4) then if l5.error == KEYWORD.TAG then  error(l5) else error(l5[1]) end end i( CL["VALUES-LIST"](list_r(l5)) );
 i( CL["UNUSE-PACKAGE"](CL["PACKAGE-USE-LIST"](l1), l1) );
 i( CL["RENAME-PACKAGE"](l1, CL["PACKAGE-NAME"](l1), false) );
 local l9 = CL["GENSYM"](false); single_value();  local l10 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   for __k, __v in pairs(CL_LIB["%FIND-PACKAGE"](l1)) do  local l11 = __k; local l12 = __v; single_value();  local l13 = n if n ~= CL["SYMBOLP"](l12) then  single_value();  l13 = CL["UNINTERN"](l12, l1) else  l13 = n.bound end local tmpres = l13 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l10.error ~= n and (l10.error ~= KEYWORD.TAG or l10.tag ~= l9) then if l10.error == KEYWORD.TAG then  error(l10) else error(l10[1]) end end i( CL["VALUES-LIST"](list_r(l10)) );
 single_value();  local l14 = nil; single_value(); LCL[CL["IDENTITY"](CL["PACKAGE-NAME"](l1))] = l14 return l14 end, 1, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["WITH-PACKAGE-ITERATOR"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G136867"],{CL["&OPTIONAL"],{LCL["NIL"]["G136868"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = l5; single_value();  local l11 = l5; single_value();  local l13 = l11; single_value();  local l14 = (l13)[1]; single_value();  single_value();  local l15 = (l13)[2]; single_value();  l11 = l15 i( l11 );
 single_value();  local l12 = l14; single_value();  local l17 = l11; single_value();  local l18 = (l17)[1]; single_value();  single_value();  local l19 = (l17)[2]; single_value();  l11 = l19 i( l11 );
 single_value();  local l16 = l18; single_value();  local l20 = l11; single_value();  single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](CL_LIB["%%PL"], CL["CONS"](l16, n)), n), CL["CONS"](CL["CONS"](CL["UNLESS"], CL["CONS"](CL["CONS"](CL["LISTP"], CL["CONS"](CL_LIB["%%PL"], n)), CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](CL_LIB["%%PL"], CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL_LIB["%%PL"], n)), n))), n))), CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](CL_LIB["%%PL"], CL["CONS"](CL["CONS"](CL["MAPCAR"], CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](CL["CONS"](CL_LIB["EL"], n), CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](CL_LIB["EL"], CL["CONS"](CL["CONS"](CL_LIB["%FIND-PACKAGE"], CL["CONS"](CL_LIB["EL"], n)), n))), CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](CL_LIB["ITER"], CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"]("pairs(", CL["CONS"](CL_LIB["EL"], CL["CONS"](")", n)))), n)), CL["CONS"](CL["CONS"](CL_LIB["KEY"], CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"]("nil", n)), n)), n)), CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](n, CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL_LIB["K"], CL["CONS"](CL_LIB["V"], n)), CL["CONS"](CL["CONS"](CL_LIB["LUA-PUSH"], CL["CONS"](CL["CONS"](CL_LIB["K"], CL["CONS"](", ", CL["CONS"](CL_LIB["V"], CL["CONS"](" = ", CL["CONS"](CL_LIB["ITER"], CL["CONS"]("(", CL["CONS"](CL_LIB["EL"], CL["CONS"](", ", CL["CONS"](CL_LIB["KEY"], CL["CONS"](")", n)))))))))), CL["CONS"](CL["CONS"](CL["IF"], CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"](CL_LIB["K"], CL["CONS"](" or n", n))), CL["CONS"](CL["CONS"](CL["PROGN"], CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](CL_LIB["KEY"], CL["CONS"](CL_LIB["K"], n))), CL["CONS"](CL["CONS"](CL["VALUES"], CL["CONS"](CL_LIB["KEY"], CL["CONS"](CL_LIB["V"], CL["CONS"](CL["T"], n)))), n))), CL["CONS"](CL["CONS"](CL["VALUES"], CL["CONS"](n, CL["CONS"](n, CL["CONS"](n, n)))), n)))), n))), n))), n))), n))), n)))), CL["CONS"](CL_LIB["%%PL"], n))), n))), CL["CONS"](CL["CONS"](CL["MACROLET"], CL["CONS"](CL["CONS"](CL["CONS"](l12, CL["CONS"](n, CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["CONS"](CL["BLOCK"], CL["CONS"](n, CL["CONS"](CL["CONS"](CL["TAGBODY"], CL["CONS"](CL_LIB["AGAIN"], CL["CONS"](CL["CONS"](CL["IF"], CL["CONS"](CL_LIB["%%PL"], CL["CONS"](CL["CONS"](CL["MULTIPLE-VALUE-BIND"], CL["CONS"](CL["CONS"](CL_LIB["K"], CL["CONS"](CL_LIB["V"], CL["CONS"](CL_LIB["IS"], n))), CL["CONS"](CL["CONS"](CL["FUNCALL"], CL["CONS"](CL["CONS"](CL["CAR"], CL["CONS"](CL_LIB["%%PL"], n)), n)), CL["CONS"](CL["CONS"](CL["IF"], CL["CONS"](CL_LIB["IS"], CL["CONS"](CL["CONS"](CL["IF"], CL["CONS"](CL["CONS"](CL["SYMBOLP"], CL["CONS"](CL_LIB["V"], n)), CL["CONS"](CL["CONS"](CL["RETURN"], CL["CONS"](CL_LIB["V"], n)), CL["CONS"](CL["CONS"](CL["GO"], CL["CONS"](CL_LIB["AGAIN"], n)), n)))), CL["CONS"](CL["CONS"](CL["PROGN"], CL["CONS"](CL["CONS"](CL["POP"], CL["CONS"](CL_LIB["%%PL"], n)), CL["CONS"](CL["CONS"](CL["GO"], CL["CONS"](CL_LIB["AGAIN"], n)), n))), n)))), n)))), n))), n))), n))), n)), n))), n), CL["APPEND"](l(l9,n)))), n))))) end, 1, 1, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["GETENV"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["NAME"],n},function (l1,  ...)   i( "Get the environment variable with the given name." );
 single_value();  return CL["FUNCALL"](os.getenv, l(CL["STRING"](l1))) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["COMMAND-LINE-ARGUMENTS"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   i( "Get the command-line-arguments that were passed to the process." );
 single_value();  local l1 = n.bound; single_value();  local l2 = arg; single_value();  local l3 = #arg; single_value();  local l4 = -1; single_value();  while true do  local l5 = n if n ~= CL[">"](l(l4,l3)) then do break end; l5 = n.bound else  l5 = n.bound end i( l5 );
 single_value();  single_value();  local l7 = l4; local l8 = n.bound; single_value();  local l6 = CL["CONS"](((l2)[l7] or l8), l1); single_value();  l1 = l6 i( l1 );
 single_value();  single_value();  local l9 = (1 + l4); single_value();  l4 = l9 local tmpres = l4 end i( n );
 single_value();  return CL["NREVERSE"](l1) end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["QUIT"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{{CL_LIB["CODE"],{0,n}},n}},function (l1,  ...)  if not l1 then  l1 = 0 end  i( "Stop the Lua process with the given CODE." );
 single_value();  return CL["FUNCALL"](os.exit, l(l1)) end, 0, 1, false, false));-- The CLOS Implementation for LCL is modified from CLOSETTE
-- The following section contains code compiled from CLOSETTE
--
-- MIT License
-- 
-- Copyright (c) 2016 Chun Tian
-- 
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
-- 
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
-- 
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
 tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["%DEFPACKAGE"](LCL["KEYWORD"]["CLOSETTE"], {{LCL["KEYWORD"]["USE"],{LCL["KEYWORD"]["COMMON-LISP"],n}},n}); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CLOSETTE"]); local l1 = {LCL["CLOSETTE"]["DEFCLASS"],{LCL["CLOSETTE"]["DEFGENERIC"],{LCL["CLOSETTE"]["DEFMETHOD"],{LCL["CLOSETTE"]["FIND-CLASS"],{LCL["CLOSETTE"]["CLASS-OF"],{LCL["CLOSETTE"]["CALL-NEXT-METHOD"],{LCL["CLOSETTE"]["NEXT-METHOD-P"],{LCL["CLOSETTE"]["SLOT-VALUE"],{LCL["CLOSETTE"]["SLOT-BOUNDP"],{LCL["CLOSETTE"]["SLOT-EXISTS-P"],{LCL["CLOSETTE"]["SLOT-MAKUNBOUND"],{LCL["CLOSETTE"]["MAKE-INSTANCE"],{LCL["CLOSETTE"]["CHANGE-CLASS"],{LCL["CLOSETTE"]["INITIALIZE-INSTANCE"],{LCL["CLOSETTE"]["REINITIALIZE-INSTANCE"],{LCL["CLOSETTE"]["SHARED-INITIALIZE"],{LCL["CLOSETTE"]["UPDATE-INSTANCE-FOR-DIFFERENT-CLASS"],{LCL["CLOSETTE"]["DESCRIBE-OBJECT"],{LCL["CLOSETTE"]["STANDARD-OBJECT"],{LCL["CLOSETTE"]["STANDARD-CLASS"],{LCL["CLOSETTE"]["STANDARD-GENERIC-FUNCTION"],{LCL["CLOSETTE"]["STANDARD-METHOD"],{LCL["CLOSETTE"]["CLASS-NAME"],{LCL["CLOSETTE"]["CLASS-DIRECT-SUPERCLASSES"],{LCL["CLOSETTE"]["CLASS-DIRECT-SLOTS"],{LCL["CLOSETTE"]["CLASS-PRECEDENCE-LIST"],{LCL["CLOSETTE"]["CLASS-SLOTS"],{LCL["CLOSETTE"]["CLASS-DIRECT-SUBCLASSES"],{LCL["CLOSETTE"]["CLASS-DIRECT-METHODS"],{LCL["CLOSETTE"]["GENERIC-FUNCTION-NAME"],{LCL["CLOSETTE"]["GENERIC-FUNCTION-LAMBDA-LIST"],{LCL["CLOSETTE"]["GENERIC-FUNCTION-METHODS"],{LCL["CLOSETTE"]["GENERIC-FUNCTION-DISCRIMINATING-FUNCTION"],{LCL["CLOSETTE"]["GENERIC-FUNCTION-METHOD-CLASS"],{LCL["CLOSETTE"]["METHOD-LAMBDA-LIST"],{LCL["CLOSETTE"]["METHOD-QUALIFIERS"],{LCL["CLOSETTE"]["METHOD-SPECIALIZERS"],{LCL["CLOSETTE"]["METHOD-BODY"],{LCL["CLOSETTE"]["METHOD-ENVIRONMENT"],{LCL["CLOSETTE"]["METHOD-GENERIC-FUNCTION"],{LCL["CLOSETTE"]["METHOD-FUNCTION"],{LCL["CLOSETTE"]["SLOT-DEFINITION-NAME"],{LCL["CLOSETTE"]["SLOT-DEFINITION-INITFUNCTION"],{LCL["CLOSETTE"]["SLOT-DEFINITION-INITFORM"],{LCL["CLOSETTE"]["SLOT-DEFINITION-INITARGS"],{LCL["CLOSETTE"]["SLOT-DEFINITION-READERS"],{LCL["CLOSETTE"]["SLOT-DEFINITION-WRITERS"],{LCL["CLOSETTE"]["SLOT-DEFINITION-ALLOCATION"],{LCL["CLOSETTE"]["COMPUTE-CLASS-PRECEDENCE-LIST"],{LCL["CLOSETTE"]["COMPUTE-SLOTS"],{LCL["CLOSETTE"]["COMPUTE-EFFECTIVE-SLOT-DEFINITION"],{LCL["CLOSETTE"]["FINALIZE-INHERITANCE"],{LCL["CLOSETTE"]["ALLOCATE-INSTANCE"],{LCL["CLOSETTE"]["SLOT-VALUE-USING-CLASS"],{LCL["CLOSETTE"]["SLOT-BOUNDP-USING-CLASS"],{LCL["CLOSETTE"]["SLOT-EXISTS-P-USING-CLASS"],{LCL["CLOSETTE"]["SLOT-MAKUNBOUND-USING-CLASS"],{LCL["CLOSETTE"]["COMPUTE-DISCRIMINATING-FUNCTION"],{LCL["CLOSETTE"]["COMPUTE-APPLICABLE-METHODS-USING-CLASSES"],{LCL["CLOSETTE"]["METHOD-MORE-SPECIFIC-P"],{LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"],{LCL["CLOSETTE"]["ADD-METHOD"],{LCL["CLOSETTE"]["REMOVE-METHOD"],{LCL["CLOSETTE"]["FIND-METHOD"],{LCL["CLOSETTE"]["COMPUTE-EFFECTIVE-METHOD-FUNCTION"],{LCL["CLOSETTE"]["COMPUTE-METHOD-FUNCTION"],{LCL["CLOSETTE"]["APPLY-METHODS"],{LCL["CLOSETTE"]["APPLY-METHOD"],{LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"],{LCL["CLOSETTE"]["SUBCLASSP"],n}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}; single_value();  tmp = CL_LIB.DEF(LCL["CLOSETTE"]["+CLOSETTE-SYMBOLS+"],l1); tmp = CL["EXPORT"](LCL["CLOSETTE"]["+CLOSETTE-SYMBOLS+"].bound, false); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CLOSETTE"]); single_value();  tmp = CL_LIB["MACRO-SETQ"](LCL["CLOSETTE"]["PUSH-ON-END"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G149318"],{CL["&OPTIONAL"],{LCL["NIL"]["G149319"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  single_value();  return CL["CONS"](CL["SETF"], CL["CONS"](l9, CL["CONS"](CL["CONS"](CL["NCONC"], CL["CONS"](l9, CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](l5, n)), n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SETGETF*"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["PLIST"],{LCL["CLOSETTE"]["KEY"],{LCL["CLOSETTE"]["NEW-VALUE"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL["GENSYM"](false); single_value();  local l5 = n if n ~= CL["EQ"](CL["GETF"](l1, l2, l4), l4) then  single_value();  single_value();  local l6 = CL["NCONC"](l(l1,CL["LIST"](l(l2)))); single_value();  l1 = l6 i( l1 );
 single_value();  single_value();  single_value();  local l7 = CL["NCONC"](l(l1,CL["LIST"](l(l3)))); single_value();  l1 = l7 l5 = l1 else  single_value();  local l8 = l2; single_value();  single_value();  local l9 = l3; single_value();  l1 = CL_LIB["SETGETF"](l1, l8, l9) l5 = l1 end return l5 end, 3, 0, false, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](LCL["CLOSETTE"]["GETF*"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(LCL["CLOSETTE"]["SETGETF*"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(LCL["CLOSETTE"]["GETF*"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["MAPAPPEND"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["FUN"],{CL["&REST"],{LCL["CLOSETTE"]["ARGS"],n}}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["SOME"](CL["NULL"].fbound, l(l2)) then  l3 = n.bound else  l3 = CL["APPEND"](l(CL["APPLY"](l1, CL["MAPCAR"](CL["CAR"].fbound, l(l2)), l()),CL["APPLY"](LCL["CLOSETTE"]["MAPAPPEND"].fbound, l1, l(CL["MAPCAR"](CL["CDR"].fbound, l(l2)))))) end return l3 end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["MAPPLIST"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["FUN"],{LCL["CLOSETTE"]["X"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["NULL"](l2) then  l3 = n.bound else  local l4 = (l2)[1]; single_value();  local l5 = CL["CADR"](l2); single_value();  l3 = CL["CONS"](CL_LIB['FUNCALL-LUA'](l1,{l4, l5, }), LCL["CLOSETTE"]["MAPPLIST"](l1, CL["CDDR"](l2))) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["PRINT-UNREADABLE-OBJECT"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G149663"],{CL["&OPTIONAL"],{LCL["NIL"]["G149664"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = l5; single_value();  local l11 = l5; single_value();  local l13 = l11; single_value();  local l14 = (l13)[1]; single_value();  single_value();  local l15 = (l13)[2]; single_value();  l11 = l15 i( l11 );
 single_value();  local l12 = l14; single_value();  local l17 = l11; single_value();  local l18 = (l17)[1]; single_value();  single_value();  local l19 = (l17)[2]; single_value();  l11 = l19 i( l11 );
 single_value();  local l16 = l18; single_value();  local l20 = CL["GETF"](l11, LCL["KEYWORD"]["TYPE"], LCL["NIL"]["G149712"]); single_value();  local l22 = n if n ~= CL["EQ"](LCL["NIL"]["G149712"], l20) then  l22 = n.bound else  l22 = l20 end local l21 = l22; single_value();  local l23 = CL["GETF"](l11, LCL["KEYWORD"]["IDENTITY"], LCL["NIL"]["G149712"]); single_value();  local l25 = n if n ~= CL["EQ"](LCL["NIL"]["G149712"], l23) then  l25 = n.bound else  l25 = l23 end local l24 = l25; single_value();  single_value();  local l26 = CL["GENSYM"]("object"); local l27 = CL["GENSYM"]("stream"); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l26, CL["CONS"](l12, n)), CL["CONS"](CL["CONS"](l27, CL["CONS"](l16, n)), n)), CL["CONS"](CL["CONS"](CL["PROG2"], CL["CONS"](CL["CONS"](CL["PROGN"], CL["CONS"](CL["CONS"](CL["WRITE-STRING"], CL["CONS"]("#<", CL["CONS"](l27, n))), CL["CONS"](CL["CONS"](CL["WHEN"], CL["CONS"](l21, CL["CONS"](CL["CONS"](CL["WRITE-STRING"], CL["CONS"](CL["CONS"](CL["STRING"], CL["CONS"](CL["CONS"](LCL["CLOSETTE"]["CLASS-NAME"], CL["CONS"](CL["CONS"](LCL["CLOSETTE"]["CLASS-OF"], CL["CONS"](l26, n)), n)), n)), CL["CONS"](l27, n))), n))), CL["CONS"](CL["CONS"](CL["WRITE-STRING"], CL["CONS"](" ", CL["CONS"](l27, n))), n)))), CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(l9,n))), CL["CONS"](CL["CONS"](CL["WRITE-STRING"], CL["CONS"](" ", CL["CONS"](l27, n))), CL["CONS"](CL["CONS"](CL["WRITE-STRING"], CL["CONS"](">", CL["CONS"](l27, n))), n))))), n))) end, 1, 1, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CLOSETTE"]); i( CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["ALLOCATE-STD-INSTANCE"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["SLOTS"],n}},function (l1, l2,  ...)   single_value();  local l3 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-STRUCT"].fbound, {}); local l4 = LCL["CLOSETTE"]["STD-INSTANCE"]; single_value(); l3[CL["IDENTITY"]("name")] = l4 i( l4 );
 local l5 = l1; single_value(); l3[CL["IDENTITY"](LCL["CLOSETTE"]["CLASS"])] = l5 i( l5 );
 local l6 = l2; single_value(); l3[CL["IDENTITY"](LCL["CLOSETTE"]["SLOTS"])] = l6 i( l6 );
 single_value();  return l3 end, 2, 0, false, false)) );
 i( CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["COPY-STD-INSTANCE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l7,  ...)   single_value();  return CL["COPY-STRUCTURE"](l7) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-TYPE-SPECIFIER"](LCL["CLOSETTE"]["STD-INSTANCE"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l8,  ...)   single_value();  return CL_LIB["%CHECK-STRUCT-TYPE"](l8, LCL["CLOSETTE"]["STD-INSTANCE"]) end, 1, 0, false, false), {CL["STRUCTURE-OBJECT"],{CL["T"],n}}) );
 i( CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-INSTANCE-P"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l9,  ...)   single_value();  return CL["TYPEP"](l9, LCL["CLOSETTE"]["STD-INSTANCE"], false) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](LCL["CLOSETTE"]["STD-INSTANCE-CLASS"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l10,  ...)   single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = n.bound; local l15 = n.bound; local l16 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l17 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l19 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l18 = l19; single_value();  single_value();  l11,l12,l13,l14,l15= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l10, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l16 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l17.error ~= n and true then if l17.error == KEYWORD.TAG then  error(l17) else error(l17[1]) end end i( CL["VALUES-LIST"](list_r(l17)) );
 single_value();  local l20 = n.bound; local l21 = n.bound; local l22 = n.bound; local l23 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l24 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l26 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l25 = l26; single_value();  single_value();  l20,l21,l22= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l15, l11, l12), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l23 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l24.error ~= n and true then if l24.error == KEYWORD.TAG then  error(l24) else error(l24[1]) end end i( CL["VALUES-LIST"](list_r(l24)) );
 single_value();  local l27 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l21,l22,CL["LIST"](l(l27)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{LCL["CLOSETTE"]["CLASS"],n}},{CL_LIB["NEW"],n}}}},n}}})),l20,CL["LIST"](l(l27)))),CL["APPEND"](l(CL["LIST"](l(LCL["CLOSETTE"]["STD-INSTANCE-CLASS"])),l20)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-INSTANCE-CLASS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l28,  ...)   single_value();  local l29 = LCL["CLOSETTE"]["CLASS"]; local l30 = n.bound; single_value();  return ((l28)[l29] or l30) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](LCL["CLOSETTE"]["STD-INSTANCE-SLOTS"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l31,  ...)   single_value();  local l32 = n.bound; local l33 = n.bound; local l34 = n.bound; local l35 = n.bound; local l36 = n.bound; local l37 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l38 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l40 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l39 = l40; single_value();  single_value();  l32,l33,l34,l35,l36= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l31, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l37 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l38.error ~= n and true then if l38.error == KEYWORD.TAG then  error(l38) else error(l38[1]) end end i( CL["VALUES-LIST"](list_r(l38)) );
 single_value();  local l41 = n.bound; local l42 = n.bound; local l43 = n.bound; local l44 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l45 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l47 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l46 = l47; single_value();  single_value();  l41,l42,l43= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l36, l32, l33), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l44 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l45.error ~= n and true then if l45.error == KEYWORD.TAG then  error(l45) else error(l45[1]) end end i( CL["VALUES-LIST"](list_r(l45)) );
 single_value();  local l48 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l42,l43,CL["LIST"](l(l48)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{LCL["CLOSETTE"]["SLOTS"],n}},{CL_LIB["NEW"],n}}}},n}}})),l41,CL["LIST"](l(l48)))),CL["APPEND"](l(CL["LIST"](l(LCL["CLOSETTE"]["STD-INSTANCE-SLOTS"])),l41)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-INSTANCE-SLOTS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l49,  ...)   single_value();  local l50 = LCL["CLOSETTE"]["SLOTS"]; local l51 = n.bound; single_value();  return ((l49)[l50] or l51) end, 1, 0, false, false)) );
 single_value();  tmp = LCL["CLOSETTE"]["STD-INSTANCE"]; tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["PRINT-STD-INSTANCE"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["INSTANCE"],{CL["STREAM"],{LCL["CLOSETTE"]["DEPTH"],n}}},function (l1, l2, l3,  ...)   i( n.bound );
 single_value();  return CL["PRINT-OBJECT"](l(l1,l2)) end, 3, 0, false, false)); local l1 = CL["LIST"](l("slot unbound")); single_value();  tmp = CL_LIB.DEF(LCL["CLOSETTE"]["SECRET-UNBOUND-VALUE"],l1); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["INSTANCE-SLOT-P"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SLOT"],n},function (l1,  ...)   single_value();  return CL["EQ"](LCL["CLOSETTE"]["SLOT-DEFINITION-ALLOCATION"](l1), LCL["KEYWORD"]["INSTANCE"]) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-ALLOCATE-INSTANCE"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["ALLOCATE-STD-INSTANCE"](l1, LCL["CLOSETTE"]["ALLOCATE-SLOT-STORAGE"](CL["COUNT-IF"](LCL["CLOSETTE"]["INSTANCE-SLOT-P"].fbound, LCL["CLOSETTE"]["CLASS-SLOTS"](l1), k()), LCL["CLOSETTE"]["SECRET-UNBOUND-VALUE"].bound)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["ALLOCATE-SLOT-STORAGE"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SIZE"],{LCL["CLOSETTE"]["INITIAL-VALUE"],n}},function (l1, l2,  ...)   single_value();  return CL["MAKE-ARRAY"](l1, k(CL_LIB["INITIAL-ELEMENT"], l2)) end, 2, 0, false, false)); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(LCL["CLOSETTE"]["THE-SLOTS-OF-STANDARD-CLASS"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"],l1); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-LOCATION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["SLOT-NAME"],n}},function (l1, l2,  ...)   single_value();  local l4 = n if n ~= CL["EQ"](l2, LCL["CLOSETTE"]["EFFECTIVE-SLOTS"]) then  l4 = CL["EQ"](l1, LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound) else  l4 = n.bound end local l3 = n if n ~= l4 then  l3 = CL["POSITION"](LCL["CLOSETTE"]["EFFECTIVE-SLOTS"], LCL["CLOSETTE"]["THE-SLOTS-OF-STANDARD-CLASS"].bound, k(CL_LIB["KEY"], LCL["CLOSETTE"]["SLOT-DEFINITION-NAME"].fbound)) else  local l5 = CL["FIND"](l2, LCL["CLOSETTE"]["CLASS-SLOTS"](l1), k(CL_LIB["KEY"], LCL["CLOSETTE"]["SLOT-DEFINITION-NAME"].fbound)); single_value();  local l6 = n if n ~= CL["NULL"](l5) then  l6 = CL["ERROR"]("The slot ~S is missing from the class ~S.", l(l2,l1)) else  local l7 = CL["POSITION"](l5, CL["REMOVE-IF-NOT"](LCL["CLOSETTE"]["INSTANCE-SLOT-P"].fbound, LCL["CLOSETTE"]["CLASS-SLOTS"](l1), k()), k()); single_value();  local l8 = n if n ~= CL["NULL"](l7) then  l8 = CL["ERROR"]("The slot ~S is not an instance~@\n                           slot in the class ~S.", l(l2,l1)) else  l8 = l7 end l6 = l8 end l3 = l6 end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-CONTENTS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SLOTS"],{LCL["CLOSETTE"]["LOCATION"],n}},function (l1, l2,  ...)   single_value();  return CL["SVREF"](l1, l2) end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-CONTENTS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["SLOTS"],{LCL["CLOSETTE"]["LOCATION"],n}}},function (l1, l2, l3,  ...)   single_value();  single_value();  local l4 = l3; single_value();  local l5 = l2; single_value();  single_value();  local l6 = l1; single_value();  return CL_LIB["%SETSVREF"](l5, l4, l6) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-SLOT-VALUE"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}},function (l1, l2,  ...)   single_value();  local l3 = LCL["CLOSETTE"]["SLOT-LOCATION"](LCL["CLOSETTE"]["CLASS-OF"](l1), l2); single_value();  local l4 = LCL["CLOSETTE"]["STD-INSTANCE-SLOTS"](l1); single_value();  local l5 = LCL["CLOSETTE"]["SLOT-CONTENTS"](l4, l3); single_value();  single_value();  local l6 = n if n ~= CL["EQ"](LCL["CLOSETTE"]["SECRET-UNBOUND-VALUE"].bound, l5) then  l6 = CL["ERROR"]("The slot ~S is unbound in the object ~S.", l(l2,l1)) else  l6 = l5 end return l6 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-VALUE"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["OBJECT"],{LCL["CLOSETTE"]["SLOT-NAME"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["EQ"](LCL["CLOSETTE"]["CLASS-OF"](LCL["CLOSETTE"]["CLASS-OF"](l1)), LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound) then  l3 = LCL["CLOSETTE"]["STD-SLOT-VALUE"](l1, l2) else  l3 = LCL["CLOSETTE"]["SLOT-VALUE-USING-CLASS"](l(LCL["CLOSETTE"]["CLASS-OF"](l1),l1,l2)) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-SLOT-VALUE"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = LCL["CLOSETTE"]["SLOT-LOCATION"](LCL["CLOSETTE"]["CLASS-OF"](l2), l3); local l5 = LCL["CLOSETTE"]["STD-INSTANCE-SLOTS"](l2); single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-CONTENTS"].setfbound, l(l1,l5,l4)) end, 3, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-VALUE"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["OBJECT"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = n if n ~= CL["EQ"](LCL["CLOSETTE"]["CLASS-OF"](LCL["CLOSETTE"]["CLASS-OF"](l2)), LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound) then  single_value();  l4 = CL["FUNCALL"](LCL["CLOSETTE"]["STD-SLOT-VALUE"].setfbound, l(l1,l2,l3)) else  l4 = LCL["CLOSETTE"]["SETF-SLOT-VALUE-USING-CLASS"](l1, LCL["CLOSETTE"]["CLASS-OF"](l2), l2, l3) end return l4 end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-SLOT-BOUNDP"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}},function (l1, l2,  ...)   single_value();  local l3 = LCL["CLOSETTE"]["SLOT-LOCATION"](LCL["CLOSETTE"]["CLASS-OF"](l1), l2); local l4 = LCL["CLOSETTE"]["STD-INSTANCE-SLOTS"](l1); single_value();  return CL["NOT"](CL["EQ"](LCL["CLOSETTE"]["SECRET-UNBOUND-VALUE"].bound, LCL["CLOSETTE"]["SLOT-CONTENTS"](l4, l3))) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-BOUNDP"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["OBJECT"],{LCL["CLOSETTE"]["SLOT-NAME"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["EQ"](LCL["CLOSETTE"]["CLASS-OF"](LCL["CLOSETTE"]["CLASS-OF"](l1)), LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound) then  l3 = LCL["CLOSETTE"]["STD-SLOT-BOUNDP"](l1, l2) else  l3 = LCL["CLOSETTE"]["SLOT-BOUNDP-USING-CLASS"](l(LCL["CLOSETTE"]["CLASS-OF"](l1),l1,l2)) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-SLOT-MAKUNBOUND"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}},function (l1, l2,  ...)   local l3 = LCL["CLOSETTE"]["SLOT-LOCATION"](LCL["CLOSETTE"]["CLASS-OF"](l1), l2); local l4 = LCL["CLOSETTE"]["STD-INSTANCE-SLOTS"](l1); single_value();  single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-CONTENTS"].setfbound, l(LCL["CLOSETTE"]["SECRET-UNBOUND-VALUE"].bound,l4,l3)) );
 single_value();  return l1 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-MAKUNBOUND"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["OBJECT"],{LCL["CLOSETTE"]["SLOT-NAME"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["EQ"](LCL["CLOSETTE"]["CLASS-OF"](LCL["CLOSETTE"]["CLASS-OF"](l1)), LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound) then  l3 = LCL["CLOSETTE"]["STD-SLOT-MAKUNBOUND"](l1, l2) else  l3 = LCL["CLOSETTE"]["SLOT-MAKUNBOUND-USING-CLASS"](l(LCL["CLOSETTE"]["CLASS-OF"](l1),l1,l2)) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-SLOT-EXISTS-P"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}},function (l1, l2,  ...)   single_value();  return CL["NOT"](CL["NULL"](CL["FIND"](l2, LCL["CLOSETTE"]["CLASS-SLOTS"](LCL["CLOSETTE"]["CLASS-OF"](l1)), k(CL_LIB["KEY"], LCL["CLOSETTE"]["SLOT-DEFINITION-NAME"].fbound)))) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-EXISTS-P"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["OBJECT"],{LCL["CLOSETTE"]["SLOT-NAME"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["EQ"](LCL["CLOSETTE"]["CLASS-OF"](LCL["CLOSETTE"]["CLASS-OF"](l1)), LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound) then  l3 = LCL["CLOSETTE"]["STD-SLOT-EXISTS-P"](l1, l2) else  l3 = LCL["CLOSETTE"]["SLOT-EXISTS-P-USING-CLASS"](l(LCL["CLOSETTE"]["CLASS-OF"](l1),l1,l2)) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CLASS-OF"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["X"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= LCL["CLOSETTE"]["STD-INSTANCE-P"](l1) then  l2 = LCL["CLOSETTE"]["STD-INSTANCE-CLASS"](l1) else  l2 = LCL["CLOSETTE"]["BUILT-IN-CLASS-OF"](l1) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["BUILT-IN-CLASS-OF"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["X"],n},function (l1,  ...)   single_value();  local l2 = l1; single_value();  local l3 = n if n ~= CL["TYPEP"](l2, CL["NULL"], false) then  single_value();  l3 = LCL["CLOSETTE"]["FIND-CLASS"](CL["NULL"], false) else  local l4 = n if n ~= CL["TYPEP"](l2, {CL["AND"],{CL["SYMBOL"],{{CL["NOT"],{CL["NULL"],n}},n}}}, false) then  single_value();  l4 = LCL["CLOSETTE"]["FIND-CLASS"](CL["SYMBOL"], false) else  local l5 = n if n ~= CL["TYPEP"](l2, {CL["COMPLEX"],{CL["*"],n}}, false) then  single_value();  l5 = LCL["CLOSETTE"]["FIND-CLASS"](CL["COMPLEX"], false) else  local l6 = n if n ~= CL["TYPEP"](l2, {CL["INTEGER"],{CL["*"],{CL["*"],n}}}, false) then  single_value();  l6 = LCL["CLOSETTE"]["FIND-CLASS"](CL["INTEGER"], false) else  local l7 = n if n ~= CL["TYPEP"](l2, {CL["FLOAT"],{CL["*"],{CL["*"],n}}}, false) then  single_value();  l7 = LCL["CLOSETTE"]["FIND-CLASS"](CL["FLOAT"], false) else  local l8 = n if n ~= CL["TYPEP"](l2, CL["CONS"], false) then  single_value();  l8 = LCL["CLOSETTE"]["FIND-CLASS"](CL["CONS"], false) else  local l9 = n if n ~= CL["TYPEP"](l2, CL["CHARACTER"], false) then  single_value();  l9 = LCL["CLOSETTE"]["FIND-CLASS"](CL["CHARACTER"], false) else  local l10 = n if n ~= CL["TYPEP"](l2, CL["HASH-TABLE"], false) then  single_value();  l10 = LCL["CLOSETTE"]["FIND-CLASS"](CL["HASH-TABLE"], false) else  local l11 = n if n ~= CL["TYPEP"](l2, CL["PACKAGE"], false) then  single_value();  l11 = LCL["CLOSETTE"]["FIND-CLASS"](CL["PACKAGE"], false) else  local l12 = n if n ~= CL["TYPEP"](l2, CL["PATHNAME"], false) then  single_value();  l12 = LCL["CLOSETTE"]["FIND-CLASS"](CL["PATHNAME"], false) else  local l13 = n if n ~= CL["TYPEP"](l2, CL["READTABLE"], false) then  single_value();  l13 = LCL["CLOSETTE"]["FIND-CLASS"](CL["READTABLE"], false) else  local l14 = n if n ~= CL["TYPEP"](l2, CL["STREAM"], false) then  single_value();  l14 = LCL["CLOSETTE"]["FIND-CLASS"](CL["STREAM"], false) else  local l15 = n if n ~= CL["TYPEP"](l2, {CL["AND"],{CL["NUMBER"],{{CL["NOT"],{{CL["OR"],{CL["INTEGER"],{CL["COMPLEX"],{CL["FLOAT"],n}}}},n}},n}}}, false) then  single_value();  l15 = LCL["CLOSETTE"]["FIND-CLASS"](CL["NUMBER"], false) else  local l16 = n if n ~= CL["TYPEP"](l2, {CL["STRING"],{CL["*"],n}}, false) then  single_value();  l16 = LCL["CLOSETTE"]["FIND-CLASS"](CL["STRING"], false) else  local l17 = n if n ~= CL["TYPEP"](l2, {LCL["CLOSETTE"]["BIT-VECTOR"],{CL["*"],n}}, false) then  single_value();  l17 = LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["BIT-VECTOR"], false) else  local l18 = n if n ~= CL["TYPEP"](l2, {CL["AND"],{{CL["VECTOR"],{CL["*"],{CL["*"],n}}},{{CL["NOT"],{{CL["OR"],{CL["STRING"],{CL["VECTOR"],n}}},n}},n}}}, false) then  single_value();  l18 = LCL["CLOSETTE"]["FIND-CLASS"](CL["VECTOR"], false) else  local l19 = n if n ~= CL["TYPEP"](l2, {CL["AND"],{{CL["ARRAY"],{CL["*"],{CL["*"],n}}},{{CL["NOT"],{CL["VECTOR"],n}},n}}}, false) then  single_value();  l19 = LCL["CLOSETTE"]["FIND-CLASS"](CL["ARRAY"], false) else  local l20 = n if n ~= CL["TYPEP"](l2, {CL["AND"],{CL["SEQUENCE"],{{CL["NOT"],{{CL["OR"],{CL["VECTOR"],{CL["LIST"],n}}},n}},n}}}, false) then  single_value();  l20 = LCL["CLOSETTE"]["FIND-CLASS"](CL["SEQUENCE"], false) else  local l21 = n if n ~= CL["TYPEP"](l2, CL["FUNCTION"], false) then  single_value();  l21 = LCL["CLOSETTE"]["FIND-CLASS"](CL["FUNCTION"], false) else  local l22 = n if n ~= CL["TYPEP"](l2, CL["T"], false) then  single_value();  l22 = LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false) else  l22 = n.bound end l21 = l22 end l20 = l21 end l19 = l20 end l18 = l19 end l17 = l18 end l16 = l17 end l15 = l16 end l14 = l15 end l13 = l14 end l12 = l13 end l11 = l12 end l10 = l11 end l9 = l10 end l8 = l9 end l7 = l8 end l6 = l7 end l5 = l6 end l4 = l5 end l3 = l4 end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SUBCLASSP"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["C1"],{LCL["CLOSETTE"]["C2"],n}},function (l1, l2,  ...)   single_value();  return CL["NOT"](CL["NULL"](CL["FIND"](l2, LCL["CLOSETTE"]["CLASS-PRECEDENCE-LIST"](l1), k()))) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SUB-SPECIALIZER-P"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["C1"],{LCL["CLOSETTE"]["C2"],{LCL["CLOSETTE"]["C-ARG"],n}}},function (l1, l2, l3,  ...)   single_value();  local l5 = n if n ~= CL["LISTP"](l1) then  l5 = CL["LISTP"](l2) else  l5 = n.bound end local l4 = n if n ~= l5 then  single_value();  l4 = n.bound else  local l6 = n if n ~= CL["LISTP"](l1) then  single_value();  l6 = CL["T"].bound else  local l7 = n if n ~= CL["LISTP"](l2) then  single_value();  l7 = n.bound else  local l8 = n if n ~= CL["T"].bound then  single_value();  local l9 = LCL["CLOSETTE"]["CLASS-PRECEDENCE-LIST"](l3); single_value();  l8 = CL["NOT"](CL["NULL"](CL["FIND"](l2, (CL["MEMBER"](l1, l9, k()))[2], k()))) else  l8 = n.bound end l7 = l8 end l6 = l7 end l4 = l6 end return l4 end, 3, 0, false, false)); local l1 = {LCL["CLOSETTE"]["DEFCLASS"],{LCL["CLOSETTE"]["STANDARD-CLASS"],{n,{{{LCL["CLOSETTE"]["NAME"],{LCL["KEYWORD"]["INITARG"],{LCL["KEYWORD"]["NAME"],n}}},{{LCL["CLOSETTE"]["DIRECT-SUPERCLASSES"],{LCL["KEYWORD"]["INITARG"],{LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],n}}},{{LCL["CLOSETTE"]["DIRECT-SLOTS"],n},{{LCL["CLOSETTE"]["CLASS-PRECEDENCE-LIST"],n},{{LCL["CLOSETTE"]["EFFECTIVE-SLOTS"],n},{{LCL["CLOSETTE"]["DIRECT-SUBCLASSES"],{LCL["KEYWORD"]["INITFORM"],{n,n}}},{{LCL["CLOSETTE"]["DIRECT-METHODS"],{LCL["KEYWORD"]["INITFORM"],{n,n}}},n}}}}}}},n}}}}; single_value();  tmp = CL_LIB.DEF(LCL["CLOSETTE"]["THE-DEFCLASS-STANDARD-CLASS"],l1); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CLASS-NAME"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["STD-SLOT-VALUE"](l1, LCL["CLOSETTE"]["NAME"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["CLASS-NAME"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["CLASS"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["NAME"])) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CLASS-DIRECT-SUPERCLASSES"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["DIRECT-SUPERCLASSES"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["CLASS-DIRECT-SUPERCLASSES"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["CLASS"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["DIRECT-SUPERCLASSES"])) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CLASS-DIRECT-SLOTS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["DIRECT-SLOTS"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["CLASS-DIRECT-SLOTS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["CLASS"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["DIRECT-SLOTS"])) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CLASS-PRECEDENCE-LIST"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["CLASS-PRECEDENCE-LIST"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["CLASS-PRECEDENCE-LIST"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["CLASS"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["CLASS-PRECEDENCE-LIST"])) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CLASS-SLOTS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["EFFECTIVE-SLOTS"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["CLASS-SLOTS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["CLASS"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["EFFECTIVE-SLOTS"])) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CLASS-DIRECT-SUBCLASSES"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["DIRECT-SUBCLASSES"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["CLASS-DIRECT-SUBCLASSES"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["CLASS"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["DIRECT-SUBCLASSES"])) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CLASS-DIRECT-METHODS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["DIRECT-METHODS"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["CLASS-DIRECT-METHODS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["CLASS"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["DIRECT-METHODS"])) end, 2, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](LCL["CLOSETTE"]["DEFCLASS"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G157206"],{CL["&OPTIONAL"],{LCL["NIL"]["G157207"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l14 = l4; single_value();  local l15 = (l14)[1]; single_value();  single_value();  local l16 = (l14)[2]; single_value();  l4 = l16 i( l4 );
 single_value();  local l13 = l15; single_value();  local l17 = l4; single_value();  single_value();  return CL["CONS"](LCL["CLOSETTE"]["ENSURE-CLASS"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), CL["CONS"](LCL["KEYWORD"]["DIRECT-SUPERCLASSES"], CL["CONS"](LCL["CLOSETTE"]["CANONICALIZE-DIRECT-SUPERCLASSES"](l9), CL["CONS"](LCL["KEYWORD"]["DIRECT-SLOTS"], CL["CONS"](LCL["CLOSETTE"]["CANONICALIZE-DIRECT-SLOTS"](l13), CL["APPEND"](l(LCL["CLOSETTE"]["CANONICALIZE-DEFCLASS-OPTIONS"](l17),n)))))))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CANONICALIZE-DIRECT-SUPERCLASSES"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["DIRECT-SUPERCLASSES"],n},function (l1,  ...)   single_value();  return CL["CONS"](CL["LIST"], CL["APPEND"](l(CL["MAPCAR"](LCL["CLOSETTE"]["CANONICALIZE-DIRECT-SUPERCLASS"].fbound, l(l1)),n))) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CANONICALIZE-DIRECT-SUPERCLASS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS-NAME"],n},function (l1,  ...)   single_value();  return CL["CONS"](LCL["CLOSETTE"]["FIND-CLASS"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l1, n)), n)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CANONICALIZE-DEFCLASS-OPTIONS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["OPTIONS"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["MAPAPPEND"](LCL["CLOSETTE"]["CANONICALIZE-DEFCLASS-OPTION"].fbound, l(l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CANONICALIZE-DIRECT-SLOTS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["DIRECT-SLOTS"],n},function (l1,  ...)   single_value();  return CL["CONS"](CL["LIST"], CL["APPEND"](l(CL["MAPCAR"](LCL["CLOSETTE"]["CANONICALIZE-DIRECT-SLOT"].fbound, l(l1)),n))) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CANONICALIZE-DIRECT-SLOT"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SPEC"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["SYMBOLP"](l1) then  l2 = CL["CONS"](CL["LIST"], CL["CONS"](LCL["KEYWORD"]["NAME"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l1, n)), n))) else  local l3 = (l1)[1]; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = n.bound; local l8 = n.bound; local l9 = n.bound; local l10 = (l1)[2]; single_value();  local l11 = CL["GENSYM"](false); single_value();  local l12 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  local l13 = n if n ~= CL["NULL"](l10) then  single_value(); do break end; l13 = n.bound else  l13 = n.bound end i( l13 );
 local l14 = (l10)[1]; single_value();  local l15 = n if n ~= CL["EQL"](l14, LCL["KEYWORD"]["INITFORM"]) then  l4 = CL["CONS"](CL["FUNCTION"], CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](n, CL["CONS"](CL["CADR"](l10), n))), n)) i( l4 );
 single_value();  l5 = CL["CONS"](CL["QUOTE"], CL["CONS"](CL["CADR"](l10), n)) l15 = l5 else  local l16 = n if n ~= CL["EQL"](l14, LCL["KEYWORD"]["INITARG"]) then  single_value();  single_value();  single_value();  local l17 = CL["NCONC"](l(l6,CL["LIST"](l(CL["CADR"](l10))))); single_value();  l6 = l17 l16 = l6 else  local l18 = n if n ~= CL["EQL"](l14, LCL["KEYWORD"]["READER"]) then  single_value();  single_value();  single_value();  local l19 = CL["NCONC"](l(l7,CL["LIST"](l(CL["CADR"](l10))))); single_value();  l7 = l19 l18 = l7 else  local l20 = n if n ~= CL["EQL"](l14, LCL["KEYWORD"]["WRITER"]) then  single_value();  single_value();  single_value();  local l21 = CL["NCONC"](l(l8,CL["LIST"](l(CL["CADR"](l10))))); single_value();  l8 = l21 l20 = l8 else  local l22 = n if n ~= CL["EQL"](l14, LCL["KEYWORD"]["ACCESSOR"]) then  single_value();  single_value();  local l23 = CL["NCONC"](l(l7,CL["LIST"](l(CL["CADR"](l10))))); single_value();  l7 = l23 i( l7 );
 single_value();  single_value();  single_value();  local l24 = CL["NCONC"](l(l8,CL["LIST"](l(CL["CONS"](CL["SETF"], CL["CONS"](CL["CADR"](l10), n)))))); single_value();  l8 = l24 l22 = l8 else  local l25 = n if n ~= CL["T"].bound then  single_value();  single_value();  local l26 = CL["NCONC"](l(l9,CL["LIST"](l(CL["CONS"](CL["QUOTE"], CL["CONS"]((l10)[1], n)))))); single_value();  l9 = l26 i( l9 );
 single_value();  single_value();  single_value();  local l27 = CL["NCONC"](l(l9,CL["LIST"](l(CL["CONS"](CL["QUOTE"], CL["CONS"](CL["CADR"](l10), n)))))); single_value();  l9 = l27 l25 = l9 else  l25 = n.bound end l22 = l25 end l20 = l22 end l18 = l20 end l16 = l18 end l15 = l16 end i( l15 );
 single_value();  local l28 = CL["CDDR"](l10); single_value();  single_value();  single_value();  local l29 = l28; single_value();  l10 = l29 local tmpres = l10 end return n end, 0, 0, false, false))); single_value(); if l12.error ~= n and (l12.error ~= KEYWORD.TAG or l12.tag ~= l11) then if l12.error == KEYWORD.TAG then  error(l12) else error(l12[1]) end end i( CL["VALUES-LIST"](list_r(l12)) );
 single_value();  local l30 = n if n ~= l4 then  single_value();  l30 = CL["CONS"](LCL["KEYWORD"]["INITFORM"], CL["CONS"](l5, CL["CONS"](LCL["KEYWORD"]["INITFUNCTION"], CL["CONS"](l4, n)))) else  l30 = n.bound end local l31 = n if n ~= l6 then  single_value();  l31 = CL["CONS"](LCL["KEYWORD"]["INITARGS"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l6, n)), n)) else  l31 = n.bound end local l32 = n if n ~= l7 then  single_value();  l32 = CL["CONS"](LCL["KEYWORD"]["READERS"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l7, n)), n)) else  l32 = n.bound end local l33 = n if n ~= l8 then  single_value();  l33 = CL["CONS"](LCL["KEYWORD"]["WRITERS"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l8, n)), n)) else  l33 = n.bound end l2 = CL["CONS"](CL["LIST"], CL["CONS"](LCL["KEYWORD"]["NAME"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l3, n)), CL["APPEND"](l(l30,CL["APPEND"](l(l31,CL["APPEND"](l(l32,CL["APPEND"](l(l33,CL["APPEND"](l(l9,n))))))))))))) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CANONICALIZE-DEFCLASS-OPTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["OPTION"],n},function (l1,  ...)   single_value();  local l2 = (l1)[1]; single_value();  local l3 = n if n ~= CL["EQL"](l2, LCL["KEYWORD"]["METACLASS"]) then  single_value();  l3 = CL["LIST"](l(LCL["KEYWORD"]["METACLASS"],CL["CONS"](LCL["CLOSETTE"]["FIND-CLASS"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["CADR"](l1), n)), n)))) else  local l4 = n if n ~= CL["EQL"](l2, LCL["KEYWORD"]["DEFAULT-INITARGS"]) then  single_value();  l4 = CL["LIST"](l(LCL["KEYWORD"]["DIRECT-DEFAULT-INITARGS"],CL["CONS"](CL["LIST"], CL["APPEND"](l(LCL["CLOSETTE"]["MAPAPPEND"](CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["X"],n},function (l5,  ...)   single_value();  return l5 end, 1, 0, false, false), l(LCL["CLOSETTE"]["MAPPLIST"](CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["KEY"],{LCL["CLOSETTE"]["VALUE"],n}},function (l6, l7,  ...)   single_value();  return CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l6, n)), CL["CONS"](l7, n)) end, 2, 0, false, false), (l1)[2]))),n))))) else  local l8 = n if n ~= CL["T"].bound then  single_value();  l8 = CL["LIST"](l(CL["CONS"](CL["QUOTE"], CL["CONS"]((l1)[1], n)),CL["CONS"](CL["QUOTE"], CL["CONS"](CL["CADR"](l1), n)))) else  l8 = n.bound end l4 = l8 end l3 = l4 end return l3 end, 1, 0, false, false)); local l1 = CL["MAKE-HASH-TABLE"](k(CL_LIB["TEST"], CL["EQ"].fbound)); single_value();  tmp = CL_LIB.DEF(LCL["CLOSETTE"]["*CLASS-TABLE*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["FIND-CLASS"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],{CL["&OPTIONAL"],{{LCL["CLOSETTE"]["ERRORP"],{CL["T"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["T"].bound end  single_value();  local l3 = CL["GETHASH"](l1, LCL["CLOSETTE"]["*CLASS-TABLE*"].bound, n.bound); single_value();  local l5 = n if n ~= CL["NULL"](l3) then  l5 = l2 else  l5 = n.bound end local l4 = n if n ~= l5 then  l4 = CL["ERROR"]("No class named ~S.", l(l1)) else  l4 = l3 end return l4 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["%SET-FIND-CLASS"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],{LCL["CLOSETTE"]["NEW-VALUE"],n}},function (l1, l2,  ...)   single_value();  single_value();  local l3 = LCL["CLOSETTE"]["*CLASS-TABLE*"].bound; single_value();  local l4 = l1; single_value();  single_value();  local l5 = l2; single_value();  return CL_LIB["SETHASH"](l4, l3, l5) end, 2, 0, false, false)); tmp = CL_LIB["%REGISTER-SETF-EXPANDER"](LCL["CLOSETTE"]["FIND-CLASS"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l2,l3,l4,l5,l6= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l1, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l11,l12,l13= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l6, l2, l3), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l12,l13,CL["LIST"](l(l18)),CL["APPEND"](l(CL["LIST"](l(LCL["CLOSETTE"]["%SET-FIND-CLASS"])),l11,CL["LIST"](l(l18)))),CL["APPEND"](l(CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"])),l11)))) end, 0, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["FORGET-ALL-CLASSES"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   i( CL["CLRHASH"](LCL["CLOSETTE"]["*CLASS-TABLE*"].bound) );
 single_value();  return CL["VALUES"](l()) end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["ENSURE-CLASS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NAME"],{CL["&REST"],{LCL["CLOSETTE"]["ALL-KEYS"],{CL["&KEY"],{{LCL["CLOSETTE"]["METACLASS"],{LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"],n}},{CL["&ALLOW-OTHER-KEYS"],n}}}}}},function (l1, l2, keys,  ...)  if not keys[LCL["CLOSETTE"]["METACLASS"]] then  keys[LCL["CLOSETTE"]["METACLASS"]] = LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound end  single_value();  local l3 = n if n ~= LCL["CLOSETTE"]["FIND-CLASS"](l1, n.bound) then  i( CL["WARN"]("Can't redefine the class named ~S.", l(l1)) );
 single_value();  l3 = LCL["CLOSETTE"]["FIND-CLASS"](l1, n.bound) else  local l5 = n if n ~= CL["EQ"](keys[LCL["CLOSETTE"]["METACLASS"]], LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound) then  l5 = LCL["CLOSETTE"]["MAKE-INSTANCE-STANDARD-CLASS"].fbound else  l5 = LCL["CLOSETTE"]["MAKE-INSTANCE"].fbound end local l4 = CL["APPLY"](l5, keys[LCL["CLOSETTE"]["METACLASS"]], l(LCL["KEYWORD"]["NAME"],l1,l2)); single_value();  local l6 = l1; single_value();  single_value();  local l7 = l4; single_value();  i( LCL["CLOSETTE"]["%SET-FIND-CLASS"](l6, l7) );
 single_value();  l3 = l4 end return l3 end, 1, 0, true, {0 , [LCL["KEYWORD"]["METACLASS"]] = LCL["CLOSETTE"]["METACLASS"]})); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["MAKE-INSTANCE-STANDARD-CLASS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METACLASS"],{CL["&KEY"],{LCL["CLOSETTE"]["NAME"],{LCL["CLOSETTE"]["DIRECT-SUPERCLASSES"],{LCL["CLOSETTE"]["DIRECT-SLOTS"],{CL["&ALLOW-OTHER-KEYS"],n}}}}}},function (l1, keys,  ...)  if not keys[LCL["CLOSETTE"]["NAME"]] then  keys[LCL["CLOSETTE"]["NAME"]] = n.bound end if not keys[LCL["CLOSETTE"]["DIRECT-SUPERCLASSES"]] then  keys[LCL["CLOSETTE"]["DIRECT-SUPERCLASSES"]] = n.bound end if not keys[LCL["CLOSETTE"]["DIRECT-SLOTS"]] then  keys[LCL["CLOSETTE"]["DIRECT-SLOTS"]] = n.bound end  i( n.bound );
 single_value();  local l2 = LCL["CLOSETTE"]["STD-ALLOCATE-INSTANCE"](LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound); single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-NAME"].setfbound, l(keys[LCL["CLOSETTE"]["NAME"]],l2)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-DIRECT-SUBCLASSES"].setfbound, l(n.bound,l2)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-DIRECT-METHODS"].setfbound, l(n.bound,l2)) );
 i( LCL["CLOSETTE"]["STD-AFTER-INITIALIZATION-FOR-CLASSES"](l2, k(LCL["CLOSETTE"]["DIRECT-SLOTS"], keys[LCL["CLOSETTE"]["DIRECT-SLOTS"]], LCL["CLOSETTE"]["DIRECT-SUPERCLASSES"], keys[LCL["CLOSETTE"]["DIRECT-SUPERCLASSES"]])) );
 single_value();  return l2 end, 1, 0, false, {0 , [LCL["KEYWORD"]["NAME"]] = LCL["CLOSETTE"]["NAME"], [LCL["KEYWORD"]["DIRECT-SUPERCLASSES"]] = LCL["CLOSETTE"]["DIRECT-SUPERCLASSES"], [LCL["KEYWORD"]["DIRECT-SLOTS"]] = LCL["CLOSETTE"]["DIRECT-SLOTS"]})); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-AFTER-INITIALIZATION-FOR-CLASSES"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],{CL["&KEY"],{LCL["CLOSETTE"]["DIRECT-SUPERCLASSES"],{LCL["CLOSETTE"]["DIRECT-SLOTS"],{CL["&ALLOW-OTHER-KEYS"],n}}}}},function (l1, keys,  ...)  if not keys[LCL["CLOSETTE"]["DIRECT-SUPERCLASSES"]] then  keys[LCL["CLOSETTE"]["DIRECT-SUPERCLASSES"]] = n.bound end if not keys[LCL["CLOSETTE"]["DIRECT-SLOTS"]] then  keys[LCL["CLOSETTE"]["DIRECT-SLOTS"]] = n.bound end  local l3 = keys[LCL["CLOSETTE"]["DIRECT-SUPERCLASSES"]]; single_value();  local l4 = n if n ~= l3 then  l4 = l3 else  l4 = CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-OBJECT"], false))) end local l2 = l4; single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-DIRECT-SUPERCLASSES"].setfbound, l(l2,l1)) );
 single_value();  local l5 = l2; single_value();  local l6 = (l5)[1]; single_value();  single_value();  local l7 = CL["GENSYM"](false); single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l9 = n if n ~= CL["NOT"](l5) then  single_value(); do break end; l9 = n.bound else  l9 = n.bound end i( l9 );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-DIRECT-SUBCLASSES"].setfbound, l(CL["CONS"](l1, LCL["CLOSETTE"]["CLASS-DIRECT-SUBCLASSES"](l6)),l6)) );
 single_value();  single_value();  local l10 = (l5)[2]; single_value();  l5 = l10 i( l5 );
 single_value();  single_value();  single_value();  local l11 = (l5)[1]; single_value();  l6 = l11 local tmpres = l6 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l8.error ~= n and (l8.error ~= KEYWORD.TAG or l8.tag ~= l7) then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 local l12 = CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SLOT-PROPERTIES"],n},function (l13,  ...)   single_value();  return CL["APPLY"](LCL["CLOSETTE"]["MAKE-DIRECT-SLOT-DEFINITION"].fbound, l13, l()) end, 1, 0, false, false), l(keys[LCL["CLOSETTE"]["DIRECT-SLOTS"]])); single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-DIRECT-SLOTS"].setfbound, l(l12,l1)) );
 single_value();  local l14 = l12; single_value();  local l15 = (l14)[1]; single_value();  single_value();  local l16 = CL["GENSYM"](false); single_value();  local l17 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l18 = n if n ~= CL["NOT"](l14) then  single_value(); do break end; l18 = n.bound else  l18 = n.bound end i( l18 );
 local l19 = LCL["CLOSETTE"]["SLOT-DEFINITION-READERS"](l15); single_value();  local l20 = (l19)[1]; single_value();  single_value();  local l21 = CL["GENSYM"](false); single_value();  local l22 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l23 = n if n ~= CL["NOT"](l19) then  single_value(); do break end; l23 = n.bound else  l23 = n.bound end i( l23 );
 i( LCL["CLOSETTE"]["ADD-READER-METHOD"](l1, l20, LCL["CLOSETTE"]["SLOT-DEFINITION-NAME"](l15)) );
 single_value();  single_value();  local l24 = (l19)[2]; single_value();  l19 = l24 i( l19 );
 single_value();  single_value();  single_value();  local l25 = (l19)[1]; single_value();  l20 = l25 local tmpres = l20 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l22.error ~= n and (l22.error ~= KEYWORD.TAG or l22.tag ~= l21) then if l22.error == KEYWORD.TAG then  error(l22) else error(l22[1]) end end i( CL["VALUES-LIST"](list_r(l22)) );
 local l26 = LCL["CLOSETTE"]["SLOT-DEFINITION-WRITERS"](l15); single_value();  local l27 = (l26)[1]; single_value();  single_value();  local l28 = CL["GENSYM"](false); single_value();  local l29 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l30 = n if n ~= CL["NOT"](l26) then  single_value(); do break end; l30 = n.bound else  l30 = n.bound end i( l30 );
 i( LCL["CLOSETTE"]["ADD-WRITER-METHOD"](l1, l27, LCL["CLOSETTE"]["SLOT-DEFINITION-NAME"](l15)) );
 single_value();  single_value();  local l31 = (l26)[2]; single_value();  l26 = l31 i( l26 );
 single_value();  single_value();  single_value();  local l32 = (l26)[1]; single_value();  l27 = l32 local tmpres = l27 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l29.error ~= n and (l29.error ~= KEYWORD.TAG or l29.tag ~= l28) then if l29.error == KEYWORD.TAG then  error(l29) else error(l29[1]) end end i( CL["VALUES-LIST"](list_r(l29)) );
 single_value();  single_value();  local l33 = (l14)[2]; single_value();  l14 = l33 i( l14 );
 single_value();  single_value();  single_value();  local l34 = (l14)[1]; single_value();  l15 = l34 local tmpres = l15 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l17.error ~= n and (l17.error ~= KEYWORD.TAG or l17.tag ~= l16) then if l17.error == KEYWORD.TAG then  error(l17) else error(l17[1]) end end i( CL["VALUES-LIST"](list_r(l17)) );
 local l35 = n if n ~= CL["EQ"](LCL["CLOSETTE"]["CLASS-OF"](l1), LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound) then  l35 = LCL["CLOSETTE"]["STD-FINALIZE-INHERITANCE"].fbound else  l35 = LCL["CLOSETTE"]["FINALIZE-INHERITANCE"].fbound end i( CL["FUNCALL"](l35, l(l1)) );
 single_value();  return CL["VALUES"](l()) end, 1, 0, false, {0 , [LCL["KEYWORD"]["DIRECT-SUPERCLASSES"]] = LCL["CLOSETTE"]["DIRECT-SUPERCLASSES"], [LCL["KEYWORD"]["DIRECT-SLOTS"]] = LCL["CLOSETTE"]["DIRECT-SLOTS"]})); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["MAKE-DIRECT-SLOT-DEFINITION"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{LCL["CLOSETTE"]["PROPERTIES"],{CL["&KEY"],{LCL["CLOSETTE"]["NAME"],{{LCL["CLOSETTE"]["INITARGS"],{n,n}},{{LCL["CLOSETTE"]["INITFORM"],{n,n}},{{LCL["CLOSETTE"]["INITFUNCTION"],{n,n}},{{LCL["CLOSETTE"]["READERS"],{n,n}},{{LCL["CLOSETTE"]["WRITERS"],{n,n}},{{LCL["CLOSETTE"]["ALLOCATION"],{LCL["KEYWORD"]["INSTANCE"],n}},{CL["&ALLOW-OTHER-KEYS"],n}}}}}}}}}}},function (l1, keys,  ...)  if not keys[LCL["CLOSETTE"]["NAME"]] then  keys[LCL["CLOSETTE"]["NAME"]] = n.bound end if not keys[LCL["CLOSETTE"]["INITARGS"]] then  keys[LCL["CLOSETTE"]["INITARGS"]] = n.bound end if not keys[LCL["CLOSETTE"]["INITFORM"]] then  keys[LCL["CLOSETTE"]["INITFORM"]] = n.bound end if not keys[LCL["CLOSETTE"]["INITFUNCTION"]] then  keys[LCL["CLOSETTE"]["INITFUNCTION"]] = n.bound end if not keys[LCL["CLOSETTE"]["READERS"]] then  keys[LCL["CLOSETTE"]["READERS"]] = n.bound end if not keys[LCL["CLOSETTE"]["WRITERS"]] then  keys[LCL["CLOSETTE"]["WRITERS"]] = n.bound end if not keys[LCL["CLOSETTE"]["ALLOCATION"]] then  keys[LCL["CLOSETTE"]["ALLOCATION"]] = LCL["KEYWORD"]["INSTANCE"] end  single_value();  local l2 = CL["COPY-LIST"](l1); single_value();  local l3 = LCL["KEYWORD"]["NAME"]; single_value();  local l4 = l2; single_value();  single_value();  local l5 = keys[LCL["CLOSETTE"]["NAME"]]; single_value();  i( LCL["CLOSETTE"]["SETGETF*"](l4, l3, l5) );
 single_value();  local l6 = LCL["KEYWORD"]["INITARGS"]; single_value();  local l7 = l2; single_value();  single_value();  local l8 = keys[LCL["CLOSETTE"]["INITARGS"]]; single_value();  i( LCL["CLOSETTE"]["SETGETF*"](l7, l6, l8) );
 single_value();  local l9 = LCL["KEYWORD"]["INITFORM"]; single_value();  local l10 = l2; single_value();  single_value();  local l11 = keys[LCL["CLOSETTE"]["INITFORM"]]; single_value();  i( LCL["CLOSETTE"]["SETGETF*"](l10, l9, l11) );
 single_value();  local l12 = LCL["KEYWORD"]["INITFUNCTION"]; single_value();  local l13 = l2; single_value();  single_value();  local l14 = keys[LCL["CLOSETTE"]["INITFUNCTION"]]; single_value();  i( LCL["CLOSETTE"]["SETGETF*"](l13, l12, l14) );
 single_value();  local l15 = LCL["KEYWORD"]["READERS"]; single_value();  local l16 = l2; single_value();  single_value();  local l17 = keys[LCL["CLOSETTE"]["READERS"]]; single_value();  i( LCL["CLOSETTE"]["SETGETF*"](l16, l15, l17) );
 single_value();  local l18 = LCL["KEYWORD"]["WRITERS"]; single_value();  local l19 = l2; single_value();  single_value();  local l20 = keys[LCL["CLOSETTE"]["WRITERS"]]; single_value();  i( LCL["CLOSETTE"]["SETGETF*"](l19, l18, l20) );
 single_value();  local l21 = LCL["KEYWORD"]["ALLOCATION"]; single_value();  local l22 = l2; single_value();  single_value();  local l23 = keys[LCL["CLOSETTE"]["ALLOCATION"]]; single_value();  i( LCL["CLOSETTE"]["SETGETF*"](l22, l21, l23) );
 single_value();  return l2 end, 0, 0, true, {0 , [LCL["KEYWORD"]["NAME"]] = LCL["CLOSETTE"]["NAME"], [LCL["KEYWORD"]["INITARGS"]] = LCL["CLOSETTE"]["INITARGS"], [LCL["KEYWORD"]["INITFORM"]] = LCL["CLOSETTE"]["INITFORM"], [LCL["KEYWORD"]["INITFUNCTION"]] = LCL["CLOSETTE"]["INITFUNCTION"], [LCL["KEYWORD"]["READERS"]] = LCL["CLOSETTE"]["READERS"], [LCL["KEYWORD"]["WRITERS"]] = LCL["CLOSETTE"]["WRITERS"], [LCL["KEYWORD"]["ALLOCATION"]] = LCL["CLOSETTE"]["ALLOCATION"]})); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["MAKE-EFFECTIVE-SLOT-DEFINITION"] , CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{LCL["CLOSETTE"]["PROPERTIES"],{CL["&KEY"],{LCL["CLOSETTE"]["NAME"],{{LCL["CLOSETTE"]["INITARGS"],{n,n}},{{LCL["CLOSETTE"]["INITFORM"],{n,n}},{{LCL["CLOSETTE"]["INITFUNCTION"],{n,n}},{{LCL["CLOSETTE"]["ALLOCATION"],{LCL["KEYWORD"]["INSTANCE"],n}},n}}}}}}}},function (l1, keys,  ...)  if not keys[LCL["CLOSETTE"]["NAME"]] then  keys[LCL["CLOSETTE"]["NAME"]] = n.bound end if not keys[LCL["CLOSETTE"]["INITARGS"]] then  keys[LCL["CLOSETTE"]["INITARGS"]] = n.bound end if not keys[LCL["CLOSETTE"]["INITFORM"]] then  keys[LCL["CLOSETTE"]["INITFORM"]] = n.bound end if not keys[LCL["CLOSETTE"]["INITFUNCTION"]] then  keys[LCL["CLOSETTE"]["INITFUNCTION"]] = n.bound end if not keys[LCL["CLOSETTE"]["ALLOCATION"]] then  keys[LCL["CLOSETTE"]["ALLOCATION"]] = LCL["KEYWORD"]["INSTANCE"] end  single_value();  local l2 = CL["COPY-LIST"](l1); single_value();  local l3 = LCL["KEYWORD"]["NAME"]; single_value();  local l4 = l2; single_value();  single_value();  local l5 = keys[LCL["CLOSETTE"]["NAME"]]; single_value();  i( LCL["CLOSETTE"]["SETGETF*"](l4, l3, l5) );
 single_value();  local l6 = LCL["KEYWORD"]["INITARGS"]; single_value();  local l7 = l2; single_value();  single_value();  local l8 = keys[LCL["CLOSETTE"]["INITARGS"]]; single_value();  i( LCL["CLOSETTE"]["SETGETF*"](l7, l6, l8) );
 single_value();  local l9 = LCL["KEYWORD"]["INITFORM"]; single_value();  local l10 = l2; single_value();  single_value();  local l11 = keys[LCL["CLOSETTE"]["INITFORM"]]; single_value();  i( LCL["CLOSETTE"]["SETGETF*"](l10, l9, l11) );
 single_value();  local l12 = LCL["KEYWORD"]["INITFUNCTION"]; single_value();  local l13 = l2; single_value();  single_value();  local l14 = keys[LCL["CLOSETTE"]["INITFUNCTION"]]; single_value();  i( LCL["CLOSETTE"]["SETGETF*"](l13, l12, l14) );
 single_value();  local l15 = LCL["KEYWORD"]["ALLOCATION"]; single_value();  local l16 = l2; single_value();  single_value();  local l17 = keys[LCL["CLOSETTE"]["ALLOCATION"]]; single_value();  i( LCL["CLOSETTE"]["SETGETF*"](l16, l15, l17) );
 single_value();  return l2 end, 0, 0, true, {0 , [LCL["KEYWORD"]["NAME"]] = LCL["CLOSETTE"]["NAME"], [LCL["KEYWORD"]["INITARGS"]] = LCL["CLOSETTE"]["INITARGS"], [LCL["KEYWORD"]["INITFORM"]] = LCL["CLOSETTE"]["INITFORM"], [LCL["KEYWORD"]["INITFUNCTION"]] = LCL["CLOSETTE"]["INITFUNCTION"], [LCL["KEYWORD"]["ALLOCATION"]] = LCL["CLOSETTE"]["ALLOCATION"]})); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-DEFINITION-NAME"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SLOT"],n},function (l1,  ...)   single_value();  return CL["GETF"](l1, LCL["KEYWORD"]["NAME"], false) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-DEFINITION-NAME"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["SLOT"],n}},function (l1, l2,  ...)   single_value();  single_value();  local l3 = LCL["KEYWORD"]["NAME"]; single_value();  local l4 = l2; single_value();  single_value();  local l5 = l1; single_value();  return LCL["CLOSETTE"]["SETGETF*"](l4, l3, l5) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-DEFINITION-INITFUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SLOT"],n},function (l1,  ...)   single_value();  return CL["GETF"](l1, LCL["KEYWORD"]["INITFUNCTION"], false) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-DEFINITION-INITFUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["SLOT"],n}},function (l1, l2,  ...)   single_value();  single_value();  local l3 = LCL["KEYWORD"]["INITFUNCTION"]; single_value();  local l4 = l2; single_value();  single_value();  local l5 = l1; single_value();  return LCL["CLOSETTE"]["SETGETF*"](l4, l3, l5) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-DEFINITION-INITFORM"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SLOT"],n},function (l1,  ...)   single_value();  return CL["GETF"](l1, LCL["KEYWORD"]["INITFORM"], false) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-DEFINITION-INITFORM"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["SLOT"],n}},function (l1, l2,  ...)   single_value();  single_value();  local l3 = LCL["KEYWORD"]["INITFORM"]; single_value();  local l4 = l2; single_value();  single_value();  local l5 = l1; single_value();  return LCL["CLOSETTE"]["SETGETF*"](l4, l3, l5) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-DEFINITION-INITARGS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SLOT"],n},function (l1,  ...)   single_value();  return CL["GETF"](l1, LCL["KEYWORD"]["INITARGS"], false) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-DEFINITION-INITARGS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["SLOT"],n}},function (l1, l2,  ...)   single_value();  single_value();  local l3 = LCL["KEYWORD"]["INITARGS"]; single_value();  local l4 = l2; single_value();  single_value();  local l5 = l1; single_value();  return LCL["CLOSETTE"]["SETGETF*"](l4, l3, l5) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-DEFINITION-READERS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SLOT"],n},function (l1,  ...)   single_value();  return CL["GETF"](l1, LCL["KEYWORD"]["READERS"], false) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-DEFINITION-READERS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["SLOT"],n}},function (l1, l2,  ...)   single_value();  single_value();  local l3 = LCL["KEYWORD"]["READERS"]; single_value();  local l4 = l2; single_value();  single_value();  local l5 = l1; single_value();  return LCL["CLOSETTE"]["SETGETF*"](l4, l3, l5) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-DEFINITION-WRITERS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SLOT"],n},function (l1,  ...)   single_value();  return CL["GETF"](l1, LCL["KEYWORD"]["WRITERS"], false) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-DEFINITION-WRITERS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["SLOT"],n}},function (l1, l2,  ...)   single_value();  single_value();  local l3 = LCL["KEYWORD"]["WRITERS"]; single_value();  local l4 = l2; single_value();  single_value();  local l5 = l1; single_value();  return LCL["CLOSETTE"]["SETGETF*"](l4, l3, l5) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-DEFINITION-ALLOCATION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SLOT"],n},function (l1,  ...)   single_value();  return CL["GETF"](l1, LCL["KEYWORD"]["ALLOCATION"], false) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOT-DEFINITION-ALLOCATION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["SLOT"],n}},function (l1, l2,  ...)   single_value();  single_value();  local l3 = LCL["KEYWORD"]["ALLOCATION"]; single_value();  local l4 = l2; single_value();  single_value();  local l5 = l1; single_value();  return LCL["CLOSETTE"]["SETGETF*"](l4, l3, l5) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-FINALIZE-INHERITANCE"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["EQ"](LCL["CLOSETTE"]["CLASS-OF"](l1), LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound) then  l2 = LCL["CLOSETTE"]["STD-COMPUTE-CLASS-PRECEDENCE-LIST"].fbound else  l2 = LCL["CLOSETTE"]["COMPUTE-CLASS-PRECEDENCE-LIST"].fbound end i( CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-PRECEDENCE-LIST"].setfbound, l(CL["FUNCALL"](l2, l(l1)),l1)) );
 single_value();  local l3 = n if n ~= CL["EQ"](LCL["CLOSETTE"]["CLASS-OF"](l1), LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound) then  l3 = LCL["CLOSETTE"]["STD-COMPUTE-SLOTS"].fbound else  l3 = LCL["CLOSETTE"]["COMPUTE-SLOTS"].fbound end i( CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-SLOTS"].setfbound, l(CL["FUNCALL"](l3, l(l1)),l1)) );
 single_value();  return CL["VALUES"](l()) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-COMPUTE-CLASS-PRECEDENCE-LIST"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],n},function (l1,  ...)   single_value();  local l2 = LCL["CLOSETTE"]["COLLECT-SUPERCLASSES*"](l1); single_value();  return LCL["CLOSETTE"]["TOPOLOGICAL-SORT"](l2, CL["REMOVE-DUPLICATES"](LCL["CLOSETTE"]["MAPAPPEND"](LCL["CLOSETTE"]["LOCAL-PRECEDENCE-ORDERING"].fbound, l(l2)), k()), LCL["CLOSETTE"]["STD-TIE-BREAKER-RULE"].fbound) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["TOPOLOGICAL-SORT"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["ELEMENTS"],{LCL["CLOSETTE"]["CONSTRAINTS"],{LCL["CLOSETTE"]["TIE-BREAKER"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = l2; local l5 = l1; local l6 = n.bound; single_value();  while true do  single_value();  local l7 = CL["REMOVE-IF"](CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],n},function (l8,  ...)   single_value();  return CL["MEMBER"](l8, l4, k(CL_LIB["KEY"], CL["CADR"].fbound)) end, 1, 0, false, false), l5, k()); local l9 = n if n ~= CL["NULL"](l7) then  single_value();  local l10 = n if n ~= CL["NULL"](l5) then  local l11 = l6; single_value(); do return l11 end; l10 = n.bound else  l10 = CL["ERROR"]("Inconsistent precedence graph.", l()) end l9 = l10 else  l9 = n.bound end i( l9 );
 single_value();  local l13 = n if n ~= CL["NULL"]((l7)[2]) then  l13 = (l7)[1] else  local l14 = l7; single_value();  local l15 = l6; single_value();  l13 = CL_LIB['FUNCALL-LUA'](l3,{l14, l15, }) end local l12 = l13; l6 = CL["APPEND"](l(l6,CL["LIST"](l(l12)))) i( l6 );
 l5 = CL["REMOVE"](l12, l5, k()) i( l5 );
 single_value();  l4 = CL["REMOVE"](l12, l4, k(CL_LIB["TEST"], CL["MEMBER"].fbound)) local tmpres = l4 end return n end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-TIE-BREAKER-RULE"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["MINIMAL-ELEMENTS"],{LCL["CLOSETTE"]["CPL-SO-FAR"],n}},function (l1, l2,  ...)   single_value();  local l3 = CL["GENSYM"](false); single_value();  local l4 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l5 = CL["REVERSE"](l2); single_value();  local l6 = (l5)[1]; single_value();  single_value();  local l7 = CL["GENSYM"](false); single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l9 = n if n ~= CL["NOT"](l5) then  single_value(); do break end; l9 = n.bound else  l9 = n.bound end i( l9 );
 local l10 = LCL["CLOSETTE"]["CLASS-DIRECT-SUPERCLASSES"](l6); single_value();  local l11 = CL["INTERSECTION"](l1, l10, k()); single_value();  single_value();  local l12 = n if n ~= CL["NOT"](CL["NULL"](l11)) then  single_value();  local l13 = CL["FUNCALL"](l, l(unpack_mv((l11)[1]))); single_value();  l12 = error({tag=CL["IDENTITY"](l3),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l13)) end)()}) else  l12 = n.bound end i( l12 );
 single_value();  single_value();  local l14 = (l5)[2]; single_value();  l5 = l14 i( l5 );
 single_value();  single_value();  single_value();  local l15 = (l5)[1]; single_value();  l6 = l15 local tmpres = l6 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l8.error ~= n and (l8.error ~= KEYWORD.TAG or l8.tag ~= l7) then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end return CL["VALUES-LIST"](list_r(l8)) end, 0, 0, false, false))); single_value(); if l4.error ~= n and (l4.error ~= KEYWORD.TAG or l4.tag ~= l3) then if l4.error == KEYWORD.TAG then  error(l4) else error(l4[1]) end end return CL["VALUES-LIST"](list_r(l4)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["COLLECT-SUPERCLASSES*"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],n},function (l1,  ...)   single_value();  local l2;l2 = {CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SEEN"],{LCL["CLOSETTE"]["SUPERCLASSES"],n}},function (l3, l4,  ...)   single_value();  local l5 = CL["SET-DIFFERENCE"](l4, l3, k()); single_value();  local l6 = n if n ~= CL["NULL"](l5) then  l6 = l4 else  local l7 = (l5)[1]; single_value();  l6 = CL_LIB["FUNCALL-LUA"]( l2[1], {CL["CONS"](l7, l3), CL["UNION"](LCL["CLOSETTE"]["CLASS-DIRECT-SUPERCLASSES"](l7), l4, k()), }) end return l6 end, 2, 0, false, false)}; single_value();  return CL_LIB["FUNCALL-LUA"]( l2[1], {n.bound, CL["LIST"](l(l1)), }) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["LOCAL-PRECEDENCE-ORDERING"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],n},function (l1,  ...)   single_value();  return CL["MAPCAR"](CL["LIST"].fbound, l(CL["CONS"](l1, CL["BUTLAST"](LCL["CLOSETTE"]["CLASS-DIRECT-SUPERCLASSES"](l1), false)),LCL["CLOSETTE"]["CLASS-DIRECT-SUPERCLASSES"](l1))) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-COMPUTE-SLOTS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],n},function (l1,  ...)   single_value();  local l2 = LCL["CLOSETTE"]["MAPAPPEND"](LCL["CLOSETTE"]["CLASS-DIRECT-SLOTS"].fbound, l(LCL["CLOSETTE"]["CLASS-PRECEDENCE-LIST"](l1))); single_value();  local l3 = CL["REMOVE-DUPLICATES"](CL["MAPCAR"](LCL["CLOSETTE"]["SLOT-DEFINITION-NAME"].fbound, l(l2)), k()); single_value();  single_value();  return CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NAME"],n},function (l4,  ...)   single_value();  local l5 = n if n ~= CL["EQ"](LCL["CLOSETTE"]["CLASS-OF"](l1), LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound) then  l5 = LCL["CLOSETTE"]["STD-COMPUTE-EFFECTIVE-SLOT-DEFINITION"].fbound else  l5 = LCL["CLOSETTE"]["COMPUTE-EFFECTIVE-SLOT-DEFINITION"].fbound end return CL["FUNCALL"](l5, l(l1,CL["REMOVE"](l4, l2, k(CL_LIB["KEY"], LCL["CLOSETTE"]["SLOT-DEFINITION-NAME"].fbound, CL_LIB["TEST-NOT"], CL["EQ"].fbound)))) end, 1, 0, false, false), l(l3)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-COMPUTE-EFFECTIVE-SLOT-DEFINITION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["DIRECT-SLOTS"],n}},function (l1, l2,  ...)   i( n.bound );
 single_value();  local l3 = CL["FIND-IF-NOT"](CL["NULL"].fbound, l2, k(CL_LIB["KEY"], LCL["CLOSETTE"]["SLOT-DEFINITION-INITFUNCTION"].fbound)); single_value();  local l4 = n if n ~= l3 then  l4 = LCL["CLOSETTE"]["SLOT-DEFINITION-INITFORM"](l3) else  l4 = n.bound end local l5 = n if n ~= l3 then  l5 = LCL["CLOSETTE"]["SLOT-DEFINITION-INITFUNCTION"](l3) else  l5 = n.bound end local l6 = n if n ~= l3 then  l6 = LCL["CLOSETTE"]["SLOT-DEFINITION-INITFORM"](l3) else  l6 = n.bound end local l7 = n if n ~= l3 then  l7 = LCL["CLOSETTE"]["SLOT-DEFINITION-INITFUNCTION"](l3) else  l7 = n.bound end return LCL["CLOSETTE"]["MAKE-EFFECTIVE-SLOT-DEFINITION"](l(LCL["KEYWORD"]["NAME"],LCL["CLOSETTE"]["SLOT-DEFINITION-NAME"]((l2)[1]),LCL["KEYWORD"]["INITFORM"],l4,LCL["KEYWORD"]["INITFUNCTION"],l5,LCL["KEYWORD"]["INITARGS"],CL["REMOVE-DUPLICATES"](LCL["CLOSETTE"]["MAPAPPEND"](LCL["CLOSETTE"]["SLOT-DEFINITION-INITARGS"].fbound, l(l2)), k()),LCL["KEYWORD"]["ALLOCATION"],LCL["CLOSETTE"]["SLOT-DEFINITION-ALLOCATION"]((l2)[1])), k(LCL["CLOSETTE"]["NAME"], LCL["CLOSETTE"]["SLOT-DEFINITION-NAME"]((l2)[1]), LCL["CLOSETTE"]["INITFORM"], l6, LCL["CLOSETTE"]["INITFUNCTION"], l7, LCL["CLOSETTE"]["INITARGS"], CL["REMOVE-DUPLICATES"](LCL["CLOSETTE"]["MAPAPPEND"](LCL["CLOSETTE"]["SLOT-DEFINITION-INITARGS"].fbound, l(l2)), k()), LCL["CLOSETTE"]["ALLOCATION"], LCL["CLOSETTE"]["SLOT-DEFINITION-ALLOCATION"]((l2)[1]))) end, 2, 0, false, false)); local l1 = {LCL["CLOSETTE"]["DEFCLASS"],{LCL["CLOSETTE"]["STANDARD-GENERIC-FUNCTION"],{n,{{{LCL["CLOSETTE"]["NAME"],{LCL["KEYWORD"]["INITARG"],{LCL["KEYWORD"]["NAME"],n}}},{{LCL["CLOSETTE"]["LAMBDA-LIST"],{LCL["KEYWORD"]["INITARG"],{LCL["KEYWORD"]["LAMBDA-LIST"],n}}},{{LCL["CLOSETTE"]["METHODS"],{LCL["KEYWORD"]["INITFORM"],{n,n}}},{{LCL["CLOSETTE"]["METHOD-CLASS"],{LCL["KEYWORD"]["INITARG"],{LCL["KEYWORD"]["METHOD-CLASS"],n}}},{{LCL["CLOSETTE"]["DISCRIMINATING-FUNCTION"],n},{{LCL["CLOSETTE"]["CLASSES-TO-EMF-TABLE"],{LCL["KEYWORD"]["INITFORM"],{{CL["MAKE-HASH-TABLE"],{LCL["KEYWORD"]["TEST"],{{CL["FUNCTION"],{CL["EQUAL"],n}},n}}},n}}},n}}}}}},n}}}}; single_value();  tmp = CL_LIB.DEF(LCL["CLOSETTE"]["THE-DEFCLASS-STANDARD-GENERIC-FUNCTION"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(LCL["CLOSETTE"]["THE-CLASS-STANDARD-GF"],l1); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["GENERIC-FUNCTION-NAME"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["NAME"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["GENERIC-FUNCTION-NAME"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["GF"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["NAME"])) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["GENERIC-FUNCTION-LAMBDA-LIST"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["LAMBDA-LIST"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["GENERIC-FUNCTION-LAMBDA-LIST"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["GF"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["LAMBDA-LIST"])) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["GENERIC-FUNCTION-METHODS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["METHODS"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["GENERIC-FUNCTION-METHODS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["GF"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["METHODS"])) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["GENERIC-FUNCTION-DISCRIMINATING-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["DISCRIMINATING-FUNCTION"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["GENERIC-FUNCTION-DISCRIMINATING-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["GF"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["DISCRIMINATING-FUNCTION"])) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["GENERIC-FUNCTION-METHOD-CLASS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["METHOD-CLASS"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["GENERIC-FUNCTION-METHOD-CLASS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["GF"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["METHOD-CLASS"])) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CLASSES-TO-EMF-TABLE"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["CLASSES-TO-EMF-TABLE"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["CLASSES-TO-EMF-TABLE"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["GF"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["CLASSES-TO-EMF-TABLE"])) end, 2, 0, false, false)); local l1 = {LCL["CLOSETTE"]["DEFCLASS"],{LCL["CLOSETTE"]["STANDARD-METHOD"],{n,{{{LCL["CLOSETTE"]["LAMBDA-LIST"],{LCL["KEYWORD"]["INITARG"],{LCL["KEYWORD"]["LAMBDA-LIST"],n}}},{{LCL["CLOSETTE"]["QUALIFIERS"],{LCL["KEYWORD"]["INITARG"],{LCL["KEYWORD"]["QUALIFIERS"],n}}},{{LCL["CLOSETTE"]["SPECIALIZERS"],{LCL["KEYWORD"]["INITARG"],{LCL["KEYWORD"]["SPECIALIZERS"],n}}},{{LCL["CLOSETTE"]["BODY"],{LCL["KEYWORD"]["INITARG"],{LCL["KEYWORD"]["BODY"],n}}},{{LCL["CLOSETTE"]["ENVIRONMENT"],{LCL["KEYWORD"]["INITARG"],{LCL["KEYWORD"]["ENVIRONMENT"],n}}},{{LCL["CLOSETTE"]["GENERIC-FUNCTION"],{LCL["KEYWORD"]["INITFORM"],{n,n}}},{{CL["FUNCTION"],n},n}}}}}}},n}}}}; single_value();  tmp = CL_LIB.DEF(LCL["CLOSETTE"]["THE-DEFCLASS-STANDARD-METHOD"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(LCL["CLOSETTE"]["THE-CLASS-STANDARD-METHOD"],l1); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["METHOD-LAMBDA-LIST"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METHOD"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["LAMBDA-LIST"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["METHOD-LAMBDA-LIST"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["METHOD"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["LAMBDA-LIST"])) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["METHOD-QUALIFIERS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METHOD"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["QUALIFIERS"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["METHOD-QUALIFIERS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["METHOD"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["QUALIFIERS"])) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["METHOD-SPECIALIZERS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METHOD"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["SPECIALIZERS"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["METHOD-SPECIALIZERS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["METHOD"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["SPECIALIZERS"])) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["METHOD-BODY"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METHOD"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["BODY"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["METHOD-BODY"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["METHOD"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["BODY"])) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["METHOD-ENVIRONMENT"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METHOD"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["ENVIRONMENT"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["METHOD-ENVIRONMENT"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["METHOD"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["ENVIRONMENT"])) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["METHOD-GENERIC-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METHOD"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, LCL["CLOSETTE"]["GENERIC-FUNCTION"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["METHOD-GENERIC-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["METHOD"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,LCL["CLOSETTE"]["GENERIC-FUNCTION"])) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["METHOD-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METHOD"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, CL["FUNCTION"]) end, 1, 0, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["METHOD-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["METHOD"],n}},function (l1, l2,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["SLOT-VALUE"].setfbound, l(l1,l2,CL["FUNCTION"])) end, 2, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](LCL["CLOSETTE"]["DEFGENERIC"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G159377"],{CL["&OPTIONAL"],{LCL["NIL"]["G159378"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  single_value();  return CL["CONS"](LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), CL["CONS"](LCL["KEYWORD"]["LAMBDA-LIST"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l9, n)), CL["APPEND"](l(LCL["CLOSETTE"]["CANONICALIZE-DEFGENERIC-OPTIONS"](l13),n)))))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CANONICALIZE-DEFGENERIC-OPTIONS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["OPTIONS"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["MAPAPPEND"](LCL["CLOSETTE"]["CANONICALIZE-DEFGENERIC-OPTION"].fbound, l(l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CANONICALIZE-DEFGENERIC-OPTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["OPTION"],n},function (l1,  ...)   single_value();  local l2 = (l1)[1]; single_value();  local l3 = n if n ~= CL["EQL"](l2, LCL["KEYWORD"]["GENERIC-FUNCTION-CLASS"]) then  single_value();  l3 = CL["LIST"](l(LCL["KEYWORD"]["GENERIC-FUNCTION-CLASS"],CL["CONS"](LCL["CLOSETTE"]["FIND-CLASS"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["CADR"](l1), n)), n)))) else  local l4 = n if n ~= CL["EQL"](l2, LCL["KEYWORD"]["METHOD-CLASS"]) then  single_value();  l4 = CL["LIST"](l(LCL["KEYWORD"]["METHOD-CLASS"],CL["CONS"](LCL["CLOSETTE"]["FIND-CLASS"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["CADR"](l1), n)), n)))) else  local l5 = n if n ~= CL["T"].bound then  single_value();  l5 = CL["LIST"](l(CL["CONS"](CL["QUOTE"], CL["CONS"]((l1)[1], n)),CL["CONS"](CL["QUOTE"], CL["CONS"](CL["CADR"](l1), n)))) else  l5 = n.bound end l4 = l5 end l3 = l4 end return l3 end, 1, 0, false, false)); local l1 = CL["MAKE-HASH-TABLE"](k(CL_LIB["TEST"], CL["EQUAL"].fbound)); single_value();  tmp = CL_LIB.DEF(LCL["CLOSETTE"]["*GENERIC-FUNCTION-TABLE*"],l1); local l1 = CL["MAKE-HASH-TABLE"](k(CL_LIB["TEST"], CL["EQUAL"].fbound)); single_value();  tmp = CL_LIB.DEF(LCL["CLOSETTE"]["*GENERIC-SETF-FUNCTION-TABLE*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],{CL["&OPTIONAL"],{{LCL["CLOSETTE"]["ERRORP"],{CL["T"],n}},n}}},function (l1, l2,  ...)  if not l2 then  l2 = CL["T"].bound end  single_value();  local l5 = n if n ~= CL["CONSP"](l1) then  l5 = CL["EQ"](CL["SETF"], (l1)[1]) else  l5 = n.bound end local l4 = n if n ~= l5 then  single_value();  l4 = CL["GETHASH"](CL["CADR"](l1), LCL["CLOSETTE"]["*GENERIC-SETF-FUNCTION-TABLE*"].bound, n.bound) else  local l6 = n if n ~= CL["SYMBOLP"](l1) then  single_value();  l6 = CL["GETHASH"](l1, LCL["CLOSETTE"]["*GENERIC-FUNCTION-TABLE*"].bound, n.bound) else  l6 = n.bound end l4 = l6 end local l3 = l4; single_value();  local l8 = n if n ~= CL["NULL"](l3) then  l8 = l2 else  l8 = n.bound end local l7 = n if n ~= l8 then  l7 = CL["ERROR"]("No generic function named ~S.", l(l1)) else  l7 = l3 end return l7 end, 1, 1, false, false)); tmp = CL_LIB["SETF-FUNCTION-SETQ"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{CL["SYMBOL"],n}},function (l1, l2,  ...)   single_value();  local l4 = n if n ~= CL["CONSP"](l2) then  l4 = CL["EQ"]((l2)[1], CL["SETF"]) else  l4 = n.bound end local l3 = n if n ~= l4 then  single_value();  single_value();  local l5 = LCL["CLOSETTE"]["*GENERIC-SETF-FUNCTION-TABLE*"].bound; single_value();  local l6 = CL["CADR"](l2); single_value();  single_value();  local l7 = l1; single_value();  l3 = CL_LIB["SETHASH"](l6, l5, l7) else  local l8 = n if n ~= CL["SYMBOLP"](l2) then  single_value();  single_value();  local l9 = LCL["CLOSETTE"]["*GENERIC-FUNCTION-TABLE*"].bound; single_value();  local l10 = l2; single_value();  single_value();  local l11 = l1; single_value();  l8 = CL_LIB["SETHASH"](l10, l9, l11) else  l8 = n.bound end l3 = l8 end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["FORGET-ALL-GENERIC-FUNCTIONS"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   i( CL["CLRHASH"](LCL["CLOSETTE"]["*GENERIC-FUNCTION-TABLE*"].bound) );
 i( CL["CLRHASH"](LCL["CLOSETTE"]["*GENERIC-SETF-FUNCTION-TABLE*"].bound) );
 single_value();  return CL["VALUES"](l()) end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["FUNCTION-NAME"],{CL["&REST"],{LCL["CLOSETTE"]["ALL-KEYS"],{CL["&KEY"],{{LCL["CLOSETTE"]["GENERIC-FUNCTION-CLASS"],{LCL["CLOSETTE"]["THE-CLASS-STANDARD-GF"],n}},{{LCL["CLOSETTE"]["METHOD-CLASS"],{LCL["CLOSETTE"]["THE-CLASS-STANDARD-METHOD"],n}},{CL["&ALLOW-OTHER-KEYS"],n}}}}}}},function (l1, l2, keys,  ...)  if not keys[LCL["CLOSETTE"]["GENERIC-FUNCTION-CLASS"]] then  keys[LCL["CLOSETTE"]["GENERIC-FUNCTION-CLASS"]] = LCL["CLOSETTE"]["THE-CLASS-STANDARD-GF"].bound end if not keys[LCL["CLOSETTE"]["METHOD-CLASS"]] then  keys[LCL["CLOSETTE"]["METHOD-CLASS"]] = LCL["CLOSETTE"]["THE-CLASS-STANDARD-METHOD"].bound end  single_value();  local l3 = n if n ~= LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](l1, n.bound) then  l3 = LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](l1, false) else  local l5 = n if n ~= CL["EQ"](keys[LCL["CLOSETTE"]["GENERIC-FUNCTION-CLASS"]], LCL["CLOSETTE"]["THE-CLASS-STANDARD-GF"].bound) then  l5 = LCL["CLOSETTE"]["MAKE-INSTANCE-STANDARD-GENERIC-FUNCTION"].fbound else  l5 = LCL["CLOSETTE"]["MAKE-INSTANCE"].fbound end local l4 = CL["APPLY"](l5, keys[LCL["CLOSETTE"]["GENERIC-FUNCTION-CLASS"]], l(LCL["KEYWORD"]["NAME"],l1,LCL["KEYWORD"]["METHOD-CLASS"],keys[LCL["CLOSETTE"]["METHOD-CLASS"]],l2)); single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"].setfbound, l(l4,l1)) );
 single_value();  l3 = l4 end return l3 end, 1, 0, true, {0 , [LCL["KEYWORD"]["GENERIC-FUNCTION-CLASS"]] = LCL["CLOSETTE"]["GENERIC-FUNCTION-CLASS"], [LCL["KEYWORD"]["METHOD-CLASS"]] = LCL["CLOSETTE"]["METHOD-CLASS"]})); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["FINALIZE-GENERIC-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["EQ"](LCL["CLOSETTE"]["CLASS-OF"](l1), LCL["CLOSETTE"]["THE-CLASS-STANDARD-GF"].bound) then  l2 = LCL["CLOSETTE"]["STD-COMPUTE-DISCRIMINATING-FUNCTION"].fbound else  l2 = LCL["CLOSETTE"]["COMPUTE-DISCRIMINATING-FUNCTION"].fbound end i( CL["FUNCALL"](LCL["CLOSETTE"]["GENERIC-FUNCTION-DISCRIMINATING-FUNCTION"].setfbound, l(CL["FUNCALL"](l2, l(l1)),l1)) );
 single_value();  local l3 = LCL["CLOSETTE"]["GENERIC-FUNCTION-NAME"](l1); single_value();  single_value();  local l4 = LCL["CLOSETTE"]["GENERIC-FUNCTION-DISCRIMINATING-FUNCTION"](l1); single_value();  i( CL_LIB["%SET-FDEFINITION"](l3, l4) );
 i( CL["CLRHASH"](LCL["CLOSETTE"]["CLASSES-TO-EMF-TABLE"](l1)) );
 single_value();  return CL["VALUES"](l()) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["MAKE-INSTANCE-STANDARD-GENERIC-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GENERIC-FUNCTION-CLASS"],{CL["&KEY"],{LCL["CLOSETTE"]["NAME"],{LCL["CLOSETTE"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["METHOD-CLASS"],{CL["DOCUMENTATION"],n}}}}}},function (l1, keys,  ...)  if not keys[LCL["CLOSETTE"]["NAME"]] then  keys[LCL["CLOSETTE"]["NAME"]] = n.bound end if not keys[LCL["CLOSETTE"]["LAMBDA-LIST"]] then  keys[LCL["CLOSETTE"]["LAMBDA-LIST"]] = n.bound end if not keys[LCL["CLOSETTE"]["METHOD-CLASS"]] then  keys[LCL["CLOSETTE"]["METHOD-CLASS"]] = n.bound end if not keys[CL["DOCUMENTATION"]] then  keys[CL["DOCUMENTATION"]] = n.bound end  i( n.bound );
 single_value();  local l2 = LCL["CLOSETTE"]["STD-ALLOCATE-INSTANCE"](LCL["CLOSETTE"]["THE-CLASS-STANDARD-GF"].bound); single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["GENERIC-FUNCTION-NAME"].setfbound, l(keys[LCL["CLOSETTE"]["NAME"]],l2)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["GENERIC-FUNCTION-LAMBDA-LIST"].setfbound, l(keys[LCL["CLOSETTE"]["LAMBDA-LIST"]],l2)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["GENERIC-FUNCTION-METHODS"].setfbound, l(n.bound,l2)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["GENERIC-FUNCTION-METHOD-CLASS"].setfbound, l(keys[LCL["CLOSETTE"]["METHOD-CLASS"]],l2)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["CLASSES-TO-EMF-TABLE"].setfbound, l(CL["MAKE-HASH-TABLE"](k(CL_LIB["TEST"], CL["EQUAL"].fbound)),l2)) );
 i( LCL["CLOSETTE"]["FINALIZE-GENERIC-FUNCTION"](l2) );
 single_value();  return l2 end, 1, 0, false, {0 , [LCL["KEYWORD"]["NAME"]] = LCL["CLOSETTE"]["NAME"], [LCL["KEYWORD"]["LAMBDA-LIST"]] = LCL["CLOSETTE"]["LAMBDA-LIST"], [LCL["KEYWORD"]["METHOD-CLASS"]] = LCL["CLOSETTE"]["METHOD-CLASS"], [LCL["KEYWORD"]["DOCUMENTATION"]] = CL["DOCUMENTATION"]})); tmp = CL_LIB["MACRO-SETQ"](LCL["CLOSETTE"]["DEFMETHOD"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G159718"],{CL["&OPTIONAL"],{LCL["NIL"]["G159719"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = n.bound; local l7 = n.bound; local l8 = n.bound; local l9 = n.bound; local l10 = n.bound; local l11 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l12 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l13 = l14; single_value();  single_value();  l6,l7,l8,l9,l10= unpack_mv(LCL["CLOSETTE"]["PARSE-DEFMETHOD"](l5), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l11 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l12.error ~= n and true then if l12.error == KEYWORD.TAG then  error(l12) else error(l12[1]) end end i( CL["VALUES-LIST"](list_r(l12)) );
 single_value();  return CL["CONS"](LCL["CLOSETTE"]["ENSURE-METHOD"], CL["CONS"](CL["CONS"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l6, n)), n)), CL["CONS"](LCL["KEYWORD"]["LAMBDA-LIST"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l8, n)), CL["CONS"](LCL["KEYWORD"]["QUALIFIERS"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l7, n)), CL["CONS"](LCL["KEYWORD"]["SPECIALIZERS"], CL["CONS"](LCL["CLOSETTE"]["CANONICALIZE-SPECIALIZERS"](l9), CL["CONS"](LCL["KEYWORD"]["BODY"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l10, n)), CL["CONS"](LCL["KEYWORD"]["ENVIRONMENT"], CL["CONS"](CL["CONS"](LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"], n), n)))))))))))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CANONICALIZE-SPECIALIZERS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SPECIALIZERS"],n},function (l1,  ...)   single_value();  return CL["CONS"](CL["LIST"], CL["APPEND"](l(CL["MAPCAR"](LCL["CLOSETTE"]["CANONICALIZE-SPECIALIZER"].fbound, l(l1)),n))) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CANONICALIZE-SPECIALIZER"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SPECIALIZER"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["LISTP"](l1) then  local l4 = n if n ~= CL["EQ"](CL["LENGTH"](l1), 2) then  local l5 = n if n ~= CL["SYMBOLP"]((l1)[1]) then  l5 = CL["EQ"]("EQL", CL["SYMBOL-NAME"]((l1)[1])) else  l5 = n.bound end l4 = l5 else  l4 = n.bound end local l3 = n if n ~= l4 then  l3 = CL["LIST"](l(CL["QUOTE"],l1)) else  l3 = CL["ERROR"]("Invalid argument specializer ~S", l(l1)) end l2 = l3 else  l2 = CL["CONS"](LCL["CLOSETTE"]["FIND-CLASS"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l1, n)), n)) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["PARSE-DEFMETHOD"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["ARGS"],n},function (l1,  ...)   single_value();  local l2 = (l1)[1]; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = LCL["KEYWORD"]["QUALIFIERS"]; local l7 = (l1)[2]; single_value();  local l8 = (l7)[1]; single_value();  single_value();  local l9 = CL["GENSYM"](false); single_value();  local l10 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l11 = n if n ~= CL["NOT"](l7) then  single_value(); do break end; l11 = n.bound else  l11 = n.bound end i( l11 );
 local l12 = l6; single_value();  local l13 = n if n ~= CL["EQL"](l12, LCL["KEYWORD"]["QUALIFIERS"]) then  single_value();  local l15 = n if n ~= CL["ATOM"](l8) then  l15 = CL["NOT"](CL["NULL"](l8)) else  l15 = n.bound end local l14 = n if n ~= l15 then  single_value();  single_value();  local l16 = CL["NCONC"](l(l3,CL["LIST"](l(l8)))); single_value();  l3 = l16 l14 = l3 else  l4 = l8 i( l4 );
 single_value();  l6 = LCL["KEYWORD"]["BODY"] l14 = l6 end l13 = l14 else  local l17 = n if n ~= CL["EQL"](l12, LCL["KEYWORD"]["BODY"]) then  single_value();  single_value();  single_value();  local l18 = CL["NCONC"](l(l5,CL["LIST"](l(l8)))); single_value();  l5 = l18 l17 = l5 else  local l19 = n if n ~= CL["T"].bound then  single_value();  l19 = CL["ERROR"]("ECASE", l()) else  l19 = n.bound end l17 = l19 end l13 = l17 end i( l13 );
 single_value();  single_value();  local l20 = (l7)[2]; single_value();  l7 = l20 i( l7 );
 single_value();  single_value();  single_value();  local l21 = (l7)[1]; single_value();  l8 = l21 local tmpres = l8 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l10.error ~= n and (l10.error ~= KEYWORD.TAG or l10.tag ~= l9) then if l10.error == KEYWORD.TAG then  error(l10) else error(l10[1]) end end i( CL["VALUES-LIST"](list_r(l10)) );
 single_value();  local l22 = n if n ~= CL["CONSP"](l2) then  l22 = CL["CADR"](l2) else  l22 = l2 end return CL["VALUES"](l(l2,l3,LCL["CLOSETTE"]["EXTRACT-LAMBDA-LIST"](l4),LCL["CLOSETTE"]["EXTRACT-SPECIALIZERS"](l4),CL["LIST*"](l(CL["BLOCK"],l22,l5)))) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["REQUIRED-PORTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],{LCL["CLOSETTE"]["ARGS"],n}},function (l1, l2,  ...)   single_value();  local l3 = CL["LENGTH"](LCL["CLOSETTE"]["GF-REQUIRED-ARGLIST"](l1)); local l4 = n if n ~= CL_LIB["%<"](CL["LENGTH"](l2), l3) then  single_value();  l4 = CL["ERROR"]("Too few arguments to generic function ~S.", l(l1)) else  l4 = n.bound end i( l4 );
 single_value();  return CL["SUBSEQ"](l2, 0, l3) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["GF-REQUIRED-ARGLIST"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],n},function (l1,  ...)   single_value();  local l2 = LCL["CLOSETTE"]["ANALYZE-LAMBDA-LIST"](LCL["CLOSETTE"]["GENERIC-FUNCTION-LAMBDA-LIST"](l1)); single_value();  return CL["GETF"](l2, LCL["KEYWORD"]["REQUIRED-ARGS"], false) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["EXTRACT-LAMBDA-LIST"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SPECIALIZED-LAMBDA-LIST"],n},function (l1,  ...)   single_value();  local l2 = LCL["CLOSETTE"]["ANALYZE-LAMBDA-LIST"](l1); single_value();  local l3 = CL["GETF"](l2, LCL["KEYWORD"]["REQUIRED-NAMES"], false); single_value();  local l4 = CL["GETF"](l2, LCL["KEYWORD"]["REST-VAR"], false); single_value();  local l5 = CL["GETF"](l2, LCL["KEYWORD"]["KEY-ARGS"], false); single_value();  local l6 = CL["GETF"](l2, LCL["KEYWORD"]["ALLOW-OTHER-KEYS"], false); single_value();  local l7 = CL["GETF"](l2, LCL["KEYWORD"]["OPTIONAL-ARGS"], false); single_value();  local l8 = CL["GETF"](l2, LCL["KEYWORD"]["AUXILIARY-ARGS"], false); single_value();  single_value();  local l9 = n if n ~= l4 then  l9 = CL["CONS"](CL["&REST"], CL["CONS"](l4, n)) else  l9 = n.bound end local l11 = l5; single_value();  local l12 = n if n ~= l11 then  l12 = l11 else  l12 = l6 end local l10 = n if n ~= l12 then  l10 = CL["CONS"](CL["&KEY"], CL["APPEND"](l(l5,n))) else  l10 = n.bound end local l13 = n if n ~= l6 then  l13 = {CL["&ALLOW-OTHER-KEYS"],n} else  l13 = n.bound end local l14 = n if n ~= l7 then  l14 = CL["CONS"](CL["&OPTIONAL"], CL["APPEND"](l(l7,n))) else  l14 = n.bound end local l15 = n if n ~= l8 then  l15 = CL["CONS"](CL["&AUX"], CL["APPEND"](l(l8,n))) else  l15 = n.bound end return CL["APPEND"](l(l3,CL["APPEND"](l(l9,CL["APPEND"](l(l10,CL["APPEND"](l(l13,CL["APPEND"](l(l14,CL["APPEND"](l(l15,n)))))))))))) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["EXTRACT-SPECIALIZERS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SPECIALIZED-LAMBDA-LIST"],n},function (l1,  ...)   single_value();  local l2 = LCL["CLOSETTE"]["ANALYZE-LAMBDA-LIST"](l1); single_value();  return CL["GETF"](l2, LCL["KEYWORD"]["SPECIALIZERS"], false) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["ANALYZE-LAMBDA-LIST"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["LAMBDA-LIST"],n},function (l1,  ...)   single_value();  local l2; local l3;l2 = {CL_LIB["ALLOC-FUNCTION"]({CL["SYMBOL"],n},function (l4,  ...)   single_value();  return CL["INTERN"](CL["SYMBOL-NAME"](l4), CL["FIND-PACKAGE"](CL["KEYWORD"])) end, 1, 0, false, false)};l3 = {CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["ARG"],n},function (l5,  ...)   single_value();  local l6 = n if n ~= CL["LISTP"](l5) then  local l7 = n if n ~= CL["LISTP"]((l5)[1]) then  l7 = CL["CAAR"](l5) else  l7 = CL_LIB["FUNCALL-LUA"]( l2[1], {(l5)[1], }) end l6 = l7 else  l6 = CL_LIB["FUNCALL-LUA"]( l2[1], {l5, }) end return l6 end, 1, 0, false, false)}; single_value();  local l8 = n.bound; local l9 = n.bound; local l10 = n.bound; local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = n.bound; local l15 = n.bound; local l16 = n.bound; local l17 = LCL["KEYWORD"]["PARSING-REQUIRED"]; local l18 = l1; single_value();  local l19 = (l18)[1]; single_value();  single_value();  local l20 = CL["GENSYM"](false); single_value();  local l21 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l22 = n if n ~= CL["NOT"](l18) then  single_value(); do break end; l22 = n.bound else  l22 = n.bound end i( l22 );
 local l23 = n if n ~= CL["MEMBER"](l19, CL["LAMBDA-LIST-KEYWORDS"].bound, k()) then  local l24 = l19; single_value();  local l25 = n if n ~= CL["EQL"](l24, CL["&OPTIONAL"]) then  single_value();  l17 = LCL["KEYWORD"]["PARSING-OPTIONAL"] l25 = l17 else  local l26 = n if n ~= CL["EQL"](l24, CL["&REST"]) then  single_value();  l17 = LCL["KEYWORD"]["PARSING-REST"] l26 = l17 else  local l27 = n if n ~= CL["EQL"](l24, CL["&KEY"]) then  single_value();  l17 = LCL["KEYWORD"]["PARSING-KEY"] l27 = l17 else  local l28 = n if n ~= CL["EQL"](l24, CL["&ALLOW-OTHER-KEYS"]) then  single_value();  l16 = CL["T"] l28 = l16 else  local l29 = n if n ~= CL["EQL"](l24, CL["&AUX"]) then  single_value();  l17 = LCL["KEYWORD"]["PARSING-AUX"] l29 = l17 else  local l30 = n if n ~= CL["T"].bound then  single_value();  l30 = CL["ERROR"]("ECASE", l()) else  l30 = n.bound end l29 = l30 end l28 = l29 end l27 = l28 end l26 = l27 end l25 = l26 end l23 = l25 else  local l31 = l17; single_value();  local l32 = n if n ~= CL["EQL"](l31, LCL["KEYWORD"]["PARSING-REQUIRED"]) then  single_value();  single_value();  local l33 = CL["NCONC"](l(l11,CL["LIST"](l(l19)))); single_value();  l11 = l33 i( l11 );
 single_value();  local l34 = n if n ~= CL["LISTP"](l19) then  single_value();  single_value();  local l35 = CL["NCONC"](l(l10,CL["LIST"](l((l19)[1])))); single_value();  l10 = l35 i( l10 );
 single_value();  single_value();  single_value();  local l36 = CL["NCONC"](l(l12,CL["LIST"](l(CL["CADR"](l19))))); single_value();  l12 = l36 l34 = l12 else  single_value();  single_value();  local l37 = CL["NCONC"](l(l10,CL["LIST"](l(l19)))); single_value();  l10 = l37 i( l10 );
 single_value();  single_value();  single_value();  local l38 = CL["NCONC"](l(l12,CL["LIST"](l(CL["T"])))); single_value();  l12 = l38 l34 = l12 end l32 = l34 else  local l39 = n if n ~= CL["EQL"](l31, LCL["KEYWORD"]["PARSING-OPTIONAL"]) then  single_value();  single_value();  single_value();  local l40 = CL["NCONC"](l(l14,CL["LIST"](l(l19)))); single_value();  l14 = l40 l39 = l14 else  local l41 = n if n ~= CL["EQL"](l31, LCL["KEYWORD"]["PARSING-REST"]) then  single_value();  l13 = l19 l41 = l13 else  local l42 = n if n ~= CL["EQL"](l31, LCL["KEYWORD"]["PARSING-KEY"]) then  single_value();  single_value();  local l43 = CL["NCONC"](l(l8,CL["LIST"](l(CL_LIB["FUNCALL-LUA"]( l3[1], {l19, }))))); single_value();  l8 = l43 i( l8 );
 single_value();  single_value();  single_value();  local l44 = CL["NCONC"](l(l9,CL["LIST"](l(l19)))); single_value();  l9 = l44 l42 = l9 else  local l45 = n if n ~= CL["EQL"](l31, LCL["KEYWORD"]["PARSING-AUX"]) then  single_value();  single_value();  single_value();  local l46 = CL["NCONC"](l(l15,CL["LIST"](l(l19)))); single_value();  l15 = l46 l45 = l15 else  l45 = n.bound end l42 = l45 end l41 = l42 end l39 = l41 end l32 = l39 end l23 = l32 end i( l23 );
 single_value();  single_value();  local l47 = (l18)[2]; single_value();  l18 = l47 i( l18 );
 single_value();  single_value();  single_value();  local l48 = (l18)[1]; single_value();  l19 = l48 local tmpres = l19 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l21.error ~= n and (l21.error ~= KEYWORD.TAG or l21.tag ~= l20) then if l21.error == KEYWORD.TAG then  error(l21) else error(l21[1]) end end i( CL["VALUES-LIST"](list_r(l21)) );
 single_value();  return CL["LIST"](l(LCL["KEYWORD"]["REQUIRED-NAMES"],l10,LCL["KEYWORD"]["REQUIRED-ARGS"],l11,LCL["KEYWORD"]["SPECIALIZERS"],l12,LCL["KEYWORD"]["REST-VAR"],l13,LCL["KEYWORD"]["KEYWORDS"],l8,LCL["KEYWORD"]["KEY-ARGS"],l9,LCL["KEYWORD"]["AUXILIARY-ARGS"],l15,LCL["KEYWORD"]["OPTIONAL-ARGS"],l14,LCL["KEYWORD"]["ALLOW-OTHER-KEYS"],l16)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["ENSURE-METHOD"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],{CL["&REST"],{LCL["CLOSETTE"]["ALL-KEYS"],n}}},function (l1, l2,  ...)   single_value();  local l4 = n if n ~= CL["EQ"](LCL["CLOSETTE"]["GENERIC-FUNCTION-METHOD-CLASS"](l1), LCL["CLOSETTE"]["THE-CLASS-STANDARD-METHOD"].bound) then  l4 = LCL["CLOSETTE"]["MAKE-INSTANCE-STANDARD-METHOD"].fbound else  l4 = LCL["CLOSETTE"]["MAKE-INSTANCE"].fbound end local l3 = CL["APPLY"](l4, LCL["CLOSETTE"]["GENERIC-FUNCTION-METHOD-CLASS"](l1), l(l2)); i( LCL["CLOSETTE"]["ADD-METHOD"](l1, l3) );
 single_value();  return l3 end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["MAKE-INSTANCE-STANDARD-METHOD"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METHOD-CLASS"],{CL["&KEY"],{LCL["CLOSETTE"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["QUALIFIERS"],{LCL["CLOSETTE"]["SPECIALIZERS"],{LCL["CLOSETTE"]["BODY"],{LCL["CLOSETTE"]["ENVIRONMENT"],n}}}}}}},function (l1, keys,  ...)  if not keys[LCL["CLOSETTE"]["LAMBDA-LIST"]] then  keys[LCL["CLOSETTE"]["LAMBDA-LIST"]] = n.bound end if not keys[LCL["CLOSETTE"]["QUALIFIERS"]] then  keys[LCL["CLOSETTE"]["QUALIFIERS"]] = n.bound end if not keys[LCL["CLOSETTE"]["SPECIALIZERS"]] then  keys[LCL["CLOSETTE"]["SPECIALIZERS"]] = n.bound end if not keys[LCL["CLOSETTE"]["BODY"]] then  keys[LCL["CLOSETTE"]["BODY"]] = n.bound end if not keys[LCL["CLOSETTE"]["ENVIRONMENT"]] then  keys[LCL["CLOSETTE"]["ENVIRONMENT"]] = n.bound end  i( n.bound );
 single_value();  local l2 = LCL["CLOSETTE"]["STD-ALLOCATE-INSTANCE"](LCL["CLOSETTE"]["THE-CLASS-STANDARD-METHOD"].bound); single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["METHOD-LAMBDA-LIST"].setfbound, l(keys[LCL["CLOSETTE"]["LAMBDA-LIST"]],l2)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["METHOD-QUALIFIERS"].setfbound, l(keys[LCL["CLOSETTE"]["QUALIFIERS"]],l2)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["METHOD-SPECIALIZERS"].setfbound, l(keys[LCL["CLOSETTE"]["SPECIALIZERS"]],l2)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["METHOD-BODY"].setfbound, l(keys[LCL["CLOSETTE"]["BODY"]],l2)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["METHOD-ENVIRONMENT"].setfbound, l(keys[LCL["CLOSETTE"]["ENVIRONMENT"]],l2)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["METHOD-GENERIC-FUNCTION"].setfbound, l(n.bound,l2)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["METHOD-FUNCTION"].setfbound, l(LCL["CLOSETTE"]["STD-COMPUTE-METHOD-FUNCTION"](l2),l2)) );
 single_value();  return l2 end, 1, 0, false, {0 , [LCL["KEYWORD"]["LAMBDA-LIST"]] = LCL["CLOSETTE"]["LAMBDA-LIST"], [LCL["KEYWORD"]["QUALIFIERS"]] = LCL["CLOSETTE"]["QUALIFIERS"], [LCL["KEYWORD"]["SPECIALIZERS"]] = LCL["CLOSETTE"]["SPECIALIZERS"], [LCL["KEYWORD"]["BODY"]] = LCL["CLOSETTE"]["BODY"], [LCL["KEYWORD"]["ENVIRONMENT"]] = LCL["CLOSETTE"]["ENVIRONMENT"]})); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["ADD-METHOD"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],{LCL["CLOSETTE"]["METHOD"],n}},function (l1, l2,  ...)   local l3 = LCL["CLOSETTE"]["FIND-METHOD"](l1, LCL["CLOSETTE"]["METHOD-QUALIFIERS"](l2), LCL["CLOSETTE"]["METHOD-SPECIALIZERS"](l2), n.bound); single_value();  local l4 = n if n ~= l3 then  single_value();  l4 = LCL["CLOSETTE"]["REMOVE-METHOD"](l1, l3) else  l4 = n.bound end i( l4 );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["METHOD-GENERIC-FUNCTION"].setfbound, l(l1,l2)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["GENERIC-FUNCTION-METHODS"].setfbound, l(CL["CONS"](l2, LCL["CLOSETTE"]["GENERIC-FUNCTION-METHODS"](l1)),l1)) );
 local l5 = LCL["CLOSETTE"]["METHOD-SPECIALIZERS"](l2); single_value();  local l6 = (l5)[1]; single_value();  single_value();  local l7 = CL["GENSYM"](false); single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l9 = n if n ~= CL["NOT"](l5) then  single_value(); do break end; l9 = n.bound else  l9 = n.bound end i( l9 );
 local l10 = n if n ~= CL["LISTP"](l6) then  l10 = n.bound else  single_value();  local l11 = l2; local l12 = LCL["CLOSETTE"]["CLASS-DIRECT-METHODS"](l6); single_value();  local l13 = n if n ~= CL["MEMBER"](l11, l12, k()) then  l13 = l12 else  single_value();  l13 = CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-DIRECT-METHODS"].setfbound, l(CL["CONS"](l11, LCL["CLOSETTE"]["CLASS-DIRECT-METHODS"](l6)),l6)) end l10 = l13 end i( l10 );
 single_value();  single_value();  local l14 = (l5)[2]; single_value();  l5 = l14 i( l5 );
 single_value();  single_value();  single_value();  local l15 = (l5)[1]; single_value();  l6 = l15 local tmpres = l6 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l8.error ~= n and (l8.error ~= KEYWORD.TAG or l8.tag ~= l7) then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 i( LCL["CLOSETTE"]["FINALIZE-GENERIC-FUNCTION"](l1) );
 single_value();  return l2 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["REMOVE-METHOD"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],{LCL["CLOSETTE"]["METHOD"],n}},function (l1, l2,  ...)   single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["GENERIC-FUNCTION-METHODS"].setfbound, l(CL["REMOVE"](l2, LCL["CLOSETTE"]["GENERIC-FUNCTION-METHODS"](l1), k()),l1)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["METHOD-GENERIC-FUNCTION"].setfbound, l(n.bound,l2)) );
 local l3 = LCL["CLOSETTE"]["METHOD-SPECIALIZERS"](l2); single_value();  local l4 = (l3)[1]; single_value();  single_value();  local l5 = CL["GENSYM"](false); single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l7 = n if n ~= CL["NOT"](l3) then  single_value(); do break end; l7 = n.bound else  l7 = n.bound end i( l7 );
 local l8 = n if n ~= CL["LISTP"](l4) then  l8 = n.bound else  single_value();  single_value();  l8 = CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-DIRECT-METHODS"].setfbound, l(CL["REMOVE"](l2, LCL["CLOSETTE"]["CLASS-DIRECT-METHODS"](l4), k()),l4)) end i( l8 );
 single_value();  single_value();  local l9 = (l3)[2]; single_value();  l3 = l9 i( l3 );
 single_value();  single_value();  single_value();  local l10 = (l3)[1]; single_value();  l4 = l10 local tmpres = l4 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l6.error ~= n and (l6.error ~= KEYWORD.TAG or l6.tag ~= l5) then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end i( CL["VALUES-LIST"](list_r(l6)) );
 i( LCL["CLOSETTE"]["FINALIZE-GENERIC-FUNCTION"](l1) );
 single_value();  return l2 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["FIND-METHOD"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],{LCL["CLOSETTE"]["QUALIFIERS"],{LCL["CLOSETTE"]["SPECIALIZERS"],{CL["&OPTIONAL"],{{LCL["CLOSETTE"]["ERRORP"],{CL["T"],n}},n}}}}},function (l1, l2, l3, l4,  ...)  if not l4 then  l4 = CL["T"].bound end  single_value();  local l5 = CL["FIND-IF"](CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METHOD"],n},function (l6,  ...)   single_value();  local l7 = n if n ~= CL["EQUAL"](l2, LCL["CLOSETTE"]["METHOD-QUALIFIERS"](l6)) then  l7 = CL["EQUAL"](l3, LCL["CLOSETTE"]["METHOD-SPECIALIZERS"](l6)) else  l7 = n.bound end return l7 end, 1, 0, false, false), LCL["CLOSETTE"]["GENERIC-FUNCTION-METHODS"](l1), k()); single_value();  local l9 = n if n ~= CL["NULL"](l5) then  l9 = l4 else  l9 = n.bound end local l8 = n if n ~= l9 then  l8 = CL["ERROR"]("No such method for ~S.", l(LCL["CLOSETTE"]["GENERIC-FUNCTION-NAME"](l1))) else  l8 = l5 end return l8 end, 3, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["ADD-READER-METHOD"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["FN-NAME"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},function (l1, l2, l3,  ...)   i( LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](l2, l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["OBJECT"],n}), k()), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["OBJECT"],n},LCL["KEYWORD"]["QUALIFIERS"],n.bound,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(l1)),LCL["KEYWORD"]["BODY"],CL["CONS"](LCL["CLOSETTE"]["SLOT-VALUE"], CL["CONS"](LCL["CLOSETTE"]["OBJECT"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l3, n)), n))),LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))) );
 single_value();  return CL["VALUES"](l()) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["ADD-WRITER-METHOD"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["FN-NAME"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},function (l1, l2, l3,  ...)   i( LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](l2, l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["OBJECT"],n}}), k()), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["OBJECT"],n}},LCL["KEYWORD"]["QUALIFIERS"],n.bound,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false),l1)),LCL["KEYWORD"]["BODY"],CL["CONS"](CL["SETF"], CL["CONS"](CL["CONS"](LCL["CLOSETTE"]["SLOT-VALUE"], CL["CONS"](LCL["CLOSETTE"]["OBJECT"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l3, n)), n))), CL["CONS"](LCL["CLOSETTE"]["NEW-VALUE"], n))),LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))) );
 single_value();  return CL["VALUES"](l()) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["APPLY-GENERIC-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],{LCL["CLOSETTE"]["ARGS"],n}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](LCL["CLOSETTE"]["GENERIC-FUNCTION-DISCRIMINATING-FUNCTION"](l1), l2, l()) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-COMPUTE-DISCRIMINATING-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],n},function (l1,  ...)   single_value();  return CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{LCL["CLOSETTE"]["ARGS"],n}},function (l2,  ...)   single_value();  local l3 = LCL["CLOSETTE"]["REQUIRED-PORTION"](l1, l2); single_value();  local l4 = CL["MAPCAR"](LCL["CLOSETTE"]["CLASS-OF"].fbound, l(l3)); single_value();  local l5 = CL["GETHASH"](l4, LCL["CLOSETTE"]["CLASSES-TO-EMF-TABLE"](l1), n.bound); single_value();  single_value();  local l6 = n if n ~= l5 then  local l7 = l2; single_value();  l6 = CL_LIB['FUNCALL-LUA'](l5,{l7, }) else  l6 = LCL["CLOSETTE"]["SLOW-METHOD-LOOKUP"](l1, l2, l4) end return l6 end, 0, 0, true, false) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SLOW-METHOD-LOOKUP"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],{LCL["CLOSETTE"]["ARGS"],{LCL["CLOSETTE"]["CLASSES"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = LCL["CLOSETTE"]["COMPUTE-APPLICABLE-METHODS-USING-CLASSES"](l1, LCL["CLOSETTE"]["REQUIRED-PORTION"](l1, l2), l3); local l5 = n if n ~= CL["NULL"](l4) then  single_value();  l5 = CL["ERROR"]("No applicable methods", l()) else  l5 = n.bound end i( l5 );
 single_value();  local l7 = n if n ~= CL["EQ"](LCL["CLOSETTE"]["CLASS-OF"](l1), LCL["CLOSETTE"]["THE-CLASS-STANDARD-GF"].bound) then  l7 = LCL["CLOSETTE"]["STD-COMPUTE-EFFECTIVE-METHOD-FUNCTION"].fbound else  l7 = LCL["CLOSETTE"]["COMPUTE-EFFECTIVE-METHOD-FUNCTION"].fbound end local l6 = CL["FUNCALL"](l7, l(l1,l4)); single_value();  local l8 = LCL["CLOSETTE"]["CLASSES-TO-EMF-TABLE"](l1); single_value();  local l9 = l3; single_value();  single_value();  local l10 = l6; single_value();  i( CL_LIB["SETHASH"](l9, l8, l10) );
 single_value();  local l11 = l2; single_value();  return CL_LIB['FUNCALL-LUA'](l6,{l11, }) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["CHECK-VALUE-FIT-SPECIALIZER"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["VALUE"],{LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["SPECIALIZER"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = n if n ~= CL["LISTP"](l3) then  l4 = CL["EQL"](l1, CL["CADR"](l3)) else  l4 = LCL["CLOSETTE"]["SUBCLASSP"](l2, l3) end return l4 end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["COMPUTE-APPLICABLE-METHODS-USING-CLASSES"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],{CL["VALUES"],{LCL["CLOSETTE"]["REQUIRED-CLASSES"],n}}},function (l1, l2, l3,  ...)   single_value();  return CL["SORT"](CL["COPY-LIST"](CL["REMOVE-IF-NOT"](CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METHOD"],n},function (l4,  ...)   single_value();  return CL["EVERY"](LCL["CLOSETTE"]["CHECK-VALUE-FIT-SPECIALIZER"].fbound, l(l2,l3,LCL["CLOSETTE"]["METHOD-SPECIALIZERS"](l4))) end, 1, 0, false, false), LCL["CLOSETTE"]["GENERIC-FUNCTION-METHODS"](l1), k())), CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["M1"],{LCL["CLOSETTE"]["M2"],n}},function (l5, l6,  ...)   single_value();  local l7 = n if n ~= CL["EQ"](LCL["CLOSETTE"]["CLASS-OF"](l1), LCL["CLOSETTE"]["THE-CLASS-STANDARD-GF"].bound) then  l7 = LCL["CLOSETTE"]["STD-METHOD-MORE-SPECIFIC-P"].fbound else  l7 = LCL["CLOSETTE"]["METHOD-MORE-SPECIFIC-P"].fbound end return CL["FUNCALL"](l7, l(l1,l5,l6,l3)) end, 2, 0, false, false), k()) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-METHOD-MORE-SPECIFIC-P"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],{LCL["CLOSETTE"]["METHOD1"],{LCL["CLOSETTE"]["METHOD2"],{LCL["CLOSETTE"]["REQUIRED-CLASSES"],n}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 single_value();  local l5 = CL["GENSYM"](false); single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   i( CL["MAPC"](CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SPEC1"],{LCL["CLOSETTE"]["SPEC2"],{LCL["CLOSETTE"]["ARG-CLASS"],n}}},function (l7, l8, l9,  ...)   single_value();  local l10 = n if n ~= CL["EQ"](l7, l8) then  l10 = n.bound else  single_value();  local l11 = CL["FUNCALL"](l, l(unpack_mv(LCL["CLOSETTE"]["SUB-SPECIALIZER-P"](l7, l8, l9)))); single_value();  l10 = error({tag=CL["IDENTITY"](l5),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l11)) end)()}) end return l10 end, 3, 0, false, false), l(LCL["CLOSETTE"]["METHOD-SPECIALIZERS"](l2),LCL["CLOSETTE"]["METHOD-SPECIALIZERS"](l3),l4)) );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l6.error ~= n and (l6.error ~= KEYWORD.TAG or l6.tag ~= l5) then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end return CL["VALUES-LIST"](list_r(l6)) end, 4, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["APPLY-METHODS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],{LCL["CLOSETTE"]["ARGS"],{LCL["CLOSETTE"]["METHODS"],n}}},function (l1, l2, l3,  ...)   single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["COMPUTE-EFFECTIVE-METHOD-FUNCTION"](l(l1,l3)), l(l2)) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["PRIMARY-METHOD-P"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METHOD"],n},function (l1,  ...)   single_value();  return CL["NULL"](LCL["CLOSETTE"]["METHOD-QUALIFIERS"](l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["BEFORE-METHOD-P"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METHOD"],n},function (l1,  ...)   single_value();  return CL["EQUAL"]({LCL["KEYWORD"]["BEFORE"],n}, LCL["CLOSETTE"]["METHOD-QUALIFIERS"](l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["AFTER-METHOD-P"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METHOD"],n},function (l1,  ...)   single_value();  return CL["EQUAL"]({LCL["KEYWORD"]["AFTER"],n}, LCL["CLOSETTE"]["METHOD-QUALIFIERS"](l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["AROUND-METHOD-P"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METHOD"],n},function (l1,  ...)   single_value();  return CL["EQUAL"]({LCL["KEYWORD"]["AROUND"],n}, LCL["CLOSETTE"]["METHOD-QUALIFIERS"](l1)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-COMPUTE-EFFECTIVE-METHOD-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["GF"],{LCL["CLOSETTE"]["METHODS"],n}},function (l1, l2,  ...)   single_value();  local l3 = CL["REMOVE-IF-NOT"](LCL["CLOSETTE"]["PRIMARY-METHOD-P"].fbound, l2, k()); local l4 = CL["FIND-IF"](LCL["CLOSETTE"]["AROUND-METHOD-P"].fbound, l2, k()); local l5 = n if n ~= CL["NULL"](l3) then  single_value();  l5 = CL["ERROR"]("No primary methods for the~@\n             generic function ~S.", l(l1)) else  l5 = n.bound end i( l5 );
 single_value();  local l6 = n if n ~= l4 then  local l8 = n if n ~= CL["EQ"](LCL["CLOSETTE"]["CLASS-OF"](l1), LCL["CLOSETTE"]["THE-CLASS-STANDARD-GF"].bound) then  l8 = LCL["CLOSETTE"]["STD-COMPUTE-EFFECTIVE-METHOD-FUNCTION"].fbound else  l8 = LCL["CLOSETTE"]["COMPUTE-EFFECTIVE-METHOD-FUNCTION"].fbound end local l7 = CL["FUNCALL"](l8, l(l1,CL["REMOVE"](l4, l2, k()))); single_value();  l6 = CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["ARGS"],n},function (l9,  ...)   single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["METHOD-FUNCTION"](l4), l(l9,l7)) end, 1, 0, false, false) else  local l10 = LCL["CLOSETTE"]["COMPUTE-PRIMARY-EMFUN"]((l3)[2]); local l11 = CL["REMOVE-IF-NOT"](LCL["CLOSETTE"]["BEFORE-METHOD-P"].fbound, l2, k()); local l12 = CL["REVERSE"](CL["REMOVE-IF-NOT"](LCL["CLOSETTE"]["AFTER-METHOD-P"].fbound, l2, k())); single_value();  l6 = CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["ARGS"],n},function (l13,  ...)   local l14 = l11; single_value();  local l15 = (l14)[1]; single_value();  single_value();  local l16 = CL["GENSYM"](false); single_value();  local l17 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l18 = n if n ~= CL["NOT"](l14) then  single_value(); do break end; l18 = n.bound else  l18 = n.bound end i( l18 );
 i( CL["FUNCALL"](LCL["CLOSETTE"]["METHOD-FUNCTION"](l15), l(l13,n.bound)) );
 single_value();  single_value();  local l19 = (l14)[2]; single_value();  l14 = l19 i( l14 );
 single_value();  single_value();  single_value();  local l20 = (l14)[1]; single_value();  l15 = l20 local tmpres = l15 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l17.error ~= n and (l17.error ~= KEYWORD.TAG or l17.tag ~= l16) then if l17.error == KEYWORD.TAG then  error(l17) else error(l17[1]) end end i( CL["VALUES-LIST"](list_r(l17)) );
 single_value();  local l21 = CL["FUNCALL"](l, l(unpack_mv(CL["FUNCALL"](LCL["CLOSETTE"]["METHOD-FUNCTION"]((l3)[1]), l(l13,l10))))); single_value();  local l22 = l12; single_value();  local l23 = (l22)[1]; single_value();  single_value();  local l24 = CL["GENSYM"](false); single_value();  local l25 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l26 = n if n ~= CL["NOT"](l22) then  single_value(); do break end; l26 = n.bound else  l26 = n.bound end i( l26 );
 i( CL["FUNCALL"](LCL["CLOSETTE"]["METHOD-FUNCTION"](l23), l(l13,n.bound)) );
 single_value();  single_value();  local l27 = (l22)[2]; single_value();  l22 = l27 i( l22 );
 single_value();  single_value();  single_value();  local l28 = (l22)[1]; single_value();  l23 = l28 local tmpres = l23 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l25.error ~= n and (l25.error ~= KEYWORD.TAG or l25.tag ~= l24) then if l25.error == KEYWORD.TAG then  error(l25) else error(l25[1]) end end i( CL["VALUES-LIST"](list_r(l25)) );
 single_value();  return CL["VALUES-LIST"](l21) end, 1, 0, false, false) end return l6 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["COMPUTE-PRIMARY-EMFUN"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METHODS"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["NULL"](l1) then  l2 = n.bound else  local l3 = LCL["CLOSETTE"]["COMPUTE-PRIMARY-EMFUN"]((l1)[2]); single_value();  l2 = CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["ARGS"],n},function (l4,  ...)   single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["METHOD-FUNCTION"]((l1)[1]), l(l4,l3)) end, 1, 0, false, false) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["APPLY-METHOD"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METHOD"],{LCL["CLOSETTE"]["ARGS"],{LCL["CLOSETTE"]["NEXT-METHODS"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = n if n ~= CL["NULL"](l3) then  l4 = n.bound else  l4 = LCL["CLOSETTE"]["COMPUTE-EFFECTIVE-METHOD-FUNCTION"](l(LCL["CLOSETTE"]["METHOD-GENERIC-FUNCTION"](l1),l3)) end return CL["FUNCALL"](LCL["CLOSETTE"]["METHOD-FUNCTION"](l1), l(l2,l4)) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["STD-COMPUTE-METHOD-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["METHOD"],n},function (l1,  ...)   single_value();  local l2 = LCL["CLOSETTE"]["METHOD-BODY"](l1); local l3 = LCL["CLOSETTE"]["METHOD-LAMBDA-LIST"](l1); single_value();  return LCL["CLOSETTE"]["COMPILE-IN-LEXICAL-ENVIRONMENT"](LCL["CLOSETTE"]["METHOD-ENVIRONMENT"](l1), CL["CONS"](CL["LAMBDA"], CL["CONS"](CL["CONS"](LCL["CLOSETTE"]["ARGS"], CL["CONS"](LCL["CLOSETTE"]["NEXT-EMFUN"], n)), CL["CONS"](CL["CONS"](CL["FLET"], CL["CONS"](CL["CONS"](CL["CONS"](LCL["CLOSETTE"]["CALL-NEXT-METHOD"], CL["CONS"](CL["CONS"](CL["&REST"], CL["CONS"](LCL["CLOSETTE"]["CNM-ARGS"], n)), CL["CONS"](CL["CONS"](CL["IF"], CL["CONS"](CL["CONS"](CL["NULL"], CL["CONS"](LCL["CLOSETTE"]["NEXT-EMFUN"], n)), CL["CONS"](CL["CONS"](CL["ERROR"], CL["CONS"]("No next method for the~@\n                              generic function ~S.", CL["CONS"](CL["CONS"](LCL["CLOSETTE"]["METHOD-GENERIC-FUNCTION"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l1, n)), n)), n))), CL["CONS"](CL["CONS"](CL["FUNCALL"], CL["CONS"](LCL["CLOSETTE"]["NEXT-EMFUN"], CL["CONS"](CL["CONS"](CL["OR"], CL["CONS"](LCL["CLOSETTE"]["CNM-ARGS"], CL["CONS"](LCL["CLOSETTE"]["ARGS"], n))), n))), n)))), n))), CL["CONS"](CL["CONS"](LCL["CLOSETTE"]["NEXT-METHOD-P"], CL["CONS"](n, CL["CONS"](CL["CONS"](CL["NOT"], CL["CONS"](CL["CONS"](CL["NULL"], CL["CONS"](LCL["CLOSETTE"]["NEXT-EMFUN"], n)), n)), n))), n)), CL["CONS"](CL["CONS"](CL["APPLY"], CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](LCL["CLOSETTE"]["KLUDGE-ARGLIST"](l3), CL["CONS"](l2, n))), n)), CL["CONS"](LCL["CLOSETTE"]["ARGS"], n))), n))), n)))) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["KLUDGE-ARGLIST"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["LAMBDA-LIST"],n},function (l1,  ...)   single_value();  local l3 = n if n ~= CL["MEMBER"](CL["&KEY"], l1, k()) then  l3 = CL["NOT"](CL["MEMBER"](CL["&ALLOW-OTHER-KEYS"], l1, k())) else  l3 = n.bound end local l2 = n if n ~= l3 then  l2 = CL["APPEND"](l(l1,{CL["&ALLOW-OTHER-KEYS"],n})) else  local l5 = n if n ~= CL["NOT"](CL["MEMBER"](CL["&REST"], l1, k())) then  l5 = CL["NOT"](CL["MEMBER"](CL["&KEY"], l1, k())) else  l5 = n.bound end local l4 = n if n ~= l5 then  l4 = CL["APPEND"](l(l1,{CL["&KEY"],{CL["&ALLOW-OTHER-KEYS"],n}})) else  l4 = l1 end l2 = l4 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return n.bound end, 0, 0, false, false)); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(LCL["CLOSETTE"]["COMPILE-METHODS"],l1); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["COMPILE-IN-LEXICAL-ENVIRONMENT"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["ENV"],{LCL["CLOSETTE"]["LAMBDA-EXPR"],n}},function (l1, l2,  ...)   i( n.bound );
 single_value();  local l3 = n if n ~= LCL["CLOSETTE"]["COMPILE-METHODS"].bound then  l3 = CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["COMPILE"].fbound, {n.bound, l2, }) else  l3 = CL["EVAL"](CL["CONS"](CL["FUNCTION"], CL["CONS"](l2, n))) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CLOSETTE"]); tmp = CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["FORGET-ALL-CLASSES"].fbound, {}); tmp = CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["FORGET-ALL-GENERIC-FUNCTIONS"].fbound, {}); LCL["CLOSETTE"]["THE-SLOTS-OF-STANDARD-CLASS"].bound = CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["SLOTD"],n},function (l1,  ...)   single_value();  local l2 = CL["GETF"]((l1)[2], LCL["KEYWORD"]["INITARG"], false); single_value();  local l3 = n if n ~= l2 then  l3 = CL["LIST"](l(l2)) else  l3 = n.bound end local l4 = CL["GETF"]((l1)[2], LCL["KEYWORD"]["INITFORM"], false); single_value();  local l5 = n if n ~= l4 then  l5 = CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL["EVAL"](l4) end, 0, 0, false, false) else  l5 = n.bound end local l6 = CL["GETF"]((l1)[2], LCL["KEYWORD"]["INITARG"], false); single_value();  local l7 = n if n ~= l6 then  l7 = CL["LIST"](l(l6)) else  l7 = n.bound end local l8 = CL["GETF"]((l1)[2], LCL["KEYWORD"]["INITFORM"], false); single_value();  local l9 = n if n ~= l8 then  l9 = CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL["EVAL"](l8) end, 0, 0, false, false) else  l9 = n.bound end return LCL["CLOSETTE"]["MAKE-EFFECTIVE-SLOT-DEFINITION"](l(LCL["KEYWORD"]["NAME"],(l1)[1],LCL["KEYWORD"]["INITARGS"],l3,LCL["KEYWORD"]["INITFORM"],CL["GETF"]((l1)[2], LCL["KEYWORD"]["INITFORM"], false),LCL["KEYWORD"]["INITFUNCTION"],l5,LCL["KEYWORD"]["ALLOCATION"],LCL["KEYWORD"]["INSTANCE"]), k(LCL["CLOSETTE"]["NAME"], (l1)[1], LCL["CLOSETTE"]["INITARGS"], l7, LCL["CLOSETTE"]["INITFORM"], CL["GETF"]((l1)[2], LCL["KEYWORD"]["INITFORM"], false), LCL["CLOSETTE"]["INITFUNCTION"], l9, LCL["CLOSETTE"]["ALLOCATION"], LCL["KEYWORD"]["INSTANCE"])) end, 1, 0, false, false), l(CL["NTH"](3, LCL["CLOSETTE"]["THE-DEFCLASS-STANDARD-CLASS"].bound))) tmp = LCL["CLOSETTE"]["THE-SLOTS-OF-STANDARD-CLASS"].bound; LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound = LCL["CLOSETTE"]["ALLOCATE-STD-INSTANCE"](LCL["CLOSETTE"]["TBA"], CL["MAKE-ARRAY"](CL["LENGTH"](LCL["CLOSETTE"]["THE-SLOTS-OF-STANDARD-CLASS"].bound), k(CL_LIB["INITIAL-ELEMENT"], LCL["CLOSETTE"]["SECRET-UNBOUND-VALUE"].bound))) tmp = LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound; single_value();  local l1 = LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound; single_value();  single_value();  local l2 = LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound; single_value();  tmp = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l3, l4,  ...)   single_value();  local l5 = l4; single_value(); l3[CL["IDENTITY"](LCL["CLOSETTE"]["CLASS"])] = l5 return l5 end, 2, 0, false, false), {l1, l2, }); single_value();  tmp = CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-SLOTS"].setfbound, l(LCL["CLOSETTE"]["THE-SLOTS-OF-STANDARD-CLASS"].bound,LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound)); single_value();  local l1 = CL["T"]; single_value();  single_value();  local l3 = LCL["CLOSETTE"]["STD-ALLOCATE-INSTANCE"](LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound); single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-NAME"].setfbound, l(CL["T"],l3)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-DIRECT-SUBCLASSES"].setfbound, l(n.bound,l3)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-DIRECT-SUPERCLASSES"].setfbound, l(n.bound,l3)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-DIRECT-METHODS"].setfbound, l(n.bound,l3)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-DIRECT-SLOTS"].setfbound, l(n.bound,l3)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-PRECEDENCE-LIST"].setfbound, l(CL["LIST"](l(l3)),l3)) );
 single_value();  i( CL["FUNCALL"](LCL["CLOSETTE"]["CLASS-SLOTS"].setfbound, l(n.bound,l3)) );
 single_value();  local l2 = l3; single_value();  tmp = LCL["CLOSETTE"]["%SET-FIND-CLASS"](l1, l2); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](LCL["CLOSETTE"]["STANDARD-OBJECT"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound = CL["EVAL"](LCL["CLOSETTE"]["THE-DEFCLASS-STANDARD-CLASS"].bound) tmp = LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound; single_value();  local l1 = CL["T"]; single_value();  local l2 = LCL["CLOSETTE"]["FIND-CLASS"](l1, false); single_value();  single_value();  local l3 = LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound; single_value();  tmp = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l4, l5,  ...)   single_value();  local l6 = l5; single_value(); l4[CL["IDENTITY"](LCL["CLOSETTE"]["CLASS"])] = l6 return l6 end, 2, 0, false, false), {l2, l3, }); single_value();  local l1 = LCL["CLOSETTE"]["STANDARD-OBJECT"]; single_value();  local l2 = LCL["CLOSETTE"]["FIND-CLASS"](l1, false); single_value();  single_value();  local l3 = LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound; single_value();  tmp = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l4, l5,  ...)   single_value();  local l6 = l5; single_value(); l4[CL["IDENTITY"](LCL["CLOSETTE"]["CLASS"])] = l6 return l6 end, 2, 0, false, false), {l2, l3, }); single_value();  local l1 = LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound; single_value();  single_value();  local l2 = LCL["CLOSETTE"]["THE-CLASS-STANDARD-CLASS"].bound; single_value();  tmp = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l3, l4,  ...)   single_value();  local l5 = l4; single_value(); l3[CL["IDENTITY"](LCL["CLOSETTE"]["CLASS"])] = l5 return l5 end, 2, 0, false, false), {l1, l2, }); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["SYMBOL"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["SEQUENCE"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["ARRAY"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["NUMBER"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["CHARACTER"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["FUNCTION"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["HASH-TABLE"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["PACKAGE"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["PATHNAME"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["READTABLE"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["STREAM"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["LIST"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["SEQUENCE"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["NULL"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["SYMBOL"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["LIST"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["CONS"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["LIST"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["VECTOR"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["ARRAY"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["SEQUENCE"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](LCL["CLOSETTE"]["BIT-VECTOR"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["VECTOR"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["STRING"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["VECTOR"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["COMPLEX"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["NUMBER"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["INTEGER"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["NUMBER"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["FLOAT"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["NUMBER"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); LCL["CLOSETTE"]["THE-CLASS-STANDARD-GF"].bound = CL["EVAL"](LCL["CLOSETTE"]["THE-DEFCLASS-STANDARD-GENERIC-FUNCTION"].bound) tmp = LCL["CLOSETTE"]["THE-CLASS-STANDARD-GF"].bound; LCL["CLOSETTE"]["THE-CLASS-STANDARD-METHOD"].bound = CL["EVAL"](LCL["CLOSETTE"]["THE-DEFCLASS-STANDARD-METHOD"].bound) tmp = LCL["CLOSETTE"]["THE-CLASS-STANDARD-METHOD"].bound; tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CLOSETTE"]); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](CL["PRINT-OBJECT"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["INSTANCE"],{CL["STREAM"],n}}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](CL["PRINT-OBJECT"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["INSTANCE"],{CL["STREAM"],n}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{CL["PRINT-OBJECT"],{{CL_LIB["%PRINT-OBJECT"],{LCL["CLOSETTE"]["INSTANCE"],{CL["STREAM"],n}}},{n,n}}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](CL["PRINT-OBJECT"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["INSTANCE"],{CL["STREAM"],n}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-OBJECT"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{CL["PRINT-OBJECT"],{{CL["PRINT-UNREADABLE-OBJECT"],{{LCL["CLOSETTE"]["INSTANCE"],{CL["STREAM"],{LCL["KEYWORD"]["IDENTITY"],{CL["T"],n}}}},{{CL["FORMAT"],{CL["STREAM"],{"~:(~S~)",{{LCL["CLOSETTE"]["CLASS-NAME"],{{LCL["CLOSETTE"]["CLASS-OF"],{LCL["CLOSETTE"]["INSTANCE"],n}},n}},n}}}},n}}},{LCL["CLOSETTE"]["INSTANCE"],n}}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["SLOT-VALUE-USING-CLASS"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["SLOT-VALUE-USING-CLASS"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-CLASS"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["SLOT-VALUE-USING-CLASS"],{{LCL["CLOSETTE"]["STD-SLOT-VALUE"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = CL_LIB["FUNCTION-SETQ"](LCL["CLOSETTE"]["SETF-SLOT-VALUE-USING-CLASS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["CLOSETTE"]["NEW-VALUE"],{LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["OBJECT"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}}},function (l1, l2, l3, l4,  ...)   single_value();  single_value();  return CL["FUNCALL"](LCL["CLOSETTE"]["STD-SLOT-VALUE"].setfbound, l(l1,l3,l4)) end, 4, 0, false, false)); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["SLOT-EXISTS-P-USING-CLASS"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["SLOT-EXISTS-P-USING-CLASS"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-CLASS"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["SLOT-EXISTS-P-USING-CLASS"],{{LCL["CLOSETTE"]["STD-SLOT-EXISTS-P"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["SLOT-BOUNDP-USING-CLASS"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["SLOT-BOUNDP-USING-CLASS"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-CLASS"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["SLOT-BOUNDP-USING-CLASS"],{{LCL["CLOSETTE"]["STD-SLOT-BOUNDP"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["SLOT-MAKUNBOUND-USING-CLASS"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["SLOT-MAKUNBOUND-USING-CLASS"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-CLASS"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["SLOT-MAKUNBOUND-USING-CLASS"],{{LCL["CLOSETTE"]["STD-SLOT-MAKUNBOUND"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["ALLOCATE-INSTANCE"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],n}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["ALLOCATE-INSTANCE"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],n},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-CLASS"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["ALLOCATE-INSTANCE"],{{LCL["CLOSETTE"]["STD-ALLOCATE-INSTANCE"],{LCL["CLOSETTE"]["CLASS"],n}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["MAKE-INSTANCE"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],{CL["&KEY"],n}}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["MAKE-INSTANCE"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],{CL["&REST"],{LCL["CLOSETTE"]["INITARGS"],n}}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-CLASS"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["MAKE-INSTANCE"],{{CL["LET"],{{{LCL["CLOSETTE"]["INSTANCE"],{{LCL["CLOSETTE"]["ALLOCATE-INSTANCE"],{LCL["CLOSETTE"]["CLASS"],n}},n}},n},{{CL["APPLY"],{{CL["FUNCTION"],{LCL["CLOSETTE"]["INITIALIZE-INSTANCE"],n}},{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["INITARGS"],n}}}},{LCL["CLOSETTE"]["INSTANCE"],n}}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["MAKE-INSTANCE"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],{CL["&REST"],{LCL["CLOSETTE"]["INITARGS"],n}}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["SYMBOL"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["MAKE-INSTANCE"],{{CL["APPLY"],{{CL["FUNCTION"],{LCL["CLOSETTE"]["MAKE-INSTANCE"],n}},{{LCL["CLOSETTE"]["FIND-CLASS"],{LCL["CLOSETTE"]["CLASS"],n}},{LCL["CLOSETTE"]["INITARGS"],n}}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["INITIALIZE-INSTANCE"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["INSTANCE"],{CL["&KEY"],n}}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["INITIALIZE-INSTANCE"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["INSTANCE"],{CL["&REST"],{LCL["CLOSETTE"]["INITARGS"],n}}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-OBJECT"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["INITIALIZE-INSTANCE"],{{CL["APPLY"],{{CL["FUNCTION"],{LCL["CLOSETTE"]["SHARED-INITIALIZE"],n}},{LCL["CLOSETTE"]["INSTANCE"],{CL["T"],{LCL["CLOSETTE"]["INITARGS"],n}}}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["REINITIALIZE-INSTANCE"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["INSTANCE"],{CL["&KEY"],n}}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["REINITIALIZE-INSTANCE"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["INSTANCE"],{CL["&REST"],{LCL["CLOSETTE"]["INITARGS"],n}}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-OBJECT"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["REINITIALIZE-INSTANCE"],{{CL["APPLY"],{{CL["FUNCTION"],{LCL["CLOSETTE"]["SHARED-INITIALIZE"],n}},{LCL["CLOSETTE"]["INSTANCE"],{n,{LCL["CLOSETTE"]["INITARGS"],n}}}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["SHARED-INITIALIZE"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAMES"],{CL["&KEY"],n}}}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["SHARED-INITIALIZE"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAMES"],{CL["&REST"],{LCL["CLOSETTE"]["ALL-KEYS"],n}}}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-OBJECT"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["SHARED-INITIALIZE"],{{CL["DOLIST"],{{LCL["CLOSETTE"]["SLOT"],{{LCL["CLOSETTE"]["CLASS-SLOTS"],{{LCL["CLOSETTE"]["CLASS-OF"],{LCL["CLOSETTE"]["INSTANCE"],n}},n}},n}},{{CL["LET"],{{{LCL["CLOSETTE"]["SLOT-NAME"],{{LCL["CLOSETTE"]["SLOT-DEFINITION-NAME"],{LCL["CLOSETTE"]["SLOT"],n}},n}},n},{{CL["MULTIPLE-VALUE-BIND"],{{LCL["CLOSETTE"]["INIT-KEY"],{LCL["CLOSETTE"]["INIT-VALUE"],{LCL["CLOSETTE"]["FOUNDP"],n}}},{{CL["GET-PROPERTIES"],{LCL["CLOSETTE"]["ALL-KEYS"],{{LCL["CLOSETTE"]["SLOT-DEFINITION-INITARGS"],{LCL["CLOSETTE"]["SLOT"],n}},n}}},{{CL["DECLARE"],{{CL["IGNORE"],{LCL["CLOSETTE"]["INIT-KEY"],n}},n}},{{CL["IF"],{LCL["CLOSETTE"]["FOUNDP"],{{CL["SETF"],{{LCL["CLOSETTE"]["SLOT-VALUE"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},{LCL["CLOSETTE"]["INIT-VALUE"],n}}},{{CL["WHEN"],{{CL["AND"],{{CL["NOT"],{{LCL["CLOSETTE"]["SLOT-BOUNDP"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},n}},{{CL["NOT"],{{CL["NULL"],{{LCL["CLOSETTE"]["SLOT-DEFINITION-INITFUNCTION"],{LCL["CLOSETTE"]["SLOT"],n}},n}},n}},{{CL["OR"],{{CL["EQ"],{LCL["CLOSETTE"]["SLOT-NAMES"],{CL["T"],n}}},{{CL["MEMBER"],{LCL["CLOSETTE"]["SLOT-NAME"],{LCL["CLOSETTE"]["SLOT-NAMES"],n}}},n}}},n}}}},{{CL["SETF"],{{LCL["CLOSETTE"]["SLOT-VALUE"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},{{CL["FUNCALL"],{{LCL["CLOSETTE"]["SLOT-DEFINITION-INITFUNCTION"],{LCL["CLOSETTE"]["SLOT"],n}},n}},n}}},n}}},n}}}},n}}}}},n}}},n}}},{LCL["CLOSETTE"]["INSTANCE"],n}}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["CHANGE-CLASS"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["NEW-CLASS"],{CL["&KEY"],n}}}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["CHANGE-CLASS"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["OLD-INSTANCE"],{LCL["CLOSETTE"]["NEW-CLASS"],{CL["&REST"],{LCL["CLOSETTE"]["INITARGS"],n}}}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-OBJECT"], false),LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-CLASS"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["CHANGE-CLASS"],{{CL["LET"],{{{LCL["CLOSETTE"]["NEW-INSTANCE"],{{LCL["CLOSETTE"]["ALLOCATE-INSTANCE"],{LCL["CLOSETTE"]["NEW-CLASS"],n}},n}},n},{{CL["DOLIST"],{{LCL["CLOSETTE"]["SLOT-NAME"],{{CL["MAPCAR"],{{CL["FUNCTION"],{LCL["CLOSETTE"]["SLOT-DEFINITION-NAME"],n}},{{LCL["CLOSETTE"]["CLASS-SLOTS"],{LCL["CLOSETTE"]["NEW-CLASS"],n}},n}}},n}},{{CL["WHEN"],{{CL["AND"],{{LCL["CLOSETTE"]["SLOT-EXISTS-P"],{LCL["CLOSETTE"]["OLD-INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},{{LCL["CLOSETTE"]["SLOT-BOUNDP"],{LCL["CLOSETTE"]["OLD-INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},n}}},{{CL["SETF"],{{LCL["CLOSETTE"]["SLOT-VALUE"],{LCL["CLOSETTE"]["NEW-INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},{{LCL["CLOSETTE"]["SLOT-VALUE"],{LCL["CLOSETTE"]["OLD-INSTANCE"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},n}}},n}}},n}}},{{CL["ROTATEF"],{{LCL["CLOSETTE"]["STD-INSTANCE-SLOTS"],{LCL["CLOSETTE"]["NEW-INSTANCE"],n}},{{LCL["CLOSETTE"]["STD-INSTANCE-SLOTS"],{LCL["CLOSETTE"]["OLD-INSTANCE"],n}},n}}},{{CL["ROTATEF"],{{LCL["CLOSETTE"]["STD-INSTANCE-CLASS"],{LCL["CLOSETTE"]["NEW-INSTANCE"],n}},{{LCL["CLOSETTE"]["STD-INSTANCE-CLASS"],{LCL["CLOSETTE"]["OLD-INSTANCE"],n}},n}}},{{CL["APPLY"],{{CL["FUNCTION"],{LCL["CLOSETTE"]["UPDATE-INSTANCE-FOR-DIFFERENT-CLASS"],n}},{LCL["CLOSETTE"]["NEW-INSTANCE"],{LCL["CLOSETTE"]["OLD-INSTANCE"],{LCL["CLOSETTE"]["INITARGS"],n}}}}},{LCL["CLOSETTE"]["OLD-INSTANCE"],n}}}}}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["CHANGE-CLASS"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["INSTANCE"],{LCL["CLOSETTE"]["NEW-CLASS"],{CL["&REST"],{LCL["CLOSETTE"]["INITARGS"],n}}}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-OBJECT"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["SYMBOL"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["CHANGE-CLASS"],{{CL["APPLY"],{{CL["FUNCTION"],{LCL["CLOSETTE"]["CHANGE-CLASS"],n}},{LCL["CLOSETTE"]["INSTANCE"],{{LCL["CLOSETTE"]["FIND-CLASS"],{LCL["CLOSETTE"]["NEW-CLASS"],n}},{LCL["CLOSETTE"]["INITARGS"],n}}}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["UPDATE-INSTANCE-FOR-DIFFERENT-CLASS"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["OLD"],{LCL["CLOSETTE"]["NEW"],{CL["&KEY"],n}}}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["UPDATE-INSTANCE-FOR-DIFFERENT-CLASS"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["OLD"],{LCL["CLOSETTE"]["NEW"],{CL["&REST"],{LCL["CLOSETTE"]["INITARGS"],n}}}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-OBJECT"], false),LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-OBJECT"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["UPDATE-INSTANCE-FOR-DIFFERENT-CLASS"],{{CL["LET"],{{{LCL["CLOSETTE"]["ADDED-SLOTS"],{{CL["REMOVE-IF"],{{CL["FUNCTION"],{{CL["LAMBDA"],{{LCL["CLOSETTE"]["SLOT-NAME"],n},{{LCL["CLOSETTE"]["SLOT-EXISTS-P"],{LCL["CLOSETTE"]["OLD"],{LCL["CLOSETTE"]["SLOT-NAME"],n}}},n}}},n}},{{CL["MAPCAR"],{{CL["FUNCTION"],{LCL["CLOSETTE"]["SLOT-DEFINITION-NAME"],n}},{{LCL["CLOSETTE"]["CLASS-SLOTS"],{{LCL["CLOSETTE"]["CLASS-OF"],{LCL["CLOSETTE"]["NEW"],n}},n}},n}}},n}}},n}},n},{{CL["APPLY"],{{CL["FUNCTION"],{LCL["CLOSETTE"]["SHARED-INITIALIZE"],n}},{LCL["CLOSETTE"]["NEW"],{LCL["CLOSETTE"]["ADDED-SLOTS"],{LCL["CLOSETTE"]["INITARGS"],n}}}}},n}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](CL["PRINT-OBJECT"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],{CL["STREAM"],n}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-CLASS"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{CL["PRINT-OBJECT"],{{CL["PRINT-UNREADABLE-OBJECT"],{{LCL["CLOSETTE"]["CLASS"],{CL["STREAM"],{LCL["KEYWORD"]["IDENTITY"],{CL["T"],n}}}},{{CL["FORMAT"],{CL["STREAM"],{"~:(~S~) ~S",{{LCL["CLOSETTE"]["CLASS-NAME"],{{LCL["CLOSETTE"]["CLASS-OF"],{LCL["CLOSETTE"]["CLASS"],n}},n}},{{LCL["CLOSETTE"]["CLASS-NAME"],{LCL["CLOSETTE"]["CLASS"],n}},n}}}}},n}}},{LCL["CLOSETTE"]["CLASS"],n}}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["INITIALIZE-INSTANCE"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],{CL["&REST"],{LCL["CLOSETTE"]["ARGS"],n}}},LCL["KEYWORD"]["QUALIFIERS"],{LCL["KEYWORD"]["AFTER"],n},LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-CLASS"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["INITIALIZE-INSTANCE"],{{CL["APPLY"],{{CL["FUNCTION"],{LCL["CLOSETTE"]["STD-AFTER-INITIALIZATION-FOR-CLASSES"],n}},{LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["ARGS"],n}}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["FINALIZE-INHERITANCE"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],n}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["FINALIZE-INHERITANCE"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],n},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-CLASS"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["FINALIZE-INHERITANCE"],{{LCL["CLOSETTE"]["STD-FINALIZE-INHERITANCE"],{LCL["CLOSETTE"]["CLASS"],n}},{{CL["VALUES"],n},n}}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["COMPUTE-CLASS-PRECEDENCE-LIST"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],n}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["COMPUTE-CLASS-PRECEDENCE-LIST"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],n},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-CLASS"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["COMPUTE-CLASS-PRECEDENCE-LIST"],{{LCL["CLOSETTE"]["STD-COMPUTE-CLASS-PRECEDENCE-LIST"],{LCL["CLOSETTE"]["CLASS"],n}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["COMPUTE-SLOTS"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],n}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["COMPUTE-SLOTS"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],n},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-CLASS"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["COMPUTE-SLOTS"],{{LCL["CLOSETTE"]["STD-COMPUTE-SLOTS"],{LCL["CLOSETTE"]["CLASS"],n}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["COMPUTE-EFFECTIVE-SLOT-DEFINITION"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["DIRECT-SLOTS"],n}}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["COMPUTE-EFFECTIVE-SLOT-DEFINITION"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["DIRECT-SLOTS"],n}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-CLASS"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["COMPUTE-EFFECTIVE-SLOT-DEFINITION"],{{LCL["CLOSETTE"]["STD-COMPUTE-EFFECTIVE-SLOT-DEFINITION"],{LCL["CLOSETTE"]["CLASS"],{LCL["CLOSETTE"]["DIRECT-SLOTS"],n}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](CL["PRINT-OBJECT"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["GF"],{CL["STREAM"],n}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-GENERIC-FUNCTION"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{CL["PRINT-OBJECT"],{{CL["PRINT-UNREADABLE-OBJECT"],{{LCL["CLOSETTE"]["GF"],{CL["STREAM"],{LCL["KEYWORD"]["IDENTITY"],{CL["T"],n}}}},{{CL["FORMAT"],{CL["STREAM"],{"~:(~S~) ~S",{{LCL["CLOSETTE"]["CLASS-NAME"],{{LCL["CLOSETTE"]["CLASS-OF"],{LCL["CLOSETTE"]["GF"],n}},n}},{{LCL["CLOSETTE"]["GENERIC-FUNCTION-NAME"],{LCL["CLOSETTE"]["GF"],n}},n}}}}},n}}},{LCL["CLOSETTE"]["GF"],n}}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["INITIALIZE-INSTANCE"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["GF"],n},LCL["KEYWORD"]["QUALIFIERS"],{LCL["KEYWORD"]["AFTER"],n},LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-GENERIC-FUNCTION"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["INITIALIZE-INSTANCE"],{{LCL["CLOSETTE"]["FINALIZE-GENERIC-FUNCTION"],{LCL["CLOSETTE"]["GF"],n}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](CL["PRINT-OBJECT"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["METHOD"],{CL["STREAM"],n}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-METHOD"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{CL["PRINT-OBJECT"],{{CL["PRINT-UNREADABLE-OBJECT"],{{LCL["CLOSETTE"]["METHOD"],{CL["STREAM"],{LCL["KEYWORD"]["IDENTITY"],{CL["T"],n}}}},{{CL["FORMAT"],{CL["STREAM"],{"~:(~S~) ~S~{ ~S~} ~S",{{LCL["CLOSETTE"]["CLASS-NAME"],{{LCL["CLOSETTE"]["CLASS-OF"],{LCL["CLOSETTE"]["METHOD"],n}},n}},{{LCL["CLOSETTE"]["GENERIC-FUNCTION-NAME"],{{LCL["CLOSETTE"]["METHOD-GENERIC-FUNCTION"],{LCL["CLOSETTE"]["METHOD"],n}},n}},{{LCL["CLOSETTE"]["METHOD-QUALIFIERS"],{LCL["CLOSETTE"]["METHOD"],n}},{{CL["MAPCAR"],{{CL["FUNCTION"],{LCL["CLOSETTE"]["CLASS-NAME"],n}},{{LCL["CLOSETTE"]["METHOD-SPECIALIZERS"],{LCL["CLOSETTE"]["METHOD"],n}},n}}},n}}}}}}},n}}},{LCL["CLOSETTE"]["METHOD"],n}}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["INITIALIZE-INSTANCE"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["METHOD"],n},LCL["KEYWORD"]["QUALIFIERS"],{LCL["KEYWORD"]["AFTER"],n},LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-METHOD"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["INITIALIZE-INSTANCE"],{{CL["SETF"],{{LCL["CLOSETTE"]["METHOD-FUNCTION"],{LCL["CLOSETTE"]["METHOD"],n}},{{LCL["CLOSETTE"]["COMPUTE-METHOD-FUNCTION"],{LCL["CLOSETTE"]["METHOD"],n}},n}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["COMPUTE-DISCRIMINATING-FUNCTION"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["GF"],n}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["COMPUTE-DISCRIMINATING-FUNCTION"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["GF"],n},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-GENERIC-FUNCTION"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["COMPUTE-DISCRIMINATING-FUNCTION"],{{LCL["CLOSETTE"]["STD-COMPUTE-DISCRIMINATING-FUNCTION"],{LCL["CLOSETTE"]["GF"],n}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["METHOD-MORE-SPECIFIC-P"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["GF"],{LCL["CLOSETTE"]["METHOD1"],{LCL["CLOSETTE"]["METHOD2"],{LCL["CLOSETTE"]["REQUIRED-CLASSES"],n}}}}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["METHOD-MORE-SPECIFIC-P"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["GF"],{LCL["CLOSETTE"]["METHOD1"],{LCL["CLOSETTE"]["METHOD2"],{LCL["CLOSETTE"]["REQUIRED-CLASSES"],n}}}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-GENERIC-FUNCTION"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["METHOD-MORE-SPECIFIC-P"],{{LCL["CLOSETTE"]["STD-METHOD-MORE-SPECIFIC-P"],{LCL["CLOSETTE"]["GF"],{LCL["CLOSETTE"]["METHOD1"],{LCL["CLOSETTE"]["METHOD2"],{LCL["CLOSETTE"]["REQUIRED-CLASSES"],n}}}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["COMPUTE-EFFECTIVE-METHOD-FUNCTION"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["GF"],{LCL["CLOSETTE"]["METHODS"],n}}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["COMPUTE-EFFECTIVE-METHOD-FUNCTION"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["GF"],{LCL["CLOSETTE"]["METHODS"],n}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-GENERIC-FUNCTION"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["COMPUTE-EFFECTIVE-METHOD-FUNCTION"],{{LCL["CLOSETTE"]["STD-COMPUTE-EFFECTIVE-METHOD-FUNCTION"],{LCL["CLOSETTE"]["GF"],{LCL["CLOSETTE"]["METHODS"],n}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](LCL["CLOSETTE"]["COMPUTE-METHOD-FUNCTION"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["METHOD"],n}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](LCL["CLOSETTE"]["COMPUTE-METHOD-FUNCTION"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{LCL["CLOSETTE"]["METHOD"],n},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](LCL["CLOSETTE"]["STANDARD-METHOD"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{LCL["CLOSETTE"]["COMPUTE-METHOD-FUNCTION"],{{LCL["CLOSETTE"]["STD-COMPUTE-METHOD-FUNCTION"],{LCL["CLOSETTE"]["METHOD"],n}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {})));-- END OF THE CLOSETTE COMPILED CODE
 tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); single_value();  tmp = CL["USE-PACKAGE"](LCL["KEYWORD"]["CLOSETTE"], false); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*BREAK-ON-SIGNALS*"],l1); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["CONDITION"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l()),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["SIMPLE-CONDITION"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["CONDITION"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l(CL["LIST"](l(LCL["KEYWORD"]["NAME"],CL["FORMAT"],LCL["KEYWORD"]["INITARGS"],{LCL["KEYWORD"]["FORMAT-CONTROL"],n})),CL["LIST"](l(LCL["KEYWORD"]["NAME"],CL_LIB["ARGS"],LCL["KEYWORD"]["INITARGS"],{LCL["KEYWORD"]["FORMAT-ARGUMENTS"],n}))))), k()); tmp = CL_LIB["FUNCTION-SETQ"](CL["SIMPLE-CONDITION-FORMAT-ARGUMENTS"] , CL_LIB["ALLOC-FUNCTION"]({CL["CONDITION"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, CL_LIB["ARGS"]) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SIMPLE-CONDITION-FORMAT-CONTROL"] , CL_LIB["ALLOC-FUNCTION"]({CL["CONDITION"],n},function (l1,  ...)   single_value();  return LCL["CLOSETTE"]["SLOT-VALUE"](l1, CL["FORMAT"]) end, 1, 0, false, false)); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["SERIOUS-CONDITION"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["CONDITION"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["STORAGE-CONDITION"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["SERIOUS-CONDITION"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["ERROR"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["SERIOUS-CONDITION"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["TYPE-ERROR"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["ERROR"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l(CL["LIST"](l(LCL["KEYWORD"]["NAME"],CL_LIB["FORM"],LCL["KEYWORD"]["INITARGS"],{LCL["KEYWORD"]["FORM"],n})),CL["LIST"](l(LCL["KEYWORD"]["NAME"],CL["DATUM"],LCL["KEYWORD"]["INITARGS"],{LCL["KEYWORD"]["DATUM"],n},LCL["KEYWORD"]["READERS"],{CL["TYPE-ERROR-DATUM"],n})),CL["LIST"](l(LCL["KEYWORD"]["NAME"],CL_LIB["EXPECTED-TYPE"],LCL["KEYWORD"]["INITARGS"],{LCL["KEYWORD"]["EXPECTED-TYPE"],n},LCL["KEYWORD"]["READERS"],{CL["TYPE-ERROR-EXPECTED-TYPE"],n}))))), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["SIMPLE-ERROR"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["SIMPLE-CONDITION"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["ERROR"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["SIMPLE-TYPE-ERROR"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["SIMPLE-CONDITION"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["TYPE-ERROR"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["WARNING"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["CONDITION"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["STYLE-WARNING"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["WARNING"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["SIMPLE-WARNING"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["SIMPLE-CONDITION"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["WARNING"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["ARITHMETIC-ERROR"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["ERROR"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l(CL["LIST"](l(LCL["KEYWORD"]["NAME"],CL_LIB["OPERATION"],LCL["KEYWORD"]["INITARGS"],{LCL["KEYWORD"]["OPERATION"],n},LCL["KEYWORD"]["READERS"],{CL["ARITHMETIC-ERROR-OPERATION"],n})),CL["LIST"](l(LCL["KEYWORD"]["NAME"],CL_LIB["OPERANDS"],LCL["KEYWORD"]["INITARGS"],{LCL["KEYWORD"]["OPERANDS"],n},LCL["KEYWORD"]["READERS"],{CL["ARITHMETIC-ERROR-OPERANDS"],n}))))), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["DIVISION-BY-ZERO"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["ARITHMETIC-ERROR"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["CELL-ERROR"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["ERROR"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l(CL["LIST"](l(LCL["KEYWORD"]["NAME"],CL_LIB["NAME"],LCL["KEYWORD"]["INITARGS"],{LCL["KEYWORD"]["NAME"],n},LCL["KEYWORD"]["READERS"],{CL["CELL-ERROR-NAME"],n}))))), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["UNDEFINED-FUNCTION"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["CELL-ERROR"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["CONTROL-ERROR"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["ERROR"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["PARSE-ERROR"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["ERROR"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["PROGRAM-ERROR"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["ERROR"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["STREAM-ERROR"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["ERROR"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l(CL["LIST"](l(LCL["KEYWORD"]["NAME"],CL["STREAM"],LCL["KEYWORD"]["INITARGS"],{LCL["KEYWORD"]["STREAM"],n},LCL["KEYWORD"]["READERS"],{CL["STREAM-ERROR-STREAM"],n}))))), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["END-OF-FILE"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["STREAM-ERROR"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["READER-ERROR"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["PARSE-ERROR"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["STREAM-ERROR"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l())), k()); tmp = LCL["CLOSETTE"]["ENSURE-CLASS"](CL["PACKAGE-ERROR"], l(LCL["KEYWORD"]["DIRECT-SUPERCLASSES"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["ERROR"], false))),LCL["KEYWORD"]["DIRECT-SLOTS"],CL["LIST"](l(CL["LIST"](l(LCL["KEYWORD"]["NAME"],CL["PACKAGE"],LCL["KEYWORD"]["INITARGS"],{LCL["KEYWORD"]["PACKAGE"],n},LCL["KEYWORD"]["READERS"],{CL["PACKAGE-ERROR-PACKAGE"],n}))))), k()); tmp = LCL["CLOSETTE"]["ENSURE-GENERIC-FUNCTION"](CL_LIB["REPORT-CONDITION"], l(LCL["KEYWORD"]["LAMBDA-LIST"],{CL["CONDITION"],{CL["STREAM"],n}}), k()); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](CL_LIB["REPORT-CONDITION"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{CL_LIB["C"],{CL["STREAM"],n}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["CONDITION"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{CL_LIB["REPORT-CONDITION"],{{CL["WRITE-STRING"],{{CL_LIB["CONCAT-STRING"],{"#<",{{CL["STRING"],{{LCL["CLOSETTE"]["CLASS-NAME"],{{LCL["CLOSETTE"]["CLASS-OF"],{CL_LIB["C"],n}},n}},n}},{">",n}}}},{CL["STREAM"],n}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](CL_LIB["REPORT-CONDITION"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{CL_LIB["C"],{CL["STREAM"],n}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["SIMPLE-CONDITION"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{CL_LIB["REPORT-CONDITION"],{{CL["WRITE-STRING"],{{CL_LIB["CONCAT-STRING"],{"#<",{{CL["STRING"],{{LCL["CLOSETTE"]["CLASS-NAME"],{{LCL["CLOSETTE"]["CLASS-OF"],{CL_LIB["C"],n}},n}},n}},{" ",{{CL["APPLY"],{{CL["QUOTE"],{CL["FORMAT"],n}},{n,{{CL["SIMPLE-CONDITION-FORMAT-CONTROL"],{CL_LIB["C"],n}},{{CL["SIMPLE-CONDITION-FORMAT-ARGUMENTS"],{CL_LIB["C"],n}},n}}}}},{">",n}}}}}},{CL["STREAM"],n}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = LCL["CLOSETTE"]["ENSURE-METHOD"](LCL["CLOSETTE"]["FIND-GENERIC-FUNCTION"](CL_LIB["REPORT-CONDITION"], false), l(LCL["KEYWORD"]["LAMBDA-LIST"],{CL_LIB["C"],{CL["STREAM"],n}},LCL["KEYWORD"]["QUALIFIERS"],n,LCL["KEYWORD"]["SPECIALIZERS"],CL["LIST"](l(LCL["CLOSETTE"]["FIND-CLASS"](CL["TYPE-ERROR"], false),LCL["CLOSETTE"]["FIND-CLASS"](CL["T"], false))),LCL["KEYWORD"]["BODY"],{CL["BLOCK"],{CL_LIB["REPORT-CONDITION"],{{CL["WRITE-STRING"],{{CL_LIB["CONCAT-STRING"],{"#<",{{CL["STRING"],{{LCL["CLOSETTE"]["CLASS-NAME"],{{LCL["CLOSETTE"]["CLASS-OF"],{CL_LIB["C"],n}},n}},n}},{" ",{"The value of ",{{CL["PRINC-TO-STRING"],{{LCL["CLOSETTE"]["SLOT-VALUE"],{CL_LIB["C"],{{CL["QUOTE"],{CL_LIB["FORM"],n}},n}}},n}},{", ",{{CL["PRINC-TO-STRING"],{{CL["TYPE-ERROR-DATUM"],{CL_LIB["C"],n}},n}},{", ",{"is not ",{{CL["PRINC-TO-STRING"],{{CL["TYPE-ERROR-EXPECTED-TYPE"],{CL_LIB["C"],n}},n}},{">",n}}}}}}}}}}}},{CL["STREAM"],n}}},n}}},LCL["KEYWORD"]["ENVIRONMENT"],CL_LIB["FUNCALL-LUA"]( LCL["CLOSETTE"]["TOP-LEVEL-ENVIRONMENT"].fbound, {}))); tmp = CL_LIB["MACRO-SETQ"](CL["DEFINE-CONDITION"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G186909"],{CL["&OPTIONAL"],{LCL["NIL"]["G186910"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l14 = l4; single_value();  local l15 = (l14)[1]; single_value();  single_value();  local l16 = (l14)[2]; single_value();  l4 = l16 i( l4 );
 single_value();  local l13 = l15; single_value();  local l17 = l4; single_value();  local l18 = n if n ~= CL["SOME"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["E"],n},function (l19,  ...)   single_value();  return LCL["CLOSETTE"]["SUBCLASSP"](LCL["CLOSETTE"]["FIND-CLASS"](l19, false), LCL["CLOSETTE"]["FIND-CLASS"](CL["CONDITION"], false)) end, 1, 0, false, false), l(l9)) then  l18 = n.bound else  single_value();  local l20 = CL["CONDITION"]; local l21 = l9; single_value();  local l22 = n if n ~= CL["MEMBER"](l20, l21, k()) then  l22 = l21 else  single_value();  single_value();  local l23 = CL["CONS"](l20, l9); single_value();  l9 = l23 l22 = l9 end l18 = l22 end i( l18 );
 single_value();  local l24 = CL["ASSOC"](LCL["KEYWORD"]["REPORT"], l17, k()); single_value();  local l26 = n if n ~= l24 then  single_value();  l26 = CL["CONS"](LCL["CLOSETTE"]["DEFMETHOD"], CL["CONS"](CL_LIB["REPORT-CONDITION"], CL["CONS"](CL["CONS"](CL["CONS"](CL_LIB["C"], CL["CONS"](l5, n)), CL["CONS"](CL["STREAM"], n)), CL["CONS"](CL["CONS"](CL["FUNCALL"], CL["CONS"](CL["CADR"](l24), CL["CONS"](CL_LIB["C"], CL["CONS"](CL["STREAM"], n)))), n)))) else  l26 = n.bound end local l25 = CL["CONS"](CL["PROGN"], CL["CONS"](CL["CONS"](LCL["CLOSETTE"]["DEFCLASS"], CL["CONS"](l5, CL["CONS"](l9, CL["CONS"](l13, CL["APPEND"](l(CL["REMOVE"](LCL["KEYWORD"]["REPORT"], l17, k(CL_LIB["KEY"], CL["CAR"].fbound)),n)))))), CL["CONS"](l26, CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), n)))); single_value();  i( CL["EVAL"](l25) );
 single_value();  return l25 end, 1, 1, false, false)); i( CL_LIB["FUNCTION-SETQ"](CL_LIB["MAKE-THREAD-STORAGE"] , CL_LIB["ALLOC-FUNCTION"]({CL["&KEY"],{{CL_LIB["HANDLERS"],{n,n}},{{CL_LIB["RESTARTS"],{n,n}},n}}},function (keys,  ...)  if not keys[CL_LIB["HANDLERS"]] then  keys[CL_LIB["HANDLERS"]] = n.bound end if not keys[CL_LIB["RESTARTS"]] then  keys[CL_LIB["RESTARTS"]] = n.bound end  single_value();  local l1 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-STRUCT"].fbound, {}); local l2 = CL_LIB["THREAD-STORAGE"]; single_value(); l1[CL["IDENTITY"]("name")] = l2 i( l2 );
 local l3 = keys[CL_LIB["HANDLERS"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["HANDLERS"])] = l3 i( l3 );
 local l4 = keys[CL_LIB["RESTARTS"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["RESTARTS"])] = l4 i( l4 );
 single_value();  return l1 end, 0, 0, false, {0 , [LCL["KEYWORD"]["HANDLERS"]] = CL_LIB["HANDLERS"], [LCL["KEYWORD"]["RESTARTS"]] = CL_LIB["RESTARTS"]})) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["COPY-THREAD-STORAGE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l5,  ...)   single_value();  return CL["COPY-STRUCTURE"](l5) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL_LIB["THREAD-STORAGE"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l6,  ...)   single_value();  return CL_LIB["%CHECK-STRUCT-TYPE"](l6, CL_LIB["THREAD-STORAGE"]) end, 1, 0, false, false), {CL["STRUCTURE-OBJECT"],{CL["T"],n}}) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["THREAD-STORAGE-P"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l7,  ...)   single_value();  return CL["TYPEP"](l7, CL_LIB["THREAD-STORAGE"], false) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["THREAD-STORAGE-HANDLERS"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l8,  ...)   single_value();  local l9 = n.bound; local l10 = n.bound; local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l9,l10,l11,l12,l13= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l8, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = n.bound; local l19 = n.bound; local l20 = n.bound; local l21 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l22 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l24 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l23 = l24; single_value();  single_value();  l18,l19,l20= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l13, l9, l10), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l21 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l22.error ~= n and true then if l22.error == KEYWORD.TAG then  error(l22) else error(l22[1]) end end i( CL["VALUES-LIST"](list_r(l22)) );
 single_value();  local l25 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l19,l20,CL["LIST"](l(l25)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["HANDLERS"],n}},{CL_LIB["NEW"],n}}}},n}}})),l18,CL["LIST"](l(l25)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["THREAD-STORAGE-HANDLERS"])),l18)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["THREAD-STORAGE-HANDLERS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l26,  ...)   single_value();  local l27 = CL_LIB["HANDLERS"]; local l28 = n.bound; single_value();  return ((l26)[l27] or l28) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["THREAD-STORAGE-RESTARTS"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l29,  ...)   single_value();  local l30 = n.bound; local l31 = n.bound; local l32 = n.bound; local l33 = n.bound; local l34 = n.bound; local l35 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l36 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l38 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l37 = l38; single_value();  single_value();  l30,l31,l32,l33,l34= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l29, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l35 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l36.error ~= n and true then if l36.error == KEYWORD.TAG then  error(l36) else error(l36[1]) end end i( CL["VALUES-LIST"](list_r(l36)) );
 single_value();  local l39 = n.bound; local l40 = n.bound; local l41 = n.bound; local l42 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l43 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l45 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l44 = l45; single_value();  single_value();  l39,l40,l41= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l34, l30, l31), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l42 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l43.error ~= n and true then if l43.error == KEYWORD.TAG then  error(l43) else error(l43[1]) end end i( CL["VALUES-LIST"](list_r(l43)) );
 single_value();  local l46 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l40,l41,CL["LIST"](l(l46)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["RESTARTS"],n}},{CL_LIB["NEW"],n}}}},n}}})),l39,CL["LIST"](l(l46)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["THREAD-STORAGE-RESTARTS"])),l39)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["THREAD-STORAGE-RESTARTS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l47,  ...)   single_value();  local l48 = CL_LIB["RESTARTS"]; local l49 = n.bound; single_value();  return ((l47)[l48] or l49) end, 1, 0, false, false)) );
 single_value();  tmp = CL_LIB["THREAD-STORAGE"]; local l1 = CL_LIB["MAKE-THREAD-STORAGE"](k()); single_value();  tmp = CL_LIB.DEF(CL_LIB["*THREAD*"],l1); tmp = CL["RESTART-NAME"]; i( CL_LIB["FUNCTION-SETQ"](CL_LIB["MAKE-RESTART"] , CL_LIB["ALLOC-FUNCTION"]({CL["&KEY"],{{CL_LIB["NAME"],{n,n}},{{CL["FUNCTION"],{n,n}},{{CL_LIB["INTERACTIVE-FUNCTION"],{n,n}},{{CL_LIB["REPORT-FUNCTION"],{n,n}},{{CL_LIB["TEST-FUNCTION"],{n,n}},n}}}}}},function (keys,  ...)  if not keys[CL_LIB["NAME"]] then  keys[CL_LIB["NAME"]] = n.bound end if not keys[CL["FUNCTION"]] then  keys[CL["FUNCTION"]] = n.bound end if not keys[CL_LIB["INTERACTIVE-FUNCTION"]] then  keys[CL_LIB["INTERACTIVE-FUNCTION"]] = n.bound end if not keys[CL_LIB["REPORT-FUNCTION"]] then  keys[CL_LIB["REPORT-FUNCTION"]] = n.bound end if not keys[CL_LIB["TEST-FUNCTION"]] then  keys[CL_LIB["TEST-FUNCTION"]] = n.bound end  single_value();  local l1 = CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-STRUCT"].fbound, {}); local l2 = CL["RESTART"]; single_value(); l1[CL["IDENTITY"]("name")] = l2 i( l2 );
 local l3 = keys[CL_LIB["NAME"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["NAME"])] = l3 i( l3 );
 local l4 = keys[CL["FUNCTION"]]; single_value(); l1[CL["IDENTITY"](CL["FUNCTION"])] = l4 i( l4 );
 local l5 = keys[CL_LIB["INTERACTIVE-FUNCTION"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["INTERACTIVE-FUNCTION"])] = l5 i( l5 );
 local l6 = keys[CL_LIB["REPORT-FUNCTION"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["REPORT-FUNCTION"])] = l6 i( l6 );
 local l7 = keys[CL_LIB["TEST-FUNCTION"]]; single_value(); l1[CL["IDENTITY"](CL_LIB["TEST-FUNCTION"])] = l7 i( l7 );
 single_value();  return l1 end, 0, 0, false, {0 , [LCL["KEYWORD"]["NAME"]] = CL_LIB["NAME"], [LCL["KEYWORD"]["FUNCTION"]] = CL["FUNCTION"], [LCL["KEYWORD"]["INTERACTIVE-FUNCTION"]] = CL_LIB["INTERACTIVE-FUNCTION"], [LCL["KEYWORD"]["REPORT-FUNCTION"]] = CL_LIB["REPORT-FUNCTION"], [LCL["KEYWORD"]["TEST-FUNCTION"]] = CL_LIB["TEST-FUNCTION"]})) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["COPY-RESTART"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l8,  ...)   single_value();  return CL["COPY-STRUCTURE"](l8) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-TYPE-SPECIFIER"](CL["RESTART"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],n},function (l9,  ...)   single_value();  return CL_LIB["%CHECK-STRUCT-TYPE"](l9, CL["RESTART"]) end, 1, 0, false, false), {CL["STRUCTURE-OBJECT"],{CL["T"],n}}) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["RESTART-P"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l10,  ...)   single_value();  return CL["TYPEP"](l10, CL["RESTART"], false) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL["RESTART-NAME"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l11,  ...)   single_value();  local l12 = n.bound; local l13 = n.bound; local l14 = n.bound; local l15 = n.bound; local l16 = n.bound; local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l18 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l20 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l19 = l20; single_value();  single_value();  l12,l13,l14,l15,l16= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l11, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l17 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l18.error ~= n and true then if l18.error == KEYWORD.TAG then  error(l18) else error(l18[1]) end end i( CL["VALUES-LIST"](list_r(l18)) );
 single_value();  local l21 = n.bound; local l22 = n.bound; local l23 = n.bound; local l24 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l25 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l27 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l26 = l27; single_value();  single_value();  l21,l22,l23= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l16, l12, l13), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l24 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l25.error ~= n and true then if l25.error == KEYWORD.TAG then  error(l25) else error(l25[1]) end end i( CL["VALUES-LIST"](list_r(l25)) );
 single_value();  local l28 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l22,l23,CL["LIST"](l(l28)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["NAME"],n}},{CL_LIB["NEW"],n}}}},n}}})),l21,CL["LIST"](l(l28)))),CL["APPEND"](l(CL["LIST"](l(CL["RESTART-NAME"])),l21)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL["RESTART-NAME"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l29,  ...)   single_value();  local l30 = CL_LIB["NAME"]; local l31 = n.bound; single_value();  return ((l29)[l30] or l31) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["RESTART-FUNCTION"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l32,  ...)   single_value();  local l33 = n.bound; local l34 = n.bound; local l35 = n.bound; local l36 = n.bound; local l37 = n.bound; local l38 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l39 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l41 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l40 = l41; single_value();  single_value();  l33,l34,l35,l36,l37= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l32, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l38 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l39.error ~= n and true then if l39.error == KEYWORD.TAG then  error(l39) else error(l39[1]) end end i( CL["VALUES-LIST"](list_r(l39)) );
 single_value();  local l42 = n.bound; local l43 = n.bound; local l44 = n.bound; local l45 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l46 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l48 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l47 = l48; single_value();  single_value();  l42,l43,l44= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l37, l33, l34), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l45 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l46.error ~= n and true then if l46.error == KEYWORD.TAG then  error(l46) else error(l46[1]) end end i( CL["VALUES-LIST"](list_r(l46)) );
 single_value();  local l49 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l43,l44,CL["LIST"](l(l49)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL["FUNCTION"],n}},{CL_LIB["NEW"],n}}}},n}}})),l42,CL["LIST"](l(l49)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["RESTART-FUNCTION"])),l42)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["RESTART-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l50,  ...)   single_value();  local l51 = CL["FUNCTION"]; local l52 = n.bound; single_value();  return ((l50)[l51] or l52) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["RESTART-INTERACTIVE-FUNCTION"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l53,  ...)   single_value();  local l54 = n.bound; local l55 = n.bound; local l56 = n.bound; local l57 = n.bound; local l58 = n.bound; local l59 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l60 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l62 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l61 = l62; single_value();  single_value();  l54,l55,l56,l57,l58= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l53, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l59 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l60.error ~= n and true then if l60.error == KEYWORD.TAG then  error(l60) else error(l60[1]) end end i( CL["VALUES-LIST"](list_r(l60)) );
 single_value();  local l63 = n.bound; local l64 = n.bound; local l65 = n.bound; local l66 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l67 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l69 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l68 = l69; single_value();  single_value();  l63,l64,l65= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l58, l54, l55), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l66 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l67.error ~= n and true then if l67.error == KEYWORD.TAG then  error(l67) else error(l67[1]) end end i( CL["VALUES-LIST"](list_r(l67)) );
 single_value();  local l70 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l64,l65,CL["LIST"](l(l70)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["INTERACTIVE-FUNCTION"],n}},{CL_LIB["NEW"],n}}}},n}}})),l63,CL["LIST"](l(l70)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["RESTART-INTERACTIVE-FUNCTION"])),l63)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["RESTART-INTERACTIVE-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l71,  ...)   single_value();  local l72 = CL_LIB["INTERACTIVE-FUNCTION"]; local l73 = n.bound; single_value();  return ((l71)[l72] or l73) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["RESTART-REPORT-FUNCTION"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l74,  ...)   single_value();  local l75 = n.bound; local l76 = n.bound; local l77 = n.bound; local l78 = n.bound; local l79 = n.bound; local l80 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l81 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l83 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l82 = l83; single_value();  single_value();  l75,l76,l77,l78,l79= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l74, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l80 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l81.error ~= n and true then if l81.error == KEYWORD.TAG then  error(l81) else error(l81[1]) end end i( CL["VALUES-LIST"](list_r(l81)) );
 single_value();  local l84 = n.bound; local l85 = n.bound; local l86 = n.bound; local l87 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l88 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l90 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l89 = l90; single_value();  single_value();  l84,l85,l86= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l79, l75, l76), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l87 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l88.error ~= n and true then if l88.error == KEYWORD.TAG then  error(l88) else error(l88[1]) end end i( CL["VALUES-LIST"](list_r(l88)) );
 single_value();  local l91 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l85,l86,CL["LIST"](l(l91)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["REPORT-FUNCTION"],n}},{CL_LIB["NEW"],n}}}},n}}})),l84,CL["LIST"](l(l91)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["RESTART-REPORT-FUNCTION"])),l84)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["RESTART-REPORT-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l92,  ...)   single_value();  local l93 = CL_LIB["REPORT-FUNCTION"]; local l94 = n.bound; single_value();  return ((l92)[l93] or l94) end, 1, 0, false, false)) );
 i( CL_LIB["%REGISTER-SETF-EXPANDER"](CL_LIB["RESTART-TEST-FUNCTION"], CL_LIB["ALLOC-FUNCTION"]({CL["&REST"],{CL_LIB["X"],n}},function (l95,  ...)   single_value();  local l96 = n.bound; local l97 = n.bound; local l98 = n.bound; local l99 = n.bound; local l100 = n.bound; local l101 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l102 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l104 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l103 = l104; single_value();  single_value();  l96,l97,l98,l99,l100= unpack_mv(CL_LIB["GET-SETF-ALL-EXPANSION"](l95, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l101 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l102.error ~= n and true then if l102.error == KEYWORD.TAG then  error(l102) else error(l102[1]) end end i( CL["VALUES-LIST"](list_r(l102)) );
 single_value();  local l105 = n.bound; local l106 = n.bound; local l107 = n.bound; local l108 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l109 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l111 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l110 = l111; single_value();  single_value();  l105,l106,l107= unpack_mv(CL_LIB["GEN-SYM-ALL-GETTERS"](l100, l96, l97), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l108 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l109.error ~= n and true then if l109.error == KEYWORD.TAG then  error(l109) else error(l109[1]) end end i( CL["VALUES-LIST"](list_r(l109)) );
 single_value();  local l112 = CL["GENSYM"](false); single_value();  return CL["VALUES"](l(l106,l107,CL["LIST"](l(l112)),CL["APPEND"](l(CL["LIST"](l({CL["LAMBDA"],{{CL_LIB["PLACE"],{CL_LIB["NEW"],n}},{{CL_LIB["LUA-SET-TABLE"],{CL_LIB["PLACE"],{{CL["QUOTE"],{CL_LIB["TEST-FUNCTION"],n}},{CL_LIB["NEW"],n}}}},n}}})),l105,CL["LIST"](l(l112)))),CL["APPEND"](l(CL["LIST"](l(CL_LIB["RESTART-TEST-FUNCTION"])),l105)))) end, 0, 0, true, false)) );
 single_value();  i( CL_LIB["FUNCTION-SETQ"](CL_LIB["RESTART-TEST-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l113,  ...)   single_value();  local l114 = CL_LIB["TEST-FUNCTION"]; local l115 = n.bound; single_value();  return ((l113)[l114] or l115) end, 1, 0, false, false)) );
 single_value();  tmp = CL["RESTART"]; tmp = CL_LIB["MACRO-SETQ"](CL["HANDLER-BIND"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G188510"],{CL["&OPTIONAL"],{LCL["NIL"]["G188511"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  return CL["CONS"](CL["UNWIND-PROTECT"], CL["CONS"](CL["CONS"](CL["PROGN"], CL["CONS"](CL["CONS"](CL["PUSH"], CL["CONS"](CL["CONS"](CL["LIST"], CL["APPEND"](l(CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["B"],n},function (l10,  ...)   single_value();  return CL["CONS"](CL["LIST"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"]((l10)[1], n)), CL["CONS"](CL["CADR"](l10), n))) end, 1, 0, false, false), l(l5)),n))), CL["CONS"](CL["CONS"](CL_LIB["THREAD-STORAGE-HANDLERS"], CL["CONS"](CL_LIB["*THREAD*"], n)), n))), CL["APPEND"](l(l9,n)))), CL["CONS"](CL["CONS"](CL["POP"], CL["CONS"](CL["CONS"](CL_LIB["THREAD-STORAGE-HANDLERS"], CL["CONS"](CL_LIB["*THREAD*"], n)), n)), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["IGNORE-ERRORS"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G188593"],{CL["&OPTIONAL"],{LCL["NIL"]["G188594"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["CATCH"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l6, n)), CL["CONS"](CL["CONS"](CL["HANDLER-BIND"], CL["CONS"](CL["CONS"](CL["CONS"](CL["ERROR"], CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](CL["CONS"](CL["CONDITION"], n), CL["CONS"](CL["CONS"](CL["THROW"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l6, n)), CL["CONS"](n, n))), n))), n)), n)), n), CL["APPEND"](l(l5,n)))), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["HANDLER-CASE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G188648"],{CL["&OPTIONAL"],{LCL["NIL"]["G188649"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = CL["GENSYM"](false); single_value();  local l11 = CL["GENSYM"](false); single_value();  local l12 = CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["BIND"],n},function (l13,  ...)   single_value();  return CL["CONS"]((l13)[1], CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](CL["CADR"](l13), CL["CONS"](CL["CONS"](CL["THROW"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l10, n)), CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(CL["CDDR"](l13),n))), n))), n))), n)), n)) end, 1, 0, false, false), l(CL["REMOVE-IF"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["N"],n},function (l14,  ...)   single_value();  return CL["EQ"](LCL["KEYWORD"]["NO-ERROR"], (l14)[1]) end, 1, 0, false, false), l9, k()))); single_value();  local l15 = CL["REMOVE-IF-NOT"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["N"],n},function (l16,  ...)   single_value();  return CL["EQ"](LCL["KEYWORD"]["NO-ERROR"], (l16)[1]) end, 1, 0, false, false), l9, k()); single_value();  local l18 = n if n ~= l15 then  l18 = CL["CONS"](CL["FUNCTION"], CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["APPEND"](l(CL["CDAR"](l15),n))), n)) else  l18 = n.bound end local l17 = l18; single_value();  single_value();  local l19 = n if n ~= l17 then  l19 = CL["CONS"](CL["APPLY"], CL["CONS"](l17, CL["CONS"](CL["CONS"](CL["CATCH"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l11, n)), CL["CONS"](CL["CONS"](CL["HANDLER-BIND"], CL["CONS"](l12, CL["CONS"](CL["CONS"](CL["THROW"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l11, n)), CL["CONS"](CL["CONS"](CL["MULTIPLE-VALUE-LIST"], CL["CONS"](l5, n)), n))), n))), n))), n))) else  l19 = CL["CONS"](CL["HANDLER-BIND"], CL["CONS"](l12, CL["CONS"](l5, n))) end return CL["CONS"](CL["CATCH"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l10, n)), CL["CONS"](l19, n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["RESTART-BIND"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G188795"],{CL["&OPTIONAL"],{LCL["NIL"]["G188796"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  return CL["CONS"](CL["UNWIND-PROTECT"], CL["CONS"](CL["CONS"](CL["PROGN"], CL["CONS"](CL["CONS"](CL["PUSH"], CL["CONS"](CL["CONS"](CL["LIST"], CL["APPEND"](l(CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["R"],n},function (l10,  ...)   single_value();  local l11 = l10; single_value();  local l12 = l10; single_value();  local l14 = l12; single_value();  local l15 = (l14)[1]; single_value();  single_value();  local l16 = (l14)[2]; single_value();  l12 = l16 i( l12 );
 single_value();  local l13 = l15; single_value();  local l18 = l12; single_value();  local l19 = (l18)[1]; single_value();  single_value();  local l20 = (l18)[2]; single_value();  l12 = l20 i( l12 );
 single_value();  local l17 = l19; single_value();  local l21 = l12; single_value();  single_value();  return CL["CONS"](CL_LIB["MAKE-RESTART"], CL["CONS"](LCL["KEYWORD"]["NAME"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l13, n)), CL["CONS"](LCL["KEYWORD"]["FUNCTION"], CL["CONS"](l17, CL["APPEND"](l(l21,n))))))) end, 1, 0, false, false), l(l5)),n))), CL["CONS"](CL["CONS"](CL_LIB["THREAD-STORAGE-RESTARTS"], CL["CONS"](CL_LIB["*THREAD*"], n)), n))), CL["APPEND"](l(l9,n)))), CL["CONS"](CL["CONS"](CL["POP"], CL["CONS"](CL["CONS"](CL_LIB["THREAD-STORAGE-RESTARTS"], CL["CONS"](CL_LIB["*THREAD*"], n)), n)), n))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["RESTART-CASE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G188941"],{CL["&OPTIONAL"],{LCL["NIL"]["G188942"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l9 = l4; single_value();  single_value();  local l10 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["CATCH"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l10, n)), CL["CONS"](CL["CONS"](CL["RESTART-BIND"], CL["CONS"](CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["CLAUSE"],n},function (l11,  ...)   single_value();  local l12 = CL["FIRST"](l11); local l13 = CL["SECOND"](l11); local l14 = n.bound; local l15 = n.bound; local l16 = n.bound; local l17 = CL["CDDR"](l11); while true do  local l18 = n if n ~= CL["EQ"]((l17)[1], LCL["KEYWORD"]["REPORT"]) then  single_value();  l14 = CL["SECOND"](l17) l18 = l14 else  local l19 = n if n ~= CL["EQ"]((l17)[1], LCL["KEYWORD"]["INTERACTIVE"]) then  single_value();  l15 = CL["SECOND"](l17) l19 = l15 else  local l20 = n if n ~= CL["EQ"]((l17)[1], LCL["KEYWORD"]["TEST"]) then  single_value();  l16 = CL["SECOND"](l17) l20 = l16 else  local l21 = n if n ~= CL["T"].bound then  single_value(); do break end; l21 = n.bound else  l21 = n.bound end l20 = l21 end l19 = l20 end l18 = l19 end i( l18 );
 single_value();  l17 = CL["CDDR"](l17) local tmpres = l17 end i( n );
 single_value();  local l22 = n if n ~= l14 then  single_value();  local l23 = n if n ~= CL["STRINGP"](l14) then  l23 = CL["CONS"](CL["LAMBDA"], CL["CONS"](CL["CONS"](CL["STREAM"], n), CL["CONS"](CL["CONS"](CL["WRITE-STRING"], CL["CONS"](l14, CL["CONS"](CL["STREAM"], n))), n))) else  l23 = CL["CONS"](CL["FUNCTION"], CL["CONS"](l14, n)) end l22 = CL["CONS"](LCL["KEYWORD"]["REPORT-FUNCTION"], CL["CONS"](l23, n)) else  l22 = n.bound end local l24 = n if n ~= l15 then  single_value();  l24 = CL["CONS"](LCL["KEYWORD"]["INTERACTIVE-FUNCTION"], CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](l15, n)), n)) else  l24 = n.bound end local l25 = n if n ~= l16 then  single_value();  l25 = CL["CONS"](LCL["KEYWORD"]["TEST-FUNCTION"], CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](l16, n)), n)) else  l25 = n.bound end return CL["CONS"](l12, CL["CONS"](CL["CONS"](CL["FUNCTION"], CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](l13, CL["CONS"](CL["CONS"](CL["THROW"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l10, n)), CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(l17,n))), n))), n))), n)), CL["APPEND"](l(l22,CL["APPEND"](l(l24,CL["APPEND"](l(l25,n)))))))) end, 1, 0, false, false), l(l9)), CL["CONS"](l5, n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["COMPUTE-RESTARTS"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{CL["CONDITION"],n}},function (l1,  ...)  if not l1 then  l1 = n.bound end  single_value();  return CL["APPLY"](CL["CONCATENATE"].fbound, CL["LIST"], l(CL_LIB["THREAD-STORAGE-RESTARTS"](CL_LIB["*THREAD*"].bound))) end, 0, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["FIND-RESTART"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["IDENTIFIER"],{CL["&OPTIONAL"],{CL["CONDITION"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = n if n ~= CL_LIB["RESTART-P"](l1) then  l3 = l1 else  l3 = CL["FIND"](l1, CL["COMPUTE-RESTARTS"](l2), k(CL_LIB["KEY"], CL["RESTART-NAME"].fbound)) end return l3 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["INVOKE-RESTART"] , CL_LIB["ALLOC-FUNCTION"]({CL["RESTART"],{CL["&REST"],{CL_LIB["ARGUMENTS"],n}}},function (l1, l2,  ...)   single_value();  local l3 = CL["FIND-RESTART"](l1, false); single_value();  local l4 = n if n ~= l3 then  l4 = CL["APPLY"](CL_LIB["RESTART-FUNCTION"](l3), l2, l()) else  l4 = CL["ERROR"]("Can't find restart", l()) end return l4 end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["INVOKE-RESTART-INTERACTIVELY"] , CL_LIB["ALLOC-FUNCTION"]({CL["RESTART"],n},function (l1,  ...)   single_value();  local l2 = CL["FIND-RESTART"](l1, false); single_value();  local l3 = n if n ~= l2 then  local l4 = CL_LIB["RESTART-INTERACTIVE-FUNCTION"](l2); single_value();  local l5 = n if n ~= l4 then  l5 = CL["APPLY"](CL_LIB["RESTART-FUNCTION"](l2), CL_LIB['FUNCALL-LUA'](l4,{}), l()) else  l5 = CL["FUNCALL"](CL_LIB["RESTART-FUNCTION"](l2), l()) end l3 = l5 else  l3 = CL["ERROR"]("Can't find restart", l()) end return l3 end, 1, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["WITH-SIMPLE-RESTART"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G189149"],{CL["&OPTIONAL"],{LCL["NIL"]["G189150"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l5; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l5 = l12 i( l5 );
 single_value();  local l9 = l11; single_value();  local l14 = l5; single_value();  local l15 = (l14)[1]; single_value();  single_value();  local l16 = (l14)[2]; single_value();  l5 = l16 i( l5 );
 single_value();  local l13 = l15; single_value();  local l17 = l5; single_value();  local l18 = l4; single_value();  single_value();  return CL["CONS"](CL["RESTART-CASE"], CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(l18,n))), CL["CONS"](CL["CONS"](l9, CL["CONS"](n, CL["CONS"](LCL["KEYWORD"]["REPORT"], CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["CONS"](CL["CONS"](CL["STREAM"], n), CL["CONS"](CL["CONS"](CL["FORMAT"], CL["CONS"](CL["STREAM"], CL["CONS"](l13, CL["APPEND"](l(l17,n))))), n))), CL["CONS"](CL["CONS"](CL["VALUES"], CL["CONS"](n, CL["CONS"](CL["T"], n))), n))))), n))) end, 1, 1, false, false)); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL_LIB["*DEBUGGER-HOOK*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL["INVOKE-DEBUGGER"] , CL_LIB["ALLOC-FUNCTION"]({CL["CONDITION"],n},function (l1,  ...)   single_value();  local l2 = CL_LIB["*DEBUGGER-HOOK*"].bound; local l3 = n if n ~= l2 then  single_value();  local l4 = CL_LIB["*DEBUGGER-HOOK*"].bound; single_value();  local l5 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l7 = CL_LIB["*DEBUGGER-HOOK*"].bound; CL_LIB["*DEBUGGER-HOOK*"].bound = n.bound i( CL_LIB["*DEBUGGER-HOOK*"].bound );
 single_value();  local l6 = l7; single_value();  single_value();  local l8 = l1; single_value();  local l9 = l2; single_value();  return CL_LIB['FUNCALL-LUA'](l2,{l8, l9, }) end, 0, 0, false, false))); CL_LIB["*DEBUGGER-HOOK*"].bound = l4 i( CL_LIB["*DEBUGGER-HOOK*"].bound );
 single_value(); if l5.error ~= n and true then if l5.error == KEYWORD.TAG then  error(l5) else error(l5[1]) end end l3 = CL["VALUES-LIST"](list_r(l5)) else  l3 = n.bound end i( l3 );
 single_value();  return error(l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%%SIGNAL"] , CL_LIB["ALLOC-FUNCTION"]({CL["CONDITION"],n},function (l1,  ...)   single_value();  local l2 = LCL["CLOSETTE"]["CLASS-OF"](l1); local l3 = CL_LIB["THREAD-STORAGE-HANDLERS"](CL_LIB["*THREAD*"].bound); single_value();  local l4 = (l3)[1]; single_value();  single_value();  local l5 = CL["GENSYM"](false); single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l7 = n if n ~= CL["NOT"](l3) then  single_value(); do break end; l7 = n.bound else  l7 = n.bound end i( l7 );
 local l8 = l4; single_value();  local l9 = (l8)[1]; single_value();  single_value();  local l10 = CL["GENSYM"](false); single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l12 = n if n ~= CL["NOT"](l8) then  single_value(); do break end; l12 = n.bound else  l12 = n.bound end i( l12 );
 local l13 = n if n ~= LCL["CLOSETTE"]["SUBCLASSP"](l2, LCL["CLOSETTE"]["FIND-CLASS"]((l9)[1], false)) then  i( CL["FUNCALL"](CL["CADR"](l9), l(l1)) );
 single_value();  local l14 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l13 = error({tag=CL["IDENTITY"](l10),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l14)) end)()}) else  l13 = n.bound end i( l13 );
 single_value();  single_value();  local l15 = (l8)[2]; single_value();  l8 = l15 i( l8 );
 single_value();  single_value();  single_value();  local l16 = (l8)[1]; single_value();  l9 = l16 local tmpres = l9 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l11.error ~= n and (l11.error ~= KEYWORD.TAG or l11.tag ~= l10) then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end i( CL["VALUES-LIST"](list_r(l11)) );
 single_value();  single_value();  local l17 = (l3)[2]; single_value();  l3 = l17 i( l3 );
 single_value();  single_value();  single_value();  local l18 = (l3)[1]; single_value();  l4 = l18 local tmpres = l4 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l6.error ~= n and (l6.error ~= KEYWORD.TAG or l6.tag ~= l5) then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end i( CL["VALUES-LIST"](list_r(l6)) );
 single_value();  return n.bound end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SIGNAL"] , CL_LIB["ALLOC-FUNCTION"]({CL["CONDITION"],n},function (l1,  ...)   local l2 = n if n ~= CL["TYPEP"](l1, CL["*BREAK-ON-SIGNALS*"].bound, false) then  single_value();  local l3 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l4 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  local l5 = CL_LIB["*THREAD*"].bound; single_value();  single_value();  local l6 = CL["CONS"](CL["LIST"](l(CL_LIB["MAKE-RESTART"](k(CL_LIB["NAME"], CL["CONTINUE"], CL["FUNCTION"], CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  return error({tag=CL["IDENTITY"](LCL["NIL"]["G189466"]),(function () single_value() return unpack_mv(n.bound) end)()}) end, 0, 0, false, false), CL_LIB["REPORT-FUNCTION"], CL_LIB["ALLOC-FUNCTION"]({CL_LIB["S"],n},function (l7,  ...)   single_value();  return CL["FORMAT"](l7, "Continue to signal", l()) end, 1, 0, false, false))))), CL_LIB["THREAD-STORAGE-RESTARTS"](CL_LIB["*THREAD*"].bound)); single_value();  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l8, l9,  ...)   single_value();  local l10 = l9; single_value(); l8[CL["IDENTITY"](CL_LIB["RESTARTS"])] = l10 return l10 end, 2, 0, false, false), {l5, l6, }) );
 single_value();  return CL["INVOKE-DEBUGGER"](CL["MAKE-CONDITION"](CL["SIMPLE-CONDITION"], l(LCL["KEYWORD"]["FORMAT-CONTROL"],"[*break-on-signals*]: ~S",LCL["KEYWORD"]["FORMAT-ARGUMENTS"],CL["LIST"](l(l1))))) end, 0, 0, false, false))); local l11 = CL_LIB["THREAD-STORAGE-RESTARTS"](CL_LIB["*THREAD*"].bound); single_value();  local l12 = (l11)[1]; single_value();  local l13 = CL_LIB["*THREAD*"].bound; single_value();  single_value();  local l14 = (l11)[2]; single_value();  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l15, l16,  ...)   single_value();  local l17 = l16; single_value(); l15[CL["IDENTITY"](CL_LIB["RESTARTS"])] = l17 return l17 end, 2, 0, false, false), {l13, l14, }) );
 single_value();  i( l12 );
 single_value(); if l4.error ~= n and true then if l4.error == KEYWORD.TAG then  error(l4) else error(l4[1]) end end return CL["VALUES-LIST"](list_r(l4)) end, 0, 0, false, false))); single_value(); if l3.error ~= n and (l3.error ~= KEYWORD.TAG or l3.tag ~= LCL["NIL"]["G189466"]) then if l3.error == KEYWORD.TAG then  error(l3) else error(l3[1]) end end l2 = CL["VALUES-LIST"](list_r(l3)) else  l2 = n.bound end i( l2 );
 single_value();  return CL_LIB["%%SIGNAL"](l1) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MAKE-CONDITION"] , CL_LIB["ALLOC-FUNCTION"]({CL["TYPE"],{CL["&REST"],{CL_LIB["SLOT-INIT"],n}}},function (l1, l2,  ...)   single_value();  return CL["APPLY"](LCL["CLOSETTE"]["MAKE-INSTANCE"].fbound, l1, l(l2)) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%MAKE-CONDITION-SIGNAL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SIGNAL-CLASS"],{CL["DATUM"],{CL_LIB["ARGUMENTS"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = l2; single_value();  local l5 = n if n ~= CL["TYPEP"](l4, CL["SYMBOL"], false) then  single_value();  l5 = CL["APPLY"](CL["MAKE-CONDITION"].fbound, l2, l(l3)) else  local l6 = n if n ~= CL["TYPEP"](l4, CL["STRING"], false) then  single_value();  l6 = CL["MAKE-CONDITION"](l1, l(LCL["KEYWORD"]["FORMAT-CONTROL"],l2,LCL["KEYWORD"]["FORMAT-ARGUMENTS"],l3)) else  local l7 = n if n ~= CL["TYPEP"](l4, CL["T"], false) then  single_value();  l7 = CL["ERROR"]("Can't make condition", l()) else  l7 = n.bound end l6 = l7 end l5 = l6 end return l5 end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["SIGNAL"] , CL_LIB["ALLOC-FUNCTION"]({CL["DATUM"],{CL["&REST"],{CL_LIB["ARGUMENTS"],n}}},function (l1, l2,  ...)   single_value();  return CL_LIB["%SIGNAL"](CL_LIB["%MAKE-CONDITION-SIGNAL"](CL["SIMPLE-CONDITION"], l1, l2)) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ERROR"] , CL_LIB["ALLOC-FUNCTION"]({CL["DATUM"],{CL["&REST"],{CL_LIB["ARGUMENTS"],n}}},function (l1, l2,  ...)   single_value();  local l3 = CL_LIB["%MAKE-CONDITION-SIGNAL"](CL["SIMPLE-ERROR"], l1, l2); i( CL_LIB["%SIGNAL"](l3) );
 single_value();  return CL["INVOKE-DEBUGGER"](l3) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["WARN"] , CL_LIB["ALLOC-FUNCTION"]({CL["DATUM"],{CL["&REST"],{CL_LIB["ARGUMENTS"],n}}},function (l1, l2,  ...)   single_value();  local l3 = CL_LIB["%MAKE-CONDITION-SIGNAL"](CL["SIMPLE-WARNING"], l1, l2); i( CL_LIB["%SIGNAL"](l3) );
 i( CL["FRESH-LINE"](CL["*ERROR-OUTPUT*"].bound) );
 i( CL["WRITE-STRING"]("WARNING: ", CL["*ERROR-OUTPUT*"].bound, k()) );
 single_value();  return CL_LIB["REPORT-CONDITION"](l(l3,CL["*ERROR-OUTPUT*"].bound)) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["ABORT"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{CL["CONDITION"],n}},function (l1,  ...)  if not l1 then  l1 = n.bound end  single_value();  return CL["INVOKE-RESTART"](CL["ABORT"], l()) end, 0, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["CONTINUE"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{CL["CONDITION"],n}},function (l1,  ...)  if not l1 then  l1 = n.bound end  single_value();  local l2 = CL["FIND-RESTART"](CL["CONTINUE"], false); single_value();  local l3 = n if n ~= l2 then  l3 = CL["INVOKE-RESTART"](l2, l()) else  l3 = n.bound end return l3 end, 0, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["MUFFLE-WARNING"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{CL["CONDITION"],n}},function (l1,  ...)  if not l1 then  l1 = n.bound end  single_value();  return CL["INVOKE-RESTART"](CL["MUFFLE-WARNING"], l()) end, 0, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["STORE-VALUE"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{CL["CONDITION"],n}},function (l1,  ...)  if not l1 then  l1 = n.bound end  single_value();  local l2 = CL["FIND-RESTART"](CL["STORE-VALUE"], false); single_value();  local l3 = n if n ~= l2 then  l3 = CL["INVOKE-RESTART"](l2, l(CL_LIB["X"].bound)) else  l3 = n.bound end return l3 end, 0, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["USE-VALUE"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{CL["CONDITION"],n}},function (l1,  ...)  if not l1 then  l1 = n.bound end  single_value();  local l2 = CL["FIND-RESTART"](CL["USE-VALUE"], false); single_value();  local l3 = n if n ~= l2 then  l3 = CL["INVOKE-RESTART"](l2, l(CL_LIB["X"].bound)) else  l3 = n.bound end return l3 end, 0, 1, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL_LIB["*TRACE-FUNCTIONS*"],l1); local l2 = "__call"; local l3 = n.bound; single_value();  local l1 = ((CL_LIB["FUNCTION-METATABLE"].bound)[l2] or l3); single_value();  tmp = CL_LIB.DEF(CL_LIB["*FUNC-METATABLE-DEFAULT*"],l1); local l1 = function (fbound, ...) if fbound.trace then CL_LIB['%TRACE-HOOK-CALL'](fbound, l(...)) end local ret = fbound.func(...) if fbound.trace then CL_LIB['%TRACE-HOOK-RET'](fbound, ret) end return ret end; single_value();  tmp = CL_LIB.DEF(CL_LIB["*FUNC-METATABLE-TRACE*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%TRACE-HOOK-CALL"] , CL_LIB["ALLOC-FUNCTION"]({CL["FUNCTION"],{CL["&REST"],{CL_LIB["ARGUMENTS"],n}}},function (l1, l2,  ...)   i( CL["FRESH-LINE"](CL["*TRACE-OUTPUT*"].bound) );
 i( CL["WRITE-STRING"]("TRACE CALL: ", CL["*TRACE-OUTPUT*"].bound, k()) );
 i( CL["PRINT-OBJECT"](l(l1,CL["*TRACE-OUTPUT*"].bound)) );
 i( CL["WRITE-STRING"](" ", CL["*TRACE-OUTPUT*"].bound, k()) );
 i( CL["PRINT-OBJECT"](l(l2,CL["*TRACE-OUTPUT*"].bound)) );
 single_value();  return CL["FRESH-LINE"](CL["*TRACE-OUTPUT*"].bound) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%TRACE-HOOK-RET"] , CL_LIB["ALLOC-FUNCTION"]({CL["FUNCTION"],{CL["RETURN"],n}},function (l1, l2,  ...)   i( CL["FRESH-LINE"](CL["*TRACE-OUTPUT*"].bound) );
 i( CL["WRITE-STRING"]("TRACE RETURN: ", CL["*TRACE-OUTPUT*"].bound, k()) );
 i( CL["PRINT-OBJECT"](l(l1,CL["*TRACE-OUTPUT*"].bound)) );
 i( CL["WRITE-STRING"](" ", CL["*TRACE-OUTPUT*"].bound, k()) );
 i( CL["PRINT-OBJECT"](l(l2,CL["*TRACE-OUTPUT*"].bound)) );
 single_value();  return CL["FRESH-LINE"](CL["*TRACE-OUTPUT*"].bound) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ATTACH-TRACE-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l1 = CL_LIB["*FUNC-METATABLE-TRACE*"].bound; single_value(); CL_LIB["FUNCTION-METATABLE"].bound[CL["IDENTITY"]("__call")] = l1 return l1 end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["DETACH-TRACE-FUNCTION"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l1 = CL_LIB["*FUNC-METATABLE-DEFAULT*"].bound; single_value(); CL_LIB["FUNCTION-METATABLE"].bound[CL["IDENTITY"]("__call")] = l1 return l1 end, 0, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["TRACE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G202916"],{CL["&OPTIONAL"],{LCL["NIL"]["G202917"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l6, CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), n)), n), CL["CONS"](CL["CONS"](CL["UNLESS"], CL["CONS"](CL_LIB["*TRACE-FUNCTIONS*"], CL["CONS"](CL["CONS"](CL_LIB["ATTACH-TRACE-FUNCTION"], n), n))), CL["CONS"](CL["CONS"](CL["DOLIST"], CL["CONS"](CL["CONS"](CL_LIB["L"], CL["CONS"](l6, n)), CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](CL_LIB["FN"], CL["CONS"](CL["CONS"](CL["COND"], CL["CONS"](CL["CONS"](CL["CONS"](CL["SYMBOLP"], CL["CONS"](CL_LIB["L"], n)), CL["CONS"](CL["CONS"](CL["FDEFINITION"], CL["CONS"](CL_LIB["L"], n)), n)), CL["CONS"](CL["CONS"](CL["CONS"](CL["FUNCTIONP"], CL["CONS"](CL_LIB["L"], n)), CL["CONS"](CL_LIB["L"], n)), CL["CONS"](CL["CONS"](CL["T"], CL["CONS"](CL["CONS"](CL["ERROR"], CL["CONS"]("Can't trace, not a function ~S", CL["CONS"](CL_LIB["L"], n))), n)), n)))), n)), n), CL["CONS"](CL["CONS"](CL["PUSHNEW"], CL["CONS"](CL_LIB["FN"], CL["CONS"](CL_LIB["*TRACE-FUNCTIONS*"], n))), CL["CONS"](CL["CONS"](CL_LIB["LUA-SET-TABLE"], CL["CONS"](CL_LIB["FN"], CL["CONS"]("trace", CL["CONS"](CL["T"], n)))), n)))), n))), CL["CONS"](l6, n))))) end, 1, 1, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL["UNTRACE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G203000"],{CL["&OPTIONAL"],{LCL["NIL"]["G203001"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  single_value();  local l6 = n if n ~= l5 then  local l7 = CL["GENSYM"](false); single_value();  l6 = CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l7, CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l5, n)), n)), n), CL["CONS"](CL["CONS"](CL["DOLIST"], CL["CONS"](CL["CONS"](CL_LIB["L"], CL["CONS"](l7, n)), CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](CL_LIB["FN"], CL["CONS"](CL["CONS"](CL["COND"], CL["CONS"](CL["CONS"](CL["CONS"](CL["SYMBOLP"], CL["CONS"](CL_LIB["L"], n)), CL["CONS"](CL["CONS"](CL["FDEFINITION"], CL["CONS"](CL_LIB["L"], n)), n)), CL["CONS"](CL["CONS"](CL["CONS"](CL["FUNCTIONP"], CL["CONS"](CL_LIB["L"], n)), CL["CONS"](CL_LIB["L"], n)), CL["CONS"](CL["CONS"](CL["T"], CL["CONS"](CL["CONS"](CL["ERROR"], CL["CONS"]("Can't trace, not a function ~S", CL["CONS"](CL_LIB["L"], n))), n)), n)))), n)), n), CL["CONS"](CL["CONS"](CL["PUSHNEW"], CL["CONS"](CL_LIB["FN"], CL["CONS"](CL_LIB["*TRACE-FUNCTIONS*"], n))), CL["CONS"](CL["CONS"](CL_LIB["LUA-SET-TABLE"], CL["CONS"](CL_LIB["FN"], CL["CONS"]("trace", CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"]("nil", n)), n)))), n)))), n))), CL["CONS"](CL["CONS"](CL["UNLESS"], CL["CONS"](CL_LIB["*TRACE-FUNCTIONS*"], CL["CONS"](CL["CONS"](CL_LIB["DETACH-TRACE-FUNCTION"], n), n))), CL["CONS"](CL["T"], n))))) else  l6 = CL["CONS"](CL["PROGN"], CL["CONS"](CL["CONS"](CL["DOLIST"], CL["CONS"](CL["CONS"](CL_LIB["L"], CL["CONS"](CL_LIB["*TRACE-FUNCTIONS*"], n)), CL["CONS"](CL["CONS"](CL_LIB["LUA-SET-TABLE"], CL["CONS"](CL_LIB["L"], CL["CONS"]("trace", CL["CONS"](CL["CONS"](CL_LIB["LUA"], CL["CONS"]("nil", n)), n)))), n))), CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](CL_LIB["*TRACE-FUNCTIONS*"], CL["CONS"](n, n))), CL["CONS"](CL["CONS"](CL_LIB["DETACH-TRACE-FUNCTION"], n), CL["CONS"](CL["T"], n))))) end return l6 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL["BREAK"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{{CL_LIB["FORMAT-CONTROL"],{"Break",n}},{CL["&REST"],{CL_LIB["FORMAT-ARGUMENTS"],n}}}},function (l1, l2,  ...)  if not l1 then  l1 = "Break" end  local l3 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l4 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  local l5 = CL_LIB["*THREAD*"].bound; single_value();  single_value();  local l6 = CL["CONS"](CL["LIST"](l(CL_LIB["MAKE-RESTART"](k(CL_LIB["NAME"], CL["CONTINUE"], CL["FUNCTION"], CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  return error({tag=CL["IDENTITY"](LCL["NIL"]["G203111"]),(function () single_value() return unpack_mv(CL["VALUES"](l(n.bound,CL["T"].bound))) end)()}) end, 0, 0, false, false), CL_LIB["REPORT-FUNCTION"], CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l7,  ...)   single_value();  return CL["FORMAT"](l7, "Return from BREAK.", l()) end, 1, 0, false, false))))), CL_LIB["THREAD-STORAGE-RESTARTS"](CL_LIB["*THREAD*"].bound)); single_value();  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l8, l9,  ...)   single_value();  local l10 = l9; single_value(); l8[CL["IDENTITY"](CL_LIB["RESTARTS"])] = l10 return l10 end, 2, 0, false, false), {l5, l6, }) );
 single_value();  single_value();  return CL["INVOKE-DEBUGGER"](CL["MAKE-CONDITION"](CL["SIMPLE-CONDITION"], l(LCL["KEYWORD"]["FORMAT-CONTROL"],l1,LCL["KEYWORD"]["FORMAT-ARGUMENTS"],l2))) end, 0, 0, false, false))); local l11 = CL_LIB["THREAD-STORAGE-RESTARTS"](CL_LIB["*THREAD*"].bound); single_value();  local l12 = (l11)[1]; single_value();  local l13 = CL_LIB["*THREAD*"].bound; single_value();  single_value();  local l14 = (l11)[2]; single_value();  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l15, l16,  ...)   single_value();  local l17 = l16; single_value(); l15[CL["IDENTITY"](CL_LIB["RESTARTS"])] = l17 return l17 end, 2, 0, false, false), {l13, l14, }) );
 single_value();  i( l12 );
 single_value(); if l4.error ~= n and true then if l4.error == KEYWORD.TAG then  error(l4) else error(l4[1]) end end return CL["VALUES-LIST"](list_r(l4)) end, 0, 0, false, false))); single_value(); if l3.error ~= n and (l3.error ~= KEYWORD.TAG or l3.tag ~= LCL["NIL"]["G203111"]) then if l3.error == KEYWORD.TAG then  error(l3) else error(l3[1]) end end i( CL["VALUES-LIST"](list_r(l3)) );
 single_value();  return n.bound end, 0, 1, true, false)); tmp = CL_LIB["MACRO-SETQ"](CL["ASSERT"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G203244"],{CL["&OPTIONAL"],{LCL["NIL"]["G203245"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = n if n ~= l4 then  local l11 = l4; single_value();  local l12 = (l11)[1]; single_value();  single_value();  local l13 = (l11)[2]; single_value();  l4 = l13 i( l4 );
 single_value();  l10 = l12 else  l10 = n.bound end local l9 = l10; single_value();  local l15 = n if n ~= l4 then  local l16 = l4; single_value();  local l17 = (l16)[1]; single_value();  single_value();  local l18 = (l16)[2]; single_value();  l4 = l18 i( l4 );
 single_value();  l15 = l17 else  l15 = "ASSERT" end local l14 = l15; single_value();  local l19 = l4; single_value();  single_value();  return CL["CONS"](CL["UNLESS"], CL["CONS"](l5, CL["CONS"](CL["CONS"](CL["WITH-SIMPLE-RESTART"], CL["CONS"](CL["CONS"](CL["CONTINUE"], CL["CONS"]("Ignore ASSERT and continue.", n)), CL["CONS"](CL["CONS"](CL["ERROR"], CL["CONS"](l14, CL["APPEND"](l(l19,n)))), n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["%DEFPACKAGE"](LCL["KEYWORD"]["LOOP"], {{LCL["KEYWORD"]["USE"],{LCL["KEYWORD"]["CL"],n}},n}); tmp = CL_LIB["%IN-PACKAGE"]("LOOP"); local l1 = LCL["KEYWORD"]["LOOP"]; local l2 = CL["*FEATURES*"].bound; single_value();  local l3 = n if n ~= CL["MEMBER"](l1, l2, k()) then  l3 = l2 else  single_value();  single_value();  local l4 = CL["CONS"](l1, CL["*FEATURES*"].bound); single_value();  CL["*FEATURES*"].bound = l4 l3 = CL["*FEATURES*"].bound end tmp = l3; tmp = CL_LIB["%IN-PACKAGE"]("LOOP"); single_value();  local l1 = n if n ~= CL["FBOUNDP"](CL["WITH-HASH-TABLE-ITERATOR"]) then  l1 = n.bound else  single_value();  l1 = CL["WARN"]("WITH-HASH-TABLE-ITERATOR not defined in this lisp. ~\n          ~&   Loop clauses which use the HASH-KEY, HASH-KEYS, HASH-VALUE ~\n          ~&   and HASH-VALUES keywords will not work.", l()) end tmp = l1; local l1 = n.bound; single_value();  i( CL_LIB.DEF(LCL["LOOP"]["*LOOP-NAME*"],l1) );
 local l2 = n.bound; single_value();  i( CL_LIB.DEF(LCL["LOOP"]["*OUTSIDE-BINDINGS*"],l2) );
 local l3 = n.bound; single_value();  i( CL_LIB.DEF(LCL["LOOP"]["*PROLOGUE*"],l3) );
 local l4 = n.bound; single_value();  i( CL_LIB.DEF(LCL["LOOP"]["*INSIDE-BINDINGS*"],l4) );
 local l5 = n.bound; single_value();  i( CL_LIB.DEF(LCL["LOOP"]["*BODY-FORMS*"],l5) );
 local l6 = n.bound; single_value();  i( CL_LIB.DEF(LCL["LOOP"]["*ITERATION-FORMS*"],l6) );
 local l7 = n.bound; single_value();  i( CL_LIB.DEF(LCL["LOOP"]["*EPILOGUE*"],l7) );
 local l8 = n.bound; single_value();  i( CL_LIB.DEF(LCL["LOOP"]["*RESULT-VAR*"],l8) );
 local l9 = n.bound; single_value();  i( CL_LIB.DEF(LCL["LOOP"]["*RETURN-VALUE*"],l9) );
 local l10 = n.bound; single_value();  i( CL_LIB.DEF(LCL["LOOP"]["*DEFAULT-RETURN-VALUE*"],l10) );
 local l11 = n.bound; single_value();  i( CL_LIB.DEF(LCL["LOOP"]["*ACCUMULATION-VARIABLES*"],l11) );
 local l12 = n.bound; single_value();  i( CL_LIB.DEF(LCL["LOOP"]["*REMAINING-STUFF*"],l12) );
 single_value();  local l13 = CL["LIST"](l(LCL["LOOP"]["<MAGIC-COOKIE>"])); single_value();  tmp = CL_LIB.DEF(LCL["LOOP"]["*MAGIC-COOKIE*"],l13); i( n.bound );
 i( CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["MAYBE-CAR"] , CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["THING"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["CONSP"](l1) then  l2 = (l1)[1] else  l2 = l1 end return l2 end, 1, 0, false, false)) );
 i( CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["MAYBE-CDR"] , CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["THING"],n},function (l3,  ...)   single_value();  local l4 = n if n ~= CL["CONSP"](l3) then  l4 = (l3)[2] else  l4 = l3 end return l4 end, 1, 0, false, false)) );
 single_value();  tmp = CL_LIB["MACRO-SETQ"](LCL["LOOP"]["LOOP-KEYWORD-P"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G73326"],{CL["&OPTIONAL"],{LCL["NIL"]["G73327"],n}}},function (l5, l6,  ...)  if not l6 then  l6 = n.bound end  single_value();  local l7 = (l5)[2]; single_value();  local l8 = (l5)[2]; single_value();  local l10 = l8; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l8 = l12 i( l8 );
 single_value();  local l9 = l11; single_value();  local l14 = l8; single_value();  local l15 = (l14)[1]; single_value();  single_value();  local l16 = (l14)[2]; single_value();  l8 = l16 i( l8 );
 single_value();  local l13 = l15; single_value();  local l17 = l8; single_value();  single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](LCL["LOOP"]["THING"], CL["CONS"](l9, n)), n), CL["CONS"](CL["CONS"](CL["AND"], CL["CONS"](CL["CONS"](CL["SYMBOLP"], CL["CONS"](LCL["LOOP"]["THING"], n)), CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](LCL["LOOP"]["NAME"], CL["CONS"](CL["CONS"](CL["SYMBOL-NAME"], CL["CONS"](LCL["LOOP"]["THING"], n)), n)), n), CL["CONS"](CL["CONS"](CL["OR"], CL["APPEND"](l(CL["MAPCAR"](CL_LIB["ALLOC-FUNCTION"]({CL["KEYWORD"],n},function (l18,  ...)   single_value();  return CL["CONS"](CL["STRING="], CL["CONS"](LCL["LOOP"]["NAME"], CL["CONS"](l18, n))) end, 1, 0, false, false), l(CL["CONS"](l13, l17))),n))), n))), n))), n))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PREPOSITION-P"] , CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["PREP"],n},function (l1,  ...)   single_value();  local l3 = (LCL["LOOP"]["*REMAINING-STUFF*"].bound)[1]; single_value();  local l4 = n if n ~= CL["SYMBOLP"](l3) then  local l5 = CL["SYMBOL-NAME"](l3); single_value();  l4 = CL["STRING="](l5, l(l1)) else  l4 = n.bound end local l2 = n if n ~= l4 then  local l6 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l8 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  i( l7 );
 single_value();  l2 = CL["T"].bound else  l2 = n.bound end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["SPLICE-IN-SUBFORM"] , CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["FORM"],{LCL["LOOP"]["SUBFORM"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["EQ"](l1, LCL["LOOP"]["*MAGIC-COOKIE*"].bound) then  l3 = l2 else  local l4;l4 = {CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["FORM"],{LCL["LOOP"]["PATH"],n}},function (l5, l6,  ...)   single_value();  local l7 = n if n ~= CL["ATOM"](l5) then  single_value();  l7 = n.bound else  local l8 = n if n ~= CL["MEMBER"](l5, l6, k()) then  single_value();  l8 = n.bound else  local l9 = n if n ~= CL["EQ"]((l5)[1], LCL["LOOP"]["*MAGIC-COOKIE*"].bound) then  single_value();  local l10 = l5; single_value();  single_value();  local l11 = l2; single_value();  i( CL_LIB["%CAR-UPDATE"](l10, l11) );
 single_value();  l9 = CL["T"].bound else  local l12 = n if n ~= CL["T"].bound then  single_value();  local l13 = CL["CONS"](l5, l6); single_value();  local l14 = CL_LIB["FUNCALL-LUA"]( l4[1], {(l5)[1], l13, }); single_value();  local l15 = n if n ~= l14 then  l15 = l14 else  l15 = CL_LIB["FUNCALL-LUA"]( l4[1], {(l5)[2], l13, }) end l12 = l15 else  l12 = n.bound end l9 = l12 end l8 = l9 end l7 = l8 end return l7 end, 2, 0, false, false)}; single_value();  local l16 = n if n ~= CL_LIB["FUNCALL-LUA"]( l4[1], {l1, n.bound, }) then  l16 = l1 else  l16 = CL["ERROR"]("Couldn't find the magic cookie in:~% ~S~%Loop is broken.", l(l1)) end l3 = l16 end return l3 end, 2, 0, false, false)); single_value();  tmp = CL_LIB["MACRO-SETQ"](LCL["LOOP"]["QUEUE-VAR"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G73666"],{CL["&OPTIONAL"],{LCL["NIL"]["G73667"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  local l9 = l11; single_value();  local l14 = l4; single_value();  local l15 = (l14)[1]; single_value();  single_value();  local l16 = (l14)[2]; single_value();  l4 = l16 i( l4 );
 single_value();  local l13 = l15; single_value();  local l17 = CL["GETF"](l4, LCL["KEYWORD"]["INITER"], LCL["NIL"]["G73676"]); single_value();  local l19 = n if n ~= CL["EQ"](LCL["NIL"]["G73676"], l17) then  l19 = n.bound else  l19 = l17 end local l18 = l19; single_value();  local l20 = CL["NOT"](CL["EQ"](LCL["NIL"]["G73676"], l17)); single_value();  local l21 = CL["GETF"](l4, LCL["KEYWORD"]["STEPPER"], LCL["NIL"]["G73676"]); single_value();  local l23 = n if n ~= CL["EQ"](LCL["NIL"]["G73676"], l21) then  l23 = n.bound else  l23 = l21 end local l22 = l23; single_value();  local l24 = CL["NOT"](CL["EQ"](LCL["NIL"]["G73676"], l21)); single_value();  single_value();  return CL["CONS"](CL["PUSH"], CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](l9, CL["CONS"](l13, CL["CONS"](l20, CL["CONS"](l18, CL["CONS"](l24, CL["CONS"](l22, n))))))), CL["CONS"](l5, n))) end, 1, 1, false, false)); local l1 = {n,{0,{0,n}}}; single_value();  tmp = CL_LIB.DEF(LCL["LOOP"]["*DEFAULT-VALUES*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PICK-DEFAULT-VALUE"] , CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["VAR"],{CL["TYPE"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["CONSP"](l1) then  l3 = CL["CONS"](CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PICK-DEFAULT-VALUE"].fbound, {(l1)[1], LCL["LOOP"]["MAYBE-CAR"](l2), }), CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PICK-DEFAULT-VALUE"].fbound, {(l1)[2], LCL["LOOP"]["MAYBE-CDR"](l2), })) else  local l4 = LCL["LOOP"]["*DEFAULT-VALUES*"].bound; single_value();  local l5 = (l4)[1]; single_value();  single_value();  local l6 = CL["GENSYM"](false); single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l8 = n if n ~= CL["NOT"](l4) then  single_value(); do break end; l8 = n.bound else  l8 = n.bound end i( l8 );
 local l9 = n if n ~= CL["TYPEP"](l5, l2, false) then  single_value();  local l10 = CL["FUNCALL"](l, l(unpack_mv(l5))); single_value();  l9 = error({tag=CL["IDENTITY"](l6),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l10)) end)()}) else  l9 = n.bound end i( l9 );
 single_value();  single_value();  local l11 = (l4)[2]; single_value();  l4 = l11 i( l4 );
 single_value();  single_value();  single_value();  local l12 = (l4)[1]; single_value();  l5 = l12 local tmpres = l5 end i( n );
 single_value();  return CL["ERROR"]("Cannot default variables of type ~S ~\n                       (for variable ~S).", l(l2,l1)) end, 0, 0, false, false))); single_value(); if l7.error ~= n and (l7.error ~= KEYWORD.TAG or l7.tag ~= l6) then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end l3 = CL["VALUES-LIST"](list_r(l7)) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["ONLY-SIMPLE-TYPES"] , CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["TYPE-SPEC"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["ATOM"](l1) then  l2 = CL["MEMBER"](l1, {CL["FIXNUM"],{CL["FLOAT"],{CL["T"],{n,n}}}}, k()) else  local l3 = n if n ~= CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["ONLY-SIMPLE-TYPES"].fbound, {(l1)[1], }) then  l3 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["ONLY-SIMPLE-TYPES"].fbound, {(l1)[2], }) else  l3 = n.bound end l2 = l3 end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["BUILD-LET-EXPRESSION"] , CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["VARS"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["NULL"](l1) then  l2 = CL["VALUES"](l(LCL["LOOP"]["*MAGIC-COOKIE*"].bound,LCL["LOOP"]["*MAGIC-COOKIE*"].bound)) else  local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = l1; single_value();  local l8 = (l7)[1]; single_value();  single_value();  local l9 = CL["GENSYM"](false); single_value();  local l10 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l11 = n if n ~= CL["NOT"](l7) then  single_value(); do break end; l11 = n.bound else  l11 = n.bound end i( l11 );
 local l12;l12 = {CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["NAME"],{CL["TYPE"],{LCL["LOOP"]["INITIAL-P"],{LCL["LOOP"]["INITIAL"],{LCL["LOOP"]["STEPPER-P"],{LCL["LOOP"]["STEPPER"],n}}}}}},function (l13, l14, l15, l16, l17, l18,  ...)   single_value();  local l19 = n if n ~= CL["ATOM"](l13) then  single_value();  local l20 = n if n ~= CL["NOT"](l17) then  single_value();  single_value();  single_value();  local l21 = CL["CONS"](CL["LIST"](l(l14,l13,l16)), l4); single_value();  l4 = l21 l20 = l4 else  local l22 = n if n ~= CL["NOT"](l15) then  single_value();  single_value();  single_value();  local l23 = CL["CONS"](CL["LIST"](l(l14,l13,l18)), l3); single_value();  l3 = l23 l22 = l3 else  local l24 = n if n ~= CL["T"].bound then  single_value();  single_value();  local l25 = CL["CONS"](CL["LIST"](l(l14,l13,l16)), l4); single_value();  l4 = l25 i( l4 );
 single_value();  single_value();  single_value();  local l26 = CL["NCONC"](l(l5,CL["LIST"](l(l13,l18)))); single_value();  l5 = l26 l24 = l5 else  l24 = n.bound end l22 = l24 end l20 = l22 end l19 = l20 else  local l28 = n if n ~= (l13)[1] then  l28 = (l13)[2] else  l28 = n.bound end local l27 = n if n ~= l28 then  single_value();  local l29 = CL["GENSYM"](CL["FORMAT"](n.bound, "TEMP-FOR-~A-", l(l13))); i( CL_LIB["FUNCALL-LUA"]( l12[1], {l29, CL["LIST"], l15, l16, l17, l18, }) );
 single_value();  single_value();  local l31 = n if n ~= l17 then  l31 = CL["LIST"](l((l13)[1],LCL["LOOP"]["MAYBE-CAR"](l14),n.bound,n.bound,CL["T"].bound,CL["CONS"](CL["CAR"], CL["CONS"](l29, n)))) else  l31 = CL["LIST"](l((l13)[1],LCL["LOOP"]["MAYBE-CAR"](l14),CL["T"].bound,CL["CONS"](CL["CAR"], CL["CONS"](l29, n)),n.bound,n.bound)) end local l30 = CL["CONS"](l31, l6); single_value();  l6 = l30 i( l6 );
 single_value();  single_value();  single_value();  local l33 = n if n ~= l17 then  l33 = CL["LIST"](l((l13)[2],LCL["LOOP"]["MAYBE-CDR"](l14),n.bound,n.bound,CL["T"].bound,CL["CONS"](CL["CDR"], CL["CONS"](l29, n)))) else  l33 = CL["LIST"](l((l13)[1],LCL["LOOP"]["MAYBE-CDR"](l14),CL["T"].bound,CL["CONS"](CL["CDR"], CL["CONS"](l29, n)),n.bound,n.bound)) end local l32 = CL["CONS"](l33, l6); single_value();  l6 = l32 l27 = l6 else  local l34 = n if n ~= (l13)[1] then  single_value();  l34 = CL_LIB["FUNCALL-LUA"]( l12[1], {(l13)[1], LCL["LOOP"]["MAYBE-CAR"](l14), l15, CL["CONS"](CL["CAR"], CL["CONS"](l16, n)), l17, CL["CONS"](CL["CAR"], CL["CONS"](l18, n)), }) else  local l35 = n if n ~= (l13)[2] then  single_value();  l35 = CL_LIB["FUNCALL-LUA"]( l12[1], {(l13)[2], LCL["LOOP"]["MAYBE-CDR"](l14), l15, CL["CONS"](CL["CDR"], CL["CONS"](l16, n)), l17, CL["CONS"](CL["CDR"], CL["CONS"](l18, n)), }) else  l35 = n.bound end l34 = l35 end l27 = l34 end l19 = l27 end return l19 end, 6, 0, false, false)}; single_value();  i( CL_LIB["FUNCALL-LUA"]( l12[1], {CL["FIRST"](l8), CL["SECOND"](l8), CL["THIRD"](l8), CL["FOURTH"](l8), CL["FIFTH"](l8), CL["SIXTH"](l8), }) );
 single_value();  single_value();  local l36 = (l7)[2]; single_value();  l7 = l36 i( l7 );
 single_value();  single_value();  single_value();  local l37 = (l7)[1]; single_value();  l8 = l37 local tmpres = l8 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l10.error ~= n and (l10.error ~= KEYWORD.TAG or l10.tag ~= l9) then if l10.error == KEYWORD.TAG then  error(l10) else error(l10[1]) end end i( CL["VALUES-LIST"](list_r(l10)) );
 local l38 = n if n ~= l5 then  single_value();  single_value();  single_value();  local l39 = CL["CONS"](CL["CONS"](CL["PSETQ"], l5), LCL["LOOP"]["*ITERATION-FORMS*"].bound); single_value();  LCL["LOOP"]["*ITERATION-FORMS*"].bound = l39 l38 = LCL["LOOP"]["*ITERATION-FORMS*"].bound else  l38 = n.bound end i( l38 );
 single_value();  local l40 = n.bound; local l41 = n.bound; local l42 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l43 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l45 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l44 = l45; single_value();  single_value();  l40,l41= unpack_mv(CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["BUILD-LET-EXPRESSION"].fbound, {l6, }), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l42 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l43.error ~= n and true then if l43.error == KEYWORD.TAG then  error(l43) else error(l43[1]) end end i( CL["VALUES-LIST"](list_r(l43)) );
 single_value();  l2 = CL["VALUES"](l(CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["BUILD-BINDINGS"].fbound, {l4, l40, }),CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["BUILD-BINDINGS"].fbound, {l3, l41, }))) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["BUILD-BINDINGS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["VARS"],{LCL["LOOP"]["GUTS"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["NULL"](l1) then  l3 = l2 else  l3 = CL["CONS"](CL["LET"], CL["CONS"](CL["MAPCAR"](CL["CDR"].fbound, l(l1)), CL["CONS"](CL["CONS"](CL["DECLARE"], CL["APPEND"](l(CL["MAPCAR"](LCL["LOOP"]["BUILD-DECLARE"].fbound, l(l1)),n))), CL["CONS"](l2, n)))) end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["BUILD-DECLARE"] , CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["VAR"],n},function (l1,  ...)   single_value();  return CL["CONS"](CL["TYPE"], CL["CONS"]((l1)[1], CL["CONS"](CL["CADR"](l1), n))) end, 1, 0, false, false)); single_value();  tmp = n.bound; tmp = CL_LIB["MACRO-SETQ"](CL["LOOP"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G74196"],{CL["&OPTIONAL"],{LCL["NIL"]["G74197"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l5 = l4; single_value();  i( "General iteration facility.  See the manual for details, 'cause it's\n  very confusing." );
 single_value();  local l6 = n if n ~= CL["SOME"](CL["ATOM"].fbound, l(l5)) then  l6 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-LOOP"].fbound, {l5, }) else  local l7 = CL["GENSYM"]("OUT-OF-HERE-"); single_value();  l6 = CL["CONS"](CL["BLOCK"], CL["CONS"](l7, CL["CONS"](CL["CONS"](CL_LIB["%LOOP"], CL["CONS"](CL["CONS"](CL["MACROLET"], CL["CONS"](CL["CONS"](CL["CONS"](CL["LOOP-FINISH"], CL["CONS"](n, CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["CONS"](CL["RETURN-FROM"], CL["CONS"](l7, n)), n)), n))), n), CL["APPEND"](l(l5,n)))), n)), n))) end return l6 end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-LOOP"] , CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["STUFF"],n},function (l1,  ...)   single_value();  local l2 = LCL["LOOP"]["*PROLOGUE*"].bound; single_value();  local l3 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l5 = LCL["LOOP"]["*PROLOGUE*"].bound; LCL["LOOP"]["*PROLOGUE*"].bound = n.bound i( LCL["LOOP"]["*PROLOGUE*"].bound );
 single_value();  local l4 = l5; single_value();  single_value();  local l6 = LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound; single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l9 = LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound; LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound = LCL["LOOP"]["*MAGIC-COOKIE*"].bound i( LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound );
 single_value();  local l8 = l9; single_value();  single_value();  local l10 = LCL["LOOP"]["*INSIDE-BINDINGS*"].bound; single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l13 = LCL["LOOP"]["*INSIDE-BINDINGS*"].bound; LCL["LOOP"]["*INSIDE-BINDINGS*"].bound = LCL["LOOP"]["*MAGIC-COOKIE*"].bound i( LCL["LOOP"]["*INSIDE-BINDINGS*"].bound );
 single_value();  local l12 = l13; single_value();  single_value();  local l14 = LCL["LOOP"]["*BODY-FORMS*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = LCL["LOOP"]["*BODY-FORMS*"].bound; LCL["LOOP"]["*BODY-FORMS*"].bound = n.bound i( LCL["LOOP"]["*BODY-FORMS*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  local l18 = LCL["LOOP"]["*ITERATION-FORMS*"].bound; single_value();  local l19 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l21 = LCL["LOOP"]["*ITERATION-FORMS*"].bound; LCL["LOOP"]["*ITERATION-FORMS*"].bound = n.bound i( LCL["LOOP"]["*ITERATION-FORMS*"].bound );
 single_value();  local l20 = l21; single_value();  single_value();  local l22 = LCL["LOOP"]["*EPILOGUE*"].bound; single_value();  local l23 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l25 = LCL["LOOP"]["*EPILOGUE*"].bound; LCL["LOOP"]["*EPILOGUE*"].bound = n.bound i( LCL["LOOP"]["*EPILOGUE*"].bound );
 single_value();  local l24 = l25; single_value();  single_value();  local l26 = LCL["LOOP"]["*RESULT-VAR*"].bound; single_value();  local l27 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l29 = LCL["LOOP"]["*RESULT-VAR*"].bound; LCL["LOOP"]["*RESULT-VAR*"].bound = n.bound i( LCL["LOOP"]["*RESULT-VAR*"].bound );
 single_value();  local l28 = l29; single_value();  single_value();  local l30 = LCL["LOOP"]["*RETURN-VALUE*"].bound; single_value();  local l31 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l33 = LCL["LOOP"]["*RETURN-VALUE*"].bound; LCL["LOOP"]["*RETURN-VALUE*"].bound = n.bound i( LCL["LOOP"]["*RETURN-VALUE*"].bound );
 single_value();  local l32 = l33; single_value();  single_value();  local l34 = LCL["LOOP"]["*DEFAULT-RETURN-VALUE*"].bound; single_value();  local l35 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l37 = LCL["LOOP"]["*DEFAULT-RETURN-VALUE*"].bound; LCL["LOOP"]["*DEFAULT-RETURN-VALUE*"].bound = n.bound i( LCL["LOOP"]["*DEFAULT-RETURN-VALUE*"].bound );
 single_value();  local l36 = l37; single_value();  single_value();  local l38 = LCL["LOOP"]["*ACCUMULATION-VARIABLES*"].bound; single_value();  local l39 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l41 = LCL["LOOP"]["*ACCUMULATION-VARIABLES*"].bound; LCL["LOOP"]["*ACCUMULATION-VARIABLES*"].bound = n.bound i( LCL["LOOP"]["*ACCUMULATION-VARIABLES*"].bound );
 single_value();  local l40 = l41; single_value();  single_value();  local l42 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l43 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l45 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; LCL["LOOP"]["*REMAINING-STUFF*"].bound = l1 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l44 = l45; single_value();  single_value();  local l46 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-NAMED"].fbound, {}); single_value();  while true do  local l47 = n if n ~= CL["NULL"](LCL["LOOP"]["*REMAINING-STUFF*"].bound) then  single_value(); do break end; l47 = n.bound else  l47 = n.bound end i( l47 );
 single_value();  local l49 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l50 = (l49)[1]; single_value();  single_value();  local l51 = (l49)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l51 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l48 = l50; single_value();  local l52 = n if n ~= CL["NOT"](CL["SYMBOLP"](l48)) then  single_value();  l52 = CL["ERROR"]("Invalid clause, ~S, must be a symbol.", l(l48)) else  local l54 = l48; single_value();  local l55 = n if n ~= CL["SYMBOLP"](l54) then  local l56 = CL["SYMBOL-NAME"](l54); single_value();  l55 = CL["STRING="](l56, l("INITIALLY")) else  l55 = n.bound end local l53 = n if n ~= l55 then  single_value();  single_value();  single_value();  local l57 = CL["NCONC"](l(LCL["LOOP"]["*PROLOGUE*"].bound,CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-EXPR-LIST"].fbound, {}))); single_value();  LCL["LOOP"]["*PROLOGUE*"].bound = l57 l53 = LCL["LOOP"]["*PROLOGUE*"].bound else  local l59 = l48; single_value();  local l60 = n if n ~= CL["SYMBOLP"](l59) then  local l61 = CL["SYMBOL-NAME"](l59); single_value();  l60 = CL["STRING="](l61, l("FINALLY")) else  l60 = n.bound end local l58 = n if n ~= l60 then  single_value();  l58 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-FINALLY"].fbound, {}) else  local l63 = l48; single_value();  local l64 = n if n ~= CL["SYMBOLP"](l63) then  local l65 = CL["SYMBOL-NAME"](l63); single_value();  l64 = CL["STRING="](l65, l("WITH")) else  l64 = n.bound end local l62 = n if n ~= l64 then  single_value();  l62 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-WITH"].fbound, {}) else  local l67 = l48; single_value();  local l68 = n if n ~= CL["SYMBOLP"](l67) then  local l69 = CL["SYMBOL-NAME"](l67); single_value();  local l70 = CL["STRING="](l69, l("FOR")); single_value();  local l71 = n if n ~= l70 then  l71 = l70 else  l71 = CL["STRING="](l69, l("AS")) end l68 = l71 else  l68 = n.bound end local l66 = n if n ~= l68 then  single_value();  l66 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-FOR-AS"].fbound, {}) else  local l73 = l48; single_value();  local l74 = n if n ~= CL["SYMBOLP"](l73) then  local l75 = CL["SYMBOL-NAME"](l73); single_value();  l74 = CL["STRING="](l75, l("REPEAT")) else  l74 = n.bound end local l72 = n if n ~= l74 then  single_value();  l72 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-REPEAT"].fbound, {}) else  local l77 = l48; single_value();  local l78 = n if n ~= CL["SYMBOLP"](l77) then  local l79 = CL["SYMBOL-NAME"](l77); single_value();  l78 = CL["STRING="](l79, l("WHILE")) else  l78 = n.bound end local l76 = n if n ~= l78 then  single_value();  single_value();  single_value();  local l81 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l82 = (l81)[1]; single_value();  single_value();  local l83 = (l81)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l83 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l80 = CL["CONS"](CL["CONS"](CL["UNLESS"], CL["CONS"](l82, CL["CONS"](CL["CONS"](CL["LOOP-FINISH"], n), n))), LCL["LOOP"]["*ITERATION-FORMS*"].bound); single_value();  LCL["LOOP"]["*ITERATION-FORMS*"].bound = l80 l76 = LCL["LOOP"]["*ITERATION-FORMS*"].bound else  local l85 = l48; single_value();  local l86 = n if n ~= CL["SYMBOLP"](l85) then  local l87 = CL["SYMBOL-NAME"](l85); single_value();  l86 = CL["STRING="](l87, l("UNTIL")) else  l86 = n.bound end local l84 = n if n ~= l86 then  single_value();  single_value();  single_value();  local l89 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l90 = (l89)[1]; single_value();  single_value();  local l91 = (l89)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l91 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l88 = CL["CONS"](CL["CONS"](CL["WHEN"], CL["CONS"](l90, CL["CONS"](CL["CONS"](CL["LOOP-FINISH"], n), n))), LCL["LOOP"]["*ITERATION-FORMS*"].bound); single_value();  LCL["LOOP"]["*ITERATION-FORMS*"].bound = l88 l84 = LCL["LOOP"]["*ITERATION-FORMS*"].bound else  local l93 = l48; single_value();  local l94 = n if n ~= CL["SYMBOLP"](l93) then  local l95 = CL["SYMBOL-NAME"](l93); single_value();  l94 = CL["STRING="](l95, l("ALWAYS")) else  l94 = n.bound end local l92 = n if n ~= l94 then  single_value();  single_value();  local l97 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l98 = (l97)[1]; single_value();  single_value();  local l99 = (l97)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l99 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l96 = CL["CONS"](CL["CONS"](CL["UNLESS"], CL["CONS"](l98, CL["CONS"](CL["CONS"](CL["RETURN-FROM"], CL["CONS"](l46, CL["CONS"](n, n))), n))), LCL["LOOP"]["*ITERATION-FORMS*"].bound); single_value();  LCL["LOOP"]["*ITERATION-FORMS*"].bound = l96 i( LCL["LOOP"]["*ITERATION-FORMS*"].bound );
 single_value();  single_value();  single_value();  local l100 = CL["T"].bound; single_value();  LCL["LOOP"]["*DEFAULT-RETURN-VALUE*"].bound = l100 l92 = LCL["LOOP"]["*DEFAULT-RETURN-VALUE*"].bound else  local l102 = l48; single_value();  local l103 = n if n ~= CL["SYMBOLP"](l102) then  local l104 = CL["SYMBOL-NAME"](l102); single_value();  l103 = CL["STRING="](l104, l("NEVER")) else  l103 = n.bound end local l101 = n if n ~= l103 then  single_value();  single_value();  local l106 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l107 = (l106)[1]; single_value();  single_value();  local l108 = (l106)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l108 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l105 = CL["CONS"](CL["CONS"](CL["WHEN"], CL["CONS"](l107, CL["CONS"](CL["CONS"](CL["RETURN-FROM"], CL["CONS"](l46, CL["CONS"](n, n))), n))), LCL["LOOP"]["*ITERATION-FORMS*"].bound); single_value();  LCL["LOOP"]["*ITERATION-FORMS*"].bound = l105 i( LCL["LOOP"]["*ITERATION-FORMS*"].bound );
 single_value();  single_value();  single_value();  local l109 = CL["T"].bound; single_value();  LCL["LOOP"]["*DEFAULT-RETURN-VALUE*"].bound = l109 l101 = LCL["LOOP"]["*DEFAULT-RETURN-VALUE*"].bound else  local l111 = l48; single_value();  local l112 = n if n ~= CL["SYMBOLP"](l111) then  local l113 = CL["SYMBOL-NAME"](l111); single_value();  l112 = CL["STRING="](l113, l("THEREIS")) else  l112 = n.bound end local l110 = n if n ~= l112 then  single_value();  single_value();  single_value();  local l115 = CL["GENSYM"]("THEREIS-"); single_value();  local l116 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l117 = (l116)[1]; single_value();  single_value();  local l118 = (l116)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l118 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l114 = CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l115, CL["CONS"](l117, n)), n), CL["CONS"](CL["CONS"](CL["WHEN"], CL["CONS"](l115, CL["CONS"](CL["CONS"](CL["RETURN-FROM"], CL["CONS"](l46, CL["CONS"](l115, n))), n))), n))), LCL["LOOP"]["*ITERATION-FORMS*"].bound); single_value();  LCL["LOOP"]["*ITERATION-FORMS*"].bound = l114 l110 = LCL["LOOP"]["*ITERATION-FORMS*"].bound else  local l119 = n if n ~= CL["T"].bound then  single_value();  single_value();  local l120 = CL["CONS"](l48, LCL["LOOP"]["*REMAINING-STUFF*"].bound); single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l120 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value(); do break end; l119 = n.bound else  l119 = n.bound end l110 = l119 end l101 = l110 end l92 = l101 end l84 = l92 end l76 = l84 end l72 = l76 end l66 = l72 end l62 = l66 end l58 = l62 end l53 = l58 end l52 = l53 end local tmpres = l52 end i( n );
 while true do  local l121 = n if n ~= CL["NULL"](LCL["LOOP"]["*REMAINING-STUFF*"].bound) then  single_value(); do break end; l121 = n.bound else  l121 = n.bound end i( l121 );
 single_value();  local l123 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l124 = (l123)[1]; single_value();  single_value();  local l125 = (l123)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l125 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l122 = l124; single_value();  local l126 = n if n ~= CL["NOT"](CL["SYMBOLP"](l122)) then  single_value();  l126 = CL["ERROR"]("Invalid clause, ~S, must be a symbol.", l(l122)) else  local l128 = l122; single_value();  local l129 = n if n ~= CL["SYMBOLP"](l128) then  local l130 = CL["SYMBOL-NAME"](l128); single_value();  l129 = CL["STRING="](l130, l("INITIALLY")) else  l129 = n.bound end local l127 = n if n ~= l129 then  single_value();  single_value();  single_value();  local l131 = CL["NCONC"](l(LCL["LOOP"]["*PROLOGUE*"].bound,CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-EXPR-LIST"].fbound, {}))); single_value();  LCL["LOOP"]["*PROLOGUE*"].bound = l131 l127 = LCL["LOOP"]["*PROLOGUE*"].bound else  local l133 = l122; single_value();  local l134 = n if n ~= CL["SYMBOLP"](l133) then  local l135 = CL["SYMBOL-NAME"](l133); single_value();  l134 = CL["STRING="](l135, l("FINALLY")) else  l134 = n.bound end local l132 = n if n ~= l134 then  single_value();  l132 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-FINALLY"].fbound, {}) else  local l137 = l122; single_value();  local l138 = n if n ~= CL["SYMBOLP"](l137) then  local l139 = CL["SYMBOL-NAME"](l137); single_value();  l138 = CL["STRING="](l139, l("WHILE")) else  l138 = n.bound end local l136 = n if n ~= l138 then  single_value();  single_value();  single_value();  local l141 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l142 = (l141)[1]; single_value();  single_value();  local l143 = (l141)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l143 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l140 = CL["NCONC"](l(LCL["LOOP"]["*BODY-FORMS*"].bound,CL["CONS"](CL["CONS"](CL["UNLESS"], CL["CONS"](l142, CL["CONS"](CL["CONS"](CL["LOOP-FINISH"], n), n))), n))); single_value();  LCL["LOOP"]["*BODY-FORMS*"].bound = l140 l136 = LCL["LOOP"]["*BODY-FORMS*"].bound else  local l145 = l122; single_value();  local l146 = n if n ~= CL["SYMBOLP"](l145) then  local l147 = CL["SYMBOL-NAME"](l145); single_value();  l146 = CL["STRING="](l147, l("UNTIL")) else  l146 = n.bound end local l144 = n if n ~= l146 then  single_value();  single_value();  single_value();  local l149 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l150 = (l149)[1]; single_value();  single_value();  local l151 = (l149)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l151 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l148 = CL["NCONC"](l(LCL["LOOP"]["*BODY-FORMS*"].bound,CL["CONS"](CL["CONS"](CL["WHEN"], CL["CONS"](l150, CL["CONS"](CL["CONS"](CL["LOOP-FINISH"], n), n))), n))); single_value();  LCL["LOOP"]["*BODY-FORMS*"].bound = l148 l144 = LCL["LOOP"]["*BODY-FORMS*"].bound else  local l153 = l122; single_value();  local l154 = n if n ~= CL["SYMBOLP"](l153) then  local l155 = CL["SYMBOL-NAME"](l153); single_value();  l154 = CL["STRING="](l155, l("ALWAYS")) else  l154 = n.bound end local l152 = n if n ~= l154 then  single_value();  single_value();  local l157 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l158 = (l157)[1]; single_value();  single_value();  local l159 = (l157)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l159 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l156 = CL["NCONC"](l(LCL["LOOP"]["*BODY-FORMS*"].bound,CL["CONS"](CL["CONS"](CL["UNLESS"], CL["CONS"](l158, CL["CONS"](CL["CONS"](CL["RETURN-FROM"], CL["CONS"](l46, CL["CONS"](n, n))), n))), n))); single_value();  LCL["LOOP"]["*BODY-FORMS*"].bound = l156 i( LCL["LOOP"]["*BODY-FORMS*"].bound );
 single_value();  single_value();  single_value();  local l160 = CL["T"].bound; single_value();  LCL["LOOP"]["*DEFAULT-RETURN-VALUE*"].bound = l160 l152 = LCL["LOOP"]["*DEFAULT-RETURN-VALUE*"].bound else  local l162 = l122; single_value();  local l163 = n if n ~= CL["SYMBOLP"](l162) then  local l164 = CL["SYMBOL-NAME"](l162); single_value();  l163 = CL["STRING="](l164, l("NEVER")) else  l163 = n.bound end local l161 = n if n ~= l163 then  single_value();  single_value();  local l166 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l167 = (l166)[1]; single_value();  single_value();  local l168 = (l166)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l168 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l165 = CL["NCONC"](l(LCL["LOOP"]["*BODY-FORMS*"].bound,CL["CONS"](CL["CONS"](CL["WHEN"], CL["CONS"](l167, CL["CONS"](CL["CONS"](CL["RETURN-FROM"], CL["CONS"](l46, CL["CONS"](n, n))), n))), n))); single_value();  LCL["LOOP"]["*BODY-FORMS*"].bound = l165 i( LCL["LOOP"]["*BODY-FORMS*"].bound );
 single_value();  single_value();  single_value();  local l169 = CL["T"].bound; single_value();  LCL["LOOP"]["*DEFAULT-RETURN-VALUE*"].bound = l169 l161 = LCL["LOOP"]["*DEFAULT-RETURN-VALUE*"].bound else  local l171 = l122; single_value();  local l172 = n if n ~= CL["SYMBOLP"](l171) then  local l173 = CL["SYMBOL-NAME"](l171); single_value();  l172 = CL["STRING="](l173, l("THEREIS")) else  l172 = n.bound end local l170 = n if n ~= l172 then  single_value();  single_value();  single_value();  local l175 = CL["GENSYM"]("THEREIS-"); single_value();  local l176 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l177 = (l176)[1]; single_value();  single_value();  local l178 = (l176)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l178 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l174 = CL["NCONC"](l(LCL["LOOP"]["*BODY-FORMS*"].bound,CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l175, CL["CONS"](l177, n)), n), CL["CONS"](CL["CONS"](CL["WHEN"], CL["CONS"](l175, CL["CONS"](CL["CONS"](CL["RETURN-FROM"], CL["CONS"](l46, CL["CONS"](l175, n))), n))), n))), n))); single_value();  LCL["LOOP"]["*BODY-FORMS*"].bound = l174 l170 = LCL["LOOP"]["*BODY-FORMS*"].bound else  local l179 = n if n ~= CL["T"].bound then  single_value();  single_value();  local l180 = CL["CONS"](l122, LCL["LOOP"]["*REMAINING-STUFF*"].bound); single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l180 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l181 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["MAYBE-PARSE-UNCONDITIONAL"].fbound, {}); single_value();  local l182 = n if n ~= l181 then  l182 = l181 else  local l183 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["MAYBE-PARSE-CONDITIONAL"].fbound, {}); single_value();  local l184 = n if n ~= l183 then  l184 = l183 else  local l185 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["MAYBE-PARSE-ACCUMULATION"].fbound, {}); single_value();  local l186 = n if n ~= l185 then  l186 = l185 else  l186 = CL["ERROR"]("Unknown clause, ~S", l(l122)) end l184 = l186 end l182 = l184 end l179 = l182 else  l179 = n.bound end l170 = l179 end l161 = l170 end l152 = l161 end l144 = l152 end l136 = l144 end l132 = l136 end l127 = l132 end l126 = l127 end local tmpres = l126 end i( n );
 single_value();  local l187 = CL["GENSYM"]("AGAIN-"); local l188 = CL["GENSYM"]("THIS-IS-THE-END-"); single_value();  local l189 = LCL["LOOP"]["*RETURN-VALUE*"].bound; single_value();  local l190 = n if n ~= l189 then  l190 = l189 else  local l191 = LCL["LOOP"]["*DEFAULT-RETURN-VALUE*"].bound; single_value();  local l192 = n if n ~= l191 then  l192 = l191 else  l192 = LCL["LOOP"]["*RESULT-VAR*"].bound end l190 = l192 end return CL["CONS"](CL["BLOCK"], CL["CONS"](l46, CL["CONS"](CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound, CL["CONS"](CL["MACROLET"], CL["CONS"](CL["CONS"](CL["CONS"](CL["LOOP-FINISH"], CL["CONS"](n, CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["CONS"](CL["GO"], CL["CONS"](l188, n)), n)), n))), CL["CONS"](CL["CONS"](LCL["LOOP"]["INTERNAL-LOOP-RETURN-FROM"], CL["CONS"](CL["CONS"](LCL["LOOP"]["VAL"], n), CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["RETURN-FROM"], n)), CL["CONS"](l46, CL["CONS"](LCL["LOOP"]["VAL"], n)))), n))), n)), CL["CONS"](CL["CONS"](CL["TAGBODY"], CL["APPEND"](l(LCL["LOOP"]["*PROLOGUE*"].bound,CL["CONS"](l187, CL["CONS"](CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {LCL["LOOP"]["*INSIDE-BINDINGS*"].bound, CL["CONS"](CL["PROGN"], CL["APPEND"](l(LCL["LOOP"]["*BODY-FORMS*"].bound,CL["APPEND"](l(CL["NREVERSE"](LCL["LOOP"]["*ITERATION-FORMS*"].bound),n))))), }), CL["CONS"](CL["CONS"](CL["GO"], CL["CONS"](l187, n)), CL["CONS"](l188, CL["APPEND"](l(LCL["LOOP"]["*EPILOGUE*"].bound,CL["CONS"](CL["CONS"](CL["RETURN-FROM"], CL["CONS"](l46, CL["CONS"](l190, n))), n)))))))))), n))), }), n))) end, 0, 0, false, false))); LCL["LOOP"]["*REMAINING-STUFF*"].bound = l42 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value(); if l43.error ~= n and true then if l43.error == KEYWORD.TAG then  error(l43) else error(l43[1]) end end return CL["VALUES-LIST"](list_r(l43)) end, 0, 0, false, false))); LCL["LOOP"]["*ACCUMULATION-VARIABLES*"].bound = l38 i( LCL["LOOP"]["*ACCUMULATION-VARIABLES*"].bound );
 single_value(); if l39.error ~= n and true then if l39.error == KEYWORD.TAG then  error(l39) else error(l39[1]) end end return CL["VALUES-LIST"](list_r(l39)) end, 0, 0, false, false))); LCL["LOOP"]["*DEFAULT-RETURN-VALUE*"].bound = l34 i( LCL["LOOP"]["*DEFAULT-RETURN-VALUE*"].bound );
 single_value(); if l35.error ~= n and true then if l35.error == KEYWORD.TAG then  error(l35) else error(l35[1]) end end return CL["VALUES-LIST"](list_r(l35)) end, 0, 0, false, false))); LCL["LOOP"]["*RETURN-VALUE*"].bound = l30 i( LCL["LOOP"]["*RETURN-VALUE*"].bound );
 single_value(); if l31.error ~= n and true then if l31.error == KEYWORD.TAG then  error(l31) else error(l31[1]) end end return CL["VALUES-LIST"](list_r(l31)) end, 0, 0, false, false))); LCL["LOOP"]["*RESULT-VAR*"].bound = l26 i( LCL["LOOP"]["*RESULT-VAR*"].bound );
 single_value(); if l27.error ~= n and true then if l27.error == KEYWORD.TAG then  error(l27) else error(l27[1]) end end return CL["VALUES-LIST"](list_r(l27)) end, 0, 0, false, false))); LCL["LOOP"]["*EPILOGUE*"].bound = l22 i( LCL["LOOP"]["*EPILOGUE*"].bound );
 single_value(); if l23.error ~= n and true then if l23.error == KEYWORD.TAG then  error(l23) else error(l23[1]) end end return CL["VALUES-LIST"](list_r(l23)) end, 0, 0, false, false))); LCL["LOOP"]["*ITERATION-FORMS*"].bound = l18 i( LCL["LOOP"]["*ITERATION-FORMS*"].bound );
 single_value(); if l19.error ~= n and true then if l19.error == KEYWORD.TAG then  error(l19) else error(l19[1]) end end return CL["VALUES-LIST"](list_r(l19)) end, 0, 0, false, false))); LCL["LOOP"]["*BODY-FORMS*"].bound = l14 i( LCL["LOOP"]["*BODY-FORMS*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end return CL["VALUES-LIST"](list_r(l15)) end, 0, 0, false, false))); LCL["LOOP"]["*INSIDE-BINDINGS*"].bound = l10 i( LCL["LOOP"]["*INSIDE-BINDINGS*"].bound );
 single_value(); if l11.error ~= n and true then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end return CL["VALUES-LIST"](list_r(l11)) end, 0, 0, false, false))); LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound = l6 i( LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound );
 single_value(); if l7.error ~= n and true then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end return CL["VALUES-LIST"](list_r(l7)) end, 0, 0, false, false))); LCL["LOOP"]["*PROLOGUE*"].bound = l2 i( LCL["LOOP"]["*PROLOGUE*"].bound );
 single_value(); if l3.error ~= n and true then if l3.error == KEYWORD.TAG then  error(l3) else error(l3[1]) end end return CL["VALUES-LIST"](list_r(l3)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-NAMED"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l2 = (LCL["LOOP"]["*REMAINING-STUFF*"].bound)[1]; single_value();  local l3 = n if n ~= CL["SYMBOLP"](l2) then  local l4 = CL["SYMBOL-NAME"](l2); single_value();  l3 = CL["STRING="](l4, l("NAMED")) else  l3 = n.bound end local l1 = n if n ~= l3 then  local l5 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l6 = (l5)[1]; single_value();  single_value();  local l7 = (l5)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l7 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  i( l6 );
 single_value();  local l8 = n if n ~= CL["SYMBOLP"]((LCL["LOOP"]["*REMAINING-STUFF*"].bound)[1]) then  local l9 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l10 = (l9)[1]; single_value();  single_value();  local l11 = (l9)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l11 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  l8 = l10 else  l8 = CL["ERROR"]("Loop name ~S is not a symbol.", l((LCL["LOOP"]["*REMAINING-STUFF*"].bound)[1])) end l1 = l8 else  l1 = n.bound end return l1 end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-EXPR-LIST"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l1 = n.bound; single_value();  while true do  local l2 = n if n ~= CL["ATOM"]((LCL["LOOP"]["*REMAINING-STUFF*"].bound)[1]) then  single_value();  local l3 = CL["NREVERSE"](l1); single_value(); do return l3 end; l2 = n.bound else  l2 = n.bound end i( l2 );
 single_value();  single_value();  single_value();  local l5 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l6 = (l5)[1]; single_value();  single_value();  local l7 = (l5)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l7 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l4 = CL["CONS"](l6, l1); single_value();  l1 = l4 local tmpres = l1 end return n end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-FINALLY"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l2 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l3 = (l2)[1]; single_value();  single_value();  local l4 = (l2)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l4 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l1 = l3; single_value();  local l6 = l1; single_value();  local l7 = n if n ~= CL["SYMBOLP"](l6) then  local l8 = CL["SYMBOL-NAME"](l6); single_value();  l7 = CL["STRING="](l8, l("RETURN")) else  l7 = n.bound end local l5 = n if n ~= l7 then  local l9 = n if n ~= CL["NOT"](CL["NULL"](LCL["LOOP"]["*RETURN-VALUE*"].bound)) then  single_value();  l9 = CL["ERROR"]("Cannot specify two FINALLY RETURN clauses.", l()) else  local l10 = n if n ~= CL["NULL"](LCL["LOOP"]["*REMAINING-STUFF*"].bound) then  single_value();  l10 = CL["ERROR"]("FINALLY RETURN must be followed with an expression.", l()) else  local l11 = n if n ~= CL["T"].bound then  single_value();  single_value();  single_value();  local l13 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l14 = (l13)[1]; single_value();  single_value();  local l15 = (l13)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l15 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l12 = l14; single_value();  LCL["LOOP"]["*RETURN-VALUE*"].bound = l12 l11 = LCL["LOOP"]["*RETURN-VALUE*"].bound else  l11 = n.bound end l10 = l11 end l9 = l10 end l5 = l9 else  local l17 = l1; single_value();  local l18 = n if n ~= CL["SYMBOLP"](l17) then  local l19 = CL["SYMBOL-NAME"](l17); single_value();  local l20 = CL["STRING="](l19, l("DO")); single_value();  local l21 = n if n ~= l20 then  l21 = l20 else  l21 = CL["STRING="](l19, l("DOING")) end l18 = l21 else  l18 = n.bound end local l16 = n if n ~= l18 then  l16 = n.bound else  single_value();  single_value();  single_value();  local l22 = CL["CONS"](l1, LCL["LOOP"]["*REMAINING-STUFF*"].bound); single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l22 l16 = LCL["LOOP"]["*REMAINING-STUFF*"].bound end i( l16 );
 single_value();  single_value();  single_value();  local l23 = CL["NCONC"](l(LCL["LOOP"]["*EPILOGUE*"].bound,CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-EXPR-LIST"].fbound, {}))); single_value();  LCL["LOOP"]["*EPILOGUE*"].bound = l23 l5 = LCL["LOOP"]["*EPILOGUE*"].bound end return l5 end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-WITH"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l1 = n.bound; while true do  local l2 = n.bound; local l3 = n.bound; local l4 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l5 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l6 = l7; single_value();  single_value();  l2,l3= unpack_mv(CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-VAR-AND-TYPE-SPEC"].fbound, {}), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l4 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l5.error ~= n and true then if l5.error == KEYWORD.TAG then  error(l5) else error(l5[1]) end end i( CL["VALUES-LIST"](list_r(l5)) );
 single_value();  local l10 = (LCL["LOOP"]["*REMAINING-STUFF*"].bound)[1]; single_value();  local l11 = n if n ~= CL["SYMBOLP"](l10) then  local l12 = CL["SYMBOL-NAME"](l10); single_value();  l11 = CL["STRING="](l12, l("=")) else  l11 = n.bound end local l9 = n if n ~= l11 then  local l13 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l14 = (l13)[1]; single_value();  single_value();  local l15 = (l13)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l15 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  i( l14 );
 single_value();  local l16 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l17 = (l16)[1]; single_value();  single_value();  local l18 = (l16)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l18 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  l9 = l17 else  l9 = CL["LIST"](l(CL["QUOTE"],CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PICK-DEFAULT-VALUE"].fbound, {l2, l3, }))) end local l8 = l9; single_value();  single_value();  single_value();  local l19 = CL["CONS"](CL["LIST"](l(l2,l3,CL["T"].bound,l8,n.bound,n.bound)), l1); single_value();  l1 = l19 i( l1 );
 single_value();  local l21 = (LCL["LOOP"]["*REMAINING-STUFF*"].bound)[1]; single_value();  local l22 = n if n ~= CL["SYMBOLP"](l21) then  local l23 = CL["SYMBOL-NAME"](l21); single_value();  l22 = CL["STRING="](l23, l("AND")) else  l22 = n.bound end local l20 = n if n ~= l22 then  local l24 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l25 = (l24)[1]; single_value();  single_value();  local l26 = (l24)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l26 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  l20 = l25 else do break end; l20 = n.bound end local tmpres = l20 end i( n );
 single_value();  local l27 = n.bound; local l28 = n.bound; local l29 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l30 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l32 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l31 = l32; single_value();  single_value();  l27,l28= unpack_mv(CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["BUILD-LET-EXPRESSION"].fbound, {l1, }), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l29 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l30.error ~= n and true then if l30.error == KEYWORD.TAG then  error(l30) else error(l30[1]) end end i( CL["VALUES-LIST"](list_r(l30)) );
 single_value();  single_value();  local l33 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound, l27, }); single_value();  LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound = l33 i( LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound );
 single_value();  single_value();  single_value();  local l34 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {LCL["LOOP"]["*INSIDE-BINDINGS*"].bound, l28, }); single_value();  LCL["LOOP"]["*INSIDE-BINDINGS*"].bound = l34 return LCL["LOOP"]["*INSIDE-BINDINGS*"].bound end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-VAR-AND-TYPE-SPEC"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l1 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l2 = (l1)[1]; single_value();  single_value();  local l3 = (l1)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l3 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  return CL["VALUES"](l(l2,CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-TYPE-SPEC"].fbound, {CL["T"].bound, }))) end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-TYPE-SPEC"] , CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["DEFAULT"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PREPOSITION-P"].fbound, {"OF-TYPE", }) then  single_value();  local l3 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l4 = (l3)[1]; single_value();  single_value();  local l5 = (l3)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l5 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  l2 = l4 else  local l7 = n if n ~= LCL["LOOP"]["*REMAINING-STUFF*"].bound then  l7 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["ONLY-SIMPLE-TYPES"].fbound, {(LCL["LOOP"]["*REMAINING-STUFF*"].bound)[1], }) else  l7 = n.bound end local l6 = n if n ~= l7 then  single_value();  local l8 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l9 = (l8)[1]; single_value();  single_value();  local l10 = (l8)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l10 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  l6 = l9 else  local l11 = n if n ~= CL["T"].bound then  single_value();  l11 = l1 else  l11 = n.bound end l6 = l11 end l2 = l6 end return l2 end, 1, 0, false, false)); local l1 = n.bound; single_value();  i( CL_LIB.DEF(LCL["LOOP"]["*FOR-AS-VARS*"],l1) );
 local l2 = n.bound; single_value();  i( CL_LIB.DEF(LCL["LOOP"]["*FOR-AS-SUB-VARS*"],l2) );
 local l3 = n.bound; single_value();  i( CL_LIB.DEF(LCL["LOOP"]["*FOR-AS-TERM-TESTS*"],l3) );
 single_value();  local l4 = n.bound; single_value();  tmp = CL_LIB.DEF(LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"],l4); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-FOR-AS"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l1 = LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"].bound; local l2 = LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound; local l3 = LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound; local l4 = LCL["LOOP"]["*FOR-AS-VARS*"].bound; single_value();  local l5 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l7 = LCL["LOOP"]["*FOR-AS-VARS*"].bound; LCL["LOOP"]["*FOR-AS-VARS*"].bound = n.bound i( LCL["LOOP"]["*FOR-AS-VARS*"].bound );
 single_value();  local l6 = l7; local l9 = LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound; LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound = n.bound i( LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound );
 single_value();  local l8 = l9; local l11 = LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound; LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound = n.bound i( LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound );
 single_value();  local l10 = l11; local l13 = LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"].bound; LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"].bound = n.bound i( LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"].bound );
 single_value();  local l12 = l13; single_value();  while true do  local l14 = n.bound; local l15 = n.bound; local l16 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l17 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l19 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l18 = l19; single_value();  single_value();  l14,l15= unpack_mv(CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-VAR-AND-TYPE-SPEC"].fbound, {}), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l16 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l17.error ~= n and true then if l17.error == KEYWORD.TAG then  error(l17) else error(l17[1]) end end i( CL["VALUES-LIST"](list_r(l17)) );
 single_value();  local l21 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l22 = (l21)[1]; single_value();  single_value();  local l23 = (l21)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l23 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l20 = l22; single_value();  local l25 = l20; single_value();  local l26 = n if n ~= CL["SYMBOLP"](l25) then  local l27 = CL["SYMBOL-NAME"](l25); single_value();  local l28 = CL["STRING="](l27, l("FROM")); single_value();  local l29 = n if n ~= l28 then  l29 = l28 else  local l30 = CL["STRING="](l27, l("DOWNFROM")); single_value();  local l31 = n if n ~= l30 then  l31 = l30 else  local l32 = CL["STRING="](l27, l("UPFROM")); single_value();  local l33 = n if n ~= l32 then  l33 = l32 else  local l34 = CL["STRING="](l27, l("TO")); single_value();  local l35 = n if n ~= l34 then  l35 = l34 else  local l36 = CL["STRING="](l27, l("DOWNTO")); single_value();  local l37 = n if n ~= l36 then  l37 = l36 else  local l38 = CL["STRING="](l27, l("UPTO")); single_value();  local l39 = n if n ~= l38 then  l39 = l38 else  local l40 = CL["STRING="](l27, l("BELOW")); single_value();  local l41 = n if n ~= l40 then  l41 = l40 else  l41 = CL["STRING="](l27, l("ABOVE")) end l39 = l41 end l37 = l39 end l35 = l37 end l33 = l35 end l31 = l33 end l29 = l31 end l26 = l29 else  l26 = n.bound end local l24 = n if n ~= l26 then  single_value();  l24 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-ARITHMETIC-FOR-AS"].fbound, {l20, l14, l15, }) else  local l43 = l20; single_value();  local l44 = n if n ~= CL["SYMBOLP"](l43) then  local l45 = CL["SYMBOL-NAME"](l43); single_value();  l44 = CL["STRING="](l45, l("IN")) else  l44 = n.bound end local l42 = n if n ~= l44 then  single_value();  l42 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-IN-FOR-AS"].fbound, {l14, l15, }) else  local l47 = l20; single_value();  local l48 = n if n ~= CL["SYMBOLP"](l47) then  local l49 = CL["SYMBOL-NAME"](l47); single_value();  l48 = CL["STRING="](l49, l("ON")) else  l48 = n.bound end local l46 = n if n ~= l48 then  single_value();  l46 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-ON-FOR-AS"].fbound, {l14, l15, }) else  local l51 = l20; single_value();  local l52 = n if n ~= CL["SYMBOLP"](l51) then  local l53 = CL["SYMBOL-NAME"](l51); single_value();  l52 = CL["STRING="](l53, l("=")) else  l52 = n.bound end local l50 = n if n ~= l52 then  single_value();  l50 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-EQUALS-FOR-AS"].fbound, {l14, l15, }) else  local l55 = l20; single_value();  local l56 = n if n ~= CL["SYMBOLP"](l55) then  local l57 = CL["SYMBOL-NAME"](l55); single_value();  l56 = CL["STRING="](l57, l("ACROSS")) else  l56 = n.bound end local l54 = n if n ~= l56 then  single_value();  l54 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-ACROSS-FOR-AS"].fbound, {l14, l15, }) else  local l59 = l20; single_value();  local l60 = n if n ~= CL["SYMBOLP"](l59) then  local l61 = CL["SYMBOL-NAME"](l59); single_value();  l60 = CL["STRING="](l61, l("BEING")) else  l60 = n.bound end local l58 = n if n ~= l60 then  single_value();  l58 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-BEING-FOR-AS"].fbound, {l14, l15, }) else  local l62 = n if n ~= CL["T"].bound then  single_value();  l62 = CL["ERROR"]("Invalid FOR/AS subclause: ~S", l(l20)) else  l62 = n.bound end l58 = l62 end l54 = l58 end l50 = l54 end l46 = l50 end l42 = l46 end l24 = l42 end i( l24 );
 single_value();  local l64 = (LCL["LOOP"]["*REMAINING-STUFF*"].bound)[1]; single_value();  local l65 = n if n ~= CL["SYMBOLP"](l64) then  local l66 = CL["SYMBOL-NAME"](l64); single_value();  l65 = CL["STRING="](l66, l("AND")) else  l65 = n.bound end local l63 = n if n ~= l65 then  local l67 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l68 = (l67)[1]; single_value();  single_value();  local l69 = (l67)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l69 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  l63 = l68 else do break end; l63 = n.bound end local tmpres = l63 end i( n );
 single_value();  local l70 = n.bound; local l71 = n.bound; local l72 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l73 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l75 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l74 = l75; single_value();  single_value();  l70,l71= unpack_mv(CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["BUILD-LET-EXPRESSION"].fbound, {LCL["LOOP"]["*FOR-AS-VARS*"].bound, }), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l72 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l73.error ~= n and true then if l73.error == KEYWORD.TAG then  error(l73) else error(l73[1]) end end i( CL["VALUES-LIST"](list_r(l73)) );
 single_value();  local l76 = n.bound; local l77 = n.bound; local l78 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l79 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l81 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l80 = l81; single_value();  single_value();  l76,l77= unpack_mv(CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["BUILD-LET-EXPRESSION"].fbound, {LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound, }), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l78 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l79.error ~= n and true then if l79.error == KEYWORD.TAG then  error(l79) else error(l79[1]) end end i( CL["VALUES-LIST"](list_r(l79)) );
 single_value();  single_value();  local l82 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound, CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {l70, l76, }), }); single_value();  LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound = l82 i( LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound );
 single_value();  local l84 = n if n ~= LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound then  l84 = CL["CONS"](CL["IF"], CL["CONS"](CL["CONS"](CL["OR"], CL["APPEND"](l(CL["NREVERSE"](LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound),n))), CL["CONS"](CL["CONS"](CL["LOOP-FINISH"], n), CL["CONS"](LCL["LOOP"]["*MAGIC-COOKIE*"].bound, n)))) else  l84 = LCL["LOOP"]["*MAGIC-COOKIE*"].bound end local l83 = l84; local l86 = n if n ~= LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"].bound then  l86 = CL["CONS"](CL["IF"], CL["CONS"](CL["CONS"](CL["OR"], CL["APPEND"](l(CL["NREVERSE"](LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"].bound),n))), CL["CONS"](CL["CONS"](CL["LOOP-FINISH"], n), CL["CONS"](LCL["LOOP"]["*MAGIC-COOKIE*"].bound, n)))) else  l86 = LCL["LOOP"]["*MAGIC-COOKIE*"].bound end local l85 = l86; single_value();  single_value();  single_value();  local l87 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {LCL["LOOP"]["*INSIDE-BINDINGS*"].bound, CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {l71, CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {l83, CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {l77, l85, }), }), }), }); single_value();  LCL["LOOP"]["*INSIDE-BINDINGS*"].bound = l87 return LCL["LOOP"]["*INSIDE-BINDINGS*"].bound end, 0, 0, false, false))); LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"].bound = l1 i( LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"].bound );
 LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound = l2 i( LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound );
 LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound = l3 i( LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound );
 LCL["LOOP"]["*FOR-AS-VARS*"].bound = l4 i( LCL["LOOP"]["*FOR-AS-VARS*"].bound );
 single_value(); if l5.error ~= n and true then if l5.error == KEYWORD.TAG then  error(l5) else error(l5[1]) end end return CL["VALUES-LIST"](list_r(l5)) end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-ARITHMETIC-FOR-AS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["SUB-CLAUSE"],{LCL["LOOP"]["NAME"],{CL["TYPE"],n}}},function (l1, l2, l3,  ...)   local l4 = n if n ~= CL["ATOM"](l2) then  l4 = n.bound else  single_value();  l4 = CL["ERROR"]("Cannot destructure arithmetic FOR/AS variables: ~S", l(l2)) end i( l4 );
 single_value();  local l5 = n.bound; local l6 = n.bound; local l7 = 1; local l8 = n.bound; local l9 = n.bound; local l11 = l1; single_value();  local l12 = n if n ~= CL["SYMBOLP"](l11) then  local l13 = CL["SYMBOL-NAME"](l11); single_value();  l12 = CL["STRING="](l13, l("FROM")) else  l12 = n.bound end local l10 = n if n ~= l12 then  single_value();  single_value();  single_value();  local l15 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l16 = (l15)[1]; single_value();  single_value();  local l17 = (l15)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l17 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l14 = l16; single_value();  l5 = l14 l10 = l5 else  local l19 = l1; single_value();  local l20 = n if n ~= CL["SYMBOLP"](l19) then  local l21 = CL["SYMBOL-NAME"](l19); single_value();  l20 = CL["STRING="](l21, l("DOWNFROM")) else  l20 = n.bound end local l18 = n if n ~= l20 then  single_value();  single_value();  local l23 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l24 = (l23)[1]; single_value();  single_value();  local l25 = (l23)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l25 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l22 = l24; single_value();  l5 = l22 i( l5 );
 single_value();  single_value();  single_value();  local l26 = LCL["KEYWORD"]["DOWN"]; single_value();  l8 = l26 l18 = l8 else  local l28 = l1; single_value();  local l29 = n if n ~= CL["SYMBOLP"](l28) then  local l30 = CL["SYMBOL-NAME"](l28); single_value();  l29 = CL["STRING="](l30, l("UPFROM")) else  l29 = n.bound end local l27 = n if n ~= l29 then  single_value();  single_value();  local l32 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l33 = (l32)[1]; single_value();  single_value();  local l34 = (l32)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l34 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l31 = l33; single_value();  l5 = l31 i( l5 );
 single_value();  single_value();  single_value();  local l35 = LCL["KEYWORD"]["UP"]; single_value();  l8 = l35 l27 = l8 else  local l36 = n if n ~= CL["T"].bound then  single_value();  single_value();  single_value();  local l37 = CL["CONS"](l1, LCL["LOOP"]["*REMAINING-STUFF*"].bound); single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l37 l36 = LCL["LOOP"]["*REMAINING-STUFF*"].bound else  l36 = n.bound end l27 = l36 end l18 = l27 end l10 = l18 end i( l10 );
 local l38 = n if n ~= CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PREPOSITION-P"].fbound, {"TO", }) then  single_value();  single_value();  single_value();  local l40 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l41 = (l40)[1]; single_value();  single_value();  local l42 = (l40)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l42 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l39 = l41; single_value();  l6 = l39 l38 = l6 else  local l43 = n if n ~= CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PREPOSITION-P"].fbound, {"DOWNTO", }) then  single_value();  single_value();  local l45 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l46 = (l45)[1]; single_value();  single_value();  local l47 = (l45)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l47 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l44 = l46; single_value();  l6 = l44 i( l6 );
 single_value();  local l48 = n if n ~= CL["EQ"](l8, LCL["KEYWORD"]["UP"]) then  l48 = CL["ERROR"]("Can't mix UPFROM and DOWNTO in ~S.", l(l2)) else  single_value();  single_value();  local l49 = LCL["KEYWORD"]["DOWN"]; single_value();  l8 = l49 l48 = l8 end l43 = l48 else  local l50 = n if n ~= CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PREPOSITION-P"].fbound, {"UPTO", }) then  single_value();  single_value();  local l52 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l53 = (l52)[1]; single_value();  single_value();  local l54 = (l52)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l54 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l51 = l53; single_value();  l6 = l51 i( l6 );
 single_value();  local l55 = n if n ~= CL["EQ"](l8, LCL["KEYWORD"]["DOWN"]) then  l55 = CL["ERROR"]("Can't mix DOWNFROM and UPTO in ~S.", l(l2)) else  single_value();  single_value();  local l56 = LCL["KEYWORD"]["UP"]; single_value();  l8 = l56 l55 = l8 end l50 = l55 else  local l57 = n if n ~= CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PREPOSITION-P"].fbound, {"ABOVE", }) then  single_value();  single_value();  local l59 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l60 = (l59)[1]; single_value();  single_value();  local l61 = (l59)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l61 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l58 = l60; single_value();  l6 = l58 i( l6 );
 single_value();  single_value();  local l62 = CL["T"].bound; single_value();  l9 = l62 i( l9 );
 single_value();  local l63 = n if n ~= CL["EQ"](l8, LCL["KEYWORD"]["UP"]) then  l63 = CL["ERROR"]("Can't mix UPFROM and ABOVE in ~S.", l(l2)) else  single_value();  single_value();  local l64 = LCL["KEYWORD"]["DOWN"]; single_value();  l8 = l64 l63 = l8 end l57 = l63 else  local l65 = n if n ~= CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PREPOSITION-P"].fbound, {"BELOW", }) then  single_value();  single_value();  local l67 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l68 = (l67)[1]; single_value();  single_value();  local l69 = (l67)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l69 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l66 = l68; single_value();  l6 = l66 i( l6 );
 single_value();  single_value();  local l70 = CL["T"].bound; single_value();  l9 = l70 i( l9 );
 single_value();  local l71 = n if n ~= CL["EQ"](l8, LCL["KEYWORD"]["DOWN"]) then  l71 = CL["ERROR"]("Can't mix DOWNFROM and BELOW in ~S.", l(l2)) else  single_value();  single_value();  local l72 = LCL["KEYWORD"]["UP"]; single_value();  l8 = l72 l71 = l8 end l65 = l71 else  l65 = n.bound end l57 = l65 end l50 = l57 end l43 = l50 end l38 = l43 end i( l38 );
 local l73 = n if n ~= CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PREPOSITION-P"].fbound, {"BY", }) then  single_value();  single_value();  single_value();  local l75 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l76 = (l75)[1]; single_value();  single_value();  local l77 = (l75)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l77 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l74 = l76; single_value();  l7 = l74 l73 = l7 else  l73 = n.bound end i( l73 );
 local l79 = n if n ~= CL["EQ"](l8, LCL["KEYWORD"]["DOWN"]) then  l79 = CL["NULL"](l5) else  l79 = n.bound end local l78 = n if n ~= l79 then  single_value();  l78 = CL["ERROR"]("No default starting value for decremental stepping.", l()) else  l78 = n.bound end i( l78 );
 single_value();  local l80 = CL["GENSYM"]("TEMP-AMOUNT-"); single_value();  single_value();  local l81 = CL["CONS"](CL["LIST"](l(l80,l3,CL["T"].bound,l7,n.bound,n.bound)), LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound = l81 i( LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound );
 single_value();  single_value();  local l83 = l5; single_value();  local l84 = n if n ~= l83 then  l84 = l83 else  l84 = 0 end local l85 = n if n ~= CL["EQ"](l8, LCL["KEYWORD"]["DOWN"]) then  l85 = CL["-"] else  l85 = CL["+"] end local l82 = CL["CONS"](CL["LIST"](l(l2,l3,CL["T"].bound,l84,CL["T"].bound,CL["CONS"](l85, CL["CONS"](l2, CL["CONS"](l80, n))))), LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound = l82 i( LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound );
 single_value();  local l86 = n if n ~= l6 then  single_value();  local l87 = CL["GENSYM"]("STOP-VAR-"); single_value();  single_value();  local l88 = CL["CONS"](CL["LIST"](l(l87,l3,CL["T"].bound,l6,n.bound,n.bound)), LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound = l88 i( LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound );
 single_value();  single_value();  single_value();  local l90 = n if n ~= CL["EQ"](l8, LCL["KEYWORD"]["DOWN"]) then  local l91 = n if n ~= l9 then  l91 = CL["<="] else  l91 = CL["<"] end l90 = l91 else  local l92 = n if n ~= l9 then  l92 = CL[">="] else  l92 = CL[">"] end l90 = l92 end local l89 = CL["CONS"](CL["LIST"](l(l90,l2,l87)), LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"].bound = l89 l86 = LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"].bound else  l86 = n.bound end return l86 end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-IN-FOR-AS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["NAME"],{CL["TYPE"],n}},function (l1, l2,  ...)   single_value();  local l3 = CL["GENSYM"]("LIST-"); single_value();  local l5 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l6 = (l5)[1]; single_value();  single_value();  local l7 = (l5)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l7 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l4 = l6; single_value();  local l9 = n if n ~= CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PREPOSITION-P"].fbound, {"BY", }) then  local l10 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l12 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  l9 = CL["CONS"](CL["FUNCALL"], CL["CONS"](l11, CL["CONS"](l3, n))) else  l9 = CL["CONS"](CL["CDR"], CL["CONS"](l3, n)) end local l8 = l9; single_value();  single_value();  single_value();  local l13 = CL["CONS"](CL["LIST"](l(l3,CL["LIST"],CL["T"].bound,l4,CL["T"].bound,l8)), LCL["LOOP"]["*FOR-AS-VARS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-VARS*"].bound = l13 i( LCL["LOOP"]["*FOR-AS-VARS*"].bound );
 single_value();  single_value();  local l14 = CL["CONS"](CL["LIST"](l(l1,l2,CL["T"].bound,CL["CONS"](CL["CAR"], CL["CONS"](l3, n)),CL["T"].bound,CL["CONS"](CL["CAR"], CL["CONS"](l3, n)))), LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound = l14 i( LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound );
 single_value();  single_value();  single_value();  local l15 = CL["CONS"](CL["CONS"](CL["NULL"], CL["CONS"](l3, n)), LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"].bound = l15 return LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"].bound end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-ON-FOR-AS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["NAME"],{CL["TYPE"],n}},function (l1, l2,  ...)   single_value();  local l4 = n if n ~= CL["ATOM"](l1) then  l4 = l1 else  l4 = CL["GENSYM"]("LIST-") end local l3 = l4; single_value();  local l6 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l8 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l5 = l7; single_value();  local l10 = n if n ~= CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PREPOSITION-P"].fbound, {"BY", }) then  local l11 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l12 = (l11)[1]; single_value();  single_value();  local l13 = (l11)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l13 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  l10 = CL["CONS"](CL["FUNCALL"], CL["CONS"](l12, CL["CONS"](l3, n))) else  l10 = CL["CONS"](CL["CDR"], CL["CONS"](l3, n)) end local l9 = l10; single_value();  single_value();  local l14 = n if n ~= CL["ATOM"](l1) then  single_value();  single_value();  local l15 = CL["CONS"](CL["LIST"](l(l1,l2,CL["T"].bound,l5,CL["T"].bound,l9)), LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound = l15 i( LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound );
 single_value();  single_value();  single_value();  local l16 = CL["CONS"](CL["CONS"](CL["ENDP"], CL["CONS"](l1, n)), LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"].bound = l16 l14 = LCL["LOOP"]["*FOR-AS-SUB-TERM-TESTS*"].bound else  local l17 = n if n ~= CL["T"].bound then  single_value();  single_value();  local l18 = CL["CONS"](CL["LIST"](l(l3,l2,CL["T"].bound,l5,CL["T"].bound,l9)), LCL["LOOP"]["*FOR-AS-VARS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-VARS*"].bound = l18 i( LCL["LOOP"]["*FOR-AS-VARS*"].bound );
 single_value();  single_value();  local l19 = CL["CONS"](CL["LIST"](l(l1,l2,n.bound,n.bound,CL["T"].bound,l3)), LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound = l19 i( LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound );
 single_value();  single_value();  single_value();  local l20 = CL["CONS"](CL["CONS"](CL["ENDP"], CL["CONS"](l3, n)), LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound = l20 l17 = LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound else  l17 = n.bound end l14 = l17 end return l14 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-EQUALS-FOR-AS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["NAME"],{CL["TYPE"],n}},function (l1, l2,  ...)   single_value();  local l4 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l5 = (l4)[1]; single_value();  single_value();  local l6 = (l4)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l6 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l3 = l5; single_value();  local l7 = n if n ~= CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PREPOSITION-P"].fbound, {"THEN", }) then  single_value();  single_value();  local l9 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l10 = (l9)[1]; single_value();  single_value();  local l11 = (l9)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l11 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l8 = CL["CONS"](CL["LIST"](l(l1,l2,CL["T"].bound,l3,CL["T"].bound,l10)), LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound = l8 l7 = LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound else  single_value();  single_value();  local l12 = CL["CONS"](CL["LIST"](l(l1,l2,n.bound,n.bound,CL["T"].bound,l3)), LCL["LOOP"]["*FOR-AS-VARS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-VARS*"].bound = l12 l7 = LCL["LOOP"]["*FOR-AS-VARS*"].bound end return l7 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-ACROSS-FOR-AS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["NAME"],{CL["TYPE"],n}},function (l1, l2,  ...)   single_value();  local l3 = CL["GENSYM"]("VECTOR-"); single_value();  local l4 = CL["GENSYM"]("LENGTH-"); single_value();  local l5 = CL["GENSYM"]("INDEX-"); single_value();  single_value();  single_value();  local l7 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l8 = (l7)[1]; single_value();  single_value();  local l9 = (l7)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l9 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l6 = CL["CONS"](CL["LIST"](l(l3,CL["CONS"](CL["VECTOR"], CL["CONS"](l2, n)),CL["T"].bound,l8,n.bound,n.bound)), LCL["LOOP"]["*FOR-AS-VARS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-VARS*"].bound = l6 i( LCL["LOOP"]["*FOR-AS-VARS*"].bound );
 single_value();  single_value();  local l10 = CL["CONS"](CL["LIST"](l(l4,CL["FIXNUM"],CL["T"].bound,CL["CONS"](CL["LENGTH"], CL["CONS"](l3, n)),n.bound,n.bound)), LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound = l10 i( LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound );
 single_value();  single_value();  local l11 = CL["CONS"](CL["LIST"](l(l5,CL["FIXNUM"],CL["T"].bound,0,CL["T"].bound,CL["CONS"](CL["1+"], CL["CONS"](l5, n)))), LCL["LOOP"]["*FOR-AS-VARS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-VARS*"].bound = l11 i( LCL["LOOP"]["*FOR-AS-VARS*"].bound );
 single_value();  single_value();  local l12 = CL["CONS"](CL["LIST"](l(l1,l2,n.bound,n.bound,CL["T"].bound,CL["CONS"](CL["AREF"], CL["CONS"](l3, CL["CONS"](l5, n))))), LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound = l12 i( LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound );
 single_value();  single_value();  single_value();  local l13 = CL["CONS"](CL["CONS"](CL[">="], CL["CONS"](l5, CL["CONS"](l4, n))), LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound = l13 return LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-BEING-FOR-AS"] , CL_LIB["ALLOC-FUNCTION"]({LCL["LOOP"]["NAME"],{CL["TYPE"],n}},function (l1, l2,  ...)   local l4 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l5 = (l4)[1]; single_value();  single_value();  local l6 = (l4)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l6 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l3 = l5; single_value();  local l8 = l3; single_value();  local l9 = n if n ~= CL["SYMBOLP"](l8) then  local l10 = CL["SYMBOL-NAME"](l8); single_value();  local l11 = CL["STRING="](l10, l("EACH")); single_value();  local l12 = n if n ~= l11 then  l12 = l11 else  l12 = CL["STRING="](l10, l("THE")) end l9 = l12 else  l9 = n.bound end local l7 = n if n ~= l9 then  l7 = n.bound else  single_value();  l7 = CL["ERROR"]("BEING must be followed by either EACH or THE, not ~S", l(l3)) end i( l7 );
 single_value();  local l14 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l15 = (l14)[1]; single_value();  single_value();  local l16 = (l14)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l16 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l13 = l15; single_value();  local l18 = l13; single_value();  local l19 = n if n ~= CL["SYMBOLP"](l18) then  local l20 = CL["SYMBOL-NAME"](l18); single_value();  local l21 = CL["STRING="](l20, l("HASH-KEY")); single_value();  local l22 = n if n ~= l21 then  l22 = l21 else  local l23 = CL["STRING="](l20, l("HASH-KEYS")); single_value();  local l24 = n if n ~= l23 then  l24 = l23 else  local l25 = CL["STRING="](l20, l("HASH-VALUE")); single_value();  local l26 = n if n ~= l25 then  l26 = l25 else  l26 = CL["STRING="](l20, l("HASH-VALUES")) end l24 = l26 end l22 = l24 end l19 = l22 else  l19 = n.bound end local l17 = n if n ~= l19 then  local l28 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l29 = (l28)[1]; single_value();  single_value();  local l30 = (l28)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l30 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l27 = l29; single_value();  local l32 = l27; single_value();  local l33 = n if n ~= CL["SYMBOLP"](l32) then  local l34 = CL["SYMBOL-NAME"](l32); single_value();  local l35 = CL["STRING="](l34, l("IN")); single_value();  local l36 = n if n ~= l35 then  l36 = l35 else  l36 = CL["STRING="](l34, l("OF")) end l33 = l36 else  l33 = n.bound end local l31 = n if n ~= l33 then  l31 = n.bound else  single_value();  l31 = CL["ERROR"]("~A must be followed by either IN or OF, not ~S", l(CL["SYMBOL-NAME"](l13),l27)) end i( l31 );
 single_value();  local l38 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l39 = (l38)[1]; single_value();  single_value();  local l40 = (l38)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l40 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l37 = l39; local l41 = CL["GENSYM"](CL["FORMAT"](n.bound, "~A-ITERATOR-", l(l1))); local l42 = CL["GENSYM"](CL["FORMAT"](n.bound, "~A-EXISTS-TEMP-", l(l1))); local l43 = CL["GENSYM"](CL["FORMAT"](n.bound, "~A-KEY-TEMP-", l(l1))); local l44 = CL["GENSYM"](CL["FORMAT"](n.bound, "~A-VALUE-TEMP-", l(l1))); single_value();  single_value();  local l45 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound, CL["CONS"](CL["WITH-HASH-TABLE-ITERATOR"], CL["CONS"](CL["CONS"](l41, CL["CONS"](l37, n)), CL["CONS"](LCL["LOOP"]["*MAGIC-COOKIE*"].bound, n))), }); single_value();  LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound = l45 i( LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound );
 single_value();  local l46 = n.bound; local l47 = n.bound; local l48 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l49 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l51 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l50 = l51; single_value();  single_value();  local l52 = n if n ~= CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PREPOSITION-P"].fbound, {"USING", }) then  single_value();  l52 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-VAR-AND-TYPE-SPEC"].fbound, {}) else  l52 = n.bound end l46,l47= unpack_mv(l52, 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l48 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l49.error ~= n and true then if l49.error == KEYWORD.TAG then  error(l49) else error(l49[1]) end end i( CL["VALUES-LIST"](list_r(l49)) );
 single_value();  local l53 = n.bound; local l54 = n.bound; local l55 = n.bound; local l56 = n.bound; local l57 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l58 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l60 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l59 = l60; single_value();  single_value();  local l62 = l13; single_value();  local l63 = n if n ~= CL["SYMBOLP"](l62) then  local l64 = CL["SYMBOL-NAME"](l62); single_value();  local l65 = CL["STRING="](l64, l("HASH-KEY")); single_value();  local l66 = n if n ~= l65 then  l66 = l65 else  l66 = CL["STRING="](l64, l("HASH-KEYS")) end l63 = l66 else  l63 = n.bound end local l61 = n if n ~= l63 then  l61 = CL["VALUES"](l(l1,l2,l46,l47)) else  l61 = CL["VALUES"](l(l46,l47,l1,l2)) end l53,l54,l55,l56= unpack_mv(l61, 4) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l57 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l58.error ~= n and true then if l58.error == KEYWORD.TAG then  error(l58) else error(l58[1]) end end i( CL["VALUES-LIST"](list_r(l58)) );
 single_value();  single_value();  local l69 = n if n ~= l53 then  l69 = l55 else  l69 = n.bound end local l68 = n if n ~= l69 then  l68 = n.bound else  single_value();  local l70 = n if n ~= CL["NULL"](l53) then  l70 = CL["LIST"](l(l43)) else  l70 = n.bound end local l71 = n if n ~= CL["NULL"](l55) then  l71 = CL["LIST"](l(l44)) else  l71 = n.bound end l68 = CL["CONS"](CL["CONS"](CL["DECLARE"], CL["CONS"](CL["CONS"](CL["IGNORE"], CL["APPEND"](l(l70,CL["APPEND"](l(l71,n))))), n)), n) end local l67 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {LCL["LOOP"]["*INSIDE-BINDINGS*"].bound, CL["CONS"](CL["MULTIPLE-VALUE-BIND"], CL["CONS"](CL["CONS"](l42, CL["CONS"](l43, CL["CONS"](l44, n))), CL["CONS"](CL["CONS"](l41, n), CL["APPEND"](l(l68,CL["CONS"](LCL["LOOP"]["*MAGIC-COOKIE*"].bound, n)))))), }); single_value();  LCL["LOOP"]["*INSIDE-BINDINGS*"].bound = l67 i( LCL["LOOP"]["*INSIDE-BINDINGS*"].bound );
 single_value();  single_value();  local l72 = CL["CONS"](CL["CONS"](CL["NOT"], CL["CONS"](l42, n)), LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound = l72 i( LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound );
 local l73 = n if n ~= l53 then  single_value();  single_value();  single_value();  local l74 = CL["CONS"](CL["LIST"](l(l53,l54,n.bound,n.bound,CL["T"].bound,l43)), LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound = l74 l73 = LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound else  l73 = n.bound end i( l73 );
 single_value();  local l75 = n if n ~= l55 then  single_value();  single_value();  single_value();  local l76 = CL["CONS"](CL["LIST"](l(l55,l56,n.bound,n.bound,CL["T"].bound,l44)), LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound = l76 l75 = LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound else  l75 = n.bound end l17 = l75 else  local l78 = l13; single_value();  local l79 = n if n ~= CL["SYMBOLP"](l78) then  local l80 = CL["SYMBOL-NAME"](l78); single_value();  local l81 = CL["STRING="](l80, l("SYMBOL")); single_value();  local l82 = n if n ~= l81 then  l82 = l81 else  local l83 = CL["STRING="](l80, l("PRESENT-SYMBOL")); single_value();  local l84 = n if n ~= l83 then  l84 = l83 else  local l85 = CL["STRING="](l80, l("EXTERNAL-SYMBOL")); single_value();  local l86 = n if n ~= l85 then  l86 = l85 else  local l87 = CL["STRING="](l80, l("SYMBOLS")); single_value();  local l88 = n if n ~= l87 then  l88 = l87 else  local l89 = CL["STRING="](l80, l("PRESENT-SYMBOLS")); single_value();  local l90 = n if n ~= l89 then  l90 = l89 else  l90 = CL["STRING="](l80, l("EXTERNAL-SYMBOLS")) end l88 = l90 end l86 = l88 end l84 = l86 end l82 = l84 end l79 = l82 else  l79 = n.bound end local l77 = n if n ~= l79 then  single_value();  local l93 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PREPOSITION-P"].fbound, {"IN", }); single_value();  local l94 = n if n ~= l93 then  l94 = l93 else  l94 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PREPOSITION-P"].fbound, {"OF", }) end local l92 = n if n ~= l94 then  local l95 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l96 = (l95)[1]; single_value();  single_value();  local l97 = (l95)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l97 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  l92 = l96 else  l92 = CL["*PACKAGE*"] end local l91 = l92; local l98 = CL["GENSYM"](CL["FORMAT"](n.bound, "~A-ITERATOR-", l(l1))); local l99 = CL["GENSYM"](CL["FORMAT"](n.bound, "~A-EXISTS-TEMP-", l(l1))); local l100 = CL["GENSYM"](CL["FORMAT"](n.bound, "~A-SYMBOL-TEMP-", l(l1))); single_value();  single_value();  local l103 = l13; single_value();  local l104 = n if n ~= CL["SYMBOLP"](l103) then  local l105 = CL["SYMBOL-NAME"](l103); single_value();  local l106 = CL["STRING="](l105, l("SYMBOL")); single_value();  local l107 = n if n ~= l106 then  l107 = l106 else  l107 = CL["STRING="](l105, l("SYMBOLS")) end l104 = l107 else  l104 = n.bound end local l102 = n if n ~= l104 then  single_value();  l102 = {LCL["KEYWORD"]["INTERNAL"],{LCL["KEYWORD"]["EXTERNAL"],{LCL["KEYWORD"]["INHERITED"],n}}} else  local l109 = l13; single_value();  local l110 = n if n ~= CL["SYMBOLP"](l109) then  local l111 = CL["SYMBOL-NAME"](l109); single_value();  local l112 = CL["STRING="](l111, l("PRESENT-SYMBOL")); single_value();  local l113 = n if n ~= l112 then  l113 = l112 else  l113 = CL["STRING="](l111, l("PRESENT-SYMBOLS")) end l110 = l113 else  l110 = n.bound end local l108 = n if n ~= l110 then  single_value();  l108 = {LCL["KEYWORD"]["INTERNAL"],n} else  local l115 = l13; single_value();  local l116 = n if n ~= CL["SYMBOLP"](l115) then  local l117 = CL["SYMBOL-NAME"](l115); single_value();  local l118 = CL["STRING="](l117, l("EXTERNAL-SYMBOL")); single_value();  local l119 = n if n ~= l118 then  l119 = l118 else  l119 = CL["STRING="](l117, l("EXTERNAL-SYMBOLS")) end l116 = l119 else  l116 = n.bound end local l114 = n if n ~= l116 then  single_value();  l114 = {LCL["KEYWORD"]["EXTERNAL"],n} else  local l120 = n if n ~= CL["T"].bound then  single_value();  l120 = CL["ERROR"]("Don't know how to deal with ~A?  ~\n                           Bug in LOOP?", l(l13)) else  l120 = n.bound end l114 = l120 end l108 = l114 end l102 = l108 end local l101 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound, CL["CONS"](CL["WITH-PACKAGE-ITERATOR"], CL["CONS"](CL["CONS"](l98, CL["CONS"](l91, CL["APPEND"](l(l102,n)))), CL["CONS"](LCL["LOOP"]["*MAGIC-COOKIE*"].bound, n))), }); single_value();  LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound = l101 i( LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound );
 single_value();  single_value();  local l121 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {LCL["LOOP"]["*INSIDE-BINDINGS*"].bound, CL["CONS"](CL["MULTIPLE-VALUE-BIND"], CL["CONS"](CL["CONS"](l99, CL["CONS"](l100, n)), CL["CONS"](CL["CONS"](l98, n), CL["CONS"](LCL["LOOP"]["*MAGIC-COOKIE*"].bound, n)))), }); single_value();  LCL["LOOP"]["*INSIDE-BINDINGS*"].bound = l121 i( LCL["LOOP"]["*INSIDE-BINDINGS*"].bound );
 single_value();  single_value();  local l122 = CL["CONS"](CL["CONS"](CL["NOT"], CL["CONS"](l99, n)), LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound = l122 i( LCL["LOOP"]["*FOR-AS-TERM-TESTS*"].bound );
 single_value();  single_value();  single_value();  local l123 = CL["CONS"](CL["LIST"](l(l1,l2,n.bound,n.bound,CL["T"].bound,l100)), LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound); single_value();  LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound = l123 l77 = LCL["LOOP"]["*FOR-AS-SUB-VARS*"].bound else  local l124 = n if n ~= CL["T"].bound then  single_value();  l124 = CL["ERROR"]("Unknown sub-clause, ~A, for BEING.  Must be one of:~%  ~\n         HASH-KEY HASH-KEYS HASH-VALUE HASH-VALUES SYMBOL SYMBOLS~%  ~\n         PRESENT-SYMBOL PRESENT-SYMBOLS EXTERNAL-SYMBOL EXTERNAL-SYMBOLS", l(CL["SYMBOL-NAME"](l13))) else  l124 = n.bound end l77 = l124 end l17 = l77 end return l17 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-REPEAT"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l1 = CL["GENSYM"]("REPEAT-"); single_value();  single_value();  local l3 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l4 = (l3)[1]; single_value();  single_value();  local l5 = (l3)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l5 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l2 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound, CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l1, CL["CONS"](l4, n)), n), CL["CONS"](LCL["LOOP"]["*MAGIC-COOKIE*"].bound, n))), }); single_value();  LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound = l2 i( LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound );
 single_value();  single_value();  single_value();  local l6 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {LCL["LOOP"]["*INSIDE-BINDINGS*"].bound, CL["CONS"](CL["IF"], CL["CONS"](CL["CONS"](CL["MINUSP"], CL["CONS"](CL["CONS"](CL["DECF"], CL["CONS"](l1, n)), n)), CL["CONS"](CL["CONS"](CL["LOOP-FINISH"], n), CL["CONS"](LCL["LOOP"]["*MAGIC-COOKIE*"].bound, n)))), }); single_value();  LCL["LOOP"]["*INSIDE-BINDINGS*"].bound = l6 return LCL["LOOP"]["*INSIDE-BINDINGS*"].bound end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["MAYBE-PARSE-UNCONDITIONAL"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l2 = (LCL["LOOP"]["*REMAINING-STUFF*"].bound)[1]; single_value();  local l3 = n if n ~= CL["SYMBOLP"](l2) then  local l4 = CL["SYMBOL-NAME"](l2); single_value();  local l5 = CL["STRING="](l4, l("DO")); single_value();  local l6 = n if n ~= l5 then  l6 = l5 else  l6 = CL["STRING="](l4, l("DOING")) end l3 = l6 else  l3 = n.bound end local l1 = n if n ~= l3 then  local l7 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l8 = (l7)[1]; single_value();  single_value();  local l9 = (l7)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l9 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  i( l8 );
 single_value();  single_value();  local l10 = CL["NCONC"](l(LCL["LOOP"]["*BODY-FORMS*"].bound,CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-EXPR-LIST"].fbound, {}))); single_value();  LCL["LOOP"]["*BODY-FORMS*"].bound = l10 i( LCL["LOOP"]["*BODY-FORMS*"].bound );
 single_value();  l1 = CL["T"].bound else  local l12 = (LCL["LOOP"]["*REMAINING-STUFF*"].bound)[1]; single_value();  local l13 = n if n ~= CL["SYMBOLP"](l12) then  local l14 = CL["SYMBOL-NAME"](l12); single_value();  l13 = CL["STRING="](l14, l("RETURN")) else  l13 = n.bound end local l11 = n if n ~= l13 then  local l15 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l16 = (l15)[1]; single_value();  single_value();  local l17 = (l15)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l17 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  i( l16 );
 single_value();  single_value();  local l19 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l20 = (l19)[1]; single_value();  single_value();  local l21 = (l19)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l21 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l18 = CL["NCONC"](l(LCL["LOOP"]["*BODY-FORMS*"].bound,CL["CONS"](CL["CONS"](LCL["LOOP"]["INTERNAL-LOOP-RETURN-FROM"], CL["CONS"](l20, n)), n))); single_value();  LCL["LOOP"]["*BODY-FORMS*"].bound = l18 i( LCL["LOOP"]["*BODY-FORMS*"].bound );
 single_value();  l11 = CL["T"].bound else  l11 = n.bound end l1 = l11 end return l1 end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["MAYBE-PARSE-CONDITIONAL"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l2 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l3 = (l2)[1]; single_value();  single_value();  local l4 = (l2)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l4 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l1 = l3; single_value();  local l6 = l1; single_value();  local l7 = n if n ~= CL["SYMBOLP"](l6) then  local l8 = CL["SYMBOL-NAME"](l6); single_value();  local l9 = CL["STRING="](l8, l("IF")); single_value();  local l10 = n if n ~= l9 then  l10 = l9 else  l10 = CL["STRING="](l8, l("WHEN")) end l7 = l10 else  l7 = n.bound end local l5 = n if n ~= l7 then  local l11 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l12 = (l11)[1]; single_value();  single_value();  local l13 = (l11)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l13 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  i( CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-CONDITIONAL"].fbound, {l12, }) );
 single_value();  l5 = CL["T"].bound else  local l15 = l1; single_value();  local l16 = n if n ~= CL["SYMBOLP"](l15) then  local l17 = CL["SYMBOL-NAME"](l15); single_value();  l16 = CL["STRING="](l17, l("UNLESS")) else  l16 = n.bound end local l14 = n if n ~= l16 then  local l18 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l19 = (l18)[1]; single_value();  single_value();  local l20 = (l18)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l20 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  i( CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-CONDITIONAL"].fbound, {CL["CONS"](CL["NOT"], CL["CONS"](l19, n)), }) );
 single_value();  l14 = CL["T"].bound else  local l21 = n if n ~= CL["T"].bound then  single_value();  single_value();  local l22 = CL["CONS"](l1, LCL["LOOP"]["*REMAINING-STUFF*"].bound); single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l22 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  l21 = n.bound else  l21 = n.bound end l14 = l21 end l5 = l14 end return l5 end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-CONDITIONAL"] , CL_LIB["ALLOC-FUNCTION"]({CL["CONDITION"],n},function (l1,  ...)   single_value();  local l2 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-AND-CLAUSES"].fbound, {}); local l4 = n if n ~= CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PREPOSITION-P"].fbound, {"ELSE", }) then  single_value();  l4 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-AND-CLAUSES"].fbound, {}) else  l4 = n.bound end local l3 = l4; single_value();  single_value();  local l5 = CL["NCONC"](l(LCL["LOOP"]["*BODY-FORMS*"].bound,CL["CONS"](CL["CONS"](CL["IF"], CL["CONS"](l1, CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(l2,n))), CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(l3,n))), n)))), n))); single_value();  LCL["LOOP"]["*BODY-FORMS*"].bound = l5 i( LCL["LOOP"]["*BODY-FORMS*"].bound );
 single_value();  return CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PREPOSITION-P"].fbound, {"END", }) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-AND-CLAUSES"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l1 = LCL["LOOP"]["*BODY-FORMS*"].bound; single_value();  local l2 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l4 = LCL["LOOP"]["*BODY-FORMS*"].bound; LCL["LOOP"]["*BODY-FORMS*"].bound = n.bound i( LCL["LOOP"]["*BODY-FORMS*"].bound );
 single_value();  local l3 = l4; single_value();  while true do  local l5 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["MAYBE-PARSE-UNCONDITIONAL"].fbound, {}); single_value();  local l6 = n if n ~= l5 then  l6 = l5 else  local l7 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["MAYBE-PARSE-CONDITIONAL"].fbound, {}); single_value();  local l8 = n if n ~= l7 then  l8 = l7 else  local l9 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["MAYBE-PARSE-ACCUMULATION"].fbound, {}); single_value();  local l10 = n if n ~= l9 then  l10 = l9 else  l10 = CL["ERROR"]("Invalid clause for inside a conditional: ~S", l((LCL["LOOP"]["*REMAINING-STUFF*"].bound)[1])) end l8 = l10 end l6 = l8 end i( l6 );
 single_value();  local l11 = n if n ~= CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PREPOSITION-P"].fbound, {"AND", }) then  l11 = n.bound else  single_value(); do break end; l11 = n.bound end local tmpres = l11 end i( n );
 single_value();  return LCL["LOOP"]["*BODY-FORMS*"].bound end, 0, 0, false, false))); LCL["LOOP"]["*BODY-FORMS*"].bound = l1 i( LCL["LOOP"]["*BODY-FORMS*"].bound );
 single_value(); if l2.error ~= n and true then if l2.error == KEYWORD.TAG then  error(l2) else error(l2[1]) end end return CL["VALUES-LIST"](list_r(l2)) end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["MAYBE-PARSE-ACCUMULATION"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l2 = (LCL["LOOP"]["*REMAINING-STUFF*"].bound)[1]; single_value();  local l3 = n if n ~= CL["SYMBOLP"](l2) then  local l4 = CL["SYMBOL-NAME"](l2); single_value();  local l5 = CL["STRING="](l4, l("COLLECT")); single_value();  local l6 = n if n ~= l5 then  l6 = l5 else  local l7 = CL["STRING="](l4, l("COLLECTING")); single_value();  local l8 = n if n ~= l7 then  l8 = l7 else  local l9 = CL["STRING="](l4, l("APPEND")); single_value();  local l10 = n if n ~= l9 then  l10 = l9 else  local l11 = CL["STRING="](l4, l("APPENDING")); single_value();  local l12 = n if n ~= l11 then  l12 = l11 else  local l13 = CL["STRING="](l4, l("NCONC")); single_value();  local l14 = n if n ~= l13 then  l14 = l13 else  local l15 = CL["STRING="](l4, l("NCONCING")); single_value();  local l16 = n if n ~= l15 then  l16 = l15 else  local l17 = CL["STRING="](l4, l("COUNT")); single_value();  local l18 = n if n ~= l17 then  l18 = l17 else  local l19 = CL["STRING="](l4, l("COUNTING")); single_value();  local l20 = n if n ~= l19 then  l20 = l19 else  local l21 = CL["STRING="](l4, l("SUM")); single_value();  local l22 = n if n ~= l21 then  l22 = l21 else  local l23 = CL["STRING="](l4, l("SUMMING")); single_value();  local l24 = n if n ~= l23 then  l24 = l23 else  local l25 = CL["STRING="](l4, l("MAXIMIZE")); single_value();  local l26 = n if n ~= l25 then  l26 = l25 else  local l27 = CL["STRING="](l4, l("MAXIMIZING")); single_value();  local l28 = n if n ~= l27 then  l28 = l27 else  local l29 = CL["STRING="](l4, l("MINIMIZE")); single_value();  local l30 = n if n ~= l29 then  l30 = l29 else  l30 = CL["STRING="](l4, l("MINIMIZING")) end l28 = l30 end l26 = l28 end l24 = l26 end l22 = l24 end l20 = l22 end l18 = l20 end l16 = l18 end l14 = l16 end l12 = l14 end l10 = l12 end l8 = l10 end l6 = l8 end l3 = l6 else  l3 = n.bound end local l1 = n if n ~= l3 then  i( CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-ACCUMULATION"].fbound, {}) );
 single_value();  l1 = CL["T"].bound else  l1 = n.bound end return l1 end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](LCL["LOOP"]["PARSE-ACCUMULATION"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l2 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l3 = (l2)[1]; single_value();  single_value();  local l4 = (l2)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l4 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l1 = l3; single_value();  local l6 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l8 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  local l5 = l7; single_value();  local l10 = n if n ~= CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PREPOSITION-P"].fbound, {"INTO", }) then  local l11 = LCL["LOOP"]["*REMAINING-STUFF*"].bound; single_value();  local l12 = (l11)[1]; single_value();  single_value();  local l13 = (l11)[2]; single_value();  LCL["LOOP"]["*REMAINING-STUFF*"].bound = l13 i( LCL["LOOP"]["*REMAINING-STUFF*"].bound );
 single_value();  l10 = l12 else  local l14 = LCL["LOOP"]["*RESULT-VAR*"].bound; single_value();  local l15 = n if n ~= l14 then  l15 = l14 else  single_value();  single_value();  local l16 = CL["GENSYM"](CL["CONCATENATE"](CL["STRING"], l(CL["STRING"](l1),"-"))); single_value();  LCL["LOOP"]["*RESULT-VAR*"].bound = l16 l15 = LCL["LOOP"]["*RESULT-VAR*"].bound end l10 = l15 end local l9 = l10; single_value();  local l17 = CL["ASSOC"](l9, LCL["LOOP"]["*ACCUMULATION-VARIABLES*"].bound, k()); single_value();  local l18 = n.bound; single_value();  local l19 = n.bound; single_value();  local l21 = l1; single_value();  local l22 = n if n ~= CL["SYMBOLP"](l21) then  local l23 = CL["SYMBOL-NAME"](l21); single_value();  local l24 = CL["STRING="](l23, l("COLLECT")); single_value();  local l25 = n if n ~= l24 then  l25 = l24 else  local l26 = CL["STRING="](l23, l("COLLECTING")); single_value();  local l27 = n if n ~= l26 then  l27 = l26 else  local l28 = CL["STRING="](l23, l("APPEND")); single_value();  local l29 = n if n ~= l28 then  l29 = l28 else  local l30 = CL["STRING="](l23, l("APPENDING")); single_value();  local l31 = n if n ~= l30 then  l31 = l30 else  local l32 = CL["STRING="](l23, l("NCONC")); single_value();  local l33 = n if n ~= l32 then  l33 = l32 else  l33 = CL["STRING="](l23, l("NCONCING")) end l31 = l33 end l29 = l31 end l27 = l29 end l25 = l27 end l22 = l25 else  l22 = n.bound end local l20 = n if n ~= l22 then  single_value();  single_value();  local l34 = n.bound; single_value();  l19 = l34 i( l19 );
 single_value();  single_value();  local l35 = CL["LIST"]; single_value();  l18 = l35 i( l18 );
 single_value();  local l37 = CL["CADDR"](l17); single_value();  local l38 = n if n ~= l37 then  l38 = l37 else  local l39 = CL["GENSYM"]("LAST-"); single_value();  single_value();  local l40 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound, CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l9, CL["CONS"](n, n)), CL["CONS"](CL["CONS"](l39, CL["CONS"](n, n)), n)), CL["CONS"](CL["CONS"](CL["DECLARE"], CL["CONS"](CL["CONS"](CL["TYPE"], CL["CONS"](CL["LIST"], CL["CONS"](l9, CL["CONS"](l39, n)))), n)), CL["CONS"](LCL["LOOP"]["*MAGIC-COOKIE*"].bound, n)))), }); single_value();  LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound = l40 i( LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound );
 local l41 = n if n ~= CL["NULL"](l17) then  single_value();  single_value();  single_value();  single_value();  local l43 = CL["LIST"](l(l9,CL["LIST"],l39)); single_value();  l17 = l43 local l42 = CL["CONS"](l17, LCL["LOOP"]["*ACCUMULATION-VARIABLES*"].bound); single_value();  LCL["LOOP"]["*ACCUMULATION-VARIABLES*"].bound = l42 l41 = LCL["LOOP"]["*ACCUMULATION-VARIABLES*"].bound else  single_value();  l41 = CL["FUNCALL"](CL["CDDR"].setfbound, l(CL["LIST"](l(l39)),l17)) end i( l41 );
 single_value();  l38 = l39 end local l36 = l38; local l46 = l1; single_value();  local l47 = n if n ~= CL["SYMBOLP"](l46) then  local l48 = CL["SYMBOL-NAME"](l46); single_value();  local l49 = CL["STRING="](l48, l("COLLECT")); single_value();  local l50 = n if n ~= l49 then  l50 = l49 else  l50 = CL["STRING="](l48, l("COLLECTING")) end l47 = l50 else  l47 = n.bound end local l45 = n if n ~= l47 then  single_value();  l45 = CL["CONS"](CL["LIST"], CL["CONS"](l5, n)) else  local l52 = l1; single_value();  local l53 = n if n ~= CL["SYMBOLP"](l52) then  local l54 = CL["SYMBOL-NAME"](l52); single_value();  local l55 = CL["STRING="](l54, l("APPEND")); single_value();  local l56 = n if n ~= l55 then  l56 = l55 else  l56 = CL["STRING="](l54, l("APPENDING")) end l53 = l56 else  l53 = n.bound end local l51 = n if n ~= l53 then  single_value();  l51 = CL["CONS"](CL["COPY-LIST"], CL["CONS"](l5, n)) else  local l58 = l1; single_value();  local l59 = n if n ~= CL["SYMBOLP"](l58) then  local l60 = CL["SYMBOL-NAME"](l58); single_value();  local l61 = CL["STRING="](l60, l("NCONC")); single_value();  local l62 = n if n ~= l61 then  l62 = l61 else  l62 = CL["STRING="](l60, l("NCONCING")) end l59 = l62 else  l59 = n.bound end local l57 = n if n ~= l59 then  single_value();  l57 = l5 else  local l63 = n if n ~= CL["T"].bound then  single_value();  l63 = CL["ERROR"]("Bug in loop?", l()) else  l63 = n.bound end l57 = l63 end l51 = l57 end l45 = l51 end local l44 = l45; single_value();  single_value();  single_value();  local l64 = CL["NCONC"](l(LCL["LOOP"]["*BODY-FORMS*"].bound,CL["CONS"](CL["CONS"](CL["COND"], CL["CONS"](CL["CONS"](CL["CONS"](CL["NULL"], CL["CONS"](l9, n)), CL["CONS"](CL["CONS"](CL["SETF"], CL["CONS"](l9, CL["CONS"](l44, n))), CL["CONS"](CL["CONS"](CL["SETF"], CL["CONS"](l36, CL["CONS"](CL["CONS"](CL["LAST"], CL["CONS"](l9, n)), n))), n))), CL["CONS"](CL["CONS"](CL["T"], CL["CONS"](CL["CONS"](CL["NCONC"], CL["CONS"](l36, CL["CONS"](l44, n))), CL["CONS"](CL["CONS"](CL["SETF"], CL["CONS"](l36, CL["CONS"](CL["CONS"](CL["LAST"], CL["CONS"](l36, n)), n))), n))), n))), n))); single_value();  LCL["LOOP"]["*BODY-FORMS*"].bound = l64 l20 = LCL["LOOP"]["*BODY-FORMS*"].bound else  local l66 = l1; single_value();  local l67 = n if n ~= CL["SYMBOLP"](l66) then  local l68 = CL["SYMBOL-NAME"](l66); single_value();  local l69 = CL["STRING="](l68, l("COUNT")); single_value();  local l70 = n if n ~= l69 then  l70 = l69 else  l70 = CL["STRING="](l68, l("COUNTING")) end l67 = l70 else  l67 = n.bound end local l65 = n if n ~= l67 then  single_value();  single_value();  local l71 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-TYPE-SPEC"].fbound, {CL["UNSIGNED-BYTE"], }); single_value();  l18 = l71 i( l18 );
 single_value();  single_value();  local l72 = 0; single_value();  l19 = l72 i( l19 );
 single_value();  single_value();  single_value();  local l73 = CL["NCONC"](l(LCL["LOOP"]["*BODY-FORMS*"].bound,CL["CONS"](CL["CONS"](CL["WHEN"], CL["CONS"](l5, CL["CONS"](CL["CONS"](CL["INCF"], CL["CONS"](l9, n)), n))), n))); single_value();  LCL["LOOP"]["*BODY-FORMS*"].bound = l73 l65 = LCL["LOOP"]["*BODY-FORMS*"].bound else  local l75 = l1; single_value();  local l76 = n if n ~= CL["SYMBOLP"](l75) then  local l77 = CL["SYMBOL-NAME"](l75); single_value();  local l78 = CL["STRING="](l77, l("SUM")); single_value();  local l79 = n if n ~= l78 then  l79 = l78 else  l79 = CL["STRING="](l77, l("SUMMING")) end l76 = l79 else  l76 = n.bound end local l74 = n if n ~= l76 then  single_value();  single_value();  local l80 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-TYPE-SPEC"].fbound, {CL["NUMBER"], }); single_value();  l18 = l80 i( l18 );
 single_value();  single_value();  local l81 = 0; single_value();  l19 = l81 i( l19 );
 single_value();  single_value();  single_value();  local l82 = CL["NCONC"](l(LCL["LOOP"]["*BODY-FORMS*"].bound,CL["CONS"](CL["CONS"](CL["INCF"], CL["CONS"](l9, CL["CONS"](l5, n))), n))); single_value();  LCL["LOOP"]["*BODY-FORMS*"].bound = l82 l74 = LCL["LOOP"]["*BODY-FORMS*"].bound else  local l84 = l1; single_value();  local l85 = n if n ~= CL["SYMBOLP"](l84) then  local l86 = CL["SYMBOL-NAME"](l84); single_value();  local l87 = CL["STRING="](l86, l("MAXIMIZE")); single_value();  local l88 = n if n ~= l87 then  l88 = l87 else  l88 = CL["STRING="](l86, l("MAXIMIZING")) end l85 = l88 else  l85 = n.bound end local l83 = n if n ~= l85 then  single_value();  single_value();  local l89 = CL["CONS"](CL["OR"], CL["CONS"](CL["NULL"], CL["CONS"](CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-TYPE-SPEC"].fbound, {CL["NUMBER"], }), n))); single_value();  l18 = l89 i( l18 );
 single_value();  single_value();  local l90 = n.bound; single_value();  l19 = l90 i( l19 );
 single_value();  single_value();  single_value();  local l92 = CL["GENSYM"]("MAX-TEMP-"); single_value();  local l91 = CL["NCONC"](l(LCL["LOOP"]["*BODY-FORMS*"].bound,CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l92, CL["CONS"](l5, n)), n), CL["CONS"](CL["CONS"](CL["WHEN"], CL["CONS"](CL["CONS"](CL["OR"], CL["CONS"](CL["CONS"](CL["NULL"], CL["CONS"](l9, n)), CL["CONS"](CL["CONS"](CL[">"], CL["CONS"](l92, CL["CONS"](l9, n))), n))), CL["CONS"](CL["CONS"](CL["SETF"], CL["CONS"](l9, CL["CONS"](l92, n))), n))), n))), n))); single_value();  LCL["LOOP"]["*BODY-FORMS*"].bound = l91 l83 = LCL["LOOP"]["*BODY-FORMS*"].bound else  local l94 = l1; single_value();  local l95 = n if n ~= CL["SYMBOLP"](l94) then  local l96 = CL["SYMBOL-NAME"](l94); single_value();  local l97 = CL["STRING="](l96, l("MINIMIZE")); single_value();  local l98 = n if n ~= l97 then  l98 = l97 else  l98 = CL["STRING="](l96, l("MINIMIZING")) end l95 = l98 else  l95 = n.bound end local l93 = n if n ~= l95 then  single_value();  single_value();  local l99 = CL["CONS"](CL["OR"], CL["CONS"](CL["NULL"], CL["CONS"](CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["PARSE-TYPE-SPEC"].fbound, {CL["NUMBER"], }), n))); single_value();  l18 = l99 i( l18 );
 single_value();  single_value();  local l100 = n.bound; single_value();  l19 = l100 i( l19 );
 single_value();  single_value();  single_value();  local l102 = CL["GENSYM"]("MIN-TEMP-"); single_value();  local l101 = CL["NCONC"](l(LCL["LOOP"]["*BODY-FORMS*"].bound,CL["CONS"](CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l102, CL["CONS"](l5, n)), n), CL["CONS"](CL["CONS"](CL["WHEN"], CL["CONS"](CL["CONS"](CL["OR"], CL["CONS"](CL["CONS"](CL["NULL"], CL["CONS"](l9, n)), CL["CONS"](CL["CONS"](CL["<"], CL["CONS"](l102, CL["CONS"](l9, n))), n))), CL["CONS"](CL["CONS"](CL["SETF"], CL["CONS"](l9, CL["CONS"](l102, n))), n))), n))), n))); single_value();  LCL["LOOP"]["*BODY-FORMS*"].bound = l101 l93 = LCL["LOOP"]["*BODY-FORMS*"].bound else  local l103 = n if n ~= CL["T"].bound then  single_value();  l103 = CL["ERROR"]("Invalid accumulation clause: ~S", l(l1)) else  l103 = n.bound end l93 = l103 end l83 = l93 end l74 = l83 end l65 = l74 end l20 = l65 end i( l20 );
 single_value();  local l104 = n if n ~= l17 then  single_value();  local l105 = n if n ~= CL["EQUAL"](l18, CL["CADR"](l17)) then  l105 = n.bound else  single_value();  l105 = CL["ERROR"]("Attempt to use ~S for both types ~S and ~S.", l(l9,l18,CL["CADR"](l17))) end l104 = l105 else  local l106 = n if n ~= CL["T"].bound then  single_value();  single_value();  local l107 = CL["CONS"](CL["LIST"](l(l9,l18)), LCL["LOOP"]["*ACCUMULATION-VARIABLES*"].bound); single_value();  LCL["LOOP"]["*ACCUMULATION-VARIABLES*"].bound = l107 i( LCL["LOOP"]["*ACCUMULATION-VARIABLES*"].bound );
 single_value();  single_value();  single_value();  local l108 = CL_LIB["FUNCALL-LUA"]( LCL["LOOP"]["SPLICE-IN-SUBFORM"].fbound, {LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound, CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l9, CL["CONS"](l19, n)), n), CL["CONS"](CL["CONS"](CL["DECLARE"], CL["CONS"](CL["CONS"](CL["TYPE"], CL["CONS"](l18, CL["CONS"](l9, n))), n)), CL["CONS"](LCL["LOOP"]["*MAGIC-COOKIE*"].bound, n)))), }); single_value();  LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound = l108 l106 = LCL["LOOP"]["*OUTSIDE-BINDINGS*"].bound else  l106 = n.bound end l104 = l106 end return l104 end, 0, 0, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); local l1 = ""; single_value();  tmp = CL_LIB.DEF(CL_LIB["*FORMAT-CONTROL-STRING*"],l1); local l1 = CL["MAKE-ARRAY"](128, k(CL_LIB["ELEMENT-TYPE"], CL["BASE-CHAR"])); single_value();  tmp = CL_LIB.DEF(CL_LIB["*FORMAT-CHAR-TABLE*"],l1); local l1 = 0; single_value();  tmp = CL_LIB.DEF(CL_LIB["*FORMAT-INDEX*"],l1); local l1 = 0; single_value();  tmp = CL_LIB.DEF(CL_LIB["*FORMAT-LENGTH*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL_LIB["*FORMAT-ARGUMENTS*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL_LIB["*FORMAT-STREAM-STACK*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL_LIB["*FORMAT-PPRINT*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL_LIB["*FORMAT-COLON-REST*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL_LIB["*FORMAT-TOP-LEVEL*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-ERROR"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["COMPLAINT"],{CL["&REST"],{CL_LIB["ARGS"],n}}},function (l1, l2,  ...)   single_value();  return error({tag=CL["IDENTITY"](CL_LIB["FORMAT-ERROR"]),(function () single_value() return unpack_mv(CL["LIST"](l(CL["LIST"](l("~1{~:}~%~S~%~V@T^",l1,l2,CL_LIB["*FORMAT-CONTROL-STRING*"].bound,CL["1+"](CL_LIB["*FORMAT-INDEX*"].bound)))))) end)()}) end, 1, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-NO-FLAGS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["COLON"],{CL_LIB["ATSIGN"],n}},function (l1, l2,  ...)   single_value();  local l4 = n if n ~= l1 then  l4 = l2 else  l4 = n.bound end local l3 = n if n ~= l4 then  single_value();  l3 = CL_LIB["FORMAT-ERROR"]("Flags not allowed", l()) else  local l5 = n if n ~= l1 then  single_value();  l5 = CL_LIB["FORMAT-ERROR"](": flag not allowed", l()) else  local l6 = n if n ~= l2 then  single_value();  l6 = CL_LIB["FORMAT-ERROR"]("@ flag not allowed", l()) else  l6 = n.bound end l5 = l6 end l3 = l5 end return l3 end, 2, 0, false, false)); i( CL_LIB["FUNCTION-SETQ"](CL_LIB["REQUIRE-TYPE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["EL"],{CL["TYPE"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["TYPEP"](l1, l2, false) then  l3 = l1 else  l3 = CL["ERROR"]("require-type", l()) end return l3 end, 2, 0, false, false)) );
 i( CL_LIB["MACRO-SETQ"](CL_LIB["WHILE"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G228241"],{CL["&OPTIONAL"],{LCL["NIL"]["G228242"],n}}},function (l4, l5,  ...)  if not l5 then  l5 = n.bound end  single_value();  local l6 = (l4)[2]; single_value();  local l7 = (l4)[2]; single_value();  local l9 = l7; single_value();  local l10 = (l9)[1]; single_value();  single_value();  local l11 = (l9)[2]; single_value();  l7 = l11 i( l7 );
 single_value();  local l8 = l10; single_value();  local l12 = l7; single_value();  single_value();  return CL["CONS"](CL["LOOP"], CL["CONS"](CL_LIB["WHILE"], CL["CONS"](l8, CL["CONS"](CL["DO"], CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(l12,n))), n))))) end, 1, 1, false, false)) );
 i( CL_LIB["MACRO-SETQ"](CL_LIB["UNTIL"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G228298"],{CL["&OPTIONAL"],{LCL["NIL"]["G228299"],n}}},function (l13, l14,  ...)  if not l14 then  l14 = n.bound end  single_value();  local l15 = (l13)[2]; single_value();  local l16 = (l13)[2]; single_value();  local l18 = l16; single_value();  local l19 = (l18)[1]; single_value();  single_value();  local l20 = (l18)[2]; single_value();  l16 = l20 i( l16 );
 single_value();  local l17 = l19; single_value();  local l21 = l16; single_value();  single_value();  return CL["CONS"](CL["LOOP"], CL["CONS"](CL_LIB["UNTIL"], CL["CONS"](l17, CL["CONS"](CL["DO"], CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(l21,n))), n))))) end, 1, 1, false, false)) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["COLUMN"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l22,  ...)   single_value();  return CL_LIB["STREAM-COLUMN"](l22) end, 1, 0, false, false)) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["%PR-INTEGER"] , CL_LIB["ALLOC-FUNCTION"]({CL["NUMBER"],{CL_LIB["RADIX"],{CL["STREAM"],n}}},function (l23, l24, l25,  ...)   single_value();  return CL_LIB["%PRINT-INT-RADIX"](l23, l25, l24) end, 3, 0, false, false)) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["%STR-MEMBER"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL["STRING"],{CL["&OPTIONAL"],{CL_LIB["START"],{CL_LIB["END"],n}}}}},function (l26, l27, l28, l29,  ...)  if not l28 then  l28 = n.bound end if not l29 then  l29 = n.bound end  single_value();  local l30 = CL["TYPEP"](l27, CL_LIB["SIMPLE-BASE-STRING"], false); single_value();  l27 = CL["STRING"](l27) i( l27 );
 single_value();  local l32 = l28; single_value();  local l33 = n if n ~= l32 then  l33 = l32 else  l33 = 0 end local l31 = l33; single_value();  local l35 = l29; single_value();  local l36 = n if n ~= l35 then  l36 = l35 else  l36 = CL["LENGTH"](l27) end local l34 = l36; single_value();  single_value();  local l37 = CL["GENSYM"](false); single_value();  local l38 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  local l39 = n if n ~= CL["EQ"](l31, l34) then  single_value(); do break end; l39 = n.bound else  l39 = n.bound end i( l39 );
 i( n.bound );
 local l40 = n if n ~= CL["EQ"](CL["CHAR"](l27, l31), l26) then  local l41 = CL["FUNCALL"](l, l(unpack_mv(l31))); single_value();  l40 = error({tag=CL["IDENTITY"](l37),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l41)) end)()}) else  l40 = n.bound end i( l40 );
 single_value();  single_value();  local l42 = CL["1+"](l31); single_value();  l31 = l42 i( l31 );
 single_value();  single_value();  single_value();  local l43 = n.bound; single_value();  l34 = l43 local tmpres = l34 end return n end, 0, 0, false, false))); single_value(); if l38.error ~= n and (l38.error ~= KEYWORD.TAG or l38.tag ~= l37) then if l38.error == KEYWORD.TAG then  error(l38) else error(l38[1]) end end return CL["VALUES-LIST"](list_r(l38)) end, 2, 2, false, false)) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["MEMQ"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["ITEM"],{CL["LIST"],n}},function (l44, l45,  ...)   single_value();  local l46 = l45; single_value();  single_value();  local l47 = CL["GENSYM"](false); single_value();  local l48 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  local l49 = n if n ~= CL["NULL"](l46) then  single_value(); do break end; l49 = n.bound else  l49 = n.bound end i( l49 );
 local l50 = n if n ~= CL["EQ"](l44, (l46)[1]) then  local l51 = CL["FUNCALL"](l, l(unpack_mv(l46))); single_value();  l50 = error({tag=CL["IDENTITY"](l47),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l51)) end)()}) else  l50 = n.bound end i( l50 );
 single_value();  single_value();  single_value();  local l52 = (l46)[2]; single_value();  l46 = l52 local tmpres = l46 end return n end, 0, 0, false, false))); single_value(); if l48.error ~= n and (l48.error ~= KEYWORD.TAG or l48.tag ~= l47) then if l48.error == KEYWORD.TAG then  error(l48) else error(l48[1]) end end return CL["VALUES-LIST"](list_r(l48)) end, 2, 0, false, false)) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["STREAM-WRITE-ENTIRE-STRING"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["STRING"],n}},function (l53, l54,  ...)   single_value();  return CL["WRITE-STRING"](l54, l53, k()) end, 2, 0, false, false)) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["NTHCDR-NO-OVERFLOW"] , CL_LIB["ALLOC-FUNCTION"]({CL["COUNT"],{CL["LIST"],n}},function (l55, l56,  ...)   single_value();  local l58 = CL[">"](l(l55,CL["LIST-LENGTH"](l56))); single_value();  local l59 = n if n ~= l58 then  l59 = l58 else  l59 = CL_LIB["%<"](l55, 0) end local l57 = n if n ~= l59 then  l57 = CL_LIB["FORMAT-ERROR"]("non-existent target for ~~*", l()) else  l57 = CL["NTHCDR"](l55, l56) end return l57 end, 2, 0, false, false)) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["%PARSE-NUMBER-TOKEN"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL_LIB["START"],{CL_LIB["I"],n}}},function (l60, l61, l62,  ...)   single_value();  return CL["READ-FROM-STRING"](l60, CL["T"].bound, n.bound, k(CL_LIB["START"], l61, CL_LIB["END"], l62)) end, 3, 0, false, false)) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["XP-STRUCTURE-P"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STRUCT"],n},function (l63,  ...)   single_value();  return n.bound end, 1, 0, false, false)) );
 i( CL_LIB["MACRO-SETQ"](CL_LIB["FORMAT-INDIRECT-ERROR"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G228558"],{CL["&OPTIONAL"],{LCL["NIL"]["G228559"],n}}},function (l64, l65,  ...)  if not l65 then  l65 = n.bound end  single_value();  local l66 = (l64)[2]; single_value();  local l67 = (l64)[2]; single_value();  local l69 = l67; single_value();  local l70 = (l69)[1]; single_value();  single_value();  local l71 = (l69)[2]; single_value();  l67 = l71 i( l67 );
 single_value();  local l68 = l70; single_value();  single_value();  return CL["CONS"](CL["THROW"], CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL_LIB["FORMAT-ERROR"], n)), CL["CONS"](CL["CONS"](CL["CONS"], CL["CONS"](CL["CONS"](CL["LIST"], CL["CONS"]("While processing indirect control string~%~S~%~V@T^", CL["CONS"](CL_LIB["*FORMAT-CONTROL-STRING*"], CL["CONS"](CL["CONS"](CL["1+"], CL["CONS"](CL_LIB["*FORMAT-INDEX*"], n)), n)))), CL["CONS"](l68, n))), n))) end, 1, 1, false, false)) );
 i( CL_LIB["MACRO-SETQ"](CL_LIB["GET-A-FORMAT-STRING-STREAM"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G228619"],{CL["&OPTIONAL"],{LCL["NIL"]["G228620"],n}}},function (l72, l73,  ...)  if not l73 then  l73 = n.bound end  single_value();  local l74 = (l72)[2]; single_value();  local l75 = (l72)[2]; single_value();  single_value();  return {CL["MAKE-STRING-OUTPUT-STREAM"],{LCL["KEYWORD"]["ELEMENT-TYPE"],{{CL["QUOTE"],{CL["BASE-CHAR"],n}},n}}} end, 1, 1, false, false)) );
 i( CL_LIB["MACRO-SETQ"](CL_LIB["WITH-FORMAT-STRING-OUTPUT"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G228645"],{CL["&OPTIONAL"],{LCL["NIL"]["G228646"],n}}},function (l76, l77,  ...)  if not l77 then  l77 = n.bound end  single_value();  local l78 = (l76)[2]; single_value();  local l79 = (l76)[2]; single_value();  local l81 = l79; single_value();  local l82 = (l81)[1]; single_value();  single_value();  local l83 = (l81)[2]; single_value();  l79 = l83 i( l79 );
 single_value();  local l80 = l82; single_value();  local l84 = l79; single_value();  single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["CONS"](CL["CONS"](l80, CL["CONS"](n, n)), n), CL["CONS"](CL["CONS"](CL["UNWIND-PROTECT"], CL["CONS"](CL["CONS"](CL["PROGN"], CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](l80, CL["CONS"](CL["CONS"](CL_LIB["GET-A-FORMAT-STRING-STREAM"], n), n))), CL["APPEND"](l(l84,CL["CONS"](CL["CONS"](CL["GET-OUTPUT-STREAM-STRING"], CL["CONS"](l80, n)), n))))), CL["CONS"](CL["CONS"](CL["WHEN"], CL["CONS"](CL["CONS"](CL["AND"], CL["CONS"](l80, CL["CONS"](CL["CONS"](CL["TYPEP"], CL["CONS"](l80, CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](CL["FILE-STREAM"], n)), n))), n))), CL["CONS"](CL["CONS"](CL["FILE-POSITION"], CL["CONS"](l80, CL["CONS"](0, n))), n))), n))), n))) end, 1, 1, false, false)) );
 i( CL_LIB["MACRO-SETQ"](CL_LIB["WITH-FORMAT-PARAMETERS"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G228728"],{CL["&OPTIONAL"],{CL_LIB["ENV"],n}}},function (l85, l86,  ...)  if not l86 then  l86 = n.bound end  single_value();  local l87 = (l85)[2]; single_value();  local l88 = (l85)[2]; single_value();  local l90 = l88; single_value();  local l91 = (l90)[1]; single_value();  single_value();  local l92 = (l90)[2]; single_value();  l88 = l92 i( l88 );
 single_value();  local l89 = l91; single_value();  local l94 = l88; single_value();  local l95 = (l94)[1]; single_value();  single_value();  local l96 = (l94)[2]; single_value();  l88 = l96 i( l88 );
 single_value();  local l93 = l95; single_value();  local l97 = l88; single_value();  single_value();  local l98 = l93; local l99 = n.bound; single_value();  local l100 = CL["GENSYM"](false); single_value();  local l101 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l102 = n if n ~= CL["NULL"](l98) then  single_value(); do break end; l102 = n.bound else  l102 = n.bound end i( l102 );
 single_value();  local l103 = (l98)[2]; local l104 = CL["CONS"](CL["CONS"](CL["CAAR"](l98), CL["CONS"](CL["CONS"](CL["OR"], CL["CONS"](CL["CONS"](CL["IF"], CL["CONS"](l89, CL["CONS"](CL["CONS"](CL["POP"], CL["CONS"](l89, n)), n))), CL["CONS"](CL["CADAR"](l98), n))), n)), l99); single_value();  single_value();  local l105 = l104; single_value();  l99 = l105 i( l99 );
 single_value();  single_value();  single_value();  local l106 = l103; single_value();  l98 = l106 local tmpres = l98 end i( n );
 single_value();  local l107 = n.bound; local l108 = n.bound; local l109 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l110 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l112 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l111 = l112; single_value();  single_value();  l107,l108= unpack_mv(CL["VALUES"](l(l97,n.bound)), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l109 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l110.error ~= n and true then if l110.error == KEYWORD.TAG then  error(l110) else error(l110[1]) end end i( CL["VALUES-LIST"](list_r(l110)) );
 single_value();  return CL["CONS"](CL["LET"], CL["CONS"](CL["NREVERSE"](l99), CL["APPEND"](l(l108,CL["CONS"](CL["CONS"](CL["WHEN"], CL["CONS"](l89, CL["CONS"](CL["CONS"](CL_LIB["FORMAT-ERROR"], CL["CONS"]("Too many parameters", n)), n))), CL["APPEND"](l(l107,n))))))) end, 0, 0, false, false))); single_value(); if l101.error ~= n and (l101.error ~= KEYWORD.TAG or l101.tag ~= l100) then if l101.error == KEYWORD.TAG then  error(l101) else error(l101[1]) end end return CL["VALUES-LIST"](list_r(l101)) end, 1, 1, false, false)) );
 single_value();  tmp = CL_LIB["MACRO-SETQ"](CL_LIB["FORMAT-FIND-CHAR"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G228908"],{CL["&OPTIONAL"],{LCL["NIL"]["G228909"],n}}},function (l113, l114,  ...)  if not l114 then  l114 = n.bound end  single_value();  local l115 = (l113)[2]; single_value();  local l116 = (l113)[2]; single_value();  local l118 = l116; single_value();  local l119 = (l118)[1]; single_value();  single_value();  local l120 = (l118)[2]; single_value();  l116 = l120 i( l116 );
 single_value();  local l117 = l119; single_value();  local l122 = l116; single_value();  local l123 = (l122)[1]; single_value();  single_value();  local l124 = (l122)[2]; single_value();  l116 = l124 i( l116 );
 single_value();  local l121 = l123; single_value();  local l126 = l116; single_value();  local l127 = (l126)[1]; single_value();  single_value();  local l128 = (l126)[2]; single_value();  l116 = l128 i( l116 );
 single_value();  local l125 = l127; single_value();  single_value();  return CL["CONS"](CL_LIB["%STR-MEMBER"], CL["CONS"](l117, CL["CONS"](CL_LIB["*FORMAT-CONTROL-STRING*"], CL["CONS"](l121, CL["CONS"](l125, n))))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-NEXTCHAR"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l1 = (1 + CL_LIB["*FORMAT-INDEX*"].bound); single_value();  CL_LIB["*FORMAT-INDEX*"].bound = l1 local l2 = n if n ~= CL_LIB["%<"](CL_LIB["*FORMAT-INDEX*"].bound, CL_LIB["*FORMAT-LENGTH*"].bound) then  l2 = CL["SCHAR"](CL_LIB["*FORMAT-CONTROL-STRING*"].bound, l1) else  l2 = CL_LIB["FORMAT-ERROR"]("Syntax error", l()) end return l2 end, 0, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["FORMAT-PEEK"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G229016"],{CL["&OPTIONAL"],{LCL["NIL"]["G229017"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  single_value();  return CL["CONS"](CL["SCHAR"], CL["CONS"](CL_LIB["*FORMAT-CONTROL-STRING*"], CL["CONS"](CL_LIB["*FORMAT-INDEX*"], n))) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-GET-PARAMETER"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["CH"],n},function (l1,  ...)   single_value();  local l2 = l1; single_value();  local l3 = n if n ~= CL["EQL"](l2, LCL['CL-LIB']['MAKE-CHAR']("#")) then  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  local l5 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound; single_value();  local l6 = n if n ~= l5 then  l6 = l5 else  l6 = 0 end local l4 = l6; local l7 = CL["LENGTH"](CL_LIB["*FORMAT-ARGUMENTS*"].bound); i( n.bound );
 single_value();  local l8 = n if n ~= CL["EQL"](l4, 0) then  l8 = l7 else  l8 = CL["CONS"](CL["THE"], CL["CONS"](CL["CONS"](CL["INTEGER"], CL["CONS"]((l7 - l4), CL["CONS"](l7, n))), CL["CONS"](CL["CONS"](CL["LENGTH"], CL["CONS"](CL_LIB["*FORMAT-ARGUMENTS*"], n)), n))) end l3 = l8 else  local l9 = n if n ~= CL["MEMBER"](l2, {LCL['CL-LIB']['MAKE-CHAR']("V"),{LCL['CL-LIB']['MAKE-CHAR']("v"),n}}, k()) then  single_value();  local l10 = CL_LIB["POP-FORMAT-ARG"](); i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  l9 = l10 else  local l11 = n if n ~= CL["EQL"](l2, LCL['CL-LIB']['MAKE-CHAR']("'")) then  single_value();  local l12 = CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}); i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  l11 = l12 else  local l13 = n if n ~= CL["T"].bound then  single_value();  local l15 = CL["EQ"](l1, LCL['CL-LIB']['MAKE-CHAR']("-")); single_value();  local l16 = n if n ~= l15 then  l16 = l15 else  local l17 = CL["EQ"](l1, LCL['CL-LIB']['MAKE-CHAR']("+")); single_value();  local l18 = n if n ~= l17 then  l18 = l17 else  l18 = CL["DIGIT-CHAR-P"](l1, false) end l16 = l18 end local l14 = n if n ~= l16 then  single_value();  local l19 = CL["EQ"](l1, LCL['CL-LIB']['MAKE-CHAR']("-")); l1 = CL["DIGIT-CHAR-P"](l1, false) local l20 = n if n ~= l1 then  l20 = n.bound else  single_value();  l1 = CL["DIGIT-CHAR-P"](CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}), false) local l21 = n if n ~= l1 then  l21 = n.bound else  single_value();  l21 = CL_LIB["FORMAT-ERROR"]("Illegal parameter", l()) end l20 = l21 end i( l20 );
 single_value();  local l22 = l1; single_value();  local l23 = CL["GENSYM"](false); single_value();  local l24 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  l1 = CL["DIGIT-CHAR-P"](CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}), false) local l25 = n if n ~= CL["NOT"](l1) then  single_value(); do break end; l25 = n.bound else  l25 = n.bound end i( l25 );
 single_value();  local l26 = (l1 + (l22 * 10)); single_value();  single_value();  single_value();  local l27 = l26; single_value();  l22 = l27 local tmpres = l22 end i( n );
 single_value();  local l28 = n if n ~= l19 then  l28 = - l22 else  l28 = l22 end return l28 end, 0, 0, false, false))); single_value(); if l24.error ~= n and (l24.error ~= KEYWORD.TAG or l24.tag ~= l23) then if l24.error == KEYWORD.TAG then  error(l24) else error(l24[1]) end end l14 = CL["VALUES-LIST"](list_r(l24)) else  local l29 = n if n ~= CL["T"].bound then  single_value();  l29 = n.bound else  l29 = n.bound end l14 = l29 end l13 = l14 else  l13 = n.bound end l11 = l13 end l9 = l11 end l3 = l9 end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-SKIP-PARAMETER"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["CH"],n},function (l1,  ...)   i( "Might someday want to add proper format error checking for negative \n      parameters" );
 single_value();  single_value();  local l2 = l1; single_value();  local l3 = n if n ~= CL["MEMBER"](l2, {LCL['CL-LIB']['MAKE-CHAR']("V"),{LCL['CL-LIB']['MAKE-CHAR']("v"),{LCL['CL-LIB']['MAKE-CHAR']("#"),n}}}, k()) then  single_value();  l3 = CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) else  local l4 = n if n ~= CL["EQL"](l2, LCL['CL-LIB']['MAKE-CHAR']("'")) then  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  l4 = CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) else  local l5 = n if n ~= CL["EQL"](l2, LCL['CL-LIB']['MAKE-CHAR'](",")) then  single_value();  l5 = n.bound else  local l6 = n if n ~= CL["T"].bound then  local l8 = CL["EQ"](l1, LCL['CL-LIB']['MAKE-CHAR']("-")); single_value();  local l9 = n if n ~= l8 then  l9 = l8 else  l9 = CL["EQ"](l1, LCL['CL-LIB']['MAKE-CHAR']("+")) end local l7 = n if n ~= l9 then  single_value();  l7 = CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) else  l7 = n.bound end i( l7 );
 single_value();  local l10 = CL["GENSYM"](false); single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  local l12 = CL["LIST"](l(n.bound)); single_value();  local l13 = CL["LIST"](l(n.bound)); single_value();  local l14 = l12; single_value();  local l15 = l12; single_value();  local l16 = l12; single_value();  single_value();  local l17 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l18; local l19; local l20;l18 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( l19[1], {}) end, 0, 0, false, false)};l19 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  i( n.bound );
 single_value();  local l21 = n if n ~= CL["DIGIT-CHAR-P"](CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}), false) then  l21 = n.bound else  single_value();  l21 = error({tag=CL["IDENTITY"](l16),(function () single_value() return unpack_mv(l20[1]) end)()}) end i( l21 );
 i( error({tag=CL["IDENTITY"](l15),(function () single_value() return unpack_mv(l19[1]) end)()}) );
 single_value();  return CL_LIB["FUNCALL-LUA"]( l20[1], {}) end, 0, 0, false, false)};l20 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l22 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  i( error({tag=CL["IDENTITY"](l10),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l22)) end)()}) );
 single_value();  return error({tag=CL["IDENTITY"](l13),(function () single_value() return unpack_mv(n) end)()}) end, 0, 0, false, false)}; single_value();  local l23 = l18[1]; single_value();  while true do  single_value();  local l24 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB['FUNCALL-LUA'](l23,{}) end, 0, 0, false, false))); single_value(); if l24.error ~= n and (l24.error ~= KEYWORD.TAG or l24.tag ~= l12) then if l24.error == KEYWORD.TAG then  error(l24) else error(l24[1]) end end l23 = CL["VALUES-LIST"](list_r(l24)) local tmpres = l23 end return n end, 0, 0, false, false))); single_value(); if l17.error ~= n and (l17.error ~= KEYWORD.TAG or l17.tag ~= l13) then if l17.error == KEYWORD.TAG then  error(l17) else error(l17[1]) end end return CL["VALUES-LIST"](list_r(l17)) end, 0, 0, false, false))); single_value(); if l11.error ~= n and (l11.error ~= KEYWORD.TAG or l11.tag ~= l10) then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end l6 = CL["VALUES-LIST"](list_r(l11)) else  l6 = n.bound end l5 = l6 end l4 = l5 end l3 = l4 end return l3 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-NO-SEMI"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL["&OPTIONAL"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],n}}}},function (l1, l2, l3,  ...)  if not l2 then  l2 = n.bound end if not l3 then  l3 = n.bound end  local l4 = n if n ~= CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"].bound then  single_value();  l4 = CL_LIB["FORMAT-ERROR"]("~~~:[~;:~]~:[~;@~]~c illegal in this context", l(l2,l3,l1)) else  l4 = n.bound end i( l4 );
 single_value();  CL_LIB["*FORMAT-PPRINT*"].bound = CL["T"].bound return CL_LIB["*FORMAT-PPRINT*"].bound end, 1, 2, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["PARSE-FORMAT-OPERATION"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{CL_LIB["GET-PARAMS"],n}},function (l1,  ...)  if not l1 then  l1 = n.bound end  single_value();  local l2 = CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}); local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l7 = CL["DIGIT-CHAR-P"](l2, false); single_value();  local l8 = n if n ~= l7 then  l8 = l7 else  l8 = CL_LIB["MEMQ"](l2, {LCL['CL-LIB']['MAKE-CHAR']("-"),{LCL['CL-LIB']['MAKE-CHAR'](","),{LCL['CL-LIB']['MAKE-CHAR']("#"),{LCL['CL-LIB']['MAKE-CHAR']("V"),{LCL['CL-LIB']['MAKE-CHAR']("v"),{LCL['CL-LIB']['MAKE-CHAR']("'"),n}}}}}}) end local l6 = n if n ~= l8 then  single_value();  local l9 = n if n ~= l1 then  l3 = CL["LIST"](l(CL_LIB["FORMAT-GET-PARAMETER"](l2))) i( l3 );
 single_value();  local l10 = CL["GENSYM"](false); single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  local l12 = CL["LIST"](l(n.bound)); single_value();  local l13 = CL["LIST"](l(n.bound)); single_value();  local l14 = l12; single_value();  local l15 = l12; single_value();  local l16 = l12; single_value();  single_value();  local l17 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l18; local l19; local l20;l18 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( l19[1], {}) end, 0, 0, false, false)};l19 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   l2 = CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) i( l2 );
 single_value();  single_value();  single_value();  local l21 = CL["CONS"](CL_LIB["FORMAT-GET-PARAMETER"](l2), l3); single_value();  l3 = l21 i( l3 );
 single_value();  l2 = CL["SCHAR"](CL_LIB["*FORMAT-CONTROL-STRING*"].bound, CL_LIB["*FORMAT-INDEX*"].bound) local l22 = n if n ~= CL_LIB["NEQ"](l2, LCL['CL-LIB']['MAKE-CHAR'](",")) then  single_value();  l22 = error({tag=CL["IDENTITY"](l16),(function () single_value() return unpack_mv(l20[1]) end)()}) else  l22 = n.bound end i( l22 );
 i( error({tag=CL["IDENTITY"](l15),(function () single_value() return unpack_mv(l19[1]) end)()}) );
 single_value();  return CL_LIB["FUNCALL-LUA"]( l20[1], {}) end, 0, 0, false, false)};l20 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l23 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  i( error({tag=CL["IDENTITY"](l10),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l23)) end)()}) );
 single_value();  return error({tag=CL["IDENTITY"](l13),(function () single_value() return unpack_mv(n) end)()}) end, 0, 0, false, false)}; single_value();  local l24 = l18[1]; single_value();  while true do  single_value();  local l25 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB['FUNCALL-LUA'](l24,{}) end, 0, 0, false, false))); single_value(); if l25.error ~= n and (l25.error ~= KEYWORD.TAG or l25.tag ~= l12) then if l25.error == KEYWORD.TAG then  error(l25) else error(l25[1]) end end l24 = CL["VALUES-LIST"](list_r(l25)) local tmpres = l24 end return n end, 0, 0, false, false))); single_value(); if l17.error ~= n and (l17.error ~= KEYWORD.TAG or l17.tag ~= l13) then if l17.error == KEYWORD.TAG then  error(l17) else error(l17[1]) end end return CL["VALUES-LIST"](list_r(l17)) end, 0, 0, false, false))); single_value(); if l11.error ~= n and (l11.error ~= KEYWORD.TAG or l11.tag ~= l10) then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end l9 = CL["VALUES-LIST"](list_r(l11)) else  local l26 = n if n ~= CL["T"].bound then  l3 = CL["T"].bound i( l3 );
 i( CL_LIB["FORMAT-SKIP-PARAMETER"](l2) );
 single_value();  local l27 = CL["GENSYM"](false); single_value();  local l28 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  local l29 = CL["LIST"](l(n.bound)); single_value();  local l30 = CL["LIST"](l(n.bound)); single_value();  local l31 = l29; single_value();  local l32 = l29; single_value();  local l33 = l29; single_value();  single_value();  local l34 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l35; local l36; local l37;l35 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( l36[1], {}) end, 0, 0, false, false)};l36 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   l2 = CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) i( l2 );
 single_value();  i( CL_LIB["FORMAT-SKIP-PARAMETER"](l2) );
 single_value();  l2 = CL["SCHAR"](CL_LIB["*FORMAT-CONTROL-STRING*"].bound, CL_LIB["*FORMAT-INDEX*"].bound) local l38 = n if n ~= CL_LIB["NEQ"](l2, LCL['CL-LIB']['MAKE-CHAR'](",")) then  single_value();  l38 = error({tag=CL["IDENTITY"](l33),(function () single_value() return unpack_mv(l37[1]) end)()}) else  l38 = n.bound end i( l38 );
 i( error({tag=CL["IDENTITY"](l32),(function () single_value() return unpack_mv(l36[1]) end)()}) );
 single_value();  return CL_LIB["FUNCALL-LUA"]( l37[1], {}) end, 0, 0, false, false)};l37 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l39 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  i( error({tag=CL["IDENTITY"](l27),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l39)) end)()}) );
 single_value();  return error({tag=CL["IDENTITY"](l30),(function () single_value() return unpack_mv(n) end)()}) end, 0, 0, false, false)}; single_value();  local l40 = l35[1]; single_value();  while true do  single_value();  local l41 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB['FUNCALL-LUA'](l40,{}) end, 0, 0, false, false))); single_value(); if l41.error ~= n and (l41.error ~= KEYWORD.TAG or l41.tag ~= l29) then if l41.error == KEYWORD.TAG then  error(l41) else error(l41[1]) end end l40 = CL["VALUES-LIST"](list_r(l41)) local tmpres = l40 end return n end, 0, 0, false, false))); single_value(); if l34.error ~= n and (l34.error ~= KEYWORD.TAG or l34.tag ~= l30) then if l34.error == KEYWORD.TAG then  error(l34) else error(l34[1]) end end return CL["VALUES-LIST"](list_r(l34)) end, 0, 0, false, false))); single_value(); if l28.error ~= n and (l28.error ~= KEYWORD.TAG or l28.tag ~= l27) then if l28.error == KEYWORD.TAG then  error(l28) else error(l28[1]) end end l26 = CL["VALUES-LIST"](list_r(l28)) else  l26 = n.bound end l9 = l26 end l6 = l9 else  l6 = n.bound end i( l6 );
 local l42 = l2; single_value();  local l43 = n if n ~= CL["EQL"](l42, LCL['CL-LIB']['MAKE-CHAR'](":")) then  single_value();  local l44 = CL["T"].bound; single_value();  l4 = l44 i( l4 );
 single_value();  single_value();  single_value();  local l45 = CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}); single_value();  l2 = l45 i( l2 );
 single_value();  local l46 = n if n ~= CL["EQ"](l2, LCL['CL-LIB']['MAKE-CHAR']("@")) then  single_value();  single_value();  local l47 = CL["T"].bound; single_value();  l5 = l47 i( l5 );
 single_value();  single_value();  single_value();  local l48 = CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}); single_value();  l2 = l48 l46 = l2 else  l46 = n.bound end l43 = l46 else  local l49 = n if n ~= CL["EQL"](l42, LCL['CL-LIB']['MAKE-CHAR']("@")) then  single_value();  local l50 = CL["T"].bound; single_value();  l5 = l50 i( l5 );
 single_value();  single_value();  single_value();  local l51 = CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}); single_value();  l2 = l51 i( l2 );
 single_value();  local l52 = n if n ~= CL["EQ"](l2, LCL['CL-LIB']['MAKE-CHAR'](":")) then  single_value();  single_value();  local l53 = CL["T"].bound; single_value();  l4 = l53 i( l4 );
 single_value();  single_value();  single_value();  local l54 = CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}); single_value();  l2 = l54 l52 = l2 else  l52 = n.bound end l49 = l52 else  l49 = n.bound end l43 = l49 end i( l43 );
 single_value();  local l55 = n if n ~= CL["CONSP"](l3) then  l55 = CL["NREVERSE"](l3) else  l55 = l3 end return CL["VALUES"](l(l55,l4,l5,l2)) end, 0, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-FIND-COMMAND"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["COMMAND-LIST"],{CL["&OPTIONAL"],{CL_LIB["GET-PARAMS"],{CL_LIB["EVIL-COMMANDS"],n}}}},function (l1, l2, l3,  ...)  if not l2 then  l2 = n.bound end if not l3 then  l3 = n.bound end  single_value();  local l4 = CL_LIB["*FORMAT-INDEX*"].bound; single_value();  local l5 = CL_LIB["*FORMAT-LENGTH*"].bound; single_value();  local l6 = n.bound; single_value();  single_value();  local l7 = CL["GENSYM"](false); single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  l6 = CL_LIB["%STR-MEMBER"](LCL['CL-LIB']['MAKE-CHAR']("~"), CL_LIB["*FORMAT-CONTROL-STRING*"].bound, CL_LIB["*FORMAT-INDEX*"].bound, l5) i( l6 );
 local l9 = n if n ~= CL["NOT"](l6) then  l9 = CL_LIB["FORMAT-ERROR"]("Expecting one of ~S", l(l1)) else  l9 = n.bound end i( l9 );
 CL_LIB["*FORMAT-INDEX*"].bound = l6 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value();  local l10 = n.bound; local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l10,l11,l12,l13= unpack_mv(CL_LIB["PARSE-FORMAT-OPERATION"](l2), 4) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 local l18 = n if n ~= CL_LIB["MEMQ"](l13, l1) then  single_value();  local l19 = CL["FUNCALL"](l, l(unpack_mv(CL["VALUES"](l(l4,l6,l10,l11,l12,l13))))); single_value();  l18 = error({tag=CL["IDENTITY"](l7),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l19)) end)()}) else  l18 = n.bound end i( l18 );
 local l21 = n if n ~= l3 then  local l22 = CL_LIB["MEMQ"](l13, {LCL['CL-LIB']['MAKE-CHAR']("w"),{LCL['CL-LIB']['MAKE-CHAR']("_"),{LCL['CL-LIB']['MAKE-CHAR']("i"),{LCL['CL-LIB']['MAKE-CHAR']("W"),{LCL['CL-LIB']['MAKE-CHAR']("I"),n}}}}}); single_value();  local l23 = n if n ~= l22 then  l23 = l22 else  local l24 = n if n ~= l11 then  l24 = CL_LIB["MEMQ"](l13, {LCL['CL-LIB']['MAKE-CHAR']("t"),{LCL['CL-LIB']['MAKE-CHAR']("T"),n}}) else  l24 = n.bound end l23 = l24 end l21 = l23 else  l21 = n.bound end local l20 = n if n ~= l21 then  single_value();  l20 = CL_LIB["FORMAT-ERROR"]("Illegal in this context", l()) else  l20 = n.bound end i( l20 );
 single_value();  local l25 = l13; single_value();  local l26 = n if n ~= CL["EQL"](l25, LCL['CL-LIB']['MAKE-CHAR']("{")) then  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  l26 = CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR']("}"),n}, false, false) else  local l27 = n if n ~= CL["EQL"](l25, LCL['CL-LIB']['MAKE-CHAR']("(")) then  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  l27 = CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](")"),n}, false, false) else  local l28 = n if n ~= CL["EQL"](l25, LCL['CL-LIB']['MAKE-CHAR']("[")) then  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  l28 = CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR']("]"),n}, false, false) else  local l29 = n if n ~= CL["EQL"](l25, LCL['CL-LIB']['MAKE-CHAR']("<")) then  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  local l30 = n.bound; local l31 = n.bound; local l32 = n.bound; local l33 = n.bound; local l34 = n.bound; local l35 = n.bound; local l36 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l37 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l39 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l38 = l39; single_value();  single_value();  l30,l31,l32,l33,l34,l35= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](">"),n}, false, false), 6) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l36 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l37.error ~= n and true then if l37.error == KEYWORD.TAG then  error(l37) else error(l37[1]) end end i( CL["VALUES-LIST"](list_r(l37)) );
 i( n.bound );
 single_value();  local l41 = n if n ~= l3 then  l41 = l33 else  l41 = n.bound end local l40 = n if n ~= l41 then  l40 = CL_LIB["FORMAT-ERROR"]("Logical-block directive not allowed inside justification directive", l()) else  l40 = n.bound end l29 = l40 else  local l42 = n if n ~= CL["EQL"](l25, LCL['CL-LIB']['MAKE-CHAR']("~")) then  single_value();  l42 = CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) else  local l43 = n if n ~= CL["MEMBER"](l25, {LCL['CL-LIB']['MAKE-CHAR']("}"),{LCL['CL-LIB']['MAKE-CHAR'](">"),{LCL['CL-LIB']['MAKE-CHAR'](")"),{LCL['CL-LIB']['MAKE-CHAR']("]"),n}}}}, k()) then  single_value();  l43 = CL_LIB["FORMAT-ERROR"]("No matching bracket", l()) else  l43 = n.bound end l42 = l43 end l29 = l42 end l28 = l29 end l27 = l28 end l26 = l27 end local tmpres = l26 end return n end, 0, 0, false, false))); single_value(); if l8.error ~= n and (l8.error ~= KEYWORD.TAG or l8.tag ~= l7) then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end return CL["VALUES-LIST"](list_r(l8)) end, 1, 2, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-FIND-COMMAND-NO-PARAMS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["COMMAND-LIST"],{CL["&KEY"],{{CL_LIB["COLON"],{CL["T"],n}},{{CL_LIB["ATSIGN"],{CL["T"],n}},n}}}},function (l1, keys,  ...)  if not keys[CL_LIB["COLON"]] then  keys[CL_LIB["COLON"]] = CL["T"].bound end if not keys[CL_LIB["ATSIGN"]] then  keys[CL_LIB["ATSIGN"]] = CL["T"].bound end  single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = n.bound; local l8 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l9 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l11 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l10 = l11; single_value();  single_value();  l2,l3,l4,l5,l6,l7= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"](l1, false, false), 6) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l8 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l9.error ~= n and true then if l9.error == KEYWORD.TAG then  error(l9) else error(l9[1]) end end i( CL["VALUES-LIST"](list_r(l9)) );
 local l12 = n if n ~= l4 then  single_value();  l12 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l12 = n.bound end i( l12 );
 single_value();  local l13 = n if n ~= CL["NOT"](keys[CL_LIB["COLON"]]) then  l13 = l5 else  l13 = n.bound end local l14 = n if n ~= CL["NOT"](keys[CL_LIB["ATSIGN"]]) then  l14 = l6 else  l14 = n.bound end i( CL_LIB["FORMAT-NO-FLAGS"](l13, l14) );
 single_value();  return CL["VALUES"](l(l2,l3,l7,l5,l6)) end, 1, 0, false, {0 , [LCL["KEYWORD"]["COLON"]] = CL_LIB["COLON"], [LCL["KEYWORD"]["ATSIGN"]] = CL_LIB["ATSIGN"]})); tmp = CL_LIB["FUNCTION-SETQ"](CL["FORMAT"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["CONTROL-STRING"],{CL["&REST"],{CL_LIB["FORMAT-ARGUMENTS"],n}}}},function (l1, l2, l3,  ...)   i( n.bound );
 single_value();  local l4 = n if n ~= CL["NULL"](l1) then  local l5 = CL["MAKE-STRING-OUTPUT-STREAM"](k()); i( CL["APPLY"](CL["FORMAT"].fbound, l5, l(l2,l3)) );
 single_value();  l4 = CL["GET-OUTPUT-STREAM-STRING"](l5) else  local l6 = n if n ~= CL["STRINGP"](l1) then  l6 = n.bound else  local l7 = CL_LIB["*FORMAT-TOP-LEVEL*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*FORMAT-TOP-LEVEL*"].bound; CL_LIB["*FORMAT-TOP-LEVEL*"].bound = CL["T"].bound i( CL_LIB["*FORMAT-TOP-LEVEL*"].bound );
 single_value();  local l9 = l10; single_value();  local l11 = n if n ~= CL_LIB["XP-STRUCTURE-P"](l1) then  single_value();  l1 = CL_LIB["FUNCALL-LUA"]( CL_LIB["XP-STREAM-STREAM"].fbound, {l1, }) l11 = l1 else  l11 = n.bound end i( l11 );
 local l12 = n if n ~= CL["EQ"](l1, CL["T"].bound) then  l12 = CL["*STANDARD-OUTPUT*"].bound else  l12 = CL_LIB["REQUIRE-TYPE"](l1, CL["STREAM"]) end l1 = l12 i( l1 );
 local l13 = n if n ~= CL["FUNCTIONP"](l2) then  l13 = CL["APPLY"](l2, l1, l(l3)) else  local l14 = CL_LIB["ENSURE-SIMPLE-STRING"](l2); single_value();  local l15 = CL_LIB["*FORMAT-CONTROL-STRING*"].bound; single_value();  local l16 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l18 = CL_LIB["*FORMAT-CONTROL-STRING*"].bound; CL_LIB["*FORMAT-CONTROL-STRING*"].bound = l14 i( CL_LIB["*FORMAT-CONTROL-STRING*"].bound );
 single_value();  local l17 = l18; single_value();  single_value();  local l19 = CL_LIB["*FORMAT-PPRINT*"].bound; single_value();  local l20 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l22 = CL_LIB["*FORMAT-PPRINT*"].bound; CL_LIB["*FORMAT-PPRINT*"].bound = n.bound i( CL_LIB["*FORMAT-PPRINT*"].bound );
 single_value();  local l21 = l22; single_value();  single_value();  local l23 = CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"].bound; single_value();  local l24 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l26 = CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"].bound; CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"].bound = n.bound i( CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"].bound );
 single_value();  local l25 = l26; single_value();  single_value();  i( n.bound );
 single_value();  local l27 = n if n ~= CL["NOT"](CL["POSITION"](LCL['CL-LIB']['MAKE-CHAR']("~"), l14, k())) then  single_value();  l27 = CL["WRITE-STRING"](l14, l1, k()) else  local l30 = CL["*PRINT-PRETTY*"].bound; single_value();  local l31 = n if n ~= l30 then  l31 = l30 else  l31 = CL["*PRINT-CIRCLE*"].bound end local l29 = n if n ~= l31 then  l29 = CL["NOT"](CL["TYPEP"](l1, CL_LIB["XP-STREAM"], false)) else  l29 = n.bound end local l28 = n if n ~= l29 then  single_value();  l28 = CL_LIB["FUNCALL-LUA"]( CL_LIB["MAYBE-INITIATE-XP-PRINTING"].fbound, {CL_LIB["ALLOC-FUNCTION"]({CL_LIB["S"],{CL_LIB["O"],n}},function (l32, l33,  ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( CL_LIB["DO-SUB-FORMAT-1"].fbound, {l32, l33, }) end, 2, 0, false, false), l1, l3, }) else  local l34 = n if n ~= CL["T"].bound then  single_value();  local l35 = CL_LIB["*FORMAT-COLON-REST*"].bound; local l36 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; local l37 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; single_value();  local l38 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l40 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound = l3 i( CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound );
 single_value();  local l39 = l40; local l42 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; CL_LIB["*FORMAT-ARGUMENTS*"].bound = l3 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  local l41 = l42; local l44 = CL_LIB["*FORMAT-COLON-REST*"].bound; CL_LIB["*FORMAT-COLON-REST*"].bound = CL["ERROR"] i( CL_LIB["*FORMAT-COLON-REST*"].bound );
 single_value();  local l43 = l44; single_value();  single_value();  return CL_LIB["DO-SUB-FORMAT"](l1) end, 0, 0, false, false))); CL_LIB["*FORMAT-COLON-REST*"].bound = l35 i( CL_LIB["*FORMAT-COLON-REST*"].bound );
 CL_LIB["*FORMAT-ARGUMENTS*"].bound = l36 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound = l37 i( CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound );
 single_value(); if l38.error ~= n and true then if l38.error == KEYWORD.TAG then  error(l38) else error(l38[1]) end end l34 = CL["VALUES-LIST"](list_r(l38)) else  l34 = n.bound end l28 = l34 end l27 = l28 end return l27 end, 0, 0, false, false))); CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"].bound = l23 i( CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"].bound );
 single_value(); if l24.error ~= n and true then if l24.error == KEYWORD.TAG then  error(l24) else error(l24[1]) end end return CL["VALUES-LIST"](list_r(l24)) end, 0, 0, false, false))); CL_LIB["*FORMAT-PPRINT*"].bound = l19 i( CL_LIB["*FORMAT-PPRINT*"].bound );
 single_value(); if l20.error ~= n and true then if l20.error == KEYWORD.TAG then  error(l20) else error(l20[1]) end end return CL["VALUES-LIST"](list_r(l20)) end, 0, 0, false, false))); CL_LIB["*FORMAT-CONTROL-STRING*"].bound = l15 i( CL_LIB["*FORMAT-CONTROL-STRING*"].bound );
 single_value(); if l16.error ~= n and true then if l16.error == KEYWORD.TAG then  error(l16) else error(l16[1]) end end l13 = CL["VALUES-LIST"](list_r(l16)) end i( l13 );
 single_value();  return n.bound end, 0, 0, false, false))); CL_LIB["*FORMAT-TOP-LEVEL*"].bound = l7 i( CL_LIB["*FORMAT-TOP-LEVEL*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end l6 = CL["VALUES-LIST"](list_r(l8)) end l4 = l6 end return l4 end, 2, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-TO-STRING"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL_LIB["CONTROL-STRING"],{CL["&REST"],{CL_LIB["FORMAT-ARGUMENTS"],n}}}},function (l1, l2, l3,  ...)   i( n.bound );
 single_value();  local l4 = n if n ~= l1 then  l4 = n.bound else  local l5 = CL["MAKE-STRING-OUTPUT-STREAM"](k()); i( CL["APPLY"](CL["FORMAT"].fbound, l5, l(l2,l3)) );
 single_value();  l4 = CL["GET-OUTPUT-STREAM-STRING"](l5) end return l4 end, 2, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["DO-SUB-FORMAT"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l4 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["SUB-FORMAT"](l1, 0, CL["LENGTH"](CL_LIB["*FORMAT-CONTROL-STRING*"].bound)) end, 0, 0, false, false))); single_value(); if l4.error ~= n and (l4.error ~= KEYWORD.TAG or l4.tag ~= CL_LIB["FORMAT-ESCAPE"]) then if l4.error == KEYWORD.TAG then  error(l4) else error(l4[1]) end end i( CL["VALUES-LIST"](list_r(l4)) );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l3.error ~= n and (l3.error ~= KEYWORD.TAG or l3.tag ~= CL_LIB["FORMAT-ERROR"]) then if l3.error == KEYWORD.TAG then  error(l3) else error(l3[1]) end end l2 = CL["VALUES-LIST"](list_r(l3)) i( l2 );
 single_value();  local l5 = n if n ~= l2 then  single_value();  l5 = CL["ERROR"]("~%~:{~@?~%~}", l(CL["NREVERSE"](l2))) else  l5 = n.bound end return l5 end, 1, 0, false, false)); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL_LIB["*LOGICAL-BLOCK-XP*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["POP-FORMAT-ARG"] , CL_LIB["ALLOC-FUNCTION"]({CL["&AUX"],{{CL_LIB["ARGS"],{CL_LIB["*FORMAT-ARGUMENTS*"],n}},{{CL_LIB["XP"],{CL_LIB["*LOGICAL-BLOCK-XP*"],n}},{{CL_LIB["AV"],{CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"],n}},n}}}},function ( ...)  l1 = CL_LIB["*FORMAT-ARGUMENTS*"].bound l2 = CL_LIB["*LOGICAL-BLOCK-XP*"].bound l3 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound  local l5 = n if n ~= CL["NULL"](l1) then  l5 = CL["NULL"](l2) else  l5 = n.bound end local l4 = n if n ~= l5 then  single_value();  l4 = CL_LIB["FORMAT-ERROR"]("Missing argument", l()) else  l4 = n.bound end i( l4 );
 local l6 = n if n ~= l2 then  single_value();  local l7 = n if n ~= CL["NULL"](l3) then  local l8 = n if n ~= CL_LIB["FUNCALL-LUA"]( CL_LIB["PPRINT-POP-CHECK+"].fbound, {l1, l2, }) then  single_value();  l8 = error({tag=CL["IDENTITY"](CL_LIB["LOGICAL-BLOCK"]),(function () single_value() return unpack_mv(n.bound) end)()}) else  l8 = n.bound end l7 = l8 else  l7 = n.bound end l6 = l7 else  l6 = n.bound end i( l6 );
 single_value();  local l10 = CL["NULL"](l3); single_value();  local l11 = n if n ~= l10 then  l11 = l10 else  l11 = CL["EQL"](l3, 0) end local l9 = n if n ~= l11 then  CL_LIB["*FORMAT-ARGUMENTS*"].bound = (l1)[2] i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  l9 = (l1)[1] else  local l13 = CL["GENSYM"](false); single_value();  local l14 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l15 = l1; i( n.bound );
 single_value();  local l16 = (l15)[1]; i( n.bound );
 single_value();  local l17 = 1; local l18 = 0; local l19 = l3; i( n.bound );
 single_value();  local l20 = n.bound; local l21 = n.bound; i( n.bound );
 single_value();  single_value();  local l22 = CL["LIST"](l(n.bound)); single_value();  local l23 = CL["LIST"](l(n.bound)); single_value();  local l24 = l22; single_value();  local l25 = l22; single_value();  local l26 = l22; single_value();  single_value();  local l27 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l28; local l29; local l30;l28 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( l29[1], {}) end, 0, 0, false, false)};l29 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l31 = n if n ~= CL["NULL"](l15) then  l31 = error({tag=CL["IDENTITY"](l26),(function () single_value() return unpack_mv(l30[1]) end)()}) else  local l32 = n if n ~= CL[">="](l(l18,l19)) then  l32 = error({tag=CL["IDENTITY"](l26),(function () single_value() return unpack_mv(l30[1]) end)()}) else  local l33 = n if n ~= CL["NULL"](l20) then  single_value();  single_value();  local l34 = CL["LIST"](l(CL_LIB["FUNCALL-LUA"]( CL_LIB["NX-FORM-TYPE"].fbound, {l16, }))); single_value();  l20 = l34 i( l20 );
 single_value();  single_value();  single_value();  local l35 = CL["LAST"](l20, false); single_value();  l21 = l35 l33 = l21 else  local l36 = n if n ~= CL["T"].bound then  i( CL["NCONC"](l(l21,CL["LIST"](l(CL_LIB["FUNCALL-LUA"]( CL_LIB["NX-FORM-TYPE"].fbound, {l16, }))))) );
 single_value();  single_value();  single_value();  local l37 = CL["LAST"](l21, false); single_value();  l21 = l37 l36 = l21 else  l36 = n.bound end l33 = l36 end i( l33 );
 local l38 = (l15)[2]; single_value();  single_value();  single_value();  local l39 = l38; single_value();  l15 = l39 i( l15 );
 local l40 = (l15)[1]; single_value();  single_value();  single_value();  local l41 = l40; single_value();  l16 = l41 i( l16 );
 single_value();  local l42 = (l18 + l17); single_value();  single_value();  single_value();  local l43 = l42; single_value();  l18 = l43 l32 = l18 end l31 = l32 end i( l31 );
 i( error({tag=CL["IDENTITY"](l25),(function () single_value() return unpack_mv(l29[1]) end)()}) );
 single_value();  return CL_LIB["FUNCALL-LUA"]( l30[1], {}) end, 0, 0, false, false)};l30 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l44 = CL["FUNCALL"](l, l(unpack_mv(l20))); single_value();  i( error({tag=CL["IDENTITY"](l13),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l44)) end)()}) );
 single_value();  return error({tag=CL["IDENTITY"](l23),(function () single_value() return unpack_mv(n) end)()}) end, 0, 0, false, false)}; single_value();  local l45 = l28[1]; single_value();  while true do  single_value();  local l46 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB['FUNCALL-LUA'](l45,{}) end, 0, 0, false, false))); single_value(); if l46.error ~= n and (l46.error ~= KEYWORD.TAG or l46.tag ~= l22) then if l46.error == KEYWORD.TAG then  error(l46) else error(l46[1]) end end l45 = CL["VALUES-LIST"](list_r(l46)) local tmpres = l45 end return n end, 0, 0, false, false))); single_value(); if l27.error ~= n and (l27.error ~= KEYWORD.TAG or l27.tag ~= l23) then if l27.error == KEYWORD.TAG then  error(l27) else error(l27[1]) end end return CL["VALUES-LIST"](list_r(l27)) end, 0, 0, false, false))); single_value(); if l14.error ~= n and (l14.error ~= KEYWORD.TAG or l14.tag ~= l13) then if l14.error == KEYWORD.TAG then  error(l14) else error(l14[1]) end end local l12 = CL["VALUES-LIST"](list_r(l14)); local l47 = n if n ~= CL["EQL"](l3, CL["LENGTH"](l1)) then  single_value();  CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = CL["1-"](l3) l47 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound else  l47 = n.bound end i( l47 );
 CL_LIB["*FORMAT-ARGUMENTS*"].bound = (l1)[2] i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  l9 = CL["CONS"](CL["THE"], CL["CONS"](CL["CONS"](CL["OR"], CL["APPEND"](l(l12,n))), CL["CONS"](CL["CONS"](CL["CAR"], CL["CONS"](CL_LIB["*FORMAT-ARGUMENTS*"], n)), n))) end return l9 end, 0, 0, false, false)); i( CL_LIB["FUNCTION-SETQ"](CL_LIB["ENSURE-SIMPLE-STRING"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STR"],n},function (l1,  ...)   single_value();  return CL["STRING"](l1) end, 1, 0, false, false)) );
 i( CL_LIB["FUNCTION-SETQ"](CL_LIB["ADD-FORMAT-CHAR"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL_LIB["DEF"],n}},function (l2, l3,  ...)   local l5 = n if n ~= CL["CHARACTERP"](l2) then  l5 = CL_LIB["%<"](CL["CHAR-CODE"](l2), 128) else  l5 = n.bound end local l4 = n if n ~= l5 then  l4 = n.bound else  single_value();  l4 = CL["ERROR"]("Bad argument ~S to add-format-char, expected ~S", l(l2,CL["STANDARD-CHAR"])) end i( l4 );
 single_value();  single_value();  local l6 = CL["CHAR-CODE"](CL["CHAR-UPCASE"](l2)); single_value();  local l7 = CL_LIB["*FORMAT-CHAR-TABLE*"].bound; single_value();  single_value();  local l8 = l3; single_value();  return CL_LIB["%SETSVREF"](l7, l6, l8) end, 2, 0, false, false)) );
 i( CL_LIB["MACRO-SETQ"](CL_LIB["DEFFORMAT"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G231793"],{CL["&OPTIONAL"],{LCL["NIL"]["G231794"],n}}},function (l9, l10,  ...)  if not l10 then  l10 = n.bound end  single_value();  local l11 = (l9)[2]; single_value();  local l12 = (l9)[2]; single_value();  local l14 = l12; single_value();  local l15 = (l14)[1]; single_value();  single_value();  local l16 = (l14)[2]; single_value();  l12 = l16 i( l12 );
 single_value();  local l13 = l15; single_value();  local l18 = l12; single_value();  local l19 = (l18)[1]; single_value();  single_value();  local l20 = (l18)[2]; single_value();  l12 = l20 i( l12 );
 single_value();  local l17 = l19; single_value();  local l21 = l12; single_value();  single_value();  return CL["CONS"](CL["PROGN"], CL["CONS"](CL["CONS"](CL_LIB["ADD-FORMAT-CHAR"], CL["CONS"](l13, CL["CONS"](CL["CONS"](CL["LAMBDA"], CL["APPEND"](l(l21,n))), n))), CL["CONS"](CL["CONS"](CL["QUOTE"], CL["CONS"](l17, n)), n))) end, 1, 1, false, false)) );
 single_value();  tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["SUB-FORMAT"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["*FORMAT-INDEX*"],{CL_LIB["*FORMAT-LENGTH*"],{CL["&AUX"],{CL["CHAR"],n}}}}},function (l22, l23, l25,  ...)  local l26 = CL_LIB["*FORMAT-LENGTH*"].bound ;  local l24 = CL_LIB["*FORMAT-INDEX*"].bound ; local status, ret = pcall(function ()  CL_LIB["*FORMAT-INDEX*"].bound = l23 CL_LIB["*FORMAT-LENGTH*"].bound = l25 l27 = n.bound  single_value();  local l28 = CL["GENSYM"](false); single_value();  local l29 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l30 = CL["STRING"](CL_LIB["*FORMAT-CONTROL-STRING*"].bound); single_value();  local l31 = CL_LIB["*FORMAT-LENGTH*"].bound; single_value();  local l32 = CL_LIB["*FORMAT-INDEX*"].bound; single_value();  local l33 = l32; single_value();  single_value();  local l34 = CL["LIST"](l(n.bound)); single_value();  local l35 = CL["LIST"](l(n.bound)); single_value();  local l36 = l34; single_value();  local l37 = l34; single_value();  local l38 = l34; single_value();  single_value();  local l39 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l40; local l41; local l42;l40 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   i( n.bound );
 i( error({tag=CL["IDENTITY"](l38),(function () single_value() return unpack_mv(l42[1]) end)()}) );
 single_value();  return CL_LIB["FUNCALL-LUA"]( l41[1], {}) end, 0, 0, false, false)};l41 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   CL_LIB["*FORMAT-INDEX*"].bound = CL_LIB["*FORMAT-LENGTH*"].bound i( CL_LIB["*FORMAT-INDEX*"].bound );
 i( CL_LIB["FORMAT-ERROR"]("Premature end of control string", l()) );
 single_value();  return CL_LIB["FUNCALL-LUA"]( l42[1], {}) end, 0, 0, false, false)};l42 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l43 = CL["GENSYM"](false); single_value();  local l44 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l45 = n if n ~= CL["EQ"](l32, l31) then  single_value(); do break end; l45 = n.bound else  l45 = n.bound end i( l45 );
 single_value();  local l46 = CL["SCHAR"](l30, l32); single_value();  l27 = l46 i( l27 );
 single_value();  single_value();  single_value();  local l47 = CL["1+"](l32); single_value();  l32 = l47 i( l32 );
 local l48 = n if n ~= CL["EQ"](l27, LCL['CL-LIB']['MAKE-CHAR']("~")) then  local l49 = CL["1-"](l32); single_value();  single_value();  local l50 = n if n ~= CL["EQ"](l49, l33) then  l50 = n.bound else  single_value();  l50 = CL["WRITE-STRING"](l30, l22, k(CL_LIB["START"], l33, CL_LIB["END"], l49)) end i( l50 );
 single_value();  local l51 = n.bound; local l52 = n.bound; local l53 = n.bound; local l54 = n.bound; local l55 = CL["GENSYM"](false); single_value();  local l56 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l57 = CL["LIST"](l(n.bound)); single_value();  local l58 = CL["LIST"](l(n.bound)); single_value();  local l59 = l57; single_value();  local l60 = l57; single_value();  single_value();  local l61 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l62; local l63;l62 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( l63[1], {}) end, 0, 0, false, false)};l63 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l64 = n if n ~= CL["EQ"](l32, l31) then  l64 = error({tag=CL["IDENTITY"](l37),(function () single_value() return unpack_mv(l41[1]) end)()}) else  l64 = n.bound end i( l64 );
 single_value();  local l65 = CL["SCHAR"](l30, l32); single_value();  l27 = l65 i( l27 );
 single_value();  single_value();  single_value();  local l66 = CL["1+"](l32); single_value();  l32 = l66 i( l32 );
 local l67 = n if n ~= CL["EQ"](l27, LCL['CL-LIB']['MAKE-CHAR']("#")) then  single_value();  single_value();  single_value();  local l68 = CL["CONS"](CL["LIST-LENGTH"](CL_LIB["*FORMAT-ARGUMENTS*"].bound), l51); single_value();  l51 = l68 l67 = l51 else  local l69 = n if n ~= CL["EQ"](l27, LCL['CL-LIB']['MAKE-CHAR']("'")) then  local l70 = n if n ~= CL["EQ"](l32, l31) then  l70 = error({tag=CL["IDENTITY"](l37),(function () single_value() return unpack_mv(l41[1]) end)()}) else  l70 = n.bound end i( l70 );
 single_value();  single_value();  local l71 = CL["CONS"](CL["SCHAR"](l30, l32), l51); single_value();  l51 = l71 i( l51 );
 single_value();  single_value();  local l72 = (1 + l32); single_value();  l32 = l72 l69 = l32 else  local l73 = n if n ~= CL["EQ"](l27, LCL['CL-LIB']['MAKE-CHAR'](",")) then  single_value();  single_value();  local l74 = CL["CONS"](n.bound, l51); single_value();  l51 = l74 i( l51 );
 single_value();  l73 = error({tag=CL["IDENTITY"](l60),(function () single_value() return unpack_mv(l63[1]) end)()}) else  local l76 = CL["EQ"](l27, LCL['CL-LIB']['MAKE-CHAR']("V")); single_value();  local l77 = n if n ~= l76 then  l77 = l76 else  l77 = CL["EQ"](l27, LCL['CL-LIB']['MAKE-CHAR']("v")) end local l75 = n if n ~= l77 then  single_value();  single_value();  single_value();  local l78 = CL["CONS"](CL_LIB["POP-FORMAT-ARG"](), l51); single_value();  l51 = l78 l75 = l51 else  local l80 = CL["EQ"](l27, LCL['CL-LIB']['MAKE-CHAR']("-")); single_value();  local l81 = n if n ~= l80 then  l81 = l80 else  local l82 = CL["EQ"](l27, LCL['CL-LIB']['MAKE-CHAR']("+")); single_value();  local l83 = n if n ~= l82 then  l83 = l82 else  l83 = CL["DIGIT-CHAR-P"](l27, false) end l81 = l83 end local l79 = n if n ~= l81 then  single_value();  local l84 = (l32 - 1); local l85 = n.bound; while true do  local l86 = n if n ~= CL["EQ"](l32, l31) then  single_value();  l86 = error({tag=CL["IDENTITY"](l37),(function () single_value() return unpack_mv(l41[1]) end)()}) else  l86 = n.bound end i( l86 );
 local l87 = n if n ~= CL["DIGIT-CHAR-P"](CL["SCHAR"](l30, l32), false) then  l87 = n.bound else  single_value(); do break end; l87 = n.bound end i( l87 );
 single_value();  single_value();  local l88 = (1 + l32); single_value();  l32 = l88 local tmpres = l32 end i( n );
 l85 = CL_LIB["%PARSE-NUMBER-TOKEN"](l30, l84, l32) local l89 = n if n ~= CL["NULL"](l85) then  CL_LIB["*FORMAT-INDEX*"].bound = l32 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value();  l89 = CL_LIB["FORMAT-ERROR"]("Illegal parameter", l()) else  l89 = n.bound end i( l89 );
 single_value();  single_value();  single_value();  local l90 = CL["CONS"](l85, l51); single_value();  l51 = l90 l79 = l51 else  local l91 = n if n ~= CL["T"].bound then  single_value();  local l92 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l91 = error({tag=CL["IDENTITY"](l55),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l92)) end)()}) else  l91 = n.bound end l79 = l91 end l75 = l79 end l73 = l75 end l69 = l73 end l67 = l69 end i( l67 );
 local l93 = n if n ~= CL["EQ"](l32, l31) then  l93 = error({tag=CL["IDENTITY"](l37),(function () single_value() return unpack_mv(l41[1]) end)()}) else  l93 = n.bound end i( l93 );
 single_value();  local l94 = CL["SCHAR"](l30, l32); single_value();  l27 = l94 i( l27 );
 single_value();  single_value();  single_value();  local l95 = CL["1+"](l32); single_value();  l32 = l95 i( l32 );
 local l96 = n if n ~= CL_LIB["NEQ"](l27, LCL['CL-LIB']['MAKE-CHAR'](",")) then  single_value();  local l97 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l96 = error({tag=CL["IDENTITY"](l55),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l97)) end)()}) else  l96 = n.bound end i( l96 );
 i( error({tag=CL["IDENTITY"](l60),(function () single_value() return unpack_mv(l63[1]) end)()}) );
 single_value();  return error({tag=CL["IDENTITY"](l58),(function () single_value() return unpack_mv(n) end)()}) end, 0, 0, false, false)}; single_value();  local l98 = l62[1]; single_value();  while true do  single_value();  local l99 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB['FUNCALL-LUA'](l98,{}) end, 0, 0, false, false))); single_value(); if l99.error ~= n and (l99.error ~= KEYWORD.TAG or l99.tag ~= l57) then if l99.error == KEYWORD.TAG then  error(l99) else error(l99[1]) end end l98 = CL["VALUES-LIST"](list_r(l99)) local tmpres = l98 end return n end, 0, 0, false, false))); single_value(); if l61.error ~= n and (l61.error ~= KEYWORD.TAG or l61.tag ~= l58) then if l61.error == KEYWORD.TAG then  error(l61) else error(l61[1]) end end return CL["VALUES-LIST"](list_r(l61)) end, 0, 0, false, false))); single_value(); if l56.error ~= n and (l56.error ~= KEYWORD.TAG or l56.tag ~= l55) then if l56.error == KEYWORD.TAG then  error(l56) else error(l56[1]) end end i( CL["VALUES-LIST"](list_r(l56)) );
 local l100 = n if n ~= CL["EQ"](l27, LCL['CL-LIB']['MAKE-CHAR'](":")) then  local l101 = n if n ~= CL["EQ"](l32, l31) then  l101 = error({tag=CL["IDENTITY"](l37),(function () single_value() return unpack_mv(l41[1]) end)()}) else  l101 = n.bound end i( l101 );
 single_value();  local l102 = CL["T"].bound; single_value();  l53 = l102 i( l53 );
 single_value();  single_value();  local l103 = CL["SCHAR"](l30, l32); single_value();  l27 = l103 i( l27 );
 single_value();  single_value();  single_value();  local l104 = CL["1+"](l32); single_value();  l32 = l104 i( l32 );
 single_value();  local l105 = n if n ~= CL["EQ"](l27, LCL['CL-LIB']['MAKE-CHAR']("@")) then  local l106 = n if n ~= CL["EQ"](l32, l31) then  l106 = error({tag=CL["IDENTITY"](l37),(function () single_value() return unpack_mv(l41[1]) end)()}) else  l106 = n.bound end i( l106 );
 single_value();  single_value();  local l107 = CL["T"].bound; single_value();  l54 = l107 i( l54 );
 single_value();  single_value();  local l108 = CL["SCHAR"](l30, l32); single_value();  l27 = l108 i( l27 );
 single_value();  single_value();  single_value();  local l109 = CL["1+"](l32); single_value();  l32 = l109 l105 = l32 else  l105 = n.bound end l100 = l105 else  local l110 = n if n ~= CL["EQ"](l27, LCL['CL-LIB']['MAKE-CHAR']("@")) then  local l111 = n if n ~= CL["EQ"](l32, l31) then  l111 = error({tag=CL["IDENTITY"](l37),(function () single_value() return unpack_mv(l41[1]) end)()}) else  l111 = n.bound end i( l111 );
 single_value();  local l112 = CL["T"].bound; single_value();  l54 = l112 i( l54 );
 single_value();  single_value();  local l113 = CL["SCHAR"](l30, l32); single_value();  l27 = l113 i( l27 );
 single_value();  single_value();  single_value();  local l114 = CL["1+"](l32); single_value();  l32 = l114 i( l32 );
 single_value();  local l115 = n if n ~= CL["EQ"](l27, LCL['CL-LIB']['MAKE-CHAR'](":")) then  local l116 = n if n ~= CL["EQ"](l32, l31) then  l116 = error({tag=CL["IDENTITY"](l37),(function () single_value() return unpack_mv(l41[1]) end)()}) else  l116 = n.bound end i( l116 );
 single_value();  single_value();  local l117 = CL["T"].bound; single_value();  l53 = l117 i( l53 );
 single_value();  single_value();  local l118 = CL["SCHAR"](l30, l32); single_value();  l27 = l118 i( l27 );
 single_value();  single_value();  single_value();  local l119 = CL["1+"](l32); single_value();  l32 = l119 l115 = l32 else  l115 = n.bound end l110 = l115 else  l110 = n.bound end l100 = l110 end i( l100 );
 CL_LIB["*FORMAT-INDEX*"].bound = (l32 - 1) i( CL_LIB["*FORMAT-INDEX*"].bound );
 l52 = CL["SVREF"](CL_LIB["*FORMAT-CHAR-TABLE*"].bound, CL["CHAR-CODE"](CL["CHAR-UPCASE"](l27))) local l120 = n if n ~= l52 then  l120 = CL["APPLY"](l52, l22, l(l53,l54,CL["NREVERSE"](l51))) else  l120 = CL_LIB["FORMAT-ERROR"]("Unknown directive", l()) end i( l120 );
 single_value();  single_value();  local l121 = (CL_LIB["*FORMAT-INDEX*"].bound + 1); single_value();  l32 = l121 i( l32 );
 single_value();  single_value();  single_value();  local l122 = l32; single_value();  l33 = l122 l48 = l33 else  l48 = n.bound end i( l48 );
 single_value();  single_value();  single_value();  local l123 = n.bound; single_value();  n.bound = l123 local tmpres = n.bound end i( n );
 single_value();  local l124 = n if n ~= CL["EQ"](l32, l33) then  l124 = n.bound else  single_value();  l124 = CL["WRITE-STRING"](l30, l22, k(CL_LIB["START"], l33, CL_LIB["END"], l32)) end return l124 end, 0, 0, false, false))); single_value(); if l44.error ~= n and (l44.error ~= KEYWORD.TAG or l44.tag ~= l43) then if l44.error == KEYWORD.TAG then  error(l44) else error(l44[1]) end end i( CL["VALUES-LIST"](list_r(l44)) );
 single_value();  return error({tag=CL["IDENTITY"](l35),(function () single_value() return unpack_mv(n) end)()}) end, 0, 0, false, false)}; single_value();  local l125 = l40[1]; single_value();  while true do  single_value();  local l126 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB['FUNCALL-LUA'](l125,{}) end, 0, 0, false, false))); single_value(); if l126.error ~= n and (l126.error ~= KEYWORD.TAG or l126.tag ~= l34) then if l126.error == KEYWORD.TAG then  error(l126) else error(l126[1]) end end l125 = CL["VALUES-LIST"](list_r(l126)) local tmpres = l125 end return n end, 0, 0, false, false))); single_value(); if l39.error ~= n and (l39.error ~= KEYWORD.TAG or l39.tag ~= l35) then if l39.error == KEYWORD.TAG then  error(l39) else error(l39[1]) end end return CL["VALUES-LIST"](list_r(l39)) end, 0, 0, false, false))); single_value(); if l29.error ~= n and (l29.error ~= KEYWORD.TAG or l29.tag ~= l28) then if l29.error == KEYWORD.TAG then  error(l29) else error(l29[1]) end end return CL["VALUES-LIST"](list_r(l29)) end)CL_LIB["*FORMAT-LENGTH*"].bound = l26; CL_LIB["*FORMAT-INDEX*"].bound = l24; if status then return(ret) else error(ret) end end, 3, 0, false, false)); i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("W"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],n}}},function (l1, l2, l3,  ...)   i( CL_LIB["FORMAT-NO-SEMI"](LCL['CL-LIB']['MAKE-CHAR']("W"), false, false) );
 single_value();  local l4 = CL_LIB["POP-FORMAT-ARG"](); single_value();  local l5 = n if n ~= l3 then  single_value();  local l6 = CL["*PRINT-LENGTH*"].bound; local l7 = CL["*PRINT-LEVEL*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL["*PRINT-LEVEL*"].bound; CL["*PRINT-LEVEL*"].bound = n.bound i( CL["*PRINT-LEVEL*"].bound );
 single_value();  local l9 = l10; local l12 = CL["*PRINT-LENGTH*"].bound; CL["*PRINT-LENGTH*"].bound = n.bound i( CL["*PRINT-LENGTH*"].bound );
 single_value();  local l11 = l12; single_value();  single_value();  local l13 = n if n ~= l2 then  local l14 = CL["*PRINT-PRETTY*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL["*PRINT-PRETTY*"].bound; CL["*PRINT-PRETTY*"].bound = CL["T"].bound i( CL["*PRINT-PRETTY*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  return CL["WRITE"](l4, k(CL["STREAM"], l1)) end, 0, 0, false, false))); CL["*PRINT-PRETTY*"].bound = l14 i( CL["*PRINT-PRETTY*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end l13 = CL["VALUES-LIST"](list_r(l15)) else  l13 = CL["WRITE"](l4, k(CL["STREAM"], l1)) end return l13 end, 0, 0, false, false))); CL["*PRINT-LENGTH*"].bound = l6 i( CL["*PRINT-LENGTH*"].bound );
 CL["*PRINT-LEVEL*"].bound = l7 i( CL["*PRINT-LEVEL*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end l5 = CL["VALUES-LIST"](list_r(l8)) else  local l18 = n if n ~= CL["T"].bound then  single_value();  local l19 = n if n ~= l2 then  local l20 = CL["*PRINT-PRETTY*"].bound; single_value();  local l21 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l23 = CL["*PRINT-PRETTY*"].bound; CL["*PRINT-PRETTY*"].bound = CL["T"].bound i( CL["*PRINT-PRETTY*"].bound );
 single_value();  local l22 = l23; single_value();  single_value();  return CL["WRITE"](l4, k(CL["STREAM"], l1)) end, 0, 0, false, false))); CL["*PRINT-PRETTY*"].bound = l20 i( CL["*PRINT-PRETTY*"].bound );
 single_value(); if l21.error ~= n and true then if l21.error == KEYWORD.TAG then  error(l21) else error(l21[1]) end end l19 = CL["VALUES-LIST"](list_r(l21)) else  l19 = CL["WRITE"](l4, k(CL["STREAM"], l1)) end l18 = l19 else  l18 = n.bound end l5 = l18 end return l5 end, 3, 0, false, false)) );
 single_value();  tmp = CL_LIB["FORMAT-WRITE"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("I"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 i( n.bound );
 i( CL_LIB["FORMAT-NO-SEMI"](LCL['CL-LIB']['MAKE-CHAR']("I"), false, false) );
 single_value();  local l7 = n if n ~= l4 then  local l8 = l4; single_value();  local l9 = (l8)[1]; single_value();  single_value();  local l10 = (l8)[2]; single_value();  l4 = l10 i( l4 );
 single_value();  l7 = l9 else  l7 = n.bound end local l6 = l7; single_value();  local l11 = n if n ~= l6 then  l11 = l6 else  l11 = 0 end local l5 = l11; local l12 = n if n ~= l4 then  single_value();  l12 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l12 = n.bound end i( l12 );
 single_value();  local l13 = n if n ~= l2 then  l13 = LCL["KEYWORD"]["CURRENT"] else  l13 = LCL["KEYWORD"]["BLOCK"] end return CL_LIB["FUNCALL-LUA"]( CL_LIB["PPRINT-INDENT"].fbound, {l13, l5, l1, }) end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-INDENT"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("_"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],n}}},function (l1, l2, l3,  ...)   i( CL_LIB["FORMAT-NO-SEMI"](LCL['CL-LIB']['MAKE-CHAR']("_"), false, false) );
 single_value();  local l5 = n if n ~= l3 then  single_value();  local l6 = n if n ~= l2 then  single_value();  l6 = LCL["KEYWORD"]["MANDATORY"] else  local l7 = n if n ~= CL["T"].bound then  single_value();  l7 = LCL["KEYWORD"]["MISER"] else  l7 = n.bound end l6 = l7 end l5 = l6 else  local l8 = n if n ~= l2 then  single_value();  l8 = LCL["KEYWORD"]["FILL"] else  local l9 = n if n ~= CL["T"].bound then  single_value();  l9 = LCL["KEYWORD"]["LINEAR"] else  l9 = n.bound end l8 = l9 end l5 = l8 end local l4 = l5; single_value();  return CL_LIB["FUNCALL-LUA"]( CL_LIB["PPRINT-NEWLINE"].fbound, {l4, l1, }) end, 3, 0, false, false)) );
 single_value();  tmp = CL_LIB["FORMAT-CONDITIONAL-NEWLINE"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("T"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 local l5 = n if n ~= l2 then  single_value();  l5 = CL_LIB["FORMAT-NO-SEMI"](LCL['CL-LIB']['MAKE-CHAR']("T"), CL["T"].bound, false) else  l5 = n.bound end i( l5 );
 single_value();  local l8 = n if n ~= l4 then  local l9 = l4; single_value();  local l10 = (l9)[1]; single_value();  single_value();  local l11 = (l9)[2]; single_value();  l4 = l11 i( l4 );
 single_value();  l8 = l10 else  l8 = n.bound end local l7 = l8; single_value();  local l12 = n if n ~= l7 then  l12 = l7 else  l12 = 1 end local l6 = l12; local l15 = n if n ~= l4 then  local l16 = l4; single_value();  local l17 = (l16)[1]; single_value();  single_value();  local l18 = (l16)[2]; single_value();  l4 = l18 i( l4 );
 single_value();  l15 = l17 else  l15 = n.bound end local l14 = l15; single_value();  local l19 = n if n ~= l14 then  l19 = l14 else  l19 = 1 end local l13 = l19; local l20 = n if n ~= l4 then  single_value();  l20 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l20 = n.bound end i( l20 );
 single_value();  local l22 = CL["TYPEP"](l1, CL_LIB["XP-STREAM"], false); single_value();  local l23 = n if n ~= l22 then  l23 = l22 else  l23 = CL_LIB["XP-STRUCTURE-P"](l1) end local l21 = n if n ~= l23 then  single_value();  local l25 = n if n ~= l2 then  local l26 = n if n ~= l3 then  l26 = LCL["KEYWORD"]["SECTION-RELATIVE"] else  l26 = LCL["KEYWORD"]["SECTION"] end l25 = l26 else  local l27 = n if n ~= l3 then  l27 = LCL["KEYWORD"]["LINE-RELATIVE"] else  l27 = LCL["KEYWORD"]["LINE"] end l25 = l27 end local l24 = l25; single_value();  local l28 = n if n ~= CL_LIB["XP-STRUCTURE-P"](l1) then  single_value();  l28 = CL_LIB["FUNCALL-LUA"]( CL_LIB["PPRINT-TAB+"].fbound, {l24, l6, l13, l1, }) else  local l29 = n if n ~= CL["TYPEP"](l1, CL_LIB["XP-STREAM"], false) then  single_value();  l29 = CL_LIB["FUNCALL-LUA"]( CL_LIB["PPRINT-TAB+"].fbound, {l24, l6, l13, LCL["CLOSETTE"]["SLOT-VALUE"](l1, CL_LIB["XP-STRUCTURE"]), }) else  l29 = n.bound end l28 = l29 end l21 = l28 else  local l30 = n if n ~= CL["NOT"](l2) then  single_value();  l30 = CL_LIB["PPRINT-TAB-NOT-PRETTY"](l1, l6, l13, l3) else  l30 = n.bound end l21 = l30 end return l21 end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-TAB"]; tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["PPRINT-TAB-NOT-PRETTY"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLNUM"],{CL_LIB["COLINC"],{CL["&OPTIONAL"],{CL_LIB["ATSIGN"],n}}}}},function (l1, l2, l3, l4,  ...)  if not l4 then  l4 = n.bound end  single_value();  local l5 = CL_LIB["COLUMN"](l1); single_value();  local l7 = n if n ~= l4 then  local l8 = n if n ~= l5 then  local l9 = n if n ~= CL["ZEROP"](l3) then  l9 = l2 else  l9 = (l2 + CL["MOD"](- (l5 + l2), l3)) end l8 = l9 else  l8 = l2 end l7 = l8 else  local l10 = n if n ~= l5 then  local l11 = n if n ~= CL["<="](l(l2,l5)) then  local l12 = n if n ~= CL["ZEROP"](l3) then  l12 = 0 else  l12 = (l3 - CL["MOD"]((l5 - l2), l3)) end l11 = l12 else  l11 = (l2 - l5) end l10 = l11 else  l10 = 2 end l7 = l10 end local l6 = l7; single_value();  single_value();  local l13 = CL["GENSYM"](false); single_value();  local l14 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  local l15 = CL["LIST"](l(n.bound)); single_value();  local l16 = CL["LIST"](l(n.bound)); single_value();  local l17 = l15; single_value();  local l18 = l15; single_value();  local l19 = l15; single_value();  single_value();  local l20 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l21; local l22; local l23;l21 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( l22[1], {}) end, 0, 0, false, false)};l22 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   i( CL["WRITE-STRING"]("                                                                                ", l1, k(CL_LIB["START"], 0, CL_LIB["END"], CL["MIN"](l(l6,80)))) );
 single_value();  l6 = (l6 - 80) i( l6 );
 single_value();  local l24 = n if n ~= CL[">"](l(l6,0)) then  l24 = n.bound else  single_value();  l24 = error({tag=CL["IDENTITY"](l19),(function () single_value() return unpack_mv(l23[1]) end)()}) end i( l24 );
 i( error({tag=CL["IDENTITY"](l18),(function () single_value() return unpack_mv(l22[1]) end)()}) );
 single_value();  return CL_LIB["FUNCALL-LUA"]( l23[1], {}) end, 0, 0, false, false)};l23 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l25 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  i( error({tag=CL["IDENTITY"](l13),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l25)) end)()}) );
 single_value();  return error({tag=CL["IDENTITY"](l16),(function () single_value() return unpack_mv(n) end)()}) end, 0, 0, false, false)}; single_value();  local l26 = l21[1]; single_value();  while true do  single_value();  local l27 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB['FUNCALL-LUA'](l26,{}) end, 0, 0, false, false))); single_value(); if l27.error ~= n and (l27.error ~= KEYWORD.TAG or l27.tag ~= l15) then if l27.error == KEYWORD.TAG then  error(l27) else error(l27[1]) end end l26 = CL["VALUES-LIST"](list_r(l27)) local tmpres = l26 end return n end, 0, 0, false, false))); single_value(); if l20.error ~= n and (l20.error ~= KEYWORD.TAG or l20.tag ~= l16) then if l20.error == KEYWORD.TAG then  error(l20) else error(l20[1]) end end return CL["VALUES-LIST"](list_r(l20)) end, 0, 0, false, false))); single_value(); if l14.error ~= n and (l14.error ~= KEYWORD.TAG or l14.tag ~= l13) then if l14.error == KEYWORD.TAG then  error(l14) else error(l14[1]) end end return CL["VALUES-LIST"](list_r(l14)) end, 3, 1, false, false)); i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("/"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   single_value();  local l5 = CL_LIB["*FORMAT-CONTROL-STRING*"].bound; single_value();  local l6 = CL["1+"](CL_LIB["*FORMAT-INDEX*"].bound); single_value();  local l7 = CL_LIB["%STR-MEMBER"](LCL['CL-LIB']['MAKE-CHAR']("/"), CL_LIB["*FORMAT-CONTROL-STRING*"].bound, l6, CL_LIB["*FORMAT-LENGTH*"].bound); single_value();  local l8 = n if n ~= CL["NOT"](l7) then  single_value();  l8 = CL_LIB["FORMAT-ERROR"]("Unmatched ~~/", l()) else  l8 = n.bound end i( l8 );
 single_value();  local l9 = CL_LIB["%STR-MEMBER"](LCL['CL-LIB']['MAKE-CHAR'](":"), CL_LIB["*FORMAT-CONTROL-STRING*"].bound, l6, l7); local l10 = n.bound; local l11 = n if n ~= l9 then  local l12 = CL["FIND-PACKAGE"](CL["STRING-UPCASE"](CL_LIB["FUNCALL-LUA"]( CL_LIB["%SUBSTR"].fbound, {l5, l6, l9, }), k())); single_value();  local l13 = n if n ~= l12 then  l13 = l12 else  l13 = CL_LIB["FORMAT-ERROR"]("Unknown package", l()) end l10 = l13 i( l10 );
 local l14 = n if n ~= CL["EQL"](LCL['CL-LIB']['MAKE-CHAR'](":"), CL["SCHAR"](l5, (1 + l9))) then  single_value();  l9 = (l9 + 1) l14 = l9 else  l14 = n.bound end i( l14 );
 single_value();  l6 = (l9 + 1) l11 = l6 else  local l15 = n if n ~= CL["T"].bound then  single_value();  l10 = CL["FIND-PACKAGE"]("CL-USER") l15 = l10 else  l15 = n.bound end l11 = l15 end i( l11 );
 single_value();  local l16 = CL["INTERN"](CL["STRING-UPCASE"](CL_LIB["FUNCALL-LUA"]( CL_LIB["%SUBSTR"].fbound, {l5, l6, l7, }), k()), l10); CL_LIB["*FORMAT-INDEX*"].bound = l7 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value();  return CL["APPLY"](l16, l1, l(CL_LIB["POP-FORMAT-ARG"](),l2,l3,l4)) end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-CALL-FUNCTION"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("("), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],n}}},function (l1, l2, l3,  ...)   i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  local l4 = n.bound; local l5 = n.bound; local l6 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l9 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l8 = l9; single_value();  single_value();  l4,l5= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND-NO-PARAMS"]({LCL['CL-LIB']['MAKE-CHAR'](")"),n}, k()), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l6 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l7.error ~= n and true then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end i( CL["VALUES-LIST"](list_r(l7)) );
 single_value();  local l10 = n.bound; local l11 = n if n ~= CL["TYPEP"](l1, CL_LIB["XP-STREAM"], false) then  single_value();  local l12 = LCL["CLOSETTE"]["SLOT-VALUE"](l1, CL_LIB["XP-STRUCTURE"]); local l14 = n if n ~= l2 then  l14 = l3 else  l14 = n.bound end local l13 = n if n ~= l14 then  single_value();  l13 = LCL["KEYWORD"]["UP"] else  local l15 = n if n ~= l2 then  single_value();  l15 = LCL["KEYWORD"]["CAP1"] else  local l16 = n if n ~= l3 then  single_value();  l16 = LCL["KEYWORD"]["CAP0"] else  local l17 = n if n ~= CL["T"].bound then  single_value();  l17 = LCL["KEYWORD"]["DOWN"] else  l17 = n.bound end l16 = l17 end l15 = l16 end l13 = l15 end i( CL_LIB["FUNCALL-LUA"]( CL_LIB["PUSH-CHAR-MODE"].fbound, {l12, l13, }) );
 local l18 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   i( CL_LIB["SUB-FORMAT"](l1, l4, l5) );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l18.error ~= n and (l18.error ~= KEYWORD.TAG or l18.tag ~= CL_LIB["FORMAT-ESCAPE"]) then if l18.error == KEYWORD.TAG then  error(l18) else error(l18[1]) end end l10 = CL["VALUES-LIST"](list_r(l18)) i( l10 );
 single_value();  l11 = CL_LIB["FUNCALL-LUA"]( CL_LIB["POP-CHAR-MODE"].fbound, {l12, }) else  local l19 = n if n ~= CL["T"].bound then  single_value();  local l21 = n.bound; single_value();  local l22 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  l21 = CL["MAKE-STRING-OUTPUT-STREAM"](k(CL_LIB["ELEMENT-TYPE"], CL["BASE-CHAR"])) i( l21 );
 local l23 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   i( CL_LIB["SUB-FORMAT"](l21, l4, l5) );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l23.error ~= n and (l23.error ~= KEYWORD.TAG or l23.tag ~= CL_LIB["FORMAT-ESCAPE"]) then if l23.error == KEYWORD.TAG then  error(l23) else error(l23[1]) end end l10 = CL["VALUES-LIST"](list_r(l23)) i( l10 );
 single_value();  return CL["GET-OUTPUT-STREAM-STRING"](l21) end, 0, 0, false, false))); local l25 = n if n ~= l21 then  l25 = CL["TYPEP"](l21, CL["FILE-STREAM"], false) else  l25 = n.bound end local l24 = n if n ~= l25 then  single_value();  l24 = CL["FILE-POSITION"](l21, 0) else  l24 = n.bound end i( l24 );
 single_value(); if l22.error ~= n and true then if l22.error == KEYWORD.TAG then  error(l22) else error(l22[1]) end end local l20 = CL["VALUES-LIST"](list_r(l22)); single_value();  single_value();  local l27 = n if n ~= l3 then  l27 = l2 else  l27 = n.bound end local l26 = n if n ~= l27 then  single_value();  l26 = CL["NSTRING-UPCASE"](l20, k()) else  local l28 = n if n ~= l2 then  single_value();  l28 = CL["NSTRING-CAPITALIZE"](l20, k()) else  local l29 = n if n ~= l3 then  i( CL["NSTRING-DOWNCASE"](l20, k()) );
 single_value();  local l30 = 0; single_value();  local l31 = CL["GENSYM"](false); single_value();  local l32 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l33 = n if n ~= CL[">="](l(l30,CL["LENGTH"](l20))) then  single_value(); do break end; l33 = n.bound else  l33 = n.bound end i( l33 );
 local l34 = CL["CHAR"](l20, l30); single_value();  local l35 = n if n ~= CL["ALPHA-CHAR-P"](l34) then  single_value();  local l36 = l30; single_value();  single_value();  local l37 = CL["CHAR-UPCASE"](l34); single_value();  l20 = CL_LIB["%SET-CHAR"](l20, l36, l37) i( l20 );
 single_value();  local l38 = CL["FUNCALL"](l, l(unpack_mv(l20))); single_value();  l35 = error({tag=CL["IDENTITY"](l31),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l38)) end)()}) else  l35 = n.bound end i( l35 );
 single_value();  local l39 = (1 + l30); single_value();  single_value();  single_value();  local l40 = l39; single_value();  l30 = l40 local tmpres = l30 end i( n );
 single_value();  return l20 end, 0, 0, false, false))); single_value(); if l32.error ~= n and (l32.error ~= KEYWORD.TAG or l32.tag ~= l31) then if l32.error == KEYWORD.TAG then  error(l32) else error(l32[1]) end end l29 = CL["VALUES-LIST"](list_r(l32)) else  local l41 = n if n ~= CL["T"].bound then  single_value();  l41 = CL["NSTRING-DOWNCASE"](l20, k()) else  l41 = n.bound end l29 = l41 end l28 = l29 end l26 = l28 end l19 = CL["WRITE-STRING"](l26, l1, k(CL_LIB["START"], 0, CL_LIB["END"], CL["LENGTH"](l20))) else  l19 = n.bound end l11 = l19 end i( l11 );
 single_value();  local l42 = n if n ~= l10 then  single_value();  l42 = error({tag=CL["IDENTITY"](CL_LIB["FORMAT-ESCAPE"]),(function () single_value() return unpack_mv(l10) end)()}) else  l42 = n.bound end return l42 end, 3, 0, false, false)) );
 single_value();  tmp = CL_LIB["FORMAT-CAPITALIZATION"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("^"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&OPTIONAL"],{CL_LIB["P1"],{CL_LIB["P2"],{CL_LIB["P3"],n}}}}}}},function (l1, l2, l3, l4, l5, l6,  ...)  if not l4 then  l4 = n.bound end if not l5 then  l5 = n.bound end if not l6 then  l6 = n.bound end  i( n.bound );
 local l7 = n if n ~= l3 then  single_value();  l7 = CL_LIB["FORMAT-ERROR"]("FORMAT command ~~~:[~;:~]@^ is undefined", l(l2)) else  l7 = n.bound end i( l7 );
 single_value();  local l9 = n if n ~= l6 then  single_value();  local l10 = l5; single_value();  local l11 = n if n ~= CL["TYPEP"](l10, CL_LIB["REAL"], false) then  single_value();  l11 = CL["<="](l(l4,l5,l6)) else  local l12 = n if n ~= CL["TYPEP"](l10, CL["CHARACTER"], false) then  single_value();  l12 = CL["CHAR<"](l4, l(l5,l6)) else  local l13 = n if n ~= CL["TYPEP"](l10, CL["T"], false) then  single_value();  l13 = CL["ERROR"]("etypecase, no matching branches", l()) else  l13 = n.bound end l12 = l13 end l11 = l12 end l9 = l11 else  local l14 = n if n ~= l5 then  single_value();  l14 = CL["EQUAL"](l4, l5) else  local l15 = n if n ~= l4 then  single_value();  l15 = CL["EQL"](l4, 0) else  local l16 = n if n ~= CL["T"].bound then  single_value();  local l17 = n if n ~= l2 then  l17 = CL_LIB["*FORMAT-COLON-REST*"].bound else  l17 = CL_LIB["*FORMAT-ARGUMENTS*"].bound end l16 = CL["NULL"](l17) else  l16 = n.bound end l15 = l16 end l14 = l15 end l9 = l14 end local l8 = n if n ~= l9 then  single_value();  local l18 = n if n ~= l2 then  l18 = CL_LIB["FORMAT-COLON-ESCAPE"] else  l18 = CL["T"].bound end l8 = error({tag=CL["IDENTITY"](CL_LIB["FORMAT-ESCAPE"]),(function () single_value() return unpack_mv(l18) end)()}) else  l8 = n.bound end return l8 end, 3, 3, false, false)) );
 single_value();  tmp = CL_LIB["FORMAT-ESCAPE"]; tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-UNTAGGED-CONDITION"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l1,  ...)   single_value();  local l2 = CL["GENSYM"](false); single_value();  local l3 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l4 = CL_LIB["POP-FORMAT-ARG"](); local l5 = n if n ~= CL["INTEGERP"](l4) then  l5 = n.bound else  single_value();  l5 = CL_LIB["FORMAT-ERROR"]("Argument to ~~[ must be integer - ~S", l(l4)) end i( l5 );
 single_value();  local l6 = 0; single_value();  local l7 = CL["GENSYM"](false); single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l9 = n if n ~= CL["EQ"](l6, l4) then  single_value(); do break end; l9 = n.bound else  l9 = n.bound end i( l9 );
 local l10 = n.bound; local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = n.bound; local l15 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l16 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l18 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l17 = l18; single_value();  single_value();  l10,l11,l12,l13,l14= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND-NO-PARAMS"]({LCL['CL-LIB']['MAKE-CHAR'](";"),{LCL['CL-LIB']['MAKE-CHAR']("]"),n}}, k(CL_LIB["ATSIGN"], n.bound)), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l15 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l16.error ~= n and true then if l16.error == KEYWORD.TAG then  error(l16) else error(l16[1]) end end i( CL["VALUES-LIST"](list_r(l16)) );
 i( n.bound );
 local l19 = n if n ~= CL["EQ"](l12, LCL['CL-LIB']['MAKE-CHAR']("]")) then  single_value();  local l20 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l19 = error({tag=CL["IDENTITY"](l2),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l20)) end)()}) else  l19 = n.bound end i( l19 );
 i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  local l21 = n if n ~= l13 then  local l22 = n.bound; local l23 = n.bound; local l24 = n.bound; local l25 = n.bound; local l26 = n.bound; local l27 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l28 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l30 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l29 = l30; single_value();  single_value();  l22,l23,l24,l25,l26= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND-NO-PARAMS"]({LCL['CL-LIB']['MAKE-CHAR'](";"),{LCL['CL-LIB']['MAKE-CHAR']("]"),n}}, k()), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l27 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l28.error ~= n and true then if l28.error == KEYWORD.TAG then  error(l28) else error(l28[1]) end end i( CL["VALUES-LIST"](list_r(l28)) );
 i( n.bound );
 i( CL_LIB["SUB-FORMAT"](l1, l22, l23) );
 single_value();  local l31 = n if n ~= CL["EQ"](l24, LCL['CL-LIB']['MAKE-CHAR']("]")) then  l31 = n.bound else  single_value();  l31 = CL_LIB["FORMAT-FIND-COMMAND-NO-PARAMS"]({LCL['CL-LIB']['MAKE-CHAR']("]"),n}, k()) end i( l31 );
 single_value();  local l32 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l21 = error({tag=CL["IDENTITY"](l2),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l32)) end)()}) else  l21 = n.bound end i( l21 );
 single_value();  local l33 = CL["1+"](l6); single_value();  single_value();  single_value();  local l34 = l33; single_value();  l6 = l34 local tmpres = l6 end i( n );
 single_value();  local l35 = n.bound; local l36 = n.bound; local l37 = n.bound; local l38 = n.bound; local l39 = n.bound; local l40 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l41 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l43 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l42 = l43; single_value();  single_value();  l35,l36,l37,l38,l39= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND-NO-PARAMS"]({LCL['CL-LIB']['MAKE-CHAR'](";"),{LCL['CL-LIB']['MAKE-CHAR']("]"),n}}, k(CL_LIB["ATSIGN"], n.bound)), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l40 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l41.error ~= n and true then if l41.error == KEYWORD.TAG then  error(l41) else error(l41[1]) end end i( CL["VALUES-LIST"](list_r(l41)) );
 i( n.bound );
 i( CL_LIB["SUB-FORMAT"](l1, l35, l36) );
 single_value();  local l44 = n if n ~= CL["EQ"](l37, LCL['CL-LIB']['MAKE-CHAR']("]")) then  l44 = n.bound else  single_value();  l44 = CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR']("]"),n}, false, false) end return l44 end, 0, 0, false, false))); single_value(); if l8.error ~= n and (l8.error ~= KEYWORD.TAG or l8.tag ~= l7) then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end return CL["VALUES-LIST"](list_r(l8)) end, 0, 0, false, false))); single_value(); if l3.error ~= n and (l3.error ~= KEYWORD.TAG or l3.tag ~= l2) then if l3.error == KEYWORD.TAG then  error(l3) else error(l3[1]) end end return CL["VALUES-LIST"](list_r(l3)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-FUNNY-CONDITION"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l5 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l6 = l7; single_value();  single_value();  l2,l3= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND-NO-PARAMS"]({LCL['CL-LIB']['MAKE-CHAR']("]"),n}, k()), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l4 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l5.error ~= n and true then if l5.error == KEYWORD.TAG then  error(l5) else error(l5[1]) end end i( CL["VALUES-LIST"](list_r(l5)) );
 single_value();  local l8 = n if n ~= CL_LIB["*FORMAT-ARGUMENTS*"].bound then  local l9 = n if n ~= (CL_LIB["*FORMAT-ARGUMENTS*"].bound)[1] then  l9 = CL_LIB["SUB-FORMAT"](l1, l2, l3) else  local l10 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  CL_LIB["*FORMAT-ARGUMENTS*"].bound = l12 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  l9 = l11 end l8 = l9 else  l8 = CL_LIB["FORMAT-ERROR"]("Missing argument", l()) end return l8 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-BOOLEAN-CONDITION"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],n},function (l1,  ...)   single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l8 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l7 = l8; single_value();  single_value();  l2,l3,l4= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND-NO-PARAMS"]({LCL['CL-LIB']['MAKE-CHAR'](";"),{LCL['CL-LIB']['MAKE-CHAR']("]"),n}}, k()), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l5 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l6.error ~= n and true then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end i( CL["VALUES-LIST"](list_r(l6)) );
 local l9 = n if n ~= CL["EQ"](l4, LCL['CL-LIB']['MAKE-CHAR']("]")) then  single_value();  l9 = CL_LIB["FORMAT-ERROR"]("Two clauses separated by ~~; are required for ~~:[", l()) else  l9 = n.bound end i( l9 );
 i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  local l10 = n if n ~= CL_LIB["POP-FORMAT-ARG"]() then  local l11 = n.bound; local l12 = n.bound; local l13 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l14 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l16 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l15 = l16; single_value();  single_value();  l11,l12= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND-NO-PARAMS"]({LCL['CL-LIB']['MAKE-CHAR']("]"),n}, k(CL_LIB["COLON"], n.bound, CL_LIB["ATSIGN"], n.bound)), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l13 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l14.error ~= n and true then if l14.error == KEYWORD.TAG then  error(l14) else error(l14[1]) end end i( CL["VALUES-LIST"](list_r(l14)) );
 single_value();  l10 = CL_LIB["SUB-FORMAT"](l1, l11, l12) else  i( CL_LIB["SUB-FORMAT"](l1, l2, l3) );
 single_value();  l10 = CL_LIB["FORMAT-FIND-COMMAND-NO-PARAMS"]({LCL['CL-LIB']['MAKE-CHAR']("]"),n}, k()) end return l10 end, 1, 0, false, false)); i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("["), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&OPTIONAL"],{CL_LIB["P"],n}}}}},function (l1, l2, l3, l4,  ...)  if not l4 then  l4 = n.bound end  local l5 = n if n ~= l4 then  single_value();  single_value();  single_value();  local l6 = CL["CONS"](l4, CL_LIB["*FORMAT-ARGUMENTS*"].bound); single_value();  CL_LIB["*FORMAT-ARGUMENTS*"].bound = l6 l5 = CL_LIB["*FORMAT-ARGUMENTS*"].bound else  l5 = n.bound end i( l5 );
 i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  local l7 = n if n ~= l2 then  local l8 = n if n ~= l3 then  single_value();  l8 = CL_LIB["FORMAT-ERROR"]("~~:@[ undefined", l()) else  l8 = n.bound end i( l8 );
 single_value();  l7 = CL_LIB["FORMAT-BOOLEAN-CONDITION"](l1) else  local l9 = n if n ~= l3 then  single_value();  l9 = CL_LIB["FORMAT-FUNNY-CONDITION"](l1) else  local l10 = n if n ~= CL["T"].bound then  single_value();  l10 = CL_LIB["FORMAT-UNTAGGED-CONDITION"](l1) else  l10 = n.bound end l9 = l10 end l7 = l9 end return l7 end, 3, 1, false, false)) );
 single_value();  tmp = CL_LIB["FORMAT-CONDITION"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("{"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 single_value();  local l7 = n if n ~= l4 then  local l8 = l4; single_value();  local l9 = (l8)[1]; single_value();  single_value();  local l10 = (l8)[2]; single_value();  l4 = l10 i( l4 );
 single_value();  l7 = l9 else  l7 = n.bound end local l6 = l7; single_value();  local l11 = n if n ~= l6 then  l11 = l6 else  l11 = -1 end local l5 = l11; local l12 = n if n ~= l4 then  single_value();  l12 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l12 = n.bound end i( l12 );
 i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  local l13 = n.bound; local l14 = n.bound; local l15 = n.bound; local l16 = n.bound; local l17 = n.bound; local l18 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l19 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l21 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l20 = l21; single_value();  single_value();  l13,l14,l15,l16,l17= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND-NO-PARAMS"]({LCL['CL-LIB']['MAKE-CHAR']("}"),n}, k(CL_LIB["ATSIGN"], n.bound)), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l18 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l19.error ~= n and true then if l19.error == KEYWORD.TAG then  error(l19) else error(l19[1]) end end i( CL["VALUES-LIST"](list_r(l19)) );
 i( n.bound );
 single_value();  local l22 = n if n ~= CL["EQ"](l13, l14) then  local l23 = CL_LIB["POP-FORMAT-ARG"](); local l24 = n if n ~= CL["STRINGP"](l23) then  single_value();  local l25 = n if n ~= CL["NOT"](CL["SIMPLE-STRING-P"](l23)) then  single_value();  l23 = CL["COERCE"](l23, CL["SIMPLE-STRING"]) l25 = l23 else  l25 = n.bound end l24 = l25 else  local l26 = n if n ~= CL["NOT"](CL["FUNCTIONP"](l23)) then  single_value();  l26 = CL_LIB["FORMAT-ERROR"]("Control string is not a string or function", l()) else  l26 = n.bound end l24 = l26 end i( l24 );
 single_value();  local l28 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l29 = n if n ~= CL["STRINGP"](l23) then  single_value();  local l30 = CL["LENGTH"](l23); single_value();  local l31 = CL_LIB["*FORMAT-CONTROL-STRING*"].bound; single_value();  local l32 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l34 = CL_LIB["*FORMAT-CONTROL-STRING*"].bound; CL_LIB["*FORMAT-CONTROL-STRING*"].bound = l23 i( CL_LIB["*FORMAT-CONTROL-STRING*"].bound );
 single_value();  local l33 = l34; single_value();  single_value();  local l35 = CL_LIB["*FORMAT-LENGTH*"].bound; single_value();  local l36 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l38 = CL_LIB["*FORMAT-LENGTH*"].bound; CL_LIB["*FORMAT-LENGTH*"].bound = l30 i( CL_LIB["*FORMAT-LENGTH*"].bound );
 single_value();  local l37 = l38; single_value();  single_value();  local l39 = CL_LIB["*FORMAT-INDEX*"].bound; single_value();  local l40 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l42 = CL_LIB["*FORMAT-INDEX*"].bound; CL_LIB["*FORMAT-INDEX*"].bound = 0 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value();  local l41 = l42; single_value();  single_value();  single_value();  return CL_LIB["FORMAT-DO-ITERATION"](l1, 0, l30, l5, l2, l3, l16) end, 0, 0, false, false))); CL_LIB["*FORMAT-INDEX*"].bound = l39 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value(); if l40.error ~= n and true then if l40.error == KEYWORD.TAG then  error(l40) else error(l40[1]) end end return CL["VALUES-LIST"](list_r(l40)) end, 0, 0, false, false))); CL_LIB["*FORMAT-LENGTH*"].bound = l35 i( CL_LIB["*FORMAT-LENGTH*"].bound );
 single_value(); if l36.error ~= n and true then if l36.error == KEYWORD.TAG then  error(l36) else error(l36[1]) end end return CL["VALUES-LIST"](list_r(l36)) end, 0, 0, false, false))); CL_LIB["*FORMAT-CONTROL-STRING*"].bound = l31 i( CL_LIB["*FORMAT-CONTROL-STRING*"].bound );
 single_value(); if l32.error ~= n and true then if l32.error == KEYWORD.TAG then  error(l32) else error(l32[1]) end end l29 = CL["VALUES-LIST"](list_r(l32)) else  local l43 = n if n ~= CL["T"].bound then  single_value();  l43 = CL_LIB["FORMAT-DO-ITERATION"](l1, l23, n.bound, l5, l2, l3, l16) else  l43 = n.bound end l29 = l43 end i( l29 );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l28.error ~= n and (l28.error ~= KEYWORD.TAG or l28.tag ~= CL_LIB["FORMAT-ERROR"]) then if l28.error == KEYWORD.TAG then  error(l28) else error(l28[1]) end end local l27 = CL["VALUES-LIST"](list_r(l28)); single_value();  local l44 = n if n ~= l27 then  single_value();  l44 = error({tag=CL["IDENTITY"](CL_LIB["FORMAT-ERROR"]),(function () single_value() return unpack_mv(CL["CONS"](CL["LIST"](l("While processing indirect control string~%~S~%~V@T^",CL_LIB["*FORMAT-CONTROL-STRING*"].bound,CL["1+"](CL_LIB["*FORMAT-INDEX*"].bound))), l27)) end)()}) else  l44 = n.bound end l22 = l44 else  l22 = CL_LIB["FORMAT-DO-ITERATION"](l1, l13, l14, l5, l2, l3, l16) end return l22 end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-ITERATION"]; tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-DO-ITERATION"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["START"],{CL_LIB["END"],{CL_LIB["MAX-ITER"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL_LIB["AT-LEAST-ONCE-P"],n}}}}}}},function (l1, l2, l3, l4, l5, l6, l7,  ...)   single_value();  local l8;l8 = CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["START"],{CL_LIB["END"],{CL_LIB["COLON"],{CL_LIB["AT-LEAST-ONCE-P"],n}}}}},function (l9, l10, l11, l12, l13,  ...)   single_value();  local l14 = n.bound; single_value();  local l15 = 0; single_value();  single_value();  local l16 = CL["GENSYM"](false); single_value();  local l17 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  local l19 = CL["EQ"](l15, l4); single_value();  local l20 = n if n ~= l19 then  l20 = l19 else  local l21 = n if n ~= CL["NULL"](CL_LIB["*FORMAT-ARGUMENTS*"].bound) then  local l22 = n if n ~= CL["EQ"](l15, 0) then  l22 = CL["NOT"](l13) else  l22 = CL["T"].bound end l21 = l22 else  l21 = n.bound end l20 = l21 end local l18 = n if n ~= l20 then  single_value(); do break end; l18 = n.bound else  l18 = n.bound end i( l18 );
 local l23 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l24 = n if n ~= l12 then  local l27 = n if n ~= l13 then  l27 = CL["NULL"](CL_LIB["*FORMAT-ARGUMENTS*"].bound) else  l27 = n.bound end local l26 = n if n ~= l27 then  l26 = n.bound else  single_value();  l26 = CL_LIB["POP-FORMAT-ARG"]() end local l25 = l26; single_value();  local l28 = CL_LIB["*FORMAT-TOP-LEVEL*"].bound; single_value();  local l29 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l31 = CL_LIB["*FORMAT-TOP-LEVEL*"].bound; CL_LIB["*FORMAT-TOP-LEVEL*"].bound = n.bound i( CL_LIB["*FORMAT-TOP-LEVEL*"].bound );
 single_value();  local l30 = l31; single_value();  single_value();  local l32 = CL_LIB["*FORMAT-COLON-REST*"].bound; single_value();  local l33 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l35 = CL_LIB["*FORMAT-COLON-REST*"].bound; CL_LIB["*FORMAT-COLON-REST*"].bound = CL_LIB["*FORMAT-ARGUMENTS*"].bound i( CL_LIB["*FORMAT-COLON-REST*"].bound );
 single_value();  local l34 = l35; single_value();  single_value();  local l36 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; single_value();  local l37 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l39 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; CL_LIB["*FORMAT-ARGUMENTS*"].bound = l25 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  local l38 = l39; single_value();  single_value();  local l40 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; single_value();  local l41 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l43 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound = l25 i( CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound );
 single_value();  local l42 = l43; single_value();  single_value();  local l44 = n if n ~= CL["LISTP"](CL_LIB["*FORMAT-ARGUMENTS*"].bound) then  l44 = n.bound else  single_value();  l44 = CL_LIB["FUNCALL-LUA"]( CL_LIB["REPORT-BAD-ARG"].fbound, {CL_LIB["*FORMAT-ARGUMENTS*"].bound, CL["LIST"], }) end i( l44 );
 single_value();  local l45 = n if n ~= CL["FUNCTIONP"](l10) then  l45 = CL["APPLY"](l10, l9, l(l25)) else  l45 = CL_LIB["SUB-FORMAT"](l9, l10, l11) end return l45 end, 0, 0, false, false))); CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound = l40 i( CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound );
 single_value(); if l41.error ~= n and true then if l41.error == KEYWORD.TAG then  error(l41) else error(l41[1]) end end return CL["VALUES-LIST"](list_r(l41)) end, 0, 0, false, false))); CL_LIB["*FORMAT-ARGUMENTS*"].bound = l36 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value(); if l37.error ~= n and true then if l37.error == KEYWORD.TAG then  error(l37) else error(l37[1]) end end return CL["VALUES-LIST"](list_r(l37)) end, 0, 0, false, false))); CL_LIB["*FORMAT-COLON-REST*"].bound = l32 i( CL_LIB["*FORMAT-COLON-REST*"].bound );
 single_value(); if l33.error ~= n and true then if l33.error == KEYWORD.TAG then  error(l33) else error(l33[1]) end end return CL["VALUES-LIST"](list_r(l33)) end, 0, 0, false, false))); CL_LIB["*FORMAT-TOP-LEVEL*"].bound = l28 i( CL_LIB["*FORMAT-TOP-LEVEL*"].bound );
 single_value(); if l29.error ~= n and true then if l29.error == KEYWORD.TAG then  error(l29) else error(l29[1]) end end l24 = CL["VALUES-LIST"](list_r(l29)) else  local l46 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; single_value();  local l47 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l49 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound = CL_LIB["*FORMAT-ARGUMENTS*"].bound i( CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound );
 single_value();  local l48 = l49; single_value();  single_value();  local l50 = n if n ~= CL["FUNCTIONP"](l10) then  CL_LIB["*FORMAT-ARGUMENTS*"].bound = CL["APPLY"](l10, l9, l(CL_LIB["*FORMAT-ARGUMENTS*"].bound)) l50 = CL_LIB["*FORMAT-ARGUMENTS*"].bound else  l50 = CL_LIB["SUB-FORMAT"](l9, l10, l11) end return l50 end, 0, 0, false, false))); CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound = l46 i( CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound );
 single_value(); if l47.error ~= n and true then if l47.error == KEYWORD.TAG then  error(l47) else error(l47[1]) end end l24 = CL["VALUES-LIST"](list_r(l47)) end i( l24 );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l23.error ~= n and (l23.error ~= KEYWORD.TAG or l23.tag ~= CL_LIB["FORMAT-ESCAPE"]) then if l23.error == KEYWORD.TAG then  error(l23) else error(l23[1]) end end l14 = CL["VALUES-LIST"](list_r(l23)) i( l14 );
 local l52 = CL["EQ"](l14, CL_LIB["FORMAT-COLON-ESCAPE"]); single_value();  local l53 = n if n ~= l52 then  l53 = l52 else  local l54 = n if n ~= l14 then  l54 = CL["NULL"](l12) else  l54 = n.bound end l53 = l54 end local l51 = n if n ~= l53 then  single_value();  local l55 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l51 = error({tag=CL["IDENTITY"](l16),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l55)) end)()}) else  l51 = n.bound end i( l51 );
 single_value();  single_value();  single_value();  local l56 = CL["1+"](l15); single_value();  l15 = l56 local tmpres = l15 end return n end, 0, 0, false, false))); single_value(); if l17.error ~= n and (l17.error ~= KEYWORD.TAG or l17.tag ~= l16) then if l17.error == KEYWORD.TAG then  error(l17) else error(l17[1]) end end return CL["VALUES-LIST"](list_r(l17)) end, 5, 0, false, false); single_value();  local l57 = n if n ~= l6 then  l57 = CL_LIB["FUNCALL-LUA"]( l8, {l1, l2, l3, l5, l7, }) else  local l58 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; single_value();  local l59 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l61 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; CL_LIB["*FORMAT-ARGUMENTS*"].bound = CL_LIB["POP-FORMAT-ARG"]() i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  local l60 = l61; single_value();  single_value();  local l62 = CL_LIB["*FORMAT-TOP-LEVEL*"].bound; single_value();  local l63 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l65 = CL_LIB["*FORMAT-TOP-LEVEL*"].bound; CL_LIB["*FORMAT-TOP-LEVEL*"].bound = n.bound i( CL_LIB["*FORMAT-TOP-LEVEL*"].bound );
 single_value();  local l64 = l65; single_value();  single_value();  local l66 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; single_value();  local l67 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l69 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound = CL_LIB["*FORMAT-ARGUMENTS*"].bound i( CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound );
 single_value();  local l68 = l69; single_value();  single_value();  local l70 = n if n ~= CL["LISTP"](CL_LIB["*FORMAT-ARGUMENTS*"].bound) then  l70 = n.bound else  single_value();  l70 = CL_LIB["FUNCALL-LUA"]( CL_LIB["REPORT-BAD-ARG"].fbound, {CL_LIB["*FORMAT-ARGUMENTS*"].bound, CL["LIST"], }) end i( l70 );
 single_value();  return CL_LIB["FUNCALL-LUA"]( l8, {l1, l2, l3, l5, l7, }) end, 0, 0, false, false))); CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound = l66 i( CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound );
 single_value(); if l67.error ~= n and true then if l67.error == KEYWORD.TAG then  error(l67) else error(l67[1]) end end return CL["VALUES-LIST"](list_r(l67)) end, 0, 0, false, false))); CL_LIB["*FORMAT-TOP-LEVEL*"].bound = l62 i( CL_LIB["*FORMAT-TOP-LEVEL*"].bound );
 single_value(); if l63.error ~= n and true then if l63.error == KEYWORD.TAG then  error(l63) else error(l63[1]) end end return CL["VALUES-LIST"](list_r(l63)) end, 0, 0, false, false))); CL_LIB["*FORMAT-ARGUMENTS*"].bound = l58 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value(); if l59.error ~= n and true then if l59.error == KEYWORD.TAG then  error(l59) else error(l59[1]) end end l57 = CL["VALUES-LIST"](list_r(l59)) end return l57 end, 7, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-GET-TRAILING-SEGMENTS"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  local l1 = n.bound; local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l1,l2,l3,l4,l5,l6= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](";"),{LCL['CL-LIB']['MAKE-CHAR'](">"),n}}, n.bound, CL["T"].bound), 6) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 local l11 = n if n ~= l3 then  single_value();  l11 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l11 = n.bound end i( l11 );
 local l12 = n if n ~= l4 then  single_value();  l12 = CL_LIB["FORMAT-ERROR"]("~~:; allowed only after first segment in ~~<", l()) else  l12 = n.bound end i( l12 );
 single_value();  i( CL_LIB["FORMAT-NO-FLAGS"](n.bound, l5) );
 single_value();  local l14 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l15 = n.bound; single_value();  local l16 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  l15 = CL["MAKE-STRING-OUTPUT-STREAM"](k(CL_LIB["ELEMENT-TYPE"], CL["BASE-CHAR"])) i( l15 );
 i( CL_LIB["SUB-FORMAT"](l15, l1, l2) );
 single_value();  return CL["GET-OUTPUT-STREAM-STRING"](l15) end, 0, 0, false, false))); local l18 = n if n ~= l15 then  l18 = CL["TYPEP"](l15, CL["FILE-STREAM"], false) else  l18 = n.bound end local l17 = n if n ~= l18 then  single_value();  l17 = CL["FILE-POSITION"](l15, 0) else  l17 = n.bound end i( l17 );
 single_value(); if l16.error ~= n and true then if l16.error == KEYWORD.TAG then  error(l16) else error(l16[1]) end end return CL["VALUES-LIST"](list_r(l16)) end, 0, 0, false, false))); single_value(); if l14.error ~= n and (l14.error ~= KEYWORD.TAG or l14.tag ~= CL_LIB["FORMAT-ESCAPE"]) then if l14.error == KEYWORD.TAG then  error(l14) else error(l14[1]) end end local l13 = CL["VALUES-LIST"](list_r(l14)); single_value();  local l19 = n if n ~= CL["STRINGP"](l13) then  local l20 = n if n ~= CL["EQ"](l6, LCL['CL-LIB']['MAKE-CHAR'](";")) then  local l21 = n.bound; local l22 = n.bound; local l23 = n.bound; local l24 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l25 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l27 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l26 = l27; single_value();  single_value();  l21,l22,l23= unpack_mv(CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-GET-TRAILING-SEGMENTS"].fbound, {}), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l24 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l25.error ~= n and true then if l25.error == KEYWORD.TAG then  error(l25) else error(l25[1]) end end i( CL["VALUES-LIST"](list_r(l25)) );
 single_value();  l20 = CL["VALUES"](l(CL["CONS"](l13, l21),CL["1+"](l22),(l23 + CL["LENGTH"](l13)))) else  l20 = CL["VALUES"](l(CL["LIST"](l(l13)),1,CL["LENGTH"](l13))) end l19 = l20 else  local l28 = n if n ~= CL["EQ"](l6, LCL['CL-LIB']['MAKE-CHAR'](">")) then  l28 = n.bound else  single_value();  l28 = CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](">"),n}, n.bound, CL["T"].bound) end i( l28 );
 single_value();  l19 = CL["VALUES"](l(n.bound,0,0)) end return l19 end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-GET-SEGMENTS"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l1 = n.bound; i( n.bound );
 single_value();  local l2 = n.bound; local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = n.bound; local l8 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l9 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l11 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l10 = l11; single_value();  single_value();  l2,l3,l4,l5,l6,l7= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](";"),{LCL['CL-LIB']['MAKE-CHAR'](">"),n}}, n.bound, CL["T"].bound), 6) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l8 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l9.error ~= n and true then if l9.error == KEYWORD.TAG then  error(l9) else error(l9[1]) end end i( CL["VALUES-LIST"](list_r(l9)) );
 local l12 = n if n ~= l6 then  single_value();  l12 = CL_LIB["FORMAT-ERROR"]("Atsign flag not allowed", l()) else  l12 = n.bound end i( l12 );
 single_value();  local l14 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l15 = n.bound; single_value();  local l16 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  l15 = CL["MAKE-STRING-OUTPUT-STREAM"](k(CL_LIB["ELEMENT-TYPE"], CL["BASE-CHAR"])) i( l15 );
 i( CL_LIB["SUB-FORMAT"](l15, l2, l3) );
 single_value();  return CL["GET-OUTPUT-STREAM-STRING"](l15) end, 0, 0, false, false))); local l18 = n if n ~= l15 then  l18 = CL["TYPEP"](l15, CL["FILE-STREAM"], false) else  l18 = n.bound end local l17 = n if n ~= l18 then  single_value();  l17 = CL["FILE-POSITION"](l15, 0) else  l17 = n.bound end i( l17 );
 single_value(); if l16.error ~= n and true then if l16.error == KEYWORD.TAG then  error(l16) else error(l16[1]) end end return CL["VALUES-LIST"](list_r(l16)) end, 0, 0, false, false))); single_value(); if l14.error ~= n and (l14.error ~= KEYWORD.TAG or l14.tag ~= CL_LIB["FORMAT-ESCAPE"]) then if l14.error == KEYWORD.TAG then  error(l14) else error(l14[1]) end end local l13 = CL["VALUES-LIST"](list_r(l14)); single_value();  local l19 = n if n ~= CL["STRINGP"](l13) then  local l20 = n if n ~= CL["EQ"](l7, LCL['CL-LIB']['MAKE-CHAR'](";")) then  local l21 = n if n ~= l4 then  CL_LIB["*FORMAT-INDEX*"].bound = l3 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value();  local l22 = n.bound; local l23 = n.bound; local l24 = n.bound; local l25 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l26 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l28 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l27 = l28; single_value();  single_value();  l22,l23,l24= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](";"),{LCL['CL-LIB']['MAKE-CHAR'](">"),n}}, CL["T"].bound, CL["T"].bound), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l25 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l26.error ~= n and true then if l26.error == KEYWORD.TAG then  error(l26) else error(l26[1]) end end i( CL["VALUES-LIST"](list_r(l26)) );
 l1 = l22 i( l1 );
 l1 = l23 i( l1 );
 single_value();  l4 = l24 l21 = l4 else  l21 = n.bound end i( l21 );
 single_value();  local l29 = n.bound; local l30 = n.bound; local l31 = n.bound; local l32 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l33 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l35 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l34 = l35; single_value();  single_value();  l29,l30,l31= unpack_mv(CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-GET-TRAILING-SEGMENTS"].fbound, {}), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l32 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l33.error ~= n and true then if l33.error == KEYWORD.TAG then  error(l33) else error(l33[1]) end end i( CL["VALUES-LIST"](list_r(l33)) );
 single_value();  local l36 = n if n ~= l5 then  l36 = CL["VALUES"](l(l13,l4,l29,l30,l31)) else  l36 = CL["VALUES"](l(n.bound,n.bound,CL["CONS"](l13, l29),CL["1+"](l30),(CL["LENGTH"](l13) + l31))) end l20 = l36 else  l20 = CL["VALUES"](l(n.bound,n.bound,CL["LIST"](l(l13)),1,CL["LENGTH"](l13))) end l19 = l20 else  local l37 = n if n ~= CL["EQ"](l7, LCL['CL-LIB']['MAKE-CHAR'](">")) then  l37 = n.bound else  single_value();  l37 = CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](">"),n}, n.bound, CL["T"].bound) end i( l37 );
 single_value();  l19 = CL["VALUES"](l(n.bound,n.bound,n.bound,0,0)) end return l19 end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["MAKE-PAD-SEGS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["SPACES"],{CL_LIB["SEGMENTS"],n}},function (l1, l2,  ...)   single_value();  local l3 = n.bound; local l4 = n.bound; local l5 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l8 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l7 = l8; single_value();  single_value();  l3,l4= unpack_mv(CL["TRUNCATE"](l1, l2), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l5 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l6.error ~= n and true then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end i( CL["VALUES-LIST"](list_r(l6)) );
 i( n.bound );
 single_value();  local l9 = CL["MAKE-LIST"](l2, k(CL_LIB["INITIAL-ELEMENT"], l3)); single_value();  local l10 = l9; single_value();  l3 = CL["1+"](l3) i( l3 );
 local l11 = 0; single_value();  local l12 = CL["GENSYM"](false); single_value();  local l13 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l14 = n if n ~= CL[">="](l(l11,l4)) then  single_value(); do break end; l14 = n.bound else  l14 = n.bound end i( l14 );
 i( CL["RPLACA"](l10, l3) );
 l10 = (l10)[2] i( l10 );
 single_value();  local l15 = (1 + l11); single_value();  single_value();  single_value();  local l16 = l15; single_value();  l11 = l16 local tmpres = l11 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l13.error ~= n and (l13.error ~= KEYWORD.TAG or l13.tag ~= l12) then if l13.error == KEYWORD.TAG then  error(l13) else error(l13[1]) end end i( CL["VALUES-LIST"](list_r(l13)) );
 single_value();  return l9 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-ROUND-COLUMNS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["WIDTH"],{CL_LIB["MINCOL"],{CL_LIB["COLINC"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = n if n ~= CL_LIB["%<"](l1, l2) then  l4 = (l1 + (l3 * CL["CEILING"]((l2 - l1), l3))) else  l4 = l1 end return l4 end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-JUSTIFICATION-ROUND-COLUMNS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["WIDTH"],{CL_LIB["MINCOL"],{CL_LIB["COLINC"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = n if n ~= CL_LIB["%<"](l1, l2) then  l4 = l2 else  l4 = (l2 + (l3 * CL["CEILING"]((l1 - l2), l3))) end return l4 end, 3, 0, false, false)); i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("<"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 single_value();  local l5 = n.bound; local l6 = n.bound; local l7 = n.bound; local l8 = n.bound; local l9 = n.bound; local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l13 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l12 = l13; single_value();  single_value();  l5,l6,l7,l8,l9= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND-NO-PARAMS"]({LCL['CL-LIB']['MAKE-CHAR'](">"),n}, k()), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l10 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l11.error ~= n and true then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end i( CL["VALUES-LIST"](list_r(l11)) );
 i( n.bound );
 single_value();  local l14 = n if n ~= l8 then  single_value();  l14 = CL_LIB["FORMAT-LOGICAL-BLOCK"](l1, l2, l3, l9, l5, CL_LIB["*FORMAT-INDEX*"].bound, l(l4)) else  local l15 = n if n ~= CL["T"].bound then  CL_LIB["*FORMAT-INDEX*"].bound = l5 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value();  local l18 = n if n ~= l4 then  local l19 = l4; single_value();  local l20 = (l19)[1]; single_value();  single_value();  local l21 = (l19)[2]; single_value();  l4 = l21 i( l4 );
 single_value();  l18 = l20 else  l18 = n.bound end local l17 = l18; single_value();  local l22 = n if n ~= l17 then  l22 = l17 else  l22 = 0 end local l16 = l22; local l25 = n if n ~= l4 then  local l26 = l4; single_value();  local l27 = (l26)[1]; single_value();  single_value();  local l28 = (l26)[2]; single_value();  l4 = l28 i( l4 );
 single_value();  l25 = l27 else  l25 = n.bound end local l24 = l25; single_value();  local l29 = n if n ~= l24 then  l29 = l24 else  l29 = 1 end local l23 = l29; local l32 = n if n ~= l4 then  local l33 = l4; single_value();  local l34 = (l33)[1]; single_value();  single_value();  local l35 = (l33)[2]; single_value();  l4 = l35 i( l4 );
 single_value();  l32 = l34 else  l32 = n.bound end local l31 = l32; single_value();  local l36 = n if n ~= l31 then  l36 = l31 else  l36 = 0 end local l30 = l36; local l39 = n if n ~= l4 then  local l40 = l4; single_value();  local l41 = (l40)[1]; single_value();  single_value();  local l42 = (l40)[2]; single_value();  l4 = l42 i( l4 );
 single_value();  l39 = l41 else  l39 = n.bound end local l38 = l39; single_value();  local l43 = n if n ~= l38 then  l43 = l38 else  l43 = LCL['CL-LIB']['MAKE-CHAR'](" ") end local l37 = l43; local l44 = n if n ~= l4 then  single_value();  l44 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l44 = n.bound end i( l44 );
 local l45 = n if n ~= CL["INTEGERP"](l16) then  l45 = n.bound else  single_value();  l45 = CL_LIB["FORMAT-ERROR"]("Mincol must be an integer - ~S", l(l16)) end i( l45 );
 local l47 = n if n ~= CL["INTEGERP"](l23) then  l47 = CL["PLUSP"](l23) else  l47 = n.bound end local l46 = n if n ~= l47 then  l46 = n.bound else  single_value();  l46 = CL_LIB["FORMAT-ERROR"]("Colinc must be a positive integer - ~S", l(l23)) end i( l46 );
 local l48 = n if n ~= CL["INTEGERP"](l30) then  l48 = n.bound else  single_value();  l48 = CL_LIB["FORMAT-ERROR"]("Minpad must be an integer - ~S", l(l30)) end i( l48 );
 local l49 = n if n ~= CL["CHARACTERP"](l37) then  l49 = n.bound else  single_value();  local l50 = n if n ~= CL["TYPEP"](l37, CL["CONS"](CL["INTEGER"], CL["CONS"](0, CL["CONS"](256, n))), false) then  l37 = CL["CODE-CHAR"](l37) l50 = l37 else  l50 = CL_LIB["FORMAT-ERROR"]("Padchar must be a character or integer from 0 to ~a - ~S", l(CL["CHAR-CODE-LIMIT"].bound,l37)) end l49 = l50 end i( l49 );
 i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  local l51 = n.bound; local l52 = n.bound; local l53 = n.bound; local l54 = n.bound; local l55 = n.bound; local l56 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l57 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l59 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l58 = l59; single_value();  single_value();  l51,l52,l53,l54,l55= unpack_mv(CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-GET-SEGMENTS"].fbound, {}), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l56 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l57.error ~= n and true then if l57.error == KEYWORD.TAG then  error(l57) else error(l57[1]) end end i( CL["VALUES-LIST"](list_r(l57)) );
 local l60 = n if n ~= CL["EQ"](l54, 1) then  single_value();  l30 = 0 l60 = l30 else  l60 = n.bound end i( l60 );
 single_value();  local l61 = n if n ~= l53 then  single_value();  local l64 = l2; single_value();  local l65 = n if n ~= l64 then  l65 = l64 else  l65 = CL["EQ"](l54, 1) end local l63 = n if n ~= l65 then  l63 = 1 else  l63 = 0 end local l66 = n if n ~= l3 then  l66 = 1 else  l66 = 0 end local l62 = (l63 + CL["1-"](l54) + l66); single_value();  local l67 = CL_LIB["FORMAT-JUSTIFICATION-ROUND-COLUMNS"]((l55 + (l30 * l62)), l16, l23); single_value();  local l70 = n if n ~= l3 then  local l71 = n if n ~= CL["NOT"](l2) then  l71 = CL["EQ"](l54, 1) else  l71 = n.bound end l70 = l71 else  l70 = n.bound end local l69 = n if n ~= l70 then  l69 = CL["LIST"](l(0,(l67 - l55))) else  local l73 = l2; single_value();  local l74 = n if n ~= l73 then  l74 = l73 else  l74 = CL["EQ"](l54, 1) end local l72 = n if n ~= l74 then  l72 = n.bound else  l72 = {0,n} end local l75 = n if n ~= l3 then  l75 = n.bound else  l75 = {0,n} end l69 = CL["APPEND"](l(l72,CL_LIB["MAKE-PAD-SEGS"]((l67 - l55), l62),l75)) end local l68 = l69; single_value();  local l76 = n if n ~= l51 then  local l77 = n if n ~= CL_LIB["*FORMAT-PPRINT*"].bound then  l77 = CL_LIB["FORMAT-ERROR"]("Justification illegal in this context", l()) else  l77 = n.bound end i( l77 );
 CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"].bound = CL["T"].bound i( CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"].bound );
 single_value();  local l80 = n if n ~= l52 then  local l81 = l52; single_value();  local l82 = (l81)[1]; single_value();  single_value();  local l83 = (l81)[2]; single_value();  l52 = l83 i( l52 );
 single_value();  l80 = l82 else  l80 = n.bound end local l79 = l80; single_value();  local l84 = n if n ~= l79 then  l84 = l79 else  l84 = 0 end local l78 = l84; local l87 = n if n ~= l52 then  local l88 = l52; single_value();  local l89 = (l88)[1]; single_value();  single_value();  local l90 = (l88)[2]; single_value();  l52 = l90 i( l52 );
 single_value();  l87 = l89 else  l87 = n.bound end local l86 = l87; single_value();  local l91 = n if n ~= l86 then  l91 = l86 else  l91 = CL_LIB["FUNCALL-LUA"]( CL_LIB["STREAM-LINE-LENGTH"].fbound, {l1, }) end local l85 = l91; local l92 = n if n ~= l52 then  single_value();  l92 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l92 = n.bound end i( l92 );
 single_value();  local l93 = CL_LIB["COLUMN"](l1); single_value();  local l94 = n if n ~= CL[">"](l((l93 + l67 + l78),l85)) then  single_value();  l94 = CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, l51) else  l94 = n.bound end l76 = l94 else  l76 = n.bound end i( l76 );
 single_value();  local l95 = l53; local l96 = l68; single_value();  local l97 = CL["GENSYM"](false); single_value();  local l98 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l99 = n if n ~= CL["NULL"](l95) then  single_value(); do break end; l99 = n.bound else  l99 = n.bound end i( l99 );
 local l100 = 0; single_value();  local l101 = CL["GENSYM"](false); single_value();  local l102 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l103 = n if n ~= CL[">="](l(l100,(l96)[1])) then  single_value(); do break end; l103 = n.bound else  l103 = n.bound end i( l103 );
 i( CL["WRITE-CHAR"](l37, l1) );
 single_value();  local l104 = (1 + l100); single_value();  single_value();  single_value();  local l105 = l104; single_value();  l100 = l105 local tmpres = l100 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l102.error ~= n and (l102.error ~= KEYWORD.TAG or l102.tag ~= l101) then if l102.error == KEYWORD.TAG then  error(l102) else error(l102[1]) end end i( CL["VALUES-LIST"](list_r(l102)) );
 i( CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, (l95)[1]) );
 single_value();  local l106 = (l95)[2]; local l107 = (l96)[2]; single_value();  single_value();  local l108 = l107; single_value();  l96 = l108 i( l96 );
 single_value();  single_value();  single_value();  local l109 = l106; single_value();  l95 = l109 local tmpres = l95 end i( n );
 single_value();  local l110 = 0; single_value();  local l111 = CL["GENSYM"](false); single_value();  local l112 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l113 = n if n ~= CL[">="](l(l110,(l96)[1])) then  single_value(); do break end; l113 = n.bound else  l113 = n.bound end i( l113 );
 i( CL["WRITE-CHAR"](l37, l1) );
 single_value();  local l114 = (1 + l110); single_value();  single_value();  single_value();  local l115 = l114; single_value();  l110 = l115 local tmpres = l110 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l112.error ~= n and (l112.error ~= KEYWORD.TAG or l112.tag ~= l111) then if l112.error == KEYWORD.TAG then  error(l112) else error(l112[1]) end end return CL["VALUES-LIST"](list_r(l112)) end, 0, 0, false, false))); single_value(); if l98.error ~= n and (l98.error ~= KEYWORD.TAG or l98.tag ~= l97) then if l98.error == KEYWORD.TAG then  error(l98) else error(l98[1]) end end l61 = CL["VALUES-LIST"](list_r(l98)) else  l61 = n.bound end l15 = l61 else  l15 = n.bound end l14 = l15 end return l14 end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-JUSTIFICATION"]; tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-LOGICAL-BLOCK"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL_LIB["END-ATSIGN"],{CL_LIB["START"],{CL_LIB["END"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}}}}},function (l1, l2, l3, l4, l5, l6, l7,  ...)   i( n.bound );
 single_value();  local l8; local l9;l8 = CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STR"],n},function (l10,  ...)   single_value();  local l12 = n if n ~= l10 then  local l13 = CL_LIB["%STR-MEMBER"](LCL['CL-LIB']['MAKE-CHAR']("~"), l10, false, false); single_value();  local l14 = n if n ~= l13 then  l14 = l13 else  l14 = CL_LIB["%STR-MEMBER"](LCL['CL-LIB']['MAKE-CHAR']("\n"), l10, false, false) end l12 = l14 else  l12 = n.bound end local l11 = n if n ~= l12 then  single_value();  l11 = CL_LIB["FORMAT-ERROR"]("Suffix and prefix must be simple", l()) else  l11 = n.bound end return l11 end, 1, 0, false, false);l9 = CL_LIB["ALLOC-FUNCTION"]({CL_LIB["START"],n},function (l15,  ...)   single_value();  local l16 = CL_LIB["*FORMAT-INDEX*"].bound; single_value();  local l17 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l19 = CL_LIB["*FORMAT-INDEX*"].bound; CL_LIB["*FORMAT-INDEX*"].bound = 0 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value();  local l18 = l19; single_value();  single_value();  single_value();  local l20 = CL["GENSYM"](false); single_value();  local l21 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  single_value();  i( CL_LIB["PARSE-FORMAT-OPERATION"](false) );
 single_value();  local l22 = n if n ~= CL["EQ"](CL["SCHAR"](CL_LIB["*FORMAT-CONTROL-STRING*"].bound, CL_LIB["*FORMAT-INDEX*"].bound), LCL['CL-LIB']['MAKE-CHAR']("<")) then  single_value();  local l23 = n if n ~= CL["EQ"](CL_LIB["*FORMAT-INDEX*"].bound, l15) then  single_value();  local l24 = CL["FUNCALL"](l, l(unpack_mv(CL["T"].bound))); single_value();  l23 = error({tag=CL["IDENTITY"](LCL["%BR"]["COMMON-LISP*NIL"].bound),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l24)) end)()}) else  local l25 = n if n ~= CL["T"].bound then  single_value();  local l26 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l25 = error({tag=CL["IDENTITY"](LCL["%BR"]["COMMON-LISP*NIL"].bound),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l26)) end)()}) else  l25 = n.bound end l23 = l25 end l22 = l23 else  l22 = n.bound end local tmpres = l22 end return n end, 0, 0, false, false))); single_value(); if l21.error ~= n and (l21.error ~= KEYWORD.TAG or l21.tag ~= l20) then if l21.error == KEYWORD.TAG then  error(l21) else error(l21[1]) end end return CL["VALUES-LIST"](list_r(l21)) end, 0, 0, false, false))); CL_LIB["*FORMAT-INDEX*"].bound = l16 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value(); if l17.error ~= n and true then if l17.error == KEYWORD.TAG then  error(l17) else error(l17[1]) end end return CL["VALUES-LIST"](list_r(l17)) end, 1, 0, false, false); i( CL_LIB["FORMAT-NO-SEMI"](LCL['CL-LIB']['MAKE-CHAR']("<"), false, false) );
 single_value();  local l27 = CL_LIB["*FORMAT-CONTROL-STRING*"].bound; local l29 = n if n ~= l2 then  l29 = "(" else  l29 = "" end local l28 = l29; local l31 = n if n ~= l2 then  l31 = ")" else  l31 = "" end local l30 = l31; local l32 = n.bound; local l33 = n.bound; local l34 = n.bound; local l35 = n.bound; local l36 = n.bound; local l37 = n.bound; local l38 = n.bound; i( n.bound );
 CL_LIB["*FORMAT-INDEX*"].bound = l5 i( CL_LIB["*FORMAT-INDEX*"].bound );
 local l39 = n.bound; local l40 = n.bound; local l41 = n.bound; local l42 = n.bound; local l43 = n.bound; local l44 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l45 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l47 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l46 = l47; single_value();  single_value();  l39,l40,l41,l42,l43= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](";"),{LCL['CL-LIB']['MAKE-CHAR'](">"),n}}, false, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l44 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l45.error ~= n and true then if l45.error == KEYWORD.TAG then  error(l45) else error(l45[1]) end end i( CL["VALUES-LIST"](list_r(l45)) );
 l33 = l39 i( l33 );
 l34 = l40 i( l34 );
 l35 = l41 i( l35 );
 l36 = l42 i( l36 );
 single_value();  l37 = l43 i( l37 );
 l32 = CL_LIB["FUNCALL-LUA"]( CL_LIB["%SUBSTR"].fbound, {l27, CL["1+"](l5), l34, }) i( l32 );
 local l48 = n if n ~= CL["NOT"](CL["EQL"](CL_LIB["*FORMAT-INDEX*"].bound, l6)) then  l28 = l32 i( l28 );
 local l49 = n if n ~= l37 then  l38 = CL["T"].bound l49 = l38 else  l49 = n.bound end i( l49 );
 local l50 = n.bound; local l51 = n.bound; local l52 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l53 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l55 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l54 = l55; single_value();  single_value();  l50,l51= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](";"),{LCL['CL-LIB']['MAKE-CHAR'](">"),n}}, false, false), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l52 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l53.error ~= n and true then if l53.error == KEYWORD.TAG then  error(l53) else error(l53[1]) end end i( CL["VALUES-LIST"](list_r(l53)) );
 l33 = l50 i( l33 );
 single_value();  l34 = l51 i( l34 );
 l32 = CL_LIB["FUNCALL-LUA"]( CL_LIB["%SUBSTR"].fbound, {l27, CL["1+"](l33), l34, }) i( l32 );
 single_value();  local l56 = n if n ~= CL_LIB["NEQ"](CL_LIB["*FORMAT-INDEX*"].bound, l6) then  local l57 = n.bound; local l58 = n.bound; local l59 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l60 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l62 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l61 = l62; single_value();  single_value();  l57,l58= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](";"),{LCL['CL-LIB']['MAKE-CHAR'](">"),n}}, false, false), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l59 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l60.error ~= n and true then if l60.error == KEYWORD.TAG then  error(l60) else error(l60[1]) end end i( CL["VALUES-LIST"](list_r(l60)) );
 l33 = l57 i( l33 );
 single_value();  l34 = l58 i( l34 );
 l30 = CL_LIB["FUNCALL-LUA"]( CL_LIB["%SUBSTR"].fbound, {l27, CL["1+"](l33), l34, }) i( l30 );
 single_value();  local l63 = n if n ~= CL_LIB["NEQ"](CL_LIB["*FORMAT-INDEX*"].bound, l6) then  single_value();  l63 = CL_LIB["FORMAT-ERROR"]("Too many chunks", l()) else  l63 = n.bound end l56 = l63 else  l56 = n.bound end l48 = l56 else  l48 = n.bound end i( l48 );
 local l64 = n if n ~= l4 then  single_value();  l32 = CL_LIB["FORMAT-FILL-TRANSFORM"](l32) l64 = l32 else  l64 = n.bound end i( l64 );
 i( CL_LIB["FUNCALL-LUA"]( l8, {l28, }) );
 i( CL_LIB["FUNCALL-LUA"]( l8, {l30, }) );
 single_value();  local l65 = CL_LIB["*FORMAT-TOP-LEVEL*"].bound; local l66 = CL_LIB["*FORMAT-CONTROL-STRING*"].bound; single_value();  local l67 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l69 = n if n ~= CL["NOT"](l3) then  local l70 = n if n ~= CL_LIB["*FORMAT-ARGUMENTS*"].bound then  local l72 = n if n ~= CL["LISTP"](CL_LIB["*FORMAT-ARGUMENTS*"].bound) then  l72 = CL_LIB["FUNCALL-LUA"]( l9, {l5, }) else  l72 = n.bound end local l71 = n if n ~= l72 then  local l73 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; single_value();  local l74 = (l73)[1]; single_value();  single_value();  local l75 = (l73)[2]; single_value();  CL_LIB["*FORMAT-ARGUMENTS*"].bound = l75 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  l71 = l74 else  l71 = CL_LIB["POP-FORMAT-ARG"]() end l70 = l71 else  CL_LIB["*FORMAT-INDEX*"].bound = l5 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value();  l70 = CL_LIB["FORMAT-ERROR"]("Missing argument", l()) end l69 = l70 else  local l76 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; CL_LIB["*FORMAT-ARGUMENTS*"].bound = n.bound i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  l69 = l76 end local l68 = l69; local l78 = CL_LIB["*FORMAT-CONTROL-STRING*"].bound; CL_LIB["*FORMAT-CONTROL-STRING*"].bound = l32 i( CL_LIB["*FORMAT-CONTROL-STRING*"].bound );
 single_value();  local l77 = l78; local l80 = CL_LIB["*FORMAT-TOP-LEVEL*"].bound; local l81 = n if n ~= l3 then  l81 = CL_LIB["*FORMAT-TOP-LEVEL*"].bound else  l81 = n.bound end CL_LIB["*FORMAT-TOP-LEVEL*"].bound = l81 i( CL_LIB["*FORMAT-TOP-LEVEL*"].bound );
 single_value();  local l79 = l80; single_value();  single_value();  local l82 = CL["T"].bound; local l84 = n if n ~= CL_LIB["XP-STRUCTURE-P"](l1) then  single_value();  l84 = l1 else  local l85 = n if n ~= CL["TYPEP"](l1, CL_LIB["XP-STREAM"], false) then  single_value();  l85 = LCL["CLOSETTE"]["SLOT-VALUE"](l1, CL_LIB["XP-STRUCTURE"]) else  l85 = n.bound end l84 = l85 end local l83 = l84; single_value();  local l86 = n if n ~= l83 then  single_value();  l86 = CL_LIB["LOGICAL-BLOCK-SUB"](l83, l68, l28, l30, l38, l3) else  local l87 = n if n ~= CL["T"].bound then  single_value();  l87 = CL_LIB["FUNCALL-LUA"]( CL_LIB["MAYBE-INITIATE-XP-PRINTING"].fbound, {CL_LIB["ALLOC-FUNCTION"]({CL_LIB["S"],{CL_LIB["O"],n}},function (l88, l89,  ...)   single_value();  return CL_LIB["LOGICAL-BLOCK-SUB"](l88, l89, l28, l30, l38, l3) end, 2, 0, false, false), l1, l68, }) else  l87 = n.bound end l86 = l87 end return l86 end, 0, 0, false, false))); CL_LIB["*FORMAT-TOP-LEVEL*"].bound = l65 i( CL_LIB["*FORMAT-TOP-LEVEL*"].bound );
 CL_LIB["*FORMAT-CONTROL-STRING*"].bound = l66 i( CL_LIB["*FORMAT-CONTROL-STRING*"].bound );
 single_value(); if l67.error ~= n and true then if l67.error == KEYWORD.TAG then  error(l67) else error(l67[1]) end end return CL["VALUES-LIST"](list_r(l67)) end, 6, 0, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["LOGICAL-BLOCK-SUB"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["ARGS"],{CL_LIB["PREFIX"],{CL_LIB["SUFFIX"],{CL_LIB["PER-LINE-P"],{CL_LIB["ATSIGN"],n}}}}}},function (l1, l2, l3, l4, l5, l6,  ...)   single_value();  local l8 = CL_LIB["*FORMAT-TOP-LEVEL*"].bound; single_value();  local l9 = n if n ~= l8 then  l9 = l8 else  local l10 = n if n ~= l6 then  l10 = CL["EQ"](CL_LIB["*CURRENT-LENGTH*"].bound, -1) else  l10 = n.bound end l9 = l10 end local l7 = CL["NOT"](l9); single_value();  local l11 = CL["1+"](CL_LIB["*CURRENT-LEVEL*"].bound); local l12 = -1; i( n.bound );
 single_value();  local l13 = n if n ~= CL_LIB["FUNCALL-LUA"]( CL_LIB["CHECK-BLOCK-ABBREVIATION"].fbound, {l1, l2, l7, }) then  l13 = n.bound else  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["START-BLOCK"].fbound, {l1, l3, l5, l4, }) );
 local l14 = CL_LIB["*LOGICAL-BLOCK-XP*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*LOGICAL-BLOCK-XP*"].bound; CL_LIB["*LOGICAL-BLOCK-XP*"].bound = l1 i( CL_LIB["*LOGICAL-BLOCK-XP*"].bound );
 single_value();  local l16 = l17; local l19 = n if n ~= CL_LIB["XP-STRUCTURE-P"](l1) then  l19 = CL_LIB["FUNCALL-LUA"]( CL_LIB["GET-XP-STREAM"].fbound, {l1, }) else  l19 = l1 end local l18 = l19; single_value();  single_value();  local l20 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( CL_LIB["DO-SUB-FORMAT-1"].fbound, {l18, l2, }) end, 0, 0, false, false))); single_value(); if l20.error ~= n and (l20.error ~= KEYWORD.TAG or l20.tag ~= CL_LIB["LOGICAL-BLOCK"]) then if l20.error == KEYWORD.TAG then  error(l20) else error(l20[1]) end end return CL["VALUES-LIST"](list_r(l20)) end, 0, 0, false, false))); CL_LIB["*LOGICAL-BLOCK-XP*"].bound = l14 i( CL_LIB["*LOGICAL-BLOCK-XP*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  l13 = CL_LIB["FUNCALL-LUA"]( CL_LIB["END-BLOCK"].fbound, {l1, l4, }) end return l13 end, 6, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-FILL-TRANSFORM"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],n},function (l1,  ...)   single_value();  local l2 = 0; local l3 = CL["LENGTH"](l1); local l4 = ""; local l5 = n.bound; local l6 = CL["GENSYM"](false); single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  local l8 = CL["LIST"](l(n.bound)); single_value();  local l9 = CL["LIST"](l(n.bound)); single_value();  local l10 = l8; single_value();  local l11 = l8; single_value();  local l12 = l8; single_value();  single_value();  local l13 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l14; local l15; local l16;l14 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( l15[1], {}) end, 0, 0, false, false)};l15 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l18 = CL_LIB["%STR-MEMBER"](LCL['CL-LIB']['MAKE-CHAR'](" "), l1, l2, false); single_value();  local l19 = n if n ~= l18 then  l19 = l18 else  l19 = l3 end local l20 = CL_LIB["%STR-MEMBER"](LCL['CL-LIB']['MAKE-CHAR']("	"), l1, l2, false); single_value();  local l21 = n if n ~= l20 then  l21 = l20 else  l21 = l3 end local l17 = CL["MIN"](l(l19,l21)); local l22 = n.bound; local l23 = n if n ~= CL_LIB["%<"](l17, l3) then  local l25 = n if n ~= CL[">"](l(l17,1)) then  local l26 = n if n ~= CL["EQ"](CL["SCHAR"](l1, (l17 - 1)), LCL['CL-LIB']['MAKE-CHAR']("\n")) then  l5 = CL["SCHAR"](l1, (l17 - 2)) local l27 = CL["EQ"](l5, LCL['CL-LIB']['MAKE-CHAR']("~")); single_value();  local l28 = n if n ~= l27 then  l28 = l27 else  local l29 = n if n ~= CL[">"](l(l17,2)) then  local l30 = n if n ~= CL_LIB["MEMQ"](l5, {LCL['CL-LIB']['MAKE-CHAR'](":"),{LCL['CL-LIB']['MAKE-CHAR']("@"),n}}) then  l30 = CL["EQ"](CL["SCHAR"](l1, (l17 - 3)), LCL['CL-LIB']['MAKE-CHAR']("~")) else  l30 = n.bound end l29 = l30 else  l29 = n.bound end l28 = l29 end l26 = l28 else  l26 = n.bound end l25 = l26 else  l25 = n.bound end local l24 = n if n ~= CL["NOT"](l25) then  single_value();  l22 = CL["T"].bound l24 = l22 else  l24 = n.bound end i( l24 );
 single_value();  local l31 = CL["GENSYM"](false); single_value();  local l32 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  single_value();  local l33 = CL["GENSYM"](false); single_value();  local l34 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  local l35 = CL["LIST"](l(n.bound)); single_value();  local l36 = CL["LIST"](l(n.bound)); single_value();  local l37 = l35; single_value();  local l38 = l35; single_value();  local l39 = l35; single_value();  single_value();  local l40 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l41; local l42; local l43;l41 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( l42[1], {}) end, 0, 0, false, false)};l42 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   l5 = CL["SCHAR"](l1, l17) i( l5 );
 local l44 = n if n ~= CL["NOT"](CL_LIB["%STR-MEMBER"](l5, CL_LIB["WSP"].bound, false, false)) then  single_value();  local l45 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l44 = error({tag=CL["IDENTITY"](l33),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l45)) end)()}) else  l44 = n.bound end i( l44 );
 single_value();  l17 = (1 + l17) i( l17 );
 single_value();  local l46 = n if n ~= CL_LIB["%<"](l17, l3) then  l46 = n.bound else  single_value();  l46 = error({tag=CL["IDENTITY"](l39),(function () single_value() return unpack_mv(l43[1]) end)()}) end i( l46 );
 i( error({tag=CL["IDENTITY"](l38),(function () single_value() return unpack_mv(l42[1]) end)()}) );
 single_value();  return CL_LIB["FUNCALL-LUA"]( l43[1], {}) end, 0, 0, false, false)};l43 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l47 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  i( error({tag=CL["IDENTITY"](l33),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l47)) end)()}) );
 single_value();  return error({tag=CL["IDENTITY"](l36),(function () single_value() return unpack_mv(n) end)()}) end, 0, 0, false, false)}; single_value();  local l48 = l41[1]; single_value();  while true do  single_value();  local l49 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB['FUNCALL-LUA'](l48,{}) end, 0, 0, false, false))); single_value(); if l49.error ~= n and (l49.error ~= KEYWORD.TAG or l49.tag ~= l35) then if l49.error == KEYWORD.TAG then  error(l49) else error(l49[1]) end end l48 = CL["VALUES-LIST"](list_r(l49)) local tmpres = l48 end return n end, 0, 0, false, false))); single_value(); if l40.error ~= n and (l40.error ~= KEYWORD.TAG or l40.tag ~= l36) then if l40.error == KEYWORD.TAG then  error(l40) else error(l40[1]) end end return CL["VALUES-LIST"](list_r(l40)) end, 0, 0, false, false))); single_value(); if l34.error ~= n and (l34.error ~= KEYWORD.TAG or l34.tag ~= l33) then if l34.error == KEYWORD.TAG then  error(l34) else error(l34[1]) end end i( CL["VALUES-LIST"](list_r(l34)) );
 single_value();  local l50 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  local tmpres = error({tag=CL["IDENTITY"](l6),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l50)) end)()}) end return n end, 0, 0, false, false))); single_value(); if l32.error ~= n and (l32.error ~= KEYWORD.TAG or l32.tag ~= l31) then if l32.error == KEYWORD.TAG then  error(l32) else error(l32[1]) end end l23 = CL["VALUES-LIST"](list_r(l32)) else  l23 = n.bound end i( l23 );
 local l51 = n if n ~= l22 then  l51 = "~:_" else  l51 = "" end l4 = CL_LIB["FUNCALL-LUA"]( CL_LIB["%STR-CAT"].fbound, {l4, CL_LIB["FUNCALL-LUA"]( CL_LIB["%SUBSTR"].fbound, {l1, l2, l17, }), l51, }) i( l4 );
 single_value();  l2 = l17 i( l2 );
 single_value();  local l52 = n if n ~= CL_LIB["%<"](l2, l3) then  l52 = n.bound else  single_value();  l52 = error({tag=CL["IDENTITY"](l12),(function () single_value() return unpack_mv(l16[1]) end)()}) end i( l52 );
 i( error({tag=CL["IDENTITY"](l11),(function () single_value() return unpack_mv(l15[1]) end)()}) );
 single_value();  return CL_LIB["FUNCALL-LUA"]( l16[1], {}) end, 0, 0, false, false)};l16 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l53 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  i( error({tag=CL["IDENTITY"](l6),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l53)) end)()}) );
 single_value();  return error({tag=CL["IDENTITY"](l9),(function () single_value() return unpack_mv(n) end)()}) end, 0, 0, false, false)}; single_value();  local l54 = l14[1]; single_value();  while true do  single_value();  local l55 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB['FUNCALL-LUA'](l54,{}) end, 0, 0, false, false))); single_value(); if l55.error ~= n and (l55.error ~= KEYWORD.TAG or l55.tag ~= l8) then if l55.error == KEYWORD.TAG then  error(l55) else error(l55[1]) end end l54 = CL["VALUES-LIST"](list_r(l55)) local tmpres = l54 end return n end, 0, 0, false, false))); single_value(); if l13.error ~= n and (l13.error ~= KEYWORD.TAG or l13.tag ~= l9) then if l13.error == KEYWORD.TAG then  error(l13) else error(l13[1]) end end return CL["VALUES-LIST"](list_r(l13)) end, 0, 0, false, false))); single_value(); if l7.error ~= n and (l7.error ~= KEYWORD.TAG or l7.tag ~= l6) then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end i( CL["VALUES-LIST"](list_r(l7)) );
 single_value();  return l4 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FLONUM-TO-STRING"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["N"],{CL["&OPTIONAL"],{CL_LIB["WIDTH"],{CL_LIB["FDIGITS"],{CL_LIB["SCALE"],n}}}}},function (l1, l2, l3, l4,  ...)  if not l2 then  l2 = n.bound end if not l3 then  l3 = n.bound end if not l4 then  l4 = n.bound end  single_value();  local l5 = CL["*PRINT-RADIX*"].bound; single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l8 = CL["*PRINT-RADIX*"].bound; CL["*PRINT-RADIX*"].bound = n.bound i( CL["*PRINT-RADIX*"].bound );
 single_value();  local l7 = l8; single_value();  single_value();  local l9 = n if n ~= CL["ZEROP"](l1) then  single_value();  l9 = CL["VALUES"](l("",0,0)) else  local l12 = l2; single_value();  local l13 = n if n ~= l12 then  l13 = l12 else  local l14 = l3; single_value();  local l15 = n if n ~= l14 then  l15 = l14 else  l15 = l4 end l13 = l15 end local l11 = n if n ~= CL["NOT"](l13) then  local l16 = n if n ~= CL_LIB["FUNCALL-LUA"]( CL_LIB["DOUBLE-FLOAT-P"].fbound, {l1, }) then  l16 = CL["EQ"](l1, 1e+23) else  l16 = n.bound end l11 = l16 else  l11 = n.bound end local l10 = n if n ~= l11 then  single_value();  l10 = CL["VALUES"](l("1",24,23)) else  local l17 = n if n ~= CL["T"].bound then  single_value();  local l18 = CL["MAKE-ARRAY"](12, k(CL_LIB["ELEMENT-TYPE"], CL["BASE-CHAR"], CL["FILL-POINTER"], 0, CL_LIB["ADJUSTABLE"], CL["T"].bound)); single_value();  local l19 = n.bound; local l20 = n.bound; local l21 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l22 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l24 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l23 = l24; single_value();  single_value();  l19,l20= unpack_mv(CL["INTEGER-DECODE-FLOAT"](l1), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l21 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l22.error ~= n and true then if l22.error == KEYWORD.TAG then  error(l22) else error(l22[1]) end end i( CL["VALUES-LIST"](list_r(l22)) );
 single_value();  l17 = CL_LIB["FLOAT-STRING"](l18, l19, l20, CL["INTEGER-LENGTH"](l19), l2, l3, l4) else  l17 = n.bound end l10 = l17 end l9 = l10 end return l9 end, 0, 0, false, false))); CL["*PRINT-RADIX*"].bound = l5 i( CL["*PRINT-RADIX*"].bound );
 single_value(); if l6.error ~= n and true then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end return CL["VALUES-LIST"](list_r(l6)) end, 1, 3, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FLOAT-STRING"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL_LIB["F"],{CL_LIB["E"],{CL_LIB["P"],{CL["&OPTIONAL"],{CL_LIB["WIDTH"],{CL_LIB["FDIGITS"],{CL_LIB["SCALE"],n}}}}}}}},function (l1, l2, l3, l4, l5, l6, l7,  ...)  if not l5 then  l5 = n.bound end if not l6 then  l6 = n.bound end if not l7 then  l7 = n.bound end  single_value();  single_value();  local l8 = l2; local l9 = 1; local l10 = 1; local l11 = 1; local l12 = 0; local l13 = n.bound; local l14 = n.bound; local l15 = n.bound; local l17 = n if n ~= CL["EQL"](l4, 53) then  l17 = 1048576 else  l17 = CL["ASH"](1, CL["1-"](l4)) end local l16 = n if n ~= CL["EQ"](l2, l17) then  single_value();  l15 = CL["T"].bound l16 = l15 else  l16 = n.bound end i( l16 );
 local l19 = CL["NULL"](l7); single_value();  local l20 = n if n ~= l19 then  l20 = l19 else  l20 = CL["ZEROP"](l7) end local l18 = n if n ~= l20 then  single_value();  local l21 = 0; l21 = CL["TRUNCATE"](((l3 + l4) * 0.301), false) i( l21 );
 single_value();  local l22 = n if n ~= CL_LIB["NEQ"](l21, 0) then  l12 = l21 i( l12 );
 single_value();  l7 = - l12 l22 = l7 else  l22 = n.bound end l18 = l22 else  l18 = n.bound end i( l18 );
 local l24 = n if n ~= l7 then  l24 = CL["NOT"](CL["EQL"](l7, 0)) else  l24 = n.bound end local l23 = n if n ~= l24 then  single_value();  local l25 = n if n ~= CL["MINUSP"](l7) then  l9 = (l9 * CL_LIB["FUNCALL-LUA"]( CL_LIB["5-TO-E"].fbound, {- l7, })) l25 = l9 else  local l26 = CL_LIB["FUNCALL-LUA"]( CL_LIB["5-TO-E"].fbound, {l7, }); l8 = (l8 * l26) i( l8 );
 l11 = l26 i( l11 );
 single_value();  local l27 = n if n ~= l15 then  single_value();  l10 = l26 l27 = l10 else  l27 = n.bound end l25 = l27 end l23 = l25 else  l23 = n.bound end i( l23 );
 local l29 = n if n ~= l7 then  l29 = - l7 else  l29 = 0 end local l28 = (l3 - l29); i( n.bound );
 single_value();  local l30 = n if n ~= CL[">"](l(l28,0)) then  l8 = CL["ASH"](l2, l28) i( l8 );
 l11 = CL["ASH"](l11, l28) i( l11 );
 single_value();  local l31 = n if n ~= l15 then  single_value();  l10 = CL["ASH"](l10, l28) l31 = l10 else  l31 = n.bound end l30 = l31 else  local l32 = n if n ~= CL_LIB["%<"](l28, 0) then  single_value();  l9 = CL["ASH"](l9, - l28) l32 = l9 else  l32 = n.bound end l30 = l32 end i( l30 );
 local l33 = n if n ~= l15 then  l11 = (l11 + l11) i( l11 );
 l8 = (l8 + l8) i( l8 );
 single_value();  l9 = (l9 + l9) l33 = l9 else  l33 = n.bound end i( l33 );
 local l34 = CL["CEILING"](l9, 10); local l35 = 1; local l36 = CL["GENSYM"](false); single_value();  local l37 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  local l38 = CL["LIST"](l(n.bound)); single_value();  local l39 = CL["LIST"](l(n.bound)); single_value();  local l40 = l38; single_value();  local l41 = l38; single_value();  local l42 = l38; single_value();  single_value();  local l43 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l44; local l45; local l46;l44 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( l45[1], {}) end, 0, 0, false, false)};l45 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   l12 = CL["1-"](l12) i( l12 );
 l8 = (l8 * 10) i( l8 );
 single_value();  l35 = (l35 * 10) i( l35 );
 single_value();  local l47 = n if n ~= CL_LIB["%<"](l8, l34) then  l47 = n.bound else  single_value();  l47 = error({tag=CL["IDENTITY"](l42),(function () single_value() return unpack_mv(l46[1]) end)()}) end i( l47 );
 i( error({tag=CL["IDENTITY"](l41),(function () single_value() return unpack_mv(l45[1]) end)()}) );
 single_value();  return CL_LIB["FUNCALL-LUA"]( l46[1], {}) end, 0, 0, false, false)};l46 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l48 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  i( error({tag=CL["IDENTITY"](l36),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l48)) end)()}) );
 single_value();  return error({tag=CL["IDENTITY"](l39),(function () single_value() return unpack_mv(n) end)()}) end, 0, 0, false, false)}; single_value();  local l49 = l44[1]; single_value();  while true do  single_value();  local l50 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB['FUNCALL-LUA'](l49,{}) end, 0, 0, false, false))); single_value(); if l50.error ~= n and (l50.error ~= KEYWORD.TAG or l50.tag ~= l38) then if l50.error == KEYWORD.TAG then  error(l50) else error(l50[1]) end end l49 = CL["VALUES-LIST"](list_r(l50)) local tmpres = l49 end return n end, 0, 0, false, false))); single_value(); if l43.error ~= n and (l43.error ~= KEYWORD.TAG or l43.tag ~= l39) then if l43.error == KEYWORD.TAG then  error(l43) else error(l43[1]) end end return CL["VALUES-LIST"](list_r(l43)) end, 0, 0, false, false))); single_value(); if l37.error ~= n and (l37.error ~= KEYWORD.TAG or l37.tag ~= l36) then if l37.error == KEYWORD.TAG then  error(l37) else error(l37[1]) end end i( CL["VALUES-LIST"](list_r(l37)) );
 single_value();  local l51 = n if n ~= CL[">"](l(l35,1)) then  l11 = (l11 * l35) i( l11 );
 single_value();  local l52 = n if n ~= l15 then  single_value();  l10 = (l10 * l35) l52 = l10 else  l52 = n.bound end l51 = l52 else  l51 = n.bound end i( l51 );
 local l53 = (l8 + l8); single_value();  local l54 = CL["GENSYM"](false); single_value();  local l55 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  single_value();  local l56 = (l53 + l11); single_value();  local l57 = CL["GENSYM"](false); single_value();  local l58 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  local l59 = CL["LIST"](l(n.bound)); single_value();  local l60 = CL["LIST"](l(n.bound)); single_value();  local l61 = l59; single_value();  local l62 = l59; single_value();  local l63 = l59; single_value();  single_value();  local l64 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l65; local l66; local l67;l65 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( l66[1], {}) end, 0, 0, false, false)};l66 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   l9 = (l9 * 10) i( l9 );
 single_value();  l12 = CL["1+"](l12) i( l12 );
 single_value();  local l69 = n if n ~= CL["NOT"](l14) then  l69 = CL[">"](l(l56,(l9 + l9))) else  l69 = CL[">="](l(l56,(l9 + l9))) end local l68 = n if n ~= l69 then  l68 = n.bound else  single_value();  l68 = error({tag=CL["IDENTITY"](l63),(function () single_value() return unpack_mv(l67[1]) end)()}) end i( l68 );
 i( error({tag=CL["IDENTITY"](l62),(function () single_value() return unpack_mv(l66[1]) end)()}) );
 single_value();  return CL_LIB["FUNCALL-LUA"]( l67[1], {}) end, 0, 0, false, false)};l67 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l70 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  i( error({tag=CL["IDENTITY"](l57),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l70)) end)()}) );
 single_value();  return error({tag=CL["IDENTITY"](l60),(function () single_value() return unpack_mv(n) end)()}) end, 0, 0, false, false)}; single_value();  local l71 = l65[1]; single_value();  while true do  single_value();  local l72 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB['FUNCALL-LUA'](l71,{}) end, 0, 0, false, false))); single_value(); if l72.error ~= n and (l72.error ~= KEYWORD.TAG or l72.tag ~= l59) then if l72.error == KEYWORD.TAG then  error(l72) else error(l72[1]) end end l71 = CL["VALUES-LIST"](list_r(l72)) local tmpres = l71 end return n end, 0, 0, false, false))); single_value(); if l64.error ~= n and (l64.error ~= KEYWORD.TAG or l64.tag ~= l60) then if l64.error == KEYWORD.TAG then  error(l64) else error(l64[1]) end end return CL["VALUES-LIST"](list_r(l64)) end, 0, 0, false, false))); single_value(); if l58.error ~= n and (l58.error ~= KEYWORD.TAG or l58.tag ~= l57) then if l58.error == KEYWORD.TAG then  error(l58) else error(l58[1]) end end i( CL["VALUES-LIST"](list_r(l58)) );
 local l74 = l6; single_value();  local l75 = n if n ~= l74 then  l75 = l74 else  l75 = l5 end local l73 = n if n ~= CL["NOT"](l75) then  single_value();  local l76 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l73 = error({tag=CL["IDENTITY"](LCL["%BR"]["COMMON-LISP*NIL"].bound),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l76)) end)()}) else  l73 = n.bound end i( l73 );
 local l77 = n if n ~= l6 then  single_value();  l13 = - l6 l77 = l13 else  local l78 = n if n ~= l5 then  single_value();  local l79 = n if n ~= CL_LIB["%<"](l12, 0) then  l79 = (1 - l5) else  l79 = CL["1+"]((l12 - l5)) end l13 = l79 l78 = l13 else  l78 = n.bound end l77 = l78 end i( l77 );
 local l81 = n if n ~= l13 then  l81 = (l13 - l12) else  l81 = 0 end local l80 = l81; local l82 = l9; i( n.bound );
 local l83 = n if n ~= CL[">="](l(l80,0)) then  local l84 = n if n ~= CL[">"](l(l80,0)) then  single_value();  l82 = (l82 * CL_LIB["10-TO-E"](l80)) l84 = l82 else  l84 = n.bound end l83 = l84 else  l82 = CL["CEILING"](l82, CL_LIB["10-TO-E"](- l80)) l83 = l82 end i( l83 );
 local l85 = n if n ~= l15 then  single_value();  l10 = CL["MAX"](l(l82,l10)) l85 = l10 else  l85 = n.bound end i( l85 );
 l11 = CL["MAX"](l(l82,l11)) i( l11 );
 single_value();  local l86 = n if n ~= CL["EQ"](l11, l82) then  single_value();  l14 = CL["T"].bound l86 = l14 else  l86 = n.bound end i( l86 );
 single_value();  local l88 = n if n ~= CL["NOT"](l14) then  l88 = CL["<="](l((l53 + l11),(l9 + l9))) else  l88 = CL_LIB["%<"]((l53 + l11), (l9 + l9)) end local l87 = n if n ~= l88 then  single_value();  local l89 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l87 = error({tag=CL["IDENTITY"](LCL["%BR"]["COMMON-LISP*NIL"].bound),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l89)) end)()}) else  l87 = n.bound end local tmpres = l87 end return n end, 0, 0, false, false))); single_value(); if l55.error ~= n and (l55.error ~= KEYWORD.TAG or l55.tag ~= l54) then if l55.error == KEYWORD.TAG then  error(l55) else error(l55[1]) end end i( CL["VALUES-LIST"](list_r(l55)) );
 single_value();  local l90 = l12; single_value();  local l91 = (l11 * 5); single_value();  local l93 = n if n ~= l15 then  l93 = (l10 * 5) else  l93 = n.bound end local l92 = l93; single_value();  local l94 = n.bound; single_value();  local l95 = n.bound; single_value();  local l96 = n.bound; single_value();  local l98 = n if n ~= l6 then  l98 = CL[">="](l(- l12,l6)) else  l98 = n.bound end local l97 = n if n ~= l98 then  l97 = n.bound else  local l99 = CL["GENSYM"](false); single_value();  local l100 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  single_value();  l12 = CL["1-"](l12) i( l12 );
 local l101 = n.bound; local l102 = n.bound; local l103 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l104 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l106 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l105 = l106; single_value();  single_value();  l101,l102= unpack_mv(CL["TRUNCATE"]((l8 * 10), l9), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l103 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l104.error ~= n and true then if l104.error == KEYWORD.TAG then  error(l104) else error(l104[1]) end end i( CL["VALUES-LIST"](list_r(l104)) );
 l94 = l101 i( l94 );
 single_value();  l8 = l102 i( l8 );
 local l107 = n if n ~= l15 then  l107 = l92 else  l107 = l91 end l96 = CL_LIB["%<"](l8, l107) i( l96 );
 local l108 = n if n ~= CL["NOT"](l14) then  l108 = CL[">"](l(l8,(l9 - l91))) else  l108 = CL[">="](l(l8,(l9 - l91))) end l95 = l108 i( l95 );
 local l110 = l96; single_value();  local l111 = n if n ~= l110 then  l111 = l110 else  l111 = l95 end local l109 = n if n ~= l111 then  local l112 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l109 = error({tag=CL["IDENTITY"](LCL["%BR"]["COMMON-LISP*NIL"].bound),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l112)) end)()}) else  single_value();  l109 = CL["VECTOR-PUSH-EXTEND"](CL["CODE-CHAR"]((l94 + CL["CHAR-CODE"](LCL['CL-LIB']['MAKE-CHAR']("0")))), l1, false) end i( l109 );
 local l113 = n if n ~= l15 then  single_value();  l92 = (l92 * 10) l113 = l92 else  l113 = n.bound end i( l113 );
 single_value();  l91 = (l91 * 10) local tmpres = l91 end return n end, 0, 0, false, false))); single_value(); if l100.error ~= n and (l100.error ~= KEYWORD.TAG or l100.tag ~= l99) then if l100.error == KEYWORD.TAG then  error(l100) else error(l100[1]) end end i( CL["VALUES-LIST"](list_r(l100)) );
 single_value();  local l115 = n if n ~= l96 then  l115 = CL["NOT"](l95) else  l115 = n.bound end local l114 = n if n ~= l115 then  single_value();  l114 = l94 else  local l117 = n if n ~= l95 then  l117 = CL["NOT"](l96) else  l117 = n.bound end local l116 = n if n ~= l117 then  single_value();  l116 = (l94 + 1) else  local l118 = n if n ~= CL["T"].bound then  single_value();  local l119 = n if n ~= CL["<="](l((l8 + l8),l9)) then  l119 = l94 else  l119 = CL["1+"](l94) end l118 = l119 else  l118 = n.bound end l116 = l118 end l114 = l116 end l97 = CL["VECTOR-PUSH-EXTEND"](CL["CODE-CHAR"]((l114 + CL["CHAR-CODE"](LCL['CL-LIB']['MAKE-CHAR']("0")))), l1, false) end i( l97 );
 single_value();  return CL["VALUES"](l(l1,l90,l12)) end, 4, 3, false, false)); local l1 = CL["MAKE-ARRAY"]((12 + CL["NTH"](0, CL["FUNCALL"](l, l(unpack_mv(CL["FLOOR"](324, 12)))))), k()); single_value();  tmp = CL_LIB.DEF(CL_LIB["INTEGER-POWERS-OF-10"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["10-TO-E"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["E"],n},function (l1,  ...)   i( n.bound );
 single_value();  local l2 = n if n ~= CL[">"](l(l1,335)) then  l2 = (CL_LIB["10-TO-E"](334) * CL_LIB["10-TO-E"]((l1 - 334))) else  local l3 = n if n ~= CL_LIB["%<"](l1, 12) then  l3 = CL["SVREF"](CL_LIB["INTEGER-POWERS-OF-10"].bound, l1) else  local l4 = n.bound; local l5 = n.bound; local l6 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l7 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l9 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l8 = l9; single_value();  single_value();  l4,l5= unpack_mv(CL["TRUNCATE"](l1, 12), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l6 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l7.error ~= n and true then if l7.error == KEYWORD.TAG then  error(l7) else error(l7[1]) end end i( CL["VALUES-LIST"](list_r(l7)) );
 i( n.bound );
 single_value();  local l10 = n if n ~= CL["EQL"](l5, 0) then  l10 = CL["SVREF"](CL_LIB["INTEGER-POWERS-OF-10"].bound, (l4 + 11)) else  l10 = (CL["SVREF"](CL_LIB["INTEGER-POWERS-OF-10"].bound, l5) * CL["SVREF"](CL_LIB["INTEGER-POWERS-OF-10"].bound, (l4 + 11))) end l3 = l10 end l2 = l3 end return l2 end, 1, 0, false, false)); local l1 = CL_LIB["INTEGER-POWERS-OF-10"].bound; local l2 = 0; single_value();  local l3 = CL["GENSYM"](false); single_value();  local l4 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l5 = n if n ~= CL[">="](l(l2,12)) then  single_value(); do break end; l5 = n.bound else  l5 = n.bound end i( l5 );
 single_value();  local l6 = l2; single_value();  local l7 = l1; single_value();  single_value();  local l8 = CL["EXPT"](10, l2); single_value();  i( CL_LIB["%SETSVREF"](l7, l6, l8) );
 single_value();  local l9 = (1 + l2); single_value();  single_value();  single_value();  local l10 = l9; single_value();  l2 = l10 local tmpres = l2 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l4.error ~= n and (l4.error ~= KEYWORD.TAG or l4.tag ~= l3) then if l4.error == KEYWORD.TAG then  error(l4) else error(l4[1]) end end i( CL["VALUES-LIST"](list_r(l4)) );
 single_value();  local l11 = 0; single_value();  local l12 = CL["GENSYM"](false); single_value();  local l13 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l14 = n if n ~= CL[">="](l(l11,CL["NTH"](0, CL["FUNCALL"](l, l(unpack_mv(CL["FLOOR"](324, 12))))))) then  single_value(); do break end; l14 = n.bound else  l14 = n.bound end i( l14 );
 single_value();  local l15 = (l11 + 12); single_value();  local l16 = l1; single_value();  single_value();  local l17 = CL["EXPT"](10, (12 * CL["1+"](l11))); single_value();  i( CL_LIB["%SETSVREF"](l16, l15, l17) );
 single_value();  local l18 = (1 + l11); single_value();  single_value();  single_value();  local l19 = l18; single_value();  l11 = l19 local tmpres = l11 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l13.error ~= n and (l13.error ~= KEYWORD.TAG or l13.tag ~= l12) then if l13.error == KEYWORD.TAG then  error(l13) else error(l13[1]) end end tmp = CL["VALUES-LIST"](list_r(l13)); local l1 = -148; single_value();  tmp = CL_LIB.DEF(CL_LIB["SINGLE-FLOAT-MIN-E"],l1); local l1 = -1073; single_value();  tmp = CL_LIB.DEF(CL_LIB["DOUBLE-FLOAT-MIN-E"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["ACCURATE-SCALE-EXPONENT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["V"],n},function (l1,  ...)   i( n.bound );
 single_value();  local l2 = n if n ~= CL["ZEROP"](l1) then  l2 = 1 else  local l3 = 2; local l4 = CL["FLOAT-DIGITS"](l1); local l6 = l1; single_value();  local l7 = n if n ~= CL["TYPEP"](l6, CL["SINGLE-FLOAT"], false) then  single_value();  l7 = CL_LIB["SINGLE-FLOAT-MIN-E"].bound else  local l8 = n if n ~= CL["TYPEP"](l6, CL["DOUBLE-FLOAT"], false) then  single_value();  l8 = CL_LIB["DOUBLE-FLOAT-MIN-E"].bound else  local l9 = n if n ~= CL["TYPEP"](l6, CL["T"], false) then  single_value();  l9 = CL["ERROR"]("etypecase, no matching branches", l()) else  l9 = n.bound end l8 = l9 end l7 = l8 end local l5 = l7; single_value();  local l10 = n.bound; local l11 = n.bound; local l12 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l13 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l15 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l14 = l15; single_value();  single_value();  l10,l11= unpack_mv(CL["INTEGER-DECODE-FLOAT"](l1), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l12 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l13.error ~= n and true then if l13.error == KEYWORD.TAG then  error(l13) else error(l13[1]) end end i( CL["VALUES-LIST"](list_r(l13)) );
 single_value();  local l16 = CL["EVENP"](l10); single_value();  local l17; local l18; local l19;l17 = {CL_LIB["ALLOC-FUNCTION"]({CL_LIB["X"],n},function (l20,  ...)   i( n.bound );
 single_value();  local l22 = l20; single_value();  local l23 = n if n ~= CL["TYPEP"](l22, CL["SINGLE-FLOAT"], false) then  single_value();  l23 = CL["FLOAT"](l20, CL_LIB["1D0"].bound) else  local l24 = n if n ~= CL["TYPEP"](l22, CL["DOUBLE-FLOAT"], false) then  single_value();  l24 = l20 else  local l25 = n if n ~= CL["TYPEP"](l22, CL["T"], false) then  single_value();  l25 = CL["ERROR"]("etypecase, no matching branches", l()) else  l25 = n.bound end l24 = l25 end l23 = l24 end local l21 = l23; single_value();  return CL["CEILING"]((CL["LOG"](l21, CL_LIB["10D0"].bound) - CL_LIB["1D-10"].bound), false) end, 1, 0, false, false)};l18 = {CL_LIB["ALLOC-FUNCTION"]({CL_LIB["R"],{CL_LIB["S"],{CL_LIB["M+"],{CL_LIB["K"],n}}}},function (l26, l27, l28, l29,  ...)   single_value();  local l31 = n if n ~= l16 then  l31 = CL[">="](l((l26 + l28),l27)) else  l31 = CL[">"](l((l26 + l28),l27)) end local l30 = n if n ~= l31 then  l30 = (l29 + 1) else  l30 = l29 end return l30 end, 4, 0, false, false)};l19 = {CL_LIB["ALLOC-FUNCTION"]({CL_LIB["R"],{CL_LIB["S"],{CL_LIB["M+"],n}}},function (l32, l33, l34,  ...)   single_value();  local l35 = CL_LIB["FUNCALL-LUA"]( l17[1], {l1, }); single_value();  local l36 = CL_LIB["10-TO-E"](CL["ABS"](l35)); single_value();  single_value();  local l37 = n if n ~= CL[">="](l(l35,0)) then  l37 = CL_LIB["FUNCALL-LUA"]( l18[1], {l32, (l33 * l36), l34, l35, }) else  l37 = CL_LIB["FUNCALL-LUA"]( l18[1], {(l32 * l36), l33, (l34 * l36), l35, }) end return l37 end, 3, 0, false, false)}; single_value();  local l38 = n.bound; local l39 = n.bound; local l40 = n.bound; local l41 = n if n ~= CL[">="](l(l11,0)) then  local l42 = CL["EXPT"](l3, l11); single_value();  local l43 = (l42 * l3); single_value();  single_value();  local l44 = n if n ~= CL["/="](l10, CL["EXPT"](l3, CL["1-"](l4))) then  single_value();  local l45 = (l10 * l42 * 2); single_value();  l38 = l45 i( l38 );
 single_value();  single_value();  local l46 = 2; single_value();  l39 = l46 i( l39 );
 single_value();  single_value();  single_value();  local l47 = l42; single_value();  l40 = l47 l44 = l40 else  single_value();  local l48 = (l10 * l43 * 2); single_value();  l38 = l48 i( l38 );
 single_value();  single_value();  local l49 = (l3 * 2); single_value();  l39 = l49 i( l39 );
 single_value();  single_value();  single_value();  local l50 = l43; single_value();  l40 = l50 l44 = l40 end l41 = l44 else  local l52 = CL["EQ"](l11, l5); single_value();  local l53 = n if n ~= l52 then  l53 = l52 else  l53 = CL["/="](l10, CL["EXPT"](l3, CL["1-"](l4))) end local l51 = n if n ~= l53 then  single_value();  local l54 = (l10 * 2); single_value();  l38 = l54 i( l38 );
 single_value();  single_value();  local l55 = (CL["EXPT"](l3, - l11) * 2); single_value();  l39 = l55 i( l39 );
 single_value();  single_value();  single_value();  local l56 = 1; single_value();  l40 = l56 l51 = l40 else  single_value();  local l57 = (l10 * l3 * 2); single_value();  l38 = l57 i( l38 );
 single_value();  single_value();  local l58 = (CL["EXPT"](l3, (1 - l11)) * 2); single_value();  l39 = l58 i( l39 );
 single_value();  single_value();  single_value();  local l59 = l3; single_value();  l40 = l59 l51 = l40 end l41 = l51 end i( l41 );
 single_value();  l2 = CL_LIB["FUNCALL-LUA"]( l19[1], {l38, l39, l40, }) end return l2 end, 1, 0, false, false)); i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("%"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&OPTIONAL"],{CL_LIB["REPEAT-COUNT"],n}}}}},function (l1, l2, l3, l4,  ...)  if not l4 then  l4 = n.bound end  i( CL_LIB["FORMAT-NO-FLAGS"](l2, l3) );
 single_value();  local l6 = CL["NOT"](l4); single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  local l8 = n if n ~= CL_LIB["FIXNUMP"](l4) then  l8 = CL[">"](l(l4,-1)) else  l8 = n.bound end l7 = l8 end local l5 = n if n ~= l7 then  single_value();  local l9 = 0; single_value();  local l10 = CL["GENSYM"](false); single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l13 = l4; single_value();  local l14 = n if n ~= l13 then  l14 = l13 else  l14 = 1 end local l12 = n if n ~= CL[">="](l(l9,l14)) then  single_value(); do break end; l12 = n.bound else  l12 = n.bound end i( l12 );
 i( n.bound );
 i( CL["TERPRI"](l1) );
 single_value();  local l15 = (1 + l9); single_value();  single_value();  single_value();  local l16 = l15; single_value();  l9 = l16 local tmpres = l9 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l11.error ~= n and (l11.error ~= KEYWORD.TAG or l11.tag ~= l10) then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end l5 = CL["VALUES-LIST"](list_r(l11)) else  local l17 = n if n ~= CL["T"].bound then  single_value();  l17 = CL_LIB["FORMAT-ERROR"]("Bad repeat-count.", l()) else  l17 = n.bound end l5 = l17 end return l5 end, 3, 1, false, false)) );
 single_value();  tmp = CL_LIB["FORMAT-%"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("&"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&OPTIONAL"],{CL_LIB["REPEAT-COUNT"],n}}}}},function (l1, l2, l3, l4,  ...)  if not l4 then  l4 = n.bound end  i( CL_LIB["FORMAT-NO-FLAGS"](l2, l3) );
 single_value();  local l6 = CL["NOT"](l4); single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  local l8 = n if n ~= CL_LIB["FIXNUMP"](l4) then  l8 = CL[">"](l(l4,-1)) else  l8 = n.bound end l7 = l8 end local l5 = n if n ~= l7 then  single_value();  local l9 = n if n ~= CL["EQ"](l4, 0) then  l9 = n.bound else  i( CL["FRESH-LINE"](l1) );
 single_value();  local l10 = 0; single_value();  local l11 = CL["GENSYM"](false); single_value();  local l12 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l14 = l4; single_value();  local l15 = n if n ~= l14 then  l15 = l14 else  l15 = 1 end local l13 = n if n ~= CL[">="](l(l10,CL["1-"](l15))) then  single_value(); do break end; l13 = n.bound else  l13 = n.bound end i( l13 );
 i( n.bound );
 i( CL["TERPRI"](l1) );
 single_value();  local l16 = (1 + l10); single_value();  single_value();  single_value();  local l17 = l16; single_value();  l10 = l17 local tmpres = l10 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l12.error ~= n and (l12.error ~= KEYWORD.TAG or l12.tag ~= l11) then if l12.error == KEYWORD.TAG then  error(l12) else error(l12[1]) end end l9 = CL["VALUES-LIST"](list_r(l12)) end l5 = l9 else  local l18 = n if n ~= CL["T"].bound then  single_value();  l18 = CL_LIB["FORMAT-ERROR"]("Bad repeat-count.", l()) else  l18 = n.bound end l5 = l18 end return l5 end, 3, 1, false, false)) );
 single_value();  tmp = CL_LIB["FORMAT-&"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("~"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&OPTIONAL"],{CL_LIB["REPEAT-COUNT"],n}}}}},function (l1, l2, l3, l4,  ...)  if not l4 then  l4 = n.bound end  i( CL_LIB["FORMAT-NO-FLAGS"](l2, l3) );
 single_value();  local l6 = CL["NOT"](l4); single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  local l8 = n if n ~= CL_LIB["FIXNUMP"](l4) then  l8 = CL[">"](l(l4,-1)) else  l8 = n.bound end l7 = l8 end local l5 = n if n ~= l7 then  single_value();  local l9 = 0; single_value();  local l10 = CL["GENSYM"](false); single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l13 = l4; single_value();  local l14 = n if n ~= l13 then  l14 = l13 else  l14 = 1 end local l12 = n if n ~= CL[">="](l(l9,l14)) then  single_value(); do break end; l12 = n.bound else  l12 = n.bound end i( l12 );
 i( n.bound );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("~"), l1) );
 single_value();  local l15 = (1 + l9); single_value();  single_value();  single_value();  local l16 = l15; single_value();  l9 = l16 local tmpres = l9 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l11.error ~= n and (l11.error ~= KEYWORD.TAG or l11.tag ~= l10) then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end l5 = CL["VALUES-LIST"](list_r(l11)) else  local l17 = n if n ~= CL["T"].bound then  single_value();  l17 = CL_LIB["FORMAT-ERROR"]("Bad repeat-count.", l()) else  l17 = n.bound end l5 = l17 end return l5 end, 3, 1, false, false)) );
 single_value();  tmp = CL_LIB["FORMAT-~"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("P"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],n}}},function (l1, l2, l3,  ...)   local l4 = n if n ~= l2 then  single_value();  local l5 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; local l6 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; local l7 = CL["LIST"](l(n.bound)); single_value();  local l8 = CL["LIST"](l(n.bound)); single_value();  local l9 = l7; single_value();  local l10 = l7; single_value();  single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l12; local l13;l12 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( l13[1], {}) end, 0, 0, false, false)};l13 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l14 = n if n ~= l6 then  local l15 = n if n ~= CL_LIB["NEQ"]((l6)[2], l5) then  l6 = (l6)[2] i( l6 );
 single_value();  l15 = error({tag=CL["IDENTITY"](l10),(function () single_value() return unpack_mv(l13[1]) end)()}) else  l15 = n.bound end l14 = l15 else  l14 = CL_LIB["FORMAT-ERROR"]("No previous argument", l()) end i( l14 );
 single_value();  return error({tag=CL["IDENTITY"](l8),(function () single_value() return unpack_mv(n) end)()}) end, 0, 0, false, false)}; single_value();  local l16 = l12[1]; single_value();  while true do  single_value();  local l17 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB['FUNCALL-LUA'](l16,{}) end, 0, 0, false, false))); single_value(); if l17.error ~= n and (l17.error ~= KEYWORD.TAG or l17.tag ~= l7) then if l17.error == KEYWORD.TAG then  error(l17) else error(l17[1]) end end l16 = CL["VALUES-LIST"](list_r(l17)) local tmpres = l16 end return n end, 0, 0, false, false))); single_value(); if l11.error ~= n and (l11.error ~= KEYWORD.TAG or l11.tag ~= l8) then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end i( CL["VALUES-LIST"](list_r(l11)) );
 single_value();  CL_LIB["*FORMAT-ARGUMENTS*"].bound = l6 l4 = CL_LIB["*FORMAT-ARGUMENTS*"].bound else  l4 = n.bound end i( l4 );
 single_value();  local l18 = n if n ~= CL["EQ"](CL_LIB["POP-FORMAT-ARG"](), 1) then  local l19 = n if n ~= l3 then  l19 = "y" else  l19 = "" end l18 = l19 else  local l20 = n if n ~= l3 then  l20 = "ies" else  l20 = "s" end l18 = l20 end return CL["WRITE-STRING"](l18, l1, k()) end, 3, 0, false, false)) );
 single_value();  tmp = CL_LIB["FORMAT-P"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("*"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&OPTIONAL"],{CL["COUNT"],n}}}}},function (l1, l2, l3, l4,  ...)  if not l4 then  l4 = n.bound end  i( n.bound );
 single_value();  local l5 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; single_value();  local l6 = (CL["LIST-LENGTH"](l5) - CL["LIST-LENGTH"](CL_LIB["*FORMAT-ARGUMENTS*"].bound)); single_value();  local l8 = n if n ~= l3 then  i( CL_LIB["FORMAT-NO-FLAGS"](l2, n.bound) );
 single_value();  local l9 = l4; single_value();  local l10 = n if n ~= l9 then  l10 = l9 else  l10 = 0 end l8 = l10 else  local l11 = n if n ~= CL["NULL"](l4) then  single_value();  l4 = 1 l11 = l4 else  l11 = n.bound end i( l11 );
 local l12 = n if n ~= l2 then  single_value();  l4 = - l4 l12 = l4 else  l12 = n.bound end i( l12 );
 single_value();  l8 = (l6 + l4) end local l7 = l8; single_value();  local l13 = CL_LIB["NTHCDR-NO-OVERFLOW"](l7, l5); single_value();  local l15 = n if n ~= n.bound then  local l16 = n if n ~= CL["CONSP"](l13) then  local l17 = n if n ~= CL["<="](l(l7,l6)) then  l17 = CL_LIB["*CIRCULARITY-HASH-TABLE*"].bound else  l17 = n.bound end l16 = l17 else  l16 = n.bound end l15 = l16 else  l15 = n.bound end local l14 = n if n ~= l15 then  single_value();  local l18 = l13; local l19 = n.bound; local l20 = 0; single_value();  local l21 = CL["GENSYM"](false); single_value();  local l22 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l23 = n if n ~= CL[">="](l(l20,CL["1+"]((l6 - l7)))) then  single_value(); do break end; l23 = n.bound else  l23 = n.bound end i( l23 );
 i( n.bound );
 single_value();  single_value();  local l24 = CL["CONS"]((l18)[1], l19); single_value();  l19 = l24 i( l19 );
 l18 = (l18)[2] i( l18 );
 single_value();  local l25 = (1 + l20); single_value();  single_value();  single_value();  local l26 = l25; single_value();  l20 = l26 local tmpres = l20 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l22.error ~= n and (l22.error ~= KEYWORD.TAG or l22.tag ~= l21) then if l22.error == KEYWORD.TAG then  error(l22) else error(l22[1]) end end i( CL["VALUES-LIST"](list_r(l22)) );
 single_value();  l13 = CL["NRECONC"](l19, CL["NTHCDR"](CL["1+"](l6), l5)) l14 = l13 else  l14 = n.bound end i( l14 );
 single_value();  CL_LIB["*FORMAT-ARGUMENTS*"].bound = l13 return CL_LIB["*FORMAT-ARGUMENTS*"].bound end, 3, 1, false, false)) );
 single_value();  tmp = CL_LIB["FORMAT-*"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("|"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 i( CL_LIB["FORMAT-NO-FLAGS"](l2, l3) );
 single_value();  local l7 = n if n ~= l4 then  local l8 = l4; single_value();  local l9 = (l8)[1]; single_value();  single_value();  local l10 = (l8)[2]; single_value();  l4 = l10 i( l4 );
 single_value();  l7 = l9 else  l7 = n.bound end local l6 = l7; single_value();  local l11 = n if n ~= l6 then  l11 = l6 else  l11 = 1 end local l5 = l11; local l12 = n if n ~= l4 then  single_value();  l12 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l12 = n.bound end i( l12 );
 i( n.bound );
 single_value();  local l13 = 0; single_value();  local l14 = CL["GENSYM"](false); single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l16 = n if n ~= CL[">="](l(l13,l5)) then  single_value(); do break end; l16 = n.bound else  l16 = n.bound end i( l16 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR'](""), l1) );
 single_value();  local l17 = (1 + l13); single_value();  single_value();  single_value();  local l18 = l17; single_value();  l13 = l18 local tmpres = l13 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l15.error ~= n and (l15.error ~= KEYWORD.TAG or l15.tag ~= l14) then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end return CL["VALUES-LIST"](list_r(l15)) end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-PAGE"]; tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-EAT-WHITESPACE"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l1 = CL_LIB["*FORMAT-INDEX*"].bound; single_value();  local l2 = CL_LIB["*FORMAT-CONTROL-STRING*"].bound; single_value();  local l3 = CL_LIB["*FORMAT-LENGTH*"].bound; single_value();  single_value();  local l4 = CL["GENSYM"](false); single_value();  local l5 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l7 = CL["EQ"](l1, l3); single_value();  local l8 = n if n ~= l7 then  l8 = l7 else  l8 = CL["NOT"](CL_LIB["READTABLE-WHITESPACEP"](CL["SCHAR"](l2, l1), false)) end local l6 = n if n ~= l8 then  single_value(); do break end; l6 = n.bound else  l6 = n.bound end i( l6 );
 single_value();  single_value();  local l9 = CL["1+"](l1); single_value();  l1 = l9 i( l1 );
 single_value();  single_value();  local l10 = n.bound; single_value();  l2 = l10 i( l2 );
 single_value();  single_value();  single_value();  local l11 = n.bound; single_value();  l3 = l11 local tmpres = l3 end i( n );
 single_value();  CL_LIB["*FORMAT-INDEX*"].bound = CL["1-"](l1) return CL_LIB["*FORMAT-INDEX*"].bound end, 0, 0, false, false))); single_value(); if l5.error ~= n and (l5.error ~= KEYWORD.TAG or l5.tag ~= l4) then if l5.error == KEYWORD.TAG then  error(l5) else error(l5[1]) end end return CL["VALUES-LIST"](list_r(l5)) end, 0, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-NEWLINE"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL_LIB["PARMS"],n}}}},function (l1, l2, l3, l4,  ...)   single_value();  local l5 = n if n ~= l4 then  single_value();  l5 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l5 = n.bound end i( l5 );
 single_value();  local l6 = n if n ~= l2 then  single_value();  local l7 = n if n ~= l3 then  single_value();  l7 = CL_LIB["FORMAT-ERROR"]("~:@<newline> is undefined", l()) else  l7 = n.bound end l6 = l7 else  local l8 = n if n ~= l3 then  i( CL["TERPRI"](l1) );
 single_value();  l8 = CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-EAT-WHITESPACE"].fbound, {}) else  local l9 = n if n ~= CL["T"].bound then  single_value();  l9 = CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-EAT-WHITESPACE"].fbound, {}) else  l9 = n.bound end l8 = l9 end l6 = l8 end return l6 end, 4, 0, false, false)); i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("\n"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 single_value();  return CL_LIB["FORMAT-NEWLINE"](l1, l2, l3, l4) end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-NEWLINE"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("?"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],n}}},function (l1, l2, l3,  ...)   i( CL_LIB["FORMAT-NO-FLAGS"](l2, n.bound) );
 single_value();  local l4 = CL_LIB["POP-FORMAT-ARG"](); local l6 = CL["STRINGP"](l4); single_value();  local l7 = n if n ~= l6 then  l7 = l6 else  l7 = CL["FUNCTIONP"](l4) end local l5 = n if n ~= l7 then  l5 = n.bound else  single_value();  l5 = CL_LIB["FORMAT-ERROR"]("Indirected control string is not a string or function", l()) end i( l5 );
 local l9 = n if n ~= CL["STRINGP"](l4) then  l9 = CL["NOT"](CL["SIMPLE-STRING-P"](l4)) else  l9 = n.bound end local l8 = n if n ~= l9 then  single_value();  l4 = CL["COERCE"](l4, CL["SIMPLE-STRING"]) l8 = l4 else  l8 = n.bound end i( l8 );
 single_value();  local l10 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l12 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l13 = n if n ~= CL["STRINGP"](l4) then  single_value();  local l14 = CL["LENGTH"](l4); single_value();  local l15 = CL_LIB["*FORMAT-CONTROL-STRING*"].bound; single_value();  local l16 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l18 = CL_LIB["*FORMAT-CONTROL-STRING*"].bound; CL_LIB["*FORMAT-CONTROL-STRING*"].bound = l4 i( CL_LIB["*FORMAT-CONTROL-STRING*"].bound );
 single_value();  local l17 = l18; single_value();  single_value();  local l19 = CL_LIB["*FORMAT-LENGTH*"].bound; single_value();  local l20 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l22 = CL_LIB["*FORMAT-LENGTH*"].bound; CL_LIB["*FORMAT-LENGTH*"].bound = l14 i( CL_LIB["*FORMAT-LENGTH*"].bound );
 single_value();  local l21 = l22; single_value();  single_value();  local l23 = CL_LIB["*FORMAT-INDEX*"].bound; single_value();  local l24 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l26 = CL_LIB["*FORMAT-INDEX*"].bound; CL_LIB["*FORMAT-INDEX*"].bound = 0 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value();  local l25 = l26; single_value();  single_value();  single_value();  local l27 = n if n ~= l3 then  l27 = CL_LIB["SUB-FORMAT"](l1, 0, l14) else  local l28 = CL_LIB["POP-FORMAT-ARG"](); single_value();  local l29 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; local l30 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; local l31 = CL_LIB["*FORMAT-TOP-LEVEL*"].bound; single_value();  local l32 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l34 = CL_LIB["*FORMAT-TOP-LEVEL*"].bound; CL_LIB["*FORMAT-TOP-LEVEL*"].bound = n.bound i( CL_LIB["*FORMAT-TOP-LEVEL*"].bound );
 single_value();  local l33 = l34; local l36 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; CL_LIB["*FORMAT-ARGUMENTS*"].bound = l28 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  local l35 = l36; local l38 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound = l28 i( CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound );
 single_value();  local l37 = l38; single_value();  single_value();  return CL_LIB["SUB-FORMAT"](l1, 0, l14) end, 0, 0, false, false))); CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound = l29 i( CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound );
 CL_LIB["*FORMAT-ARGUMENTS*"].bound = l30 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 CL_LIB["*FORMAT-TOP-LEVEL*"].bound = l31 i( CL_LIB["*FORMAT-TOP-LEVEL*"].bound );
 single_value(); if l32.error ~= n and true then if l32.error == KEYWORD.TAG then  error(l32) else error(l32[1]) end end l27 = CL["VALUES-LIST"](list_r(l32)) end return l27 end, 0, 0, false, false))); CL_LIB["*FORMAT-INDEX*"].bound = l23 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value(); if l24.error ~= n and true then if l24.error == KEYWORD.TAG then  error(l24) else error(l24[1]) end end return CL["VALUES-LIST"](list_r(l24)) end, 0, 0, false, false))); CL_LIB["*FORMAT-LENGTH*"].bound = l19 i( CL_LIB["*FORMAT-LENGTH*"].bound );
 single_value(); if l20.error ~= n and true then if l20.error == KEYWORD.TAG then  error(l20) else error(l20[1]) end end return CL["VALUES-LIST"](list_r(l20)) end, 0, 0, false, false))); CL_LIB["*FORMAT-CONTROL-STRING*"].bound = l15 i( CL_LIB["*FORMAT-CONTROL-STRING*"].bound );
 single_value(); if l16.error ~= n and true then if l16.error == KEYWORD.TAG then  error(l16) else error(l16[1]) end end l13 = CL["VALUES-LIST"](list_r(l16)) else  local l39 = n if n ~= CL["T"].bound then  single_value();  local l40 = n if n ~= CL["NOT"](l3) then  l40 = CL["APPLY"](l4, l1, l(CL_LIB["POP-FORMAT-ARG"]())) else  CL_LIB["*FORMAT-ARGUMENTS*"].bound = CL["APPLY"](l4, l1, l(CL_LIB["*FORMAT-ARGUMENTS*"].bound)) l40 = CL_LIB["*FORMAT-ARGUMENTS*"].bound end l39 = l40 else  l39 = n.bound end l13 = l39 end i( l13 );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l12.error ~= n and (l12.error ~= KEYWORD.TAG or l12.tag ~= CL_LIB["FORMAT-ERROR"]) then if l12.error == KEYWORD.TAG then  error(l12) else error(l12[1]) end end local l11 = CL["VALUES-LIST"](list_r(l12)); single_value();  local l41 = n if n ~= l11 then  single_value();  l41 = error({tag=CL["IDENTITY"](CL_LIB["FORMAT-ERROR"]),(function () single_value() return unpack_mv(CL["CONS"](CL["LIST"](l("While processing indirect control string~%~S~%~V@T^",CL_LIB["*FORMAT-CONTROL-STRING*"].bound,CL["1+"](CL_LIB["*FORMAT-INDEX*"].bound))), l11)) end)()}) else  l41 = n.bound end return l41 end, 0, 0, false, false))); single_value(); if l10.error ~= n and (l10.error ~= KEYWORD.TAG or l10.tag ~= CL_LIB["FORMAT-ESCAPE"]) then if l10.error == KEYWORD.TAG then  error(l10) else error(l10[1]) end end return CL["VALUES-LIST"](list_r(l10)) end, 3, 0, false, false)) );
 single_value();  tmp = CL_LIB["FORMAT-INDIRECTION"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("A"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 single_value();  local l5 = CL_LIB["POP-FORMAT-ARG"](); single_value();  local l6 = n if n ~= CL["NULL"](l4) then  local l7 = l5; single_value();  local l8 = n if n ~= l7 then  l8 = l7 else  local l9 = n if n ~= l2 then  l9 = "()" else  l9 = n.bound end l8 = l9 end l6 = CL["PRINC"](l8, l1) else  local l12 = n if n ~= l4 then  local l13 = l4; single_value();  local l14 = (l13)[1]; single_value();  single_value();  local l15 = (l13)[2]; single_value();  l4 = l15 i( l4 );
 single_value();  l12 = l14 else  l12 = n.bound end local l11 = l12; single_value();  local l16 = n if n ~= l11 then  l16 = l11 else  l16 = 0 end local l10 = l16; local l19 = n if n ~= l4 then  local l20 = l4; single_value();  local l21 = (l20)[1]; single_value();  single_value();  local l22 = (l20)[2]; single_value();  l4 = l22 i( l4 );
 single_value();  l19 = l21 else  l19 = n.bound end local l18 = l19; single_value();  local l23 = n if n ~= l18 then  l23 = l18 else  l23 = 1 end local l17 = l23; local l26 = n if n ~= l4 then  local l27 = l4; single_value();  local l28 = (l27)[1]; single_value();  single_value();  local l29 = (l27)[2]; single_value();  l4 = l29 i( l4 );
 single_value();  l26 = l28 else  l26 = n.bound end local l25 = l26; single_value();  local l30 = n if n ~= l25 then  l30 = l25 else  l30 = 0 end local l24 = l30; local l33 = n if n ~= l4 then  local l34 = l4; single_value();  local l35 = (l34)[1]; single_value();  single_value();  local l36 = (l34)[2]; single_value();  l4 = l36 i( l4 );
 single_value();  l33 = l35 else  l33 = n.bound end local l32 = l33; single_value();  local l37 = n if n ~= l32 then  l37 = l32 else  l37 = LCL['CL-LIB']['MAKE-CHAR'](" ") end local l31 = l37; local l38 = n if n ~= l4 then  single_value();  l38 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l38 = n.bound end i( l38 );
 single_value();  local l40 = l5; single_value();  local l41 = n if n ~= l40 then  l41 = l40 else  l41 = CL["NOT"](l2) end local l39 = n if n ~= l41 then  l39 = CL["PRINC-TO-STRING"](l5) else  l39 = "()" end l6 = CL_LIB["FORMAT-WRITE-FIELD"](l1, l39, l10, l17, l24, l31, l3) end return l6 end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-PRINC"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("S"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 single_value();  local l5 = CL_LIB["POP-FORMAT-ARG"](); single_value();  local l6 = n if n ~= CL["NULL"](l4) then  local l8 = l5; single_value();  local l9 = n if n ~= l8 then  l9 = l8 else  l9 = CL["NOT"](l2) end local l7 = n if n ~= l9 then  l7 = CL["PRIN1"](l5, l1) else  l7 = CL["PRINC"]("()", l1) end l6 = l7 else  local l12 = n if n ~= l4 then  local l13 = l4; single_value();  local l14 = (l13)[1]; single_value();  single_value();  local l15 = (l13)[2]; single_value();  l4 = l15 i( l4 );
 single_value();  l12 = l14 else  l12 = n.bound end local l11 = l12; single_value();  local l16 = n if n ~= l11 then  l16 = l11 else  l16 = 0 end local l10 = l16; local l19 = n if n ~= l4 then  local l20 = l4; single_value();  local l21 = (l20)[1]; single_value();  single_value();  local l22 = (l20)[2]; single_value();  l4 = l22 i( l4 );
 single_value();  l19 = l21 else  l19 = n.bound end local l18 = l19; single_value();  local l23 = n if n ~= l18 then  l23 = l18 else  l23 = 1 end local l17 = l23; local l26 = n if n ~= l4 then  local l27 = l4; single_value();  local l28 = (l27)[1]; single_value();  single_value();  local l29 = (l27)[2]; single_value();  l4 = l29 i( l4 );
 single_value();  l26 = l28 else  l26 = n.bound end local l25 = l26; single_value();  local l30 = n if n ~= l25 then  l30 = l25 else  l30 = 0 end local l24 = l30; local l33 = n if n ~= l4 then  local l34 = l4; single_value();  local l35 = (l34)[1]; single_value();  single_value();  local l36 = (l34)[2]; single_value();  l4 = l36 i( l4 );
 single_value();  l33 = l35 else  l33 = n.bound end local l32 = l33; single_value();  local l37 = n if n ~= l32 then  l37 = l32 else  l37 = LCL['CL-LIB']['MAKE-CHAR'](" ") end local l31 = l37; local l38 = n if n ~= l4 then  single_value();  l38 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l38 = n.bound end i( l38 );
 single_value();  local l40 = l5; single_value();  local l41 = n if n ~= l40 then  l41 = l40 else  l41 = CL["NOT"](l2) end local l39 = n if n ~= l41 then  l39 = CL["PRIN1-TO-STRING"](l5) else  l39 = "()" end l6 = CL_LIB["FORMAT-WRITE-FIELD"](l1, l39, l10, l17, l24, l31, l3) end return l6 end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-PRIN1"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("C"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL["CHARACTER"](CL_LIB["POP-FORMAT-ARG"]()); single_value();  local l5 = CL["CHAR-CODE"](l4); single_value();  local l6 = CL["CHAR-NAME"](l4); single_value();  single_value();  local l8 = n if n ~= l3 then  l8 = CL["NOT"](l2) else  l8 = n.bound end local l7 = n if n ~= l8 then  single_value();  l7 = CL["PRIN1"](l4, l1) else  local l9 = n if n ~= l2 then  single_value();  local l11 = CL["EQL"](l4, LCL['CL-LIB']['MAKE-CHAR'](" ")); single_value();  local l12 = n if n ~= l11 then  l12 = l11 else  l12 = CL["NOT"](CL["GRAPHIC-CHAR-P"](l4)) end local l10 = n if n ~= l12 then  l10 = CL["PRINC"](l6, l1) else  l10 = CL["WRITE-CHAR"](l4, l1) end l9 = l10 else  local l14 = l3; single_value();  local l15 = n if n ~= l14 then  l15 = l14 else  l15 = l2 end local l13 = n if n ~= CL["NOT"](l15) then  single_value();  l13 = CL["WRITE-CHAR"](l4, l1) else  local l17 = n if n ~= CL_LIB["%<"](l5, 32) then  l17 = l3 else  l17 = n.bound end local l16 = n if n ~= l17 then  l4 = CL["CODE-CHAR"](CL["LOGXOR"](l(l5,64))) i( l4 );
 local l19 = l2; single_value();  local l20 = n if n ~= l19 then  l20 = l19 else  l20 = CL_LIB["%STR-MEMBER"](l4, "@CGHIJKLM[\\]^_", false, false) end local l18 = n if n ~= l20 then  l18 = CL["PRINC"](l6, l1) else  i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("^"), l1) );
 single_value();  l18 = CL["WRITE-CHAR"](l4, l1) end i( l18 );
 i( CL["PRINC"](" (", l1) );
 i( CL["PRINC"]("Control ", l1) );
 i( CL["WRITE-CHAR"](l4, l1) );
 single_value();  l16 = CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR'](")"), l1) else  local l21 = n if n ~= l6 then  single_value();  l21 = CL["PRINC"](l6, l1) else  local l22 = n if n ~= CL["T"].bound then  single_value();  l22 = CL["WRITE-CHAR"](l4, l1) else  l22 = n.bound end l21 = l22 end l16 = l21 end l13 = l16 end l9 = l13 end l7 = l9 end return l7 end, 3, 0, false, false)) );
 single_value();  tmp = CL_LIB["FORMAT-PRINT-CHARACTER"]; tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-WRITE-FIELD"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["STRING"],{CL_LIB["MINCOL"],{CL_LIB["COLINC"],{CL_LIB["MINPAD"],{CL_LIB["PADCHAR"],{CL_LIB["PADLEFT"],n}}}}}}},function (l1, l2, l3, l4, l5, l6, l7,  ...)   local l9 = CL["NULL"](l3); single_value();  local l10 = n if n ~= l9 then  l10 = l9 else  l10 = CL["INTEGERP"](l3) end local l8 = n if n ~= l10 then  l8 = n.bound else  single_value();  l8 = CL_LIB["FORMAT-ERROR"]("Mincol must be an integer - ~S", l(l3)) end i( l8 );
 local l12 = n if n ~= CL["INTEGERP"](l4) then  l12 = CL["PLUSP"](l4) else  l12 = n.bound end local l11 = n if n ~= l12 then  l11 = n.bound else  single_value();  l11 = CL_LIB["FORMAT-ERROR"]("Colinc must be a positive integer - ~S", l(l4)) end i( l11 );
 local l13 = n if n ~= CL["INTEGERP"](l5) then  l13 = n.bound else  single_value();  l13 = CL_LIB["FORMAT-ERROR"]("Minpad must be an integer - ~S", l(l5)) end i( l13 );
 local l14 = n if n ~= CL["CHARACTERP"](l6) then  l14 = n.bound else  single_value();  local l15 = n if n ~= CL["TYPEP"](l6, CL["CONS"](CL["INTEGER"], CL["CONS"](0, CL["CONS"](256, n))), false) then  l6 = CL["CODE-CHAR"](l6) l15 = l6 else  l15 = CL_LIB["FORMAT-ERROR"]("Padchar must be a character or integer from 0 to ~a - ~S", l(CL["CHAR-CODE-LIMIT"].bound,l6)) end l14 = l15 end i( l14 );
 single_value();  local l16 = CL["LENGTH"](l2); single_value();  local l17 = (l16 + l5); single_value();  local l19 = n if n ~= l3 then  l19 = CL_LIB["FORMAT-ROUND-COLUMNS"](l17, l3, l4) else  l19 = l17 end local l18 = l19; single_value();  local l20 = n if n ~= l7 then  local l21 = 0; single_value();  local l22 = CL["GENSYM"](false); single_value();  local l23 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l24 = n if n ~= CL[">="](l(l21,(l18 - l16))) then  single_value(); do break end; l24 = n.bound else  l24 = n.bound end i( l24 );
 i( CL["WRITE-CHAR"](l6, l1) );
 single_value();  local l25 = (1 + l21); single_value();  single_value();  single_value();  local l26 = l25; single_value();  l21 = l26 local tmpres = l21 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l23.error ~= n and (l23.error ~= KEYWORD.TAG or l23.tag ~= l22) then if l23.error == KEYWORD.TAG then  error(l23) else error(l23[1]) end end l20 = CL["VALUES-LIST"](list_r(l23)) else  l20 = n.bound end i( l20 );
 i( CL["WRITE-STRING"](l2, l1, k(CL_LIB["START"], 0, CL_LIB["END"], l16)) );
 single_value();  local l27 = n if n ~= l7 then  l27 = n.bound else  single_value();  local l28 = 0; single_value();  local l29 = CL["GENSYM"](false); single_value();  local l30 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l31 = n if n ~= CL[">="](l(l28,(l18 - l16))) then  single_value(); do break end; l31 = n.bound else  l31 = n.bound end i( l31 );
 i( CL["WRITE-CHAR"](l6, l1) );
 single_value();  local l32 = (1 + l28); single_value();  single_value();  single_value();  local l33 = l32; single_value();  l28 = l33 local tmpres = l28 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l30.error ~= n and (l30.error ~= KEYWORD.TAG or l30.tag ~= l29) then if l30.error == KEYWORD.TAG then  error(l30) else error(l30[1]) end end l27 = CL["VALUES-LIST"](list_r(l30)) end return l27 end, 7, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-PRINT-NUMBER"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["NUMBER"],{CL_LIB["RADIX"],{CL_LIB["PRINT-COMMAS-P"],{CL_LIB["PRINT-SIGN-P"],{CL_LIB["PARMS"],n}}}}}},function (l1, l2, l3, l4, l5, l6,  ...)   i( n.bound );
 i( n.bound );
 local l7 = n if n ~= CL["NOT"](CL["INTEGERP"](l2)) then  local l8 = CL["*PRINT-RADIX*"].bound; local l9 = CL["*PRINT-ESCAPE*"].bound; local l10 = CL["*PRINT-BASE*"].bound; single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l13 = CL["*PRINT-BASE*"].bound; CL["*PRINT-BASE*"].bound = l3 i( CL["*PRINT-BASE*"].bound );
 single_value();  local l12 = l13; local l15 = CL["*PRINT-ESCAPE*"].bound; CL["*PRINT-ESCAPE*"].bound = n.bound i( CL["*PRINT-ESCAPE*"].bound );
 single_value();  local l14 = l15; local l17 = CL["*PRINT-RADIX*"].bound; CL["*PRINT-RADIX*"].bound = n.bound i( CL["*PRINT-RADIX*"].bound );
 single_value();  local l16 = l17; single_value();  i( n.bound );
 single_value();  return CL["PRINC"](l2, l1) end, 0, 0, false, false))); CL["*PRINT-RADIX*"].bound = l8 i( CL["*PRINT-RADIX*"].bound );
 CL["*PRINT-ESCAPE*"].bound = l9 i( CL["*PRINT-ESCAPE*"].bound );
 CL["*PRINT-BASE*"].bound = l10 i( CL["*PRINT-BASE*"].bound );
 single_value(); if l11.error ~= n and true then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end l7 = CL["VALUES-LIST"](list_r(l11)) else  local l20 = n if n ~= l6 then  local l21 = l6; single_value();  local l22 = (l21)[1]; single_value();  single_value();  local l23 = (l21)[2]; single_value();  l6 = l23 i( l6 );
 single_value();  l20 = l22 else  l20 = n.bound end local l19 = l20; single_value();  local l24 = n if n ~= l19 then  l24 = l19 else  l24 = 0 end local l18 = l24; local l27 = n if n ~= l6 then  local l28 = l6; single_value();  local l29 = (l28)[1]; single_value();  single_value();  local l30 = (l28)[2]; single_value();  l6 = l30 i( l6 );
 single_value();  l27 = l29 else  l27 = n.bound end local l26 = l27; single_value();  local l31 = n if n ~= l26 then  l31 = l26 else  l31 = LCL['CL-LIB']['MAKE-CHAR'](" ") end local l25 = l31; local l34 = n if n ~= l6 then  local l35 = l6; single_value();  local l36 = (l35)[1]; single_value();  single_value();  local l37 = (l35)[2]; single_value();  l6 = l37 i( l6 );
 single_value();  l34 = l36 else  l34 = n.bound end local l33 = l34; single_value();  local l38 = n if n ~= l33 then  l38 = l33 else  l38 = LCL['CL-LIB']['MAKE-CHAR'](",") end local l32 = l38; local l41 = n if n ~= l6 then  local l42 = l6; single_value();  local l43 = (l42)[1]; single_value();  single_value();  local l44 = (l42)[2]; single_value();  l6 = l44 i( l6 );
 single_value();  l41 = l43 else  l41 = n.bound end local l40 = l41; single_value();  local l45 = n if n ~= l40 then  l45 = l40 else  l45 = 3 end local l39 = l45; local l46 = n if n ~= l6 then  single_value();  l46 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l46 = n.bound end i( l46 );
 local l47 = n if n ~= CL["CHARACTERP"](l25) then  l47 = n.bound else  single_value();  l47 = CL["ERROR"]("Use '~A instead of ~A for padchar in format directive", l(l25,l25)) end i( l47 );
 local l49 = n if n ~= l5 then  l49 = CL[">="](l(l2,0)) else  l49 = n.bound end local l48 = n if n ~= l49 then  single_value();  l48 = LCL['CL-LIB']['MAKE-CHAR']("+") else  local l50 = n if n ~= CL_LIB["%<"](l2, 0) then  single_value();  l50 = LCL['CL-LIB']['MAKE-CHAR']("-") else  l50 = n.bound end l48 = l50 end l5 = l48 i( l5 );
 l2 = CL["ABS"](l2) i( l2 );
 single_value();  local l51 = CL["GENSYM"](false); single_value();  local l52 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l53 = CL["GENSYM"](false); single_value();  local l54 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l56 = n if n ~= CL["NOT"](l4) then  l56 = CL["EQL"](0, l18) else  l56 = n.bound end local l55 = n if n ~= l56 then  local l57 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l55 = error({tag=CL["IDENTITY"](l53),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l57)) end)()}) else  l55 = n.bound end i( l55 );
 single_value();  local l58 = 0; local l59 = 0; i( n.bound );
 local l60 = CL["ABS"](l2); single_value();  local l61 = CL["GENSYM"](false); single_value();  local l62 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  local l63 = n if n ~= CL_LIB["%<"](l60, l3) then  single_value(); do break end; l63 = n.bound else  l63 = n.bound end i( l63 );
 i( n.bound );
 l58 = (l58 + 1) i( l58 );
 single_value();  local l64 = CL["NTH"](0, CL["FUNCALL"](l, l(unpack_mv(CL["FLOOR"](l60, l3))))); single_value();  single_value();  single_value();  local l65 = l64; single_value();  l60 = l65 local tmpres = l60 end return n end, 0, 0, false, false))); single_value(); if l62.error ~= n and (l62.error ~= KEYWORD.TAG or l62.tag ~= l61) then if l62.error == KEYWORD.TAG then  error(l62) else error(l62[1]) end end i( CL["VALUES-LIST"](list_r(l62)) );
 local l66 = n if n ~= l4 then  l66 = CL["NTH"](0, CL["FUNCALL"](l, l(unpack_mv(CL["FLOOR"](l58, l39))))) else  l66 = 0 end l59 = l66 i( l59 );
 local l67 = n if n ~= l5 then  single_value();  l58 = CL["1+"](l58) l67 = l58 else  l67 = n.bound end i( l67 );
 local l69 = n if n ~= CL["EQ"](l59, 0) then  l69 = CL["<="](l(l18,l58)) else  l69 = n.bound end local l68 = n if n ~= l69 then  single_value();  local l70 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l68 = error({tag=CL["IDENTITY"](l53),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l70)) end)()}) else  l68 = n.bound end i( l68 );
 single_value();  local l71 = CL["MAKE-STRING-OUTPUT-STREAM"](k()); single_value();  local l72 = n if n ~= CL_LIB["NEQ"](l25, LCL['CL-LIB']['MAKE-CHAR'](" ")) then  single_value();  local l73 = 0; single_value();  local l74 = CL["GENSYM"](false); single_value();  local l75 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l76 = n if n ~= CL[">="](l(l73,(l18 - (l58 + l59) - 1))) then  single_value(); do break end; l76 = n.bound else  l76 = n.bound end i( l76 );
 i( CL["WRITE-CHAR"](l25, l71) );
 single_value();  local l77 = (1 + l73); single_value();  single_value();  single_value();  local l78 = l77; single_value();  l73 = l78 local tmpres = l73 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l75.error ~= n and (l75.error ~= KEYWORD.TAG or l75.tag ~= l74) then if l75.error == KEYWORD.TAG then  error(l75) else error(l75[1]) end end l72 = CL["VALUES-LIST"](list_r(l75)) else  l72 = n.bound end i( l72 );
 local l79 = n if n ~= l5 then  single_value();  l79 = CL["WRITE-CHAR"](l5, l71) else  l79 = n.bound end i( l79 );
 i( CL_LIB["%PR-INTEGER"](l2, l3, l71) );
 local l80 = 0; single_value();  local l81 = CL["GENSYM"](false); single_value();  local l82 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l83 = n if n ~= CL[">="](l(l80,l59)) then  single_value(); do break end; l83 = n.bound else  l83 = n.bound end i( l83 );
 i( CL["WRITE-CHAR"](l32, l71) );
 single_value();  local l84 = (1 + l80); single_value();  single_value();  single_value();  local l85 = l84; single_value();  l80 = l85 local tmpres = l80 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l82.error ~= n and (l82.error ~= KEYWORD.TAG or l82.tag ~= l81) then if l82.error == KEYWORD.TAG then  error(l82) else error(l82[1]) end end i( CL["VALUES-LIST"](list_r(l82)) );
 single_value();  local l86 = CL["GET-OUTPUT-STREAM-STRING"](l71); i( n.bound );
 local l87 = n if n ~= CL[">"](l(l59,0)) then  single_value();  local l88 = (CL["LENGTH"](l86) - 1); single_value();  local l89 = (l88 - l59); single_value();  single_value();  local l90 = CL["GENSYM"](false); single_value();  local l91 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  local l92 = n if n ~= CL["EQ"](l89, l88) then  single_value(); do break end; l92 = n.bound else  l92 = n.bound end i( l92 );
 i( n.bound );
 local l93 = 0; single_value();  local l94 = CL["GENSYM"](false); single_value();  local l95 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l96 = n if n ~= CL[">="](l(l93,l39)) then  single_value(); do break end; l96 = n.bound else  l96 = n.bound end i( l96 );
 local l97 = l88; single_value();  single_value();  local l98 = CL["CHAR"](l86, l89); single_value();  l86 = CL_LIB["%SET-CHAR"](l86, l97, l98) i( l86 );
 single_value();  single_value();  local l99 = CL["1-"](l88); single_value();  l88 = l99 i( l88 );
 single_value();  single_value();  single_value();  local l100 = CL["1-"](l89); single_value();  l89 = l100 i( l89 );
 single_value();  local l101 = (1 + l93); single_value();  single_value();  single_value();  local l102 = l101; single_value();  l93 = l102 local tmpres = l93 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l95.error ~= n and (l95.error ~= KEYWORD.TAG or l95.tag ~= l94) then if l95.error == KEYWORD.TAG then  error(l95) else error(l95[1]) end end i( CL["VALUES-LIST"](list_r(l95)) );
 local l103 = l88; single_value();  single_value();  local l104 = l32; single_value();  l86 = CL_LIB["%SET-CHAR"](l86, l103, l104) i( l86 );
 single_value();  single_value();  single_value();  local l105 = CL["1-"](l88); single_value();  l88 = l105 i( l88 );
 single_value();  single_value();  local l106 = n.bound; single_value();  l88 = l106 i( l88 );
 single_value();  single_value();  single_value();  local l107 = n.bound; single_value();  l89 = l107 local tmpres = l89 end return n end, 0, 0, false, false))); single_value(); if l91.error ~= n and (l91.error ~= KEYWORD.TAG or l91.tag ~= l90) then if l91.error == KEYWORD.TAG then  error(l91) else error(l91[1]) end end l87 = CL["VALUES-LIST"](list_r(l91)) else  l87 = n.bound end i( l87 );
 i( CL_LIB["FORMAT-WRITE-FIELD"](l1, l86, l18, 1, 0, l25, CL["T"].bound) );
 single_value();  local l108 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  return error({tag=CL["IDENTITY"](l51),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l108)) end)()}) end, 0, 0, false, false))); single_value(); if l54.error ~= n and (l54.error ~= KEYWORD.TAG or l54.tag ~= l53) then if l54.error == KEYWORD.TAG then  error(l54) else error(l54[1]) end end i( CL["VALUES-LIST"](list_r(l54)) );
 local l109 = n if n ~= l5 then  single_value();  l109 = CL["WRITE-CHAR"](l5, l1) else  l109 = n.bound end i( l109 );
 single_value();  return CL_LIB["%PR-INTEGER"](l2, l3, l1) end, 0, 0, false, false))); single_value(); if l52.error ~= n and (l52.error ~= KEYWORD.TAG or l52.tag ~= l51) then if l52.error == KEYWORD.TAG then  error(l52) else error(l52[1]) end end l7 = CL["VALUES-LIST"](list_r(l52)) end i( l7 );
 single_value();  return n.bound end, 6, 0, false, false)); i( CL_LIB["MACRO-SETQ"](CL_LIB["CARDINAL-ONES"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G239704"],{CL["&OPTIONAL"],{LCL["NIL"]["G239705"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  i( "Table of cardinal ones-place digits in English" );
 single_value();  return {CL["VECTOR"],{n,{"one",{"two",{"three",{"four",{"five",{"six",{"seven",{"eight",{"nine",n}}}}}}}}}}} end, 1, 1, false, false)) );
 i( CL_LIB["MACRO-SETQ"](CL_LIB["CARDINAL-TENS"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G239730"],{CL["&OPTIONAL"],{LCL["NIL"]["G239731"],n}}},function (l5, l6,  ...)  if not l6 then  l6 = n.bound end  single_value();  local l7 = (l5)[2]; single_value();  local l8 = (l5)[2]; single_value();  i( "Table of cardinal tens-place digits in English" );
 single_value();  return {CL["VECTOR"],{n,{n,{"twenty",{"thirty",{"forty",{"fifty",{"sixty",{"seventy",{"eighty",{"ninety",n}}}}}}}}}}} end, 1, 1, false, false)) );
 single_value();  tmp = CL_LIB["MACRO-SETQ"](CL_LIB["CARDINAL-TEENS"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G239757"],{CL["&OPTIONAL"],{LCL["NIL"]["G239758"],n}}},function (l9, l10,  ...)  if not l10 then  l10 = n.bound end  single_value();  local l11 = (l9)[2]; single_value();  local l12 = (l9)[2]; single_value();  single_value();  return {CL["VECTOR"],{"ten",{"eleven",{"twelve",{"thirteen",{"fourteen",{"fifteen",{"sixteen",{"seventeen",{"eighteen",{"nineteen",n}}}}}}}}}}} end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-PRINT-SMALL-CARDINAL"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["N"],n}},function (l1, l2,  ...)   single_value();  local l3 = n.bound; local l4 = n.bound; local l5 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l8 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l7 = l8; single_value();  single_value();  l3,l4= unpack_mv(CL["TRUNCATE"](l2, 100), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l5 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l6.error ~= n and true then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end i( CL["VALUES-LIST"](list_r(l6)) );
 local l9 = n if n ~= CL["PLUSP"](l3) then  i( CL["WRITE-STRING"](CL["SVREF"](CL["VECTOR"](l(n.bound,"one","two","three","four","five","six","seven","eight","nine")), l3), l1, k()) );
 i( CL["WRITE-STRING"](" hundred", l1, k()) );
 single_value();  local l10 = n if n ~= CL["PLUSP"](l4) then  single_value();  l10 = CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR'](" "), l1) else  l10 = n.bound end l9 = l10 else  l9 = n.bound end i( l9 );
 single_value();  local l11 = n if n ~= CL["PLUSP"](l4) then  single_value();  local l12 = n.bound; local l13 = n.bound; local l14 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l17 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l16 = l17; single_value();  single_value();  l12,l13= unpack_mv(CL["TRUNCATE"](l4, 10), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l14 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end i( CL["VALUES-LIST"](list_r(l15)) );
 single_value();  local l18 = n if n ~= CL_LIB["%<"](1, l12) then  i( CL["WRITE-STRING"](CL["SVREF"](CL["VECTOR"](l(n.bound,n.bound,"twenty","thirty","forty","fifty","sixty","seventy","eighty","ninety")), l12), l1, k()) );
 single_value();  local l19 = n if n ~= CL["PLUSP"](l13) then  i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("-"), l1) );
 single_value();  l19 = CL["WRITE-STRING"](CL["SVREF"](CL["VECTOR"](l(n.bound,"one","two","three","four","five","six","seven","eight","nine")), l13), l1, k()) else  l19 = n.bound end l18 = l19 else  local l20 = n if n ~= CL["EQ"](l12, 1) then  single_value();  l20 = CL["WRITE-STRING"](CL["SVREF"](CL["VECTOR"](l("ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen")), l13), l1, k()) else  local l21 = n if n ~= CL["PLUSP"](l13) then  single_value();  l21 = CL["WRITE-STRING"](CL["SVREF"](CL["VECTOR"](l(n.bound,"one","two","three","four","five","six","seven","eight","nine")), l13), l1, k()) else  l21 = n.bound end l20 = l21 end l18 = l20 end l11 = l18 else  l11 = n.bound end return l11 end, 2, 0, false, false)); single_value();  tmp = CL_LIB["MACRO-SETQ"](CL_LIB["CARDINAL-PERIODS"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G239937"],{CL["&OPTIONAL"],{LCL["NIL"]["G239938"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  i( "Table of cardinal 'teens' digits in English" );
 single_value();  return {CL["VECTOR"],{"",{" thousand",{" million",{" billion",{" trillion",{" quadrillion",{" quintillion",{" sextillion",{" septillion",{" octillion",{" nonillion",{" decillion",n}}}}}}}}}}}}} end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-PRINT-CARDINAL"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["N"],n}},function (l1, l2,  ...)   single_value();  local l3 = n if n ~= CL["MINUSP"](l2) then  i( CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, "negative ") );
 single_value();  l3 = CL_LIB["FORMAT-PRINT-CARDINAL-AUX"](l1, - l2, 0, l2) else  local l4 = n if n ~= CL["ZEROP"](l2) then  single_value();  l4 = CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, "zero") else  local l5 = n if n ~= CL["T"].bound then  single_value();  l5 = CL_LIB["FORMAT-PRINT-CARDINAL-AUX"](l1, l2, 0, l2) else  l5 = n.bound end l4 = l5 end l3 = l4 end return l3 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-PRINT-CARDINAL-AUX"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["N"],{CL_LIB["PERIOD"],{CL_LIB["ERR"],n}}}},function (l1, l2, l3, l4,  ...)   single_value();  local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l5,l6= unpack_mv(CL["TRUNCATE"](l2, 1000), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 local l11 = n if n ~= CL["<="](l(l3,10)) then  l11 = n.bound else  single_value();  l11 = CL_LIB["FORMAT-ERROR"]("Number too large to print in English: ~:D", l(l4)) end i( l11 );
 local l12 = n if n ~= CL["ZEROP"](l5) then  l12 = n.bound else  single_value();  l12 = CL_LIB["FORMAT-PRINT-CARDINAL-AUX"](l1, l5, CL["1+"](l3), l4) end i( l12 );
 single_value();  local l13 = n if n ~= CL["ZEROP"](l6) then  l13 = n.bound else  local l14 = n if n ~= CL["ZEROP"](l5) then  l14 = n.bound else  single_value();  l14 = CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR'](" "), l1) end i( l14 );
 i( CL_LIB["FORMAT-PRINT-SMALL-CARDINAL"](l1, l6) );
 single_value();  l13 = CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, CL["SVREF"](CL["VECTOR"](l(""," thousand"," million"," billion"," trillion"," quadrillion"," quintillion"," sextillion"," septillion"," octillion"," nonillion"," decillion")), l3)) end return l13 end, 4, 0, false, false)); i( CL_LIB["MACRO-SETQ"](CL_LIB["ORDINAL-ONES"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G240104"],{CL["&OPTIONAL"],{LCL["NIL"]["G240105"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  i( "Table of ordinal ones-place digits in English" );
 single_value();  return {CL["VECTOR"],{n,{"first",{"second",{"third",{"fourth",{"fifth",{"sixth",{"seventh",{"eighth",{"ninth",n}}}}}}}}}}} end, 1, 1, false, false)) );
 single_value();  tmp = CL_LIB["MACRO-SETQ"](CL_LIB["ORDINAL-TENS"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G240131"],{CL["&OPTIONAL"],{LCL["NIL"]["G240132"],n}}},function (l5, l6,  ...)  if not l6 then  l6 = n.bound end  single_value();  local l7 = (l5)[2]; single_value();  local l8 = (l5)[2]; single_value();  i( "Table of ordinal tens-place digits in English" );
 single_value();  return {CL["VECTOR"],{n,{"tenth",{"twentieth",{"thirtieth",{"fortieth",{"fiftieth",{"sixtieth",{"seventieth",{"eightieth",{"ninetieth",n}}}}}}}}}}} end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-PRINT-ORDINAL"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["N"],n}},function (l1, l2,  ...)   local l3 = n if n ~= CL["MINUSP"](l2) then  single_value();  l3 = CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, "negative ") else  l3 = n.bound end i( l3 );
 single_value();  local l4 = CL["ABS"](l2); single_value();  local l5 = n.bound; local l6 = n.bound; local l7 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l8 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l10 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  l5,l6= unpack_mv(CL["TRUNCATE"](l4, 100), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l7 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l8.error ~= n and true then if l8.error == KEYWORD.TAG then  error(l8) else error(l8[1]) end end i( CL["VALUES-LIST"](list_r(l8)) );
 local l11 = n if n ~= CL["ZEROP"](l5) then  l11 = n.bound else  single_value();  l11 = CL_LIB["FORMAT-PRINT-CARDINAL"](l1, (l4 - l6)) end i( l11 );
 local l13 = n if n ~= CL["PLUSP"](l5) then  l13 = CL["PLUSP"](l6) else  l13 = n.bound end local l12 = n if n ~= l13 then  single_value();  l12 = CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR'](" "), l1) else  l12 = n.bound end i( l12 );
 single_value();  local l14 = n.bound; local l15 = n.bound; local l16 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l17 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l19 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l18 = l19; single_value();  single_value();  l14,l15= unpack_mv(CL["TRUNCATE"](l6, 10), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l16 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l17.error ~= n and true then if l17.error == KEYWORD.TAG then  error(l17) else error(l17[1]) end end i( CL["VALUES-LIST"](list_r(l17)) );
 single_value();  local l20 = n if n ~= CL["EQ"](l6, 12) then  single_value();  l20 = CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, "twelfth") else  local l21 = n if n ~= CL["EQ"](l14, 1) then  i( CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, CL["SVREF"](CL["VECTOR"](l("ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen")), l15)) );
 single_value();  l21 = CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, "th") else  local l23 = n if n ~= CL["ZEROP"](l14) then  l23 = CL["PLUSP"](l15) else  l23 = n.bound end local l22 = n if n ~= l23 then  single_value();  l22 = CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, CL["SVREF"](CL["VECTOR"](l(n.bound,"first","second","third","fourth","fifth","sixth","seventh","eighth","ninth")), l15)) else  local l25 = n if n ~= CL["ZEROP"](l15) then  l25 = CL["PLUSP"](l14) else  l25 = n.bound end local l24 = n if n ~= l25 then  single_value();  l24 = CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, CL["SVREF"](CL["VECTOR"](l(n.bound,"tenth","twentieth","thirtieth","fortieth","fiftieth","sixtieth","seventieth","eightieth","ninetieth")), l14)) else  local l26 = n if n ~= CL["PLUSP"](l6) then  i( CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, CL["SVREF"](CL["VECTOR"](l(n.bound,n.bound,"twenty","thirty","forty","fifty","sixty","seventy","eighty","ninety")), l14)) );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("-"), l1) );
 single_value();  l26 = CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, CL["SVREF"](CL["VECTOR"](l(n.bound,"first","second","third","fourth","fifth","sixth","seventh","eighth","ninth")), l15)) else  local l27 = n if n ~= CL["PLUSP"](l4) then  single_value();  l27 = CL["WRITE-STRING"]("th", l1, k(CL_LIB["START"], 0, CL_LIB["END"], 2)) else  local l28 = n if n ~= CL["T"].bound then  single_value();  l28 = CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, "zeroth") else  l28 = n.bound end l27 = l28 end l26 = l27 end l24 = l26 end l22 = l24 end l21 = l22 end l20 = l21 end return l20 end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-PRINT-OLD-ROMAN"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["N"],n}},function (l1, l2,  ...)   local l3 = n if n ~= CL["<"](l(0,l2,5000)) then  l3 = n.bound else  single_value();  l3 = CL_LIB["FORMAT-ERROR"]("Number out of range for old Roman numerals: ~:D", l(l2)) end i( l3 );
 single_value();  local l4 = {LCL['CL-LIB']['MAKE-CHAR']("D"),{LCL['CL-LIB']['MAKE-CHAR']("C"),{LCL['CL-LIB']['MAKE-CHAR']("L"),{LCL['CL-LIB']['MAKE-CHAR']("X"),{LCL['CL-LIB']['MAKE-CHAR']("V"),{LCL['CL-LIB']['MAKE-CHAR']("I"),n}}}}}}; local l5 = {500,{100,{50,{10,{5,{1,n}}}}}}; local l6 = LCL['CL-LIB']['MAKE-CHAR']("M"); local l7 = 1000; local l8 = l2; single_value();  local l9 = CL["GENSYM"](false); single_value();  local l10 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  local l11 = n if n ~= CL["ZEROP"](l8) then  single_value(); do break end; l11 = n.bound else  l11 = n.bound end i( l11 );
 single_value();  local l12 = (l4)[2]; local l13 = (l5)[2]; local l14 = (l4)[1]; local l15 = (l5)[1]; local l17 = l8; single_value();  local l18 = CL["GENSYM"](false); single_value();  local l19 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l20 = n if n ~= CL_LIB["%<"](l17, l7) then  single_value(); do break end; l20 = n.bound else  l20 = n.bound end i( l20 );
 single_value();  i( CL["WRITE-CHAR"](l6, l1) );
 single_value();  local l21 = (l17 - l7); single_value();  single_value();  single_value();  local l22 = l21; single_value();  l17 = l22 local tmpres = l17 end i( n );
 single_value();  return l17 end, 0, 0, false, false))); single_value(); if l19.error ~= n and (l19.error ~= KEYWORD.TAG or l19.tag ~= l18) then if l19.error == KEYWORD.TAG then  error(l19) else error(l19[1]) end end local l16 = CL["VALUES-LIST"](list_r(l19)); single_value();  single_value();  local l23 = l16; single_value();  l8 = l23 i( l8 );
 single_value();  single_value();  local l24 = l15; single_value();  l7 = l24 i( l7 );
 single_value();  single_value();  local l25 = l14; single_value();  l6 = l25 i( l6 );
 single_value();  single_value();  local l26 = l13; single_value();  l5 = l26 i( l5 );
 single_value();  single_value();  single_value();  local l27 = l12; single_value();  l4 = l27 local tmpres = l4 end return n end, 0, 0, false, false))); single_value(); if l10.error ~= n and (l10.error ~= KEYWORD.TAG or l10.tag ~= l9) then if l10.error == KEYWORD.TAG then  error(l10) else error(l10[1]) end end return CL["VALUES-LIST"](list_r(l10)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-PRINT-ROMAN"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["N"],n}},function (l1, l2,  ...)   local l3 = n if n ~= CL["<"](l(0,l2,4000)) then  l3 = n.bound else  single_value();  l3 = CL_LIB["FORMAT-ERROR"]("Number out of range for Roman numerals: ~:D", l(l2)) end i( l3 );
 single_value();  local l4 = {LCL['CL-LIB']['MAKE-CHAR']("D"),{LCL['CL-LIB']['MAKE-CHAR']("C"),{LCL['CL-LIB']['MAKE-CHAR']("L"),{LCL['CL-LIB']['MAKE-CHAR']("X"),{LCL['CL-LIB']['MAKE-CHAR']("V"),{LCL['CL-LIB']['MAKE-CHAR']("I"),n}}}}}}; local l5 = {500,{100,{50,{10,{5,{1,n}}}}}}; local l6 = {LCL['CL-LIB']['MAKE-CHAR']("C"),{LCL['CL-LIB']['MAKE-CHAR']("X"),{LCL['CL-LIB']['MAKE-CHAR']("X"),{LCL['CL-LIB']['MAKE-CHAR']("I"),{LCL['CL-LIB']['MAKE-CHAR']("I"),n}}}}}; local l7 = {100,{10,{10,{1,{1,{0,n}}}}}}; local l8 = LCL['CL-LIB']['MAKE-CHAR']("M"); local l9 = 1000; local l10 = LCL['CL-LIB']['MAKE-CHAR']("C"); local l11 = 100; local l12 = l2; single_value();  local l13 = CL["GENSYM"](false); single_value();  local l14 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  local l15 = n if n ~= CL["ZEROP"](l12) then  single_value(); do break end; l15 = n.bound else  l15 = n.bound end i( l15 );
 single_value();  local l16 = (l4)[2]; local l17 = (l5)[2]; local l18 = (l6)[2]; local l19 = (l7)[2]; local l20 = (l4)[1]; local l21 = (l5)[1]; local l22 = (l6)[1]; local l23 = (l7)[1]; local l25 = l12; single_value();  local l26 = CL["GENSYM"](false); single_value();  local l27 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l28 = n if n ~= CL_LIB["%<"](l25, l9) then  single_value(); do break end; l28 = n.bound else  l28 = n.bound end i( l28 );
 single_value();  i( CL["WRITE-CHAR"](l8, l1) );
 single_value();  local l29 = (l25 - l9); single_value();  single_value();  single_value();  local l30 = l29; single_value();  l25 = l30 local tmpres = l25 end i( n );
 single_value();  local l31 = n if n ~= CL["<="](l((l9 - l11),l25)) then  i( CL["WRITE-CHAR"](l10, l1) );
 i( CL["WRITE-CHAR"](l8, l1) );
 single_value();  l31 = (l25 - (l9 - l11)) else  local l32 = n if n ~= CL["T"].bound then  single_value();  l32 = l25 else  l32 = n.bound end l31 = l32 end return l31 end, 0, 0, false, false))); single_value(); if l27.error ~= n and (l27.error ~= KEYWORD.TAG or l27.tag ~= l26) then if l27.error == KEYWORD.TAG then  error(l27) else error(l27[1]) end end local l24 = CL["VALUES-LIST"](list_r(l27)); single_value();  single_value();  local l33 = l24; single_value();  l12 = l33 i( l12 );
 single_value();  single_value();  local l34 = l23; single_value();  l11 = l34 i( l11 );
 single_value();  single_value();  local l35 = l22; single_value();  l10 = l35 i( l10 );
 single_value();  single_value();  local l36 = l21; single_value();  l9 = l36 i( l9 );
 single_value();  single_value();  local l37 = l20; single_value();  l8 = l37 i( l8 );
 single_value();  single_value();  local l38 = l19; single_value();  l7 = l38 i( l7 );
 single_value();  single_value();  local l39 = l18; single_value();  l6 = l39 i( l6 );
 single_value();  single_value();  local l40 = l17; single_value();  l5 = l40 i( l5 );
 single_value();  single_value();  single_value();  local l41 = l16; single_value();  l4 = l41 local tmpres = l4 end return n end, 0, 0, false, false))); single_value(); if l14.error ~= n and (l14.error ~= KEYWORD.TAG or l14.tag ~= l13) then if l14.error == KEYWORD.TAG then  error(l14) else error(l14[1]) end end return CL["VALUES-LIST"](list_r(l14)) end, 2, 0, false, false)); i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("D"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 single_value();  return CL_LIB["FORMAT-PRINT-NUMBER"](l1, CL_LIB["POP-FORMAT-ARG"](), 10, l2, l3, l4) end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-PRINT-DECIMAL"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("B"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 single_value();  return CL_LIB["FORMAT-PRINT-NUMBER"](l1, CL_LIB["POP-FORMAT-ARG"](), 2, l2, l3, l4) end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-PRINT-BINARY"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("O"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 single_value();  return CL_LIB["FORMAT-PRINT-NUMBER"](l1, CL_LIB["POP-FORMAT-ARG"](), 8, l2, l3, l4) end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-PRINT-OCTAL"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("X"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 single_value();  return CL_LIB["FORMAT-PRINT-NUMBER"](l1, CL_LIB["POP-FORMAT-ARG"](), 16, l2, l3, l4) end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-PRINT-HEXADECIMAL"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("R"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 single_value();  local l5 = CL_LIB["POP-FORMAT-ARG"](); local l7 = n if n ~= l4 then  local l8 = l4; single_value();  local l9 = (l8)[1]; single_value();  single_value();  local l10 = (l8)[2]; single_value();  l4 = l10 i( l4 );
 single_value();  l7 = l9 else  l7 = n.bound end local l6 = l7; single_value();  local l11 = n if n ~= l6 then  l11 = CL_LIB["FORMAT-PRINT-NUMBER"](l1, l5, l6, l2, l3, l4) else  local l12 = n if n ~= l3 then  local l13 = n if n ~= l2 then  l13 = CL_LIB["FORMAT-PRINT-OLD-ROMAN"](l1, l5) else  l13 = CL_LIB["FORMAT-PRINT-ROMAN"](l1, l5) end l12 = l13 else  local l14 = n if n ~= l2 then  l14 = CL_LIB["FORMAT-PRINT-ORDINAL"](l1, l5) else  l14 = CL_LIB["FORMAT-PRINT-CARDINAL"](l1, l5) end l12 = l14 end l11 = l12 end return l11 end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-PRINT-RADIX"]; i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("F"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 local l5 = n if n ~= l2 then  single_value();  l5 = CL_LIB["FORMAT-ERROR"]("Colon flag not allowed", l()) else  l5 = n.bound end i( l5 );
 single_value();  local l8 = n if n ~= l4 then  local l9 = l4; single_value();  local l10 = (l9)[1]; single_value();  single_value();  local l11 = (l9)[2]; single_value();  l4 = l11 i( l4 );
 single_value();  l8 = l10 else  l8 = n.bound end local l7 = l8; single_value();  local l12 = n if n ~= l7 then  l12 = l7 else  l12 = n.bound end local l6 = l12; local l15 = n if n ~= l4 then  local l16 = l4; single_value();  local l17 = (l16)[1]; single_value();  single_value();  local l18 = (l16)[2]; single_value();  l4 = l18 i( l4 );
 single_value();  l15 = l17 else  l15 = n.bound end local l14 = l15; single_value();  local l19 = n if n ~= l14 then  l19 = l14 else  l19 = n.bound end local l13 = l19; local l22 = n if n ~= l4 then  local l23 = l4; single_value();  local l24 = (l23)[1]; single_value();  single_value();  local l25 = (l23)[2]; single_value();  l4 = l25 i( l4 );
 single_value();  l22 = l24 else  l22 = n.bound end local l21 = l22; single_value();  local l26 = n if n ~= l21 then  l26 = l21 else  l26 = n.bound end local l20 = l26; local l29 = n if n ~= l4 then  local l30 = l4; single_value();  local l31 = (l30)[1]; single_value();  single_value();  local l32 = (l30)[2]; single_value();  l4 = l32 i( l4 );
 single_value();  l29 = l31 else  l29 = n.bound end local l28 = l29; single_value();  local l33 = n if n ~= l28 then  l33 = l28 else  l33 = n.bound end local l27 = l33; local l36 = n if n ~= l4 then  local l37 = l4; single_value();  local l38 = (l37)[1]; single_value();  single_value();  local l39 = (l37)[2]; single_value();  l4 = l39 i( l4 );
 single_value();  l36 = l38 else  l36 = n.bound end local l35 = l36; single_value();  local l40 = n if n ~= l35 then  l40 = l35 else  l40 = LCL['CL-LIB']['MAKE-CHAR'](" ") end local l34 = l40; local l41 = n if n ~= l4 then  single_value();  l41 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l41 = n.bound end i( l41 );
 single_value();  local l42 = CL["*PRINT-ESCAPE*"].bound; single_value();  local l43 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l44 = CL_LIB["POP-FORMAT-ARG"](); local l46 = CL["*PRINT-ESCAPE*"].bound; CL["*PRINT-ESCAPE*"].bound = n.bound i( CL["*PRINT-ESCAPE*"].bound );
 single_value();  local l45 = l46; single_value();  single_value();  local l47 = n if n ~= CL["FLOATP"](l44) then  l47 = CL_LIB["FORMAT-FIXED-AUX"](l1, l44, l6, l13, l20, l27, l34, l3) else  local l48 = n if n ~= CL["RATIONALP"](l44) then  l48 = CL_LIB["FORMAT-FIXED-AUX"](l1, CL["COERCE"](l44, CL["FLOAT"]), l6, l13, l20, l27, l34, l3) else  local l49 = CL["*PRINT-BASE*"].bound; single_value();  local l50 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l52 = CL["*PRINT-BASE*"].bound; CL["*PRINT-BASE*"].bound = 10 i( CL["*PRINT-BASE*"].bound );
 single_value();  local l51 = l52; single_value();  single_value();  return CL_LIB["FORMAT-WRITE-FIELD"](l1, CL["PRINC-TO-STRING"](l44), l6, 1, 0, LCL['CL-LIB']['MAKE-CHAR'](" "), CL["T"].bound) end, 0, 0, false, false))); CL["*PRINT-BASE*"].bound = l49 i( CL["*PRINT-BASE*"].bound );
 single_value(); if l50.error ~= n and true then if l50.error == KEYWORD.TAG then  error(l50) else error(l50[1]) end end l48 = CL["VALUES-LIST"](list_r(l50)) end l47 = l48 end return l47 end, 0, 0, false, false))); CL["*PRINT-ESCAPE*"].bound = l42 i( CL["*PRINT-ESCAPE*"].bound );
 single_value(); if l43.error ~= n and true then if l43.error == KEYWORD.TAG then  error(l43) else error(l43[1]) end end return CL["VALUES-LIST"](list_r(l43)) end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-FIXED"]; tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-FIXED-AUX"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["NUMBER"],{CL_LIB["W"],{CL_LIB["D"],{CL_LIB["K"],{CL_LIB["OVF"],{CL_LIB["PAD"],{CL_LIB["ATSIGN"],n}}}}}}}},function (l1, l2, l3, l4, l5, l6, l7, l8,  ...)   local l9 = n if n ~= l3 then  local l10 = n if n ~= CL["<="](l(l3,0)) then  l3 = n.bound l10 = l3 else  l10 = n.bound end l9 = l10 else  l9 = n.bound end i( l9 );
 single_value();  local l12 = n if n ~= CL["NOT"](l5) then  local l13 = l3; single_value();  local l14 = n if n ~= l13 then  l14 = l13 else  l14 = l4 end l12 = CL["NOT"](l14) else  l12 = n.bound end local l11 = n if n ~= l12 then  l11 = CL_LIB["FUNCALL-LUA"]( CL_LIB["PRINT-FLOAT-FREE-FORM"].fbound, {l2, l1, }) else  local l15 = l3; local l16 = CL["ABS"](l2); local l17 = n.bound; local l18 = n.bound; local l19 = n.bound; local l21 = n if n ~= l3 then  local l22 = l8; single_value();  local l23 = n if n ~= l22 then  l23 = l22 else  l23 = CL["MINUSP"](l2) end l21 = l23 else  l21 = n.bound end local l20 = n if n ~= l21 then  single_value();  single_value();  local l24 = (-1 + l15); single_value();  l15 = l24 l20 = l15 else  l20 = n.bound end i( l20 );
 local l26 = n if n ~= l4 then  local l27 = n if n ~= l3 then  local l28 = n if n ~= l8 then  l28 = 1 else  l28 = 0 end l27 = CL["<="](l(l3,(1 + l4 + l28))) else  l27 = n.bound end l26 = l27 else  l26 = n.bound end local l25 = n if n ~= l26 then  single_value();  l18 = CL["T"].bound l25 = l18 else  l25 = n.bound end i( l25 );
 local l30 = n if n ~= l4 then  l30 = CL["MINUSP"](l4) else  l30 = n.bound end local l29 = n if n ~= l30 then  single_value();  l29 = CL_LIB["FORMAT-ERROR"]("Illegal value for d", l()) else  l29 = n.bound end i( l29 );
 local l31 = n if n ~= l3 then  local l33 = n if n ~= CL_LIB["%<"](l16, 1) then  l33 = CL["NOT"](l18) else  l33 = n.bound end local l32 = n if n ~= l33 then  l32 = CL["1-"](l15) else  l32 = l15 end l31 = l32 else  l31 = n.bound end l19 = l31 i( l19 );
 local l35 = n if n ~= l3 then  l35 = CL["NOT"](CL["PLUSP"](l19)) else  l35 = n.bound end local l34 = n if n ~= l35 then  single_value();  local l36 = n if n ~= l6 then  local l37 = 0; single_value();  local l38 = CL["GENSYM"](false); single_value();  local l39 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l40 = n if n ~= CL[">="](l(l37,l3)) then  single_value(); do break end; l40 = n.bound else  l40 = n.bound end i( l40 );
 i( CL["WRITE-CHAR"](l6, l1) );
 single_value();  local l41 = (1 + l37); single_value();  single_value();  single_value();  local l42 = l41; single_value();  l37 = l42 local tmpres = l37 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l39.error ~= n and (l39.error ~= KEYWORD.TAG or l39.tag ~= l38) then if l39.error == KEYWORD.TAG then  error(l39) else error(l39[1]) end end i( CL["VALUES-LIST"](list_r(l39)) );
 single_value();  local l43 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l36 = error({tag=CL["IDENTITY"](CL.T),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l43)) end)()}) else  single_value();  local l44 = n.bound; single_value();  l15 = l44 i( l15 );
 single_value();  single_value();  local l45 = n.bound; single_value();  l3 = l45 i( l3 );
 single_value();  single_value();  single_value();  local l46 = n.bound; single_value();  l19 = l46 l36 = l19 end l34 = l36 else  l34 = n.bound end i( l34 );
 single_value();  local l47 = n.bound; local l48 = n.bound; local l49 = n.bound; local l50 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l51 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l53 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l52 = l53; single_value();  single_value();  l47,l48,l49= unpack_mv(CL_LIB["FLONUM-TO-STRING"](l16, l19, l4, l5), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l50 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l51.error ~= n and true then if l51.error == KEYWORD.TAG then  error(l51) else error(l51[1]) end end i( CL["VALUES-LIST"](list_r(l51)) );
 l17 = CL["LENGTH"](l47) i( l17 );
 local l54 = n if n ~= l3 then  single_value();  local l55 = (- (CL["MAX"](l(l48,0)) + 1) + l15); single_value();  l15 = l55 i( l15 );
 local l57 = n if n ~= CL_LIB["%<"](l48, 1) then  l57 = CL["NOT"](l18) else  l57 = n.bound end local l56 = n if n ~= l57 then  single_value();  single_value();  local l58 = (-1 + l15); single_value();  l15 = l58 l56 = l15 else  l56 = n.bound end i( l56 );
 single_value();  local l59 = n if n ~= l4 then  single_value();  local l60 = (- l4 + l15); single_value();  l15 = l60 l59 = l15 else  single_value();  local l62 = n if n ~= CL[">"](l(l15,0)) then  l62 = 1 else  l62 = 0 end local l61 = CL["MAX"](l(CL["MIN"](l(l15,- l49)),l62)); single_value();  l4 = l61 i( l4 );
 single_value();  single_value();  single_value();  local l63 = (l15 - l4); single_value();  l15 = l63 l59 = l15 end l54 = l59 else  local l64 = n if n ~= CL["NULL"](l4) then  single_value();  l4 = CL["MAX"](l(- l49,1)) l64 = l4 else  l64 = n.bound end l54 = l64 end i( l54 );
 single_value();  local l66 = n if n ~= l3 then  local l67 = n if n ~= CL_LIB["%<"](l15, 0) then  l67 = l6 else  l67 = n.bound end l66 = l67 else  l66 = n.bound end local l65 = n if n ~= l66 then  single_value();  local l68 = 0; single_value();  local l69 = CL["GENSYM"](false); single_value();  local l70 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l71 = n if n ~= CL[">="](l(l68,l3)) then  single_value(); do break end; l71 = n.bound else  l71 = n.bound end i( l71 );
 i( n.bound );
 i( CL["WRITE-CHAR"](l6, l1) );
 single_value();  local l72 = (1 + l68); single_value();  single_value();  single_value();  local l73 = l72; single_value();  l68 = l73 local tmpres = l68 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l70.error ~= n and (l70.error ~= KEYWORD.TAG or l70.tag ~= l69) then if l70.error == KEYWORD.TAG then  error(l70) else error(l70[1]) end end l65 = CL["VALUES-LIST"](list_r(l70)) else  local l74 = n if n ~= CL["T"].bound then  local l75 = n if n ~= l3 then  single_value();  local l76 = 0; single_value();  local l77 = CL["GENSYM"](false); single_value();  local l78 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l79 = n if n ~= CL[">="](l(l76,l15)) then  single_value(); do break end; l79 = n.bound else  l79 = n.bound end i( l79 );
 i( n.bound );
 i( CL["WRITE-CHAR"](l7, l1) );
 single_value();  local l80 = (1 + l76); single_value();  single_value();  single_value();  local l81 = l80; single_value();  l76 = l81 local tmpres = l76 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l78.error ~= n and (l78.error ~= KEYWORD.TAG or l78.tag ~= l77) then if l78.error == KEYWORD.TAG then  error(l78) else error(l78[1]) end end l75 = CL["VALUES-LIST"](list_r(l78)) else  l75 = n.bound end i( l75 );
 local l82 = n if n ~= CL["MINUSP"](CL["FLOAT-SIGN"](l2, false)) then  l82 = CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("-"), l1) else  local l83 = n if n ~= l8 then  l83 = CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("+"), l1) else  l83 = n.bound end l82 = l83 end i( l82 );
 single_value();  local l84 = n if n ~= CL[">"](l(l48,0)) then  single_value();  local l85 = n if n ~= CL[">"](l(l17,l48)) then  i( CL["WRITE-STRING"](l47, l1, k(CL_LIB["START"], 0, CL_LIB["END"], l48)) );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("."), l1) );
 i( CL["WRITE-STRING"](l47, l1, k(CL_LIB["START"], l48, CL_LIB["END"], l17)) );
 single_value();  local l86 = 0; single_value();  local l87 = CL["GENSYM"](false); single_value();  local l88 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l89 = n if n ~= CL[">="](l(l86,(l4 - (l17 - l48)))) then  single_value(); do break end; l89 = n.bound else  l89 = n.bound end i( l89 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) );
 single_value();  local l90 = (1 + l86); single_value();  single_value();  single_value();  local l91 = l90; single_value();  l86 = l91 local tmpres = l86 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l88.error ~= n and (l88.error ~= KEYWORD.TAG or l88.tag ~= l87) then if l88.error == KEYWORD.TAG then  error(l88) else error(l88[1]) end end l85 = CL["VALUES-LIST"](list_r(l88)) else  local l92 = n if n ~= CL["T"].bound then  i( CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, l47) );
 local l93 = 0; single_value();  local l94 = CL["GENSYM"](false); single_value();  local l95 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l96 = n if n ~= CL[">="](l(l93,(l48 - l17))) then  single_value(); do break end; l96 = n.bound else  l96 = n.bound end i( l96 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) );
 single_value();  local l97 = (1 + l93); single_value();  single_value();  single_value();  local l98 = l97; single_value();  l93 = l98 local tmpres = l93 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l95.error ~= n and (l95.error ~= KEYWORD.TAG or l95.tag ~= l94) then if l95.error == KEYWORD.TAG then  error(l95) else error(l95[1]) end end i( CL["VALUES-LIST"](list_r(l95)) );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("."), l1) );
 single_value();  local l99 = 0; single_value();  local l100 = CL["GENSYM"](false); single_value();  local l101 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l102 = n if n ~= CL[">="](l(l99,l4)) then  single_value(); do break end; l102 = n.bound else  l102 = n.bound end i( l102 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) );
 single_value();  local l103 = (1 + l99); single_value();  single_value();  single_value();  local l104 = l103; single_value();  l99 = l104 local tmpres = l99 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l101.error ~= n and (l101.error ~= KEYWORD.TAG or l101.tag ~= l100) then if l101.error == KEYWORD.TAG then  error(l101) else error(l101[1]) end end l92 = CL["VALUES-LIST"](list_r(l101)) else  l92 = n.bound end l85 = l92 end l84 = l85 else  local l105 = n if n ~= CL["T"].bound then  local l106 = n if n ~= l18 then  l106 = n.bound else  single_value();  l106 = CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) end i( l106 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("."), l1) );
 local l107 = 0; single_value();  local l108 = CL["GENSYM"](false); single_value();  local l109 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l110 = n if n ~= CL[">="](l(l107,- l48)) then  single_value(); do break end; l110 = n.bound else  l110 = n.bound end i( l110 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) );
 single_value();  local l111 = (1 + l107); single_value();  single_value();  single_value();  local l112 = l111; single_value();  l107 = l112 local tmpres = l107 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l109.error ~= n and (l109.error ~= KEYWORD.TAG or l109.tag ~= l108) then if l109.error == KEYWORD.TAG then  error(l109) else error(l109[1]) end end i( CL["VALUES-LIST"](list_r(l109)) );
 i( CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, l47) );
 single_value();  local l113 = 0; single_value();  local l114 = CL["GENSYM"](false); single_value();  local l115 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l116 = n if n ~= CL[">="](l(l113,(l4 + l49))) then  single_value(); do break end; l116 = n.bound else  l116 = n.bound end i( l116 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) );
 single_value();  local l117 = (1 + l113); single_value();  single_value();  single_value();  local l118 = l117; single_value();  l113 = l118 local tmpres = l113 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l115.error ~= n and (l115.error ~= KEYWORD.TAG or l115.tag ~= l114) then if l115.error == KEYWORD.TAG then  error(l115) else error(l115[1]) end end l105 = CL["VALUES-LIST"](list_r(l115)) else  l105 = n.bound end l84 = l105 end l74 = l84 else  l74 = n.bound end l65 = l74 end l11 = l65 end return l11 end, 8, 0, false, false)); i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("E"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 local l5 = n if n ~= l2 then  single_value();  l5 = CL_LIB["FORMAT-ERROR"]("Colon flag not allowed", l()) else  l5 = n.bound end i( l5 );
 single_value();  local l8 = n if n ~= l4 then  local l9 = l4; single_value();  local l10 = (l9)[1]; single_value();  single_value();  local l11 = (l9)[2]; single_value();  l4 = l11 i( l4 );
 single_value();  l8 = l10 else  l8 = n.bound end local l7 = l8; single_value();  local l12 = n if n ~= l7 then  l12 = l7 else  l12 = n.bound end local l6 = l12; local l15 = n if n ~= l4 then  local l16 = l4; single_value();  local l17 = (l16)[1]; single_value();  single_value();  local l18 = (l16)[2]; single_value();  l4 = l18 i( l4 );
 single_value();  l15 = l17 else  l15 = n.bound end local l14 = l15; single_value();  local l19 = n if n ~= l14 then  l19 = l14 else  l19 = n.bound end local l13 = l19; local l22 = n if n ~= l4 then  local l23 = l4; single_value();  local l24 = (l23)[1]; single_value();  single_value();  local l25 = (l23)[2]; single_value();  l4 = l25 i( l4 );
 single_value();  l22 = l24 else  l22 = n.bound end local l21 = l22; single_value();  local l26 = n if n ~= l21 then  l26 = l21 else  l26 = n.bound end local l20 = l26; local l29 = n if n ~= l4 then  local l30 = l4; single_value();  local l31 = (l30)[1]; single_value();  single_value();  local l32 = (l30)[2]; single_value();  l4 = l32 i( l4 );
 single_value();  l29 = l31 else  l29 = n.bound end local l28 = l29; single_value();  local l33 = n if n ~= l28 then  l33 = l28 else  l33 = 1 end local l27 = l33; local l36 = n if n ~= l4 then  local l37 = l4; single_value();  local l38 = (l37)[1]; single_value();  single_value();  local l39 = (l37)[2]; single_value();  l4 = l39 i( l4 );
 single_value();  l36 = l38 else  l36 = n.bound end local l35 = l36; single_value();  local l40 = n if n ~= l35 then  l40 = l35 else  l40 = n.bound end local l34 = l40; local l43 = n if n ~= l4 then  local l44 = l4; single_value();  local l45 = (l44)[1]; single_value();  single_value();  local l46 = (l44)[2]; single_value();  l4 = l46 i( l4 );
 single_value();  l43 = l45 else  l43 = n.bound end local l42 = l43; single_value();  local l47 = n if n ~= l42 then  l47 = l42 else  l47 = LCL['CL-LIB']['MAKE-CHAR'](" ") end local l41 = l47; local l50 = n if n ~= l4 then  local l51 = l4; single_value();  local l52 = (l51)[1]; single_value();  single_value();  local l53 = (l51)[2]; single_value();  l4 = l53 i( l4 );
 single_value();  l50 = l52 else  l50 = n.bound end local l49 = l50; single_value();  local l54 = n if n ~= l49 then  l54 = l49 else  l54 = n.bound end local l48 = l54; local l55 = n if n ~= l4 then  single_value();  l55 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l55 = n.bound end i( l55 );
 single_value();  local l56 = CL_LIB["POP-FORMAT-ARG"](); single_value();  local l57 = n if n ~= CL["FLOATP"](l56) then  l57 = CL_LIB["FORMAT-EXP-AUX"](l1, l56, l6, l13, l20, l27, l34, l41, l48, l3, false, false) else  local l58 = n if n ~= CL["RATIONALP"](l56) then  l58 = CL_LIB["FORMAT-EXP-AUX"](l1, CL["COERCE"](l56, CL["FLOAT"]), l6, l13, l20, l27, l34, l41, l48, l3, false, false) else  local l59 = CL["*PRINT-BASE*"].bound; single_value();  local l60 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l62 = CL["*PRINT-BASE*"].bound; CL["*PRINT-BASE*"].bound = 10 i( CL["*PRINT-BASE*"].bound );
 single_value();  local l61 = l62; single_value();  single_value();  return CL_LIB["FORMAT-WRITE-FIELD"](l1, CL["PRINC-TO-STRING"](l56), l6, 1, 0, LCL['CL-LIB']['MAKE-CHAR'](" "), CL["T"].bound) end, 0, 0, false, false))); CL["*PRINT-BASE*"].bound = l59 i( CL["*PRINT-BASE*"].bound );
 single_value(); if l60.error ~= n and true then if l60.error == KEYWORD.TAG then  error(l60) else error(l60[1]) end end l58 = CL["VALUES-LIST"](list_r(l60)) end l57 = l58 end return l57 end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-EXPONENTIAL"]; single_value();  tmp = CL_LIB["MACRO-SETQ"](CL_LIB["FORMAT-EXPONENT-MARKER"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G241785"],{CL["&OPTIONAL"],{LCL["NIL"]["G241786"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  single_value();  return CL["CONS"](CL_LIB["FLOAT-EXPONENT-CHAR"], CL["CONS"](l5, n)) end, 1, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-EXP-AUX"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["NUMBER"],{CL_LIB["W"],{CL_LIB["D"],{CL_LIB["E"],{CL_LIB["K"],{CL_LIB["OVF"],{CL_LIB["PAD"],{CL_LIB["MARKER"],{CL_LIB["ATSIGN"],{CL["&OPTIONAL"],{CL["STRING"],{CL["EXP"],n}}}}}}}}}}}}},function (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12,  ...)  if not l11 then  l11 = n.bound end if not l12 then  l12 = n.bound end  local l13 = n if n ~= CL["NOT"](l6) then  single_value();  l6 = 1 l13 = l6 else  l13 = n.bound end i( l13 );
 single_value();  local l15 = l3; single_value();  local l16 = n if n ~= l15 then  l16 = l15 else  local l17 = l4; single_value();  local l18 = n if n ~= l17 then  l18 = l17 else  local l19 = l5; single_value();  local l20 = n if n ~= l19 then  l20 = l19 else  local l21 = l9; single_value();  local l22 = n if n ~= l21 then  l22 = l21 else  l22 = CL_LIB["NEQ"](l6, 1) end l20 = l22 end l18 = l20 end l16 = l18 end local l14 = n if n ~= CL["NOT"](l16) then  l14 = CL_LIB["FUNCALL-LUA"]( CL_LIB["PRINT-A-FLOAT"].fbound, {l2, l1, CL["T"].bound, }) else  local l23 = CL["GENSYM"](false); single_value();  local l24 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  local l25 = CL["LIST"](l(n.bound)); single_value();  local l26 = CL["LIST"](l(n.bound)); single_value();  local l27 = l25; single_value();  local l28 = l25; single_value();  single_value();  local l29 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l30; local l31;l30 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l32 = n if n ~= l4 then  single_value();  local l34 = CL["MINUSP"](l4); single_value();  local l35 = n if n ~= l34 then  l35 = l34 else  local l37 = n if n ~= CL["PLUSP"](l6) then  l37 = CL[">="](l(l6,(l4 + 2))) else  l37 = n.bound end local l36 = l37; single_value();  local l38 = n if n ~= l36 then  l38 = l36 else  local l39 = n if n ~= CL["MINUSP"](l6) then  l39 = CL_LIB["%<"](l6, - l4) else  l39 = n.bound end l38 = l39 end l35 = l38 end local l33 = n if n ~= l35 then  single_value();  l33 = CL_LIB["FORMAT-ERROR"]("incompatible values for k and d", l()) else  l33 = n.bound end l32 = l33 else  l32 = n.bound end i( l32 );
 local l40 = n if n ~= CL["NOT"](l12) then  single_value();  l12 = CL_LIB["ACCURATE-SCALE-EXPONENT"](CL["ABS"](l2)) l40 = l12 else  l40 = n.bound end i( l40 );
 single_value();  return CL_LIB["FUNCALL-LUA"]( l31[1], {}) end, 0, 0, false, false)};l31 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l41 = (l12 - l6); single_value();  local l43 = CL["*PRINT-BASE*"].bound; single_value();  local l44 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l46 = CL["*PRINT-BASE*"].bound; CL["*PRINT-BASE*"].bound = 10 i( CL["*PRINT-BASE*"].bound );
 single_value();  local l45 = l46; single_value();  single_value();  return CL["PRINC-TO-STRING"](CL["ABS"](l41)) end, 0, 0, false, false))); CL["*PRINT-BASE*"].bound = l43 i( CL["*PRINT-BASE*"].bound );
 single_value(); if l44.error ~= n and true then if l44.error == KEYWORD.TAG then  error(l44) else error(l44[1]) end end local l42 = CL["VALUES-LIST"](list_r(l44)); single_value();  local l48 = l5; single_value();  local l49 = n if n ~= l48 then  l49 = l48 else  l49 = 0 end local l47 = CL["MAX"](l(CL["LENGTH"](l42),l49)); single_value();  local l51 = n if n ~= l3 then  l51 = (l3 - 2 - l47) else  l51 = n.bound end local l50 = l51; single_value();  local l52 = n.bound; single_value();  local l53 = n.bound; single_value();  local l55 = n if n ~= l3 then  local l56 = l10; single_value();  local l57 = n if n ~= l56 then  l57 = l56 else  l57 = CL["MINUSP"](CL["FLOAT-SIGN"](l2, false)) end l55 = l57 else  l55 = n.bound end local l54 = n if n ~= l55 then  single_value();  l50 = CL["1-"](l50) l54 = l50 else  l54 = n.bound end i( l54 );
 local l58 = n if n ~= l3 then  local l59 = n if n ~= l4 then  local l60 = n if n ~= CL[">"](l(l6,0)) then  l60 = (l4 + 2) else  l60 = (l4 + l6 + 1) end l59 = l60 else  local l61 = n if n ~= CL[">"](l(l6,0)) then  l61 = l50 else  l61 = (l50 + l6) end l59 = l61 end l52 = l59 i( l52 );
 single_value();  local l62 = n if n ~= CL["MINUSP"](l12) then  l52 = (l52 - l12) i( l52 );
 single_value();  local l63 = n if n ~= CL_LIB["%<"](l6, 0) then  single_value();  l52 = CL["1-"](l52) l63 = l52 else  l63 = n.bound end l62 = l63 else  l62 = n.bound end l58 = l62 else  local l65 = n if n ~= l4 then  l65 = CL["NOT"](CL["ZEROP"](l2)) else  l65 = n.bound end local l64 = n if n ~= l65 then  single_value();  l53 = (2 - l6 - l12) l64 = l53 else  l64 = n.bound end l58 = l64 end i( l58 );
 local l68 = n if n ~= l3 then  local l69 = n if n ~= l5 then  local l70 = n if n ~= l7 then  l70 = CL[">"](l(l47,l5)) else  l70 = n.bound end l69 = l70 else  l69 = n.bound end l68 = l69 else  l68 = n.bound end local l67 = l68; single_value();  local l71 = n if n ~= l67 then  l71 = l67 else  local l72 = n if n ~= l3 then  local l73 = n if n ~= l52 then  l73 = CL["NOT"](CL["PLUSP"](l52)) else  l73 = n.bound end l72 = l73 else  l72 = n.bound end l71 = l72 end local l66 = n if n ~= l71 then  local l74 = 0; single_value();  local l75 = CL["GENSYM"](false); single_value();  local l76 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l77 = n if n ~= CL[">="](l(l74,l3)) then  single_value(); do break end; l77 = n.bound else  l77 = n.bound end i( l77 );
 i( n.bound );
 i( CL["WRITE-CHAR"](l7, l1) );
 single_value();  local l78 = (1 + l74); single_value();  single_value();  single_value();  local l79 = l78; single_value();  l74 = l79 local tmpres = l74 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l76.error ~= n and (l76.error ~= KEYWORD.TAG or l76.tag ~= l75) then if l76.error == KEYWORD.TAG then  error(l76) else error(l76[1]) end end i( CL["VALUES-LIST"](list_r(l76)) );
 single_value();  local l80 = n if n ~= CL["PLUSP"](l52) then  local l81 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l80 = error({tag=CL["IDENTITY"](CL.T),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l81)) end)()}) else  l52 = n.bound l80 = l52 end l66 = l80 else  l66 = n.bound end i( l66 );
 local l82 = n if n ~= CL["NOT"](l11) then  single_value();  local l83 = n.bound; local l84 = n.bound; local l85 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l86 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l88 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l87 = l88; single_value();  single_value();  local l89 = n if n ~= CL["NOT"](l52) then  l89 = l4 else  l89 = n.bound end local l90 = n if n ~= CL["NOT"](l52) then  l90 = l53 else  l90 = n.bound end l83,l84= unpack_mv(CL_LIB["FLONUM-TO-STRING"](l2, l52, l89, l90), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l85 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l86.error ~= n and true then if l86.error == KEYWORD.TAG then  error(l86) else error(l86[1]) end end i( CL["VALUES-LIST"](list_r(l86)) );
 l11 = l83 i( l11 );
 local l91 = n if n ~= l53 then  single_value();  l84 = ((1 + l84) - l6 - l53) l91 = l84 else  l91 = n.bound end i( l91 );
 single_value();  local l92 = n if n ~= CL_LIB["NEQ"](l12, l84) then  l12 = l84 i( l12 );
 single_value();  l92 = error({tag=CL["IDENTITY"](l28),(function () single_value() return unpack_mv(l31[1]) end)()}) else  l92 = n.bound end l82 = l92 else  l82 = n.bound end i( l82 );
 single_value();  local l93 = CL["LENGTH"](l11); local l94 = n if n ~= l3 then  single_value();  local l95 = n if n ~= l4 then  l50 = (l50 - (l4 + 2)) l95 = l50 else  local l96 = n if n ~= CL_LIB["%<"](l6, 1) then  l50 = (l50 - (2 + - l6 + CL["MAX"](l(l93,1)))) l96 = l50 else  l50 = (l50 - (1 + l6 + CL["MAX"](l(1,(l93 - l6))))) l96 = l50 end l95 = l96 end l94 = l95 else  l94 = n.bound end i( l94 );
 local l98 = n if n ~= l3 then  l98 = CL_LIB["%<"](l50, 0) else  l98 = n.bound end local l97 = n if n ~= l98 then  single_value();  local l100 = n if n ~= l7 then  local l101 = CL["PLUSP"](l6); single_value();  local l102 = n if n ~= l101 then  l102 = l101 else  l102 = CL_LIB["%<"](l50, -1) end l100 = l102 else  l100 = n.bound end local l99 = n if n ~= l100 then  local l103 = 0; single_value();  local l104 = CL["GENSYM"](false); single_value();  local l105 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l106 = n if n ~= CL[">="](l(l103,l3)) then  single_value(); do break end; l106 = n.bound else  l106 = n.bound end i( l106 );
 i( n.bound );
 i( CL["WRITE-CHAR"](l7, l1) );
 single_value();  local l107 = (1 + l103); single_value();  single_value();  single_value();  local l108 = l107; single_value();  l103 = l108 local tmpres = l103 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l105.error ~= n and (l105.error ~= KEYWORD.TAG or l105.tag ~= l104) then if l105.error == KEYWORD.TAG then  error(l105) else error(l105[1]) end end i( CL["VALUES-LIST"](list_r(l105)) );
 single_value();  local l109 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l99 = error({tag=CL["IDENTITY"](CL.T),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l109)) end)()}) else  l99 = n.bound end l97 = l99 else  l97 = n.bound end i( l97 );
 local l110 = n if n ~= l3 then  single_value();  local l111 = 0; single_value();  local l112 = CL["GENSYM"](false); single_value();  local l113 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l114 = n if n ~= CL[">="](l(l111,l50)) then  single_value(); do break end; l114 = n.bound else  l114 = n.bound end i( l114 );
 i( n.bound );
 i( CL["WRITE-CHAR"](l8, l1) );
 single_value();  local l115 = (1 + l111); single_value();  single_value();  single_value();  local l116 = l115; single_value();  l111 = l116 local tmpres = l111 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l113.error ~= n and (l113.error ~= KEYWORD.TAG or l113.tag ~= l112) then if l113.error == KEYWORD.TAG then  error(l113) else error(l113[1]) end end l110 = CL["VALUES-LIST"](list_r(l113)) else  l110 = n.bound end i( l110 );
 local l117 = n if n ~= CL["MINUSP"](CL["FLOAT-SIGN"](l2, false)) then  l117 = CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("-"), l1) else  local l118 = n if n ~= l10 then  l118 = CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("+"), l1) else  l118 = n.bound end l117 = l118 end i( l117 );
 local l119 = n if n ~= CL_LIB["%<"](l6, 1) then  local l120 = n if n ~= CL["NOT"](CL["MINUSP"](l50)) then  single_value();  l120 = CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) else  l120 = n.bound end i( l120 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("."), l1) );
 local l121 = 0; single_value();  local l122 = CL["GENSYM"](false); single_value();  local l123 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l124 = n if n ~= CL[">="](l(l121,- l6)) then  single_value(); do break end; l124 = n.bound else  l124 = n.bound end i( l124 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) );
 single_value();  local l125 = (1 + l121); single_value();  single_value();  single_value();  local l126 = l125; single_value();  l121 = l126 local tmpres = l121 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l123.error ~= n and (l123.error ~= KEYWORD.TAG or l123.tag ~= l122) then if l123.error == KEYWORD.TAG then  error(l123) else error(l123[1]) end end i( CL["VALUES-LIST"](list_r(l123)) );
 local l128 = n if n ~= CL["EQ"](l93, 0) then  l128 = CL["NOT"](l4) else  l128 = n.bound end local l127 = n if n ~= l128 then  l127 = CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) else  l127 = CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, l11) end i( l127 );
 single_value();  local l129 = n if n ~= l4 then  local l130 = 0; single_value();  local l131 = CL["GENSYM"](false); single_value();  local l132 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l133 = n if n ~= CL[">="](l(l130,((l4 + l6) - l93))) then  single_value(); do break end; l133 = n.bound else  l133 = n.bound end i( l133 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) );
 single_value();  local l134 = (1 + l130); single_value();  single_value();  single_value();  local l135 = l134; single_value();  l130 = l135 local tmpres = l130 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l132.error ~= n and (l132.error ~= KEYWORD.TAG or l132.tag ~= l131) then if l132.error == KEYWORD.TAG then  error(l132) else error(l132[1]) end end l129 = CL["VALUES-LIST"](list_r(l132)) else  l129 = n.bound end l119 = l129 else  local l136 = n if n ~= CL["T"].bound then  i( CL["WRITE-STRING"](l11, l1, k(CL_LIB["START"], 0, CL_LIB["END"], CL["MIN"](l(l6,l93)))) );
 local l137 = 0; single_value();  local l138 = CL["GENSYM"](false); single_value();  local l139 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l140 = n if n ~= CL[">="](l(l137,(l6 - l93))) then  single_value(); do break end; l140 = n.bound else  l140 = n.bound end i( l140 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) );
 single_value();  local l141 = (1 + l137); single_value();  single_value();  single_value();  local l142 = l141; single_value();  l137 = l142 local tmpres = l137 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l139.error ~= n and (l139.error ~= KEYWORD.TAG or l139.tag ~= l138) then if l139.error == KEYWORD.TAG then  error(l139) else error(l139[1]) end end i( CL["VALUES-LIST"](list_r(l139)) );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("."), l1) );
 local l143 = n if n ~= CL[">"](l(l93,l6)) then  single_value();  l143 = CL["WRITE-STRING"](l11, l1, k(CL_LIB["START"], l6, CL_LIB["END"], l93)) else  l143 = n.bound end i( l143 );
 single_value();  local l144 = n if n ~= CL["NOT"](l4) then  local l145 = n if n ~= CL["<="](l(l93,l6)) then  single_value();  l145 = CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) else  l145 = n.bound end l144 = l145 else  local l146 = 0; single_value();  local l147 = CL["GENSYM"](false); single_value();  local l148 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l149 = n if n ~= CL[">="](l(l146,CL["1+"]((l4 - l6 - CL["MAX"](l(0,(l93 - l6))))))) then  single_value(); do break end; l149 = n.bound else  l149 = n.bound end i( l149 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) );
 single_value();  local l150 = (1 + l146); single_value();  single_value();  single_value();  local l151 = l150; single_value();  l146 = l151 local tmpres = l146 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l148.error ~= n and (l148.error ~= KEYWORD.TAG or l148.tag ~= l147) then if l148.error == KEYWORD.TAG then  error(l148) else error(l148[1]) end end l144 = CL["VALUES-LIST"](list_r(l148)) end l136 = l144 else  l136 = n.bound end l119 = l136 end i( l119 );
 local l152 = n if n ~= l9 then  l152 = l9 else  l152 = CL_LIB["FUNCALL-LUA"]( CL_LIB["FLOAT-EXPONENT-CHAR"].fbound, {l2, }) end i( CL["WRITE-CHAR"](l152, l1) );
 local l153 = n if n ~= CL["MINUSP"](l41) then  l153 = LCL['CL-LIB']['MAKE-CHAR']("-") else  l153 = LCL['CL-LIB']['MAKE-CHAR']("+") end i( CL["WRITE-CHAR"](l153, l1) );
 local l154 = n if n ~= l5 then  single_value();  local l155 = 0; single_value();  local l156 = CL["GENSYM"](false); single_value();  local l157 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l158 = n if n ~= CL[">="](l(l155,(l5 - CL["LENGTH"](l42)))) then  single_value(); do break end; l158 = n.bound else  l158 = n.bound end i( l158 );
 i( n.bound );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) );
 single_value();  local l159 = (1 + l155); single_value();  single_value();  single_value();  local l160 = l159; single_value();  l155 = l160 local tmpres = l155 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l157.error ~= n and (l157.error ~= KEYWORD.TAG or l157.tag ~= l156) then if l157.error == KEYWORD.TAG then  error(l157) else error(l157[1]) end end l154 = CL["VALUES-LIST"](list_r(l157)) else  l154 = n.bound end i( l154 );
 single_value();  i( CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, l42) );
 single_value();  return error({tag=CL["IDENTITY"](l26),(function () single_value() return unpack_mv(n) end)()}) end, 0, 0, false, false)}; single_value();  local l161 = l30[1]; single_value();  while true do  single_value();  local l162 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB['FUNCALL-LUA'](l161,{}) end, 0, 0, false, false))); single_value(); if l162.error ~= n and (l162.error ~= KEYWORD.TAG or l162.tag ~= l25) then if l162.error == KEYWORD.TAG then  error(l162) else error(l162[1]) end end l161 = CL["VALUES-LIST"](list_r(l162)) local tmpres = l161 end return n end, 0, 0, false, false))); single_value(); if l29.error ~= n and (l29.error ~= KEYWORD.TAG or l29.tag ~= l26) then if l29.error == KEYWORD.TAG then  error(l29) else error(l29[1]) end end return CL["VALUES-LIST"](list_r(l29)) end, 0, 0, false, false))); single_value(); if l24.error ~= n and (l24.error ~= KEYWORD.TAG or l24.tag ~= l23) then if l24.error == KEYWORD.TAG then  error(l24) else error(l24[1]) end end l14 = CL["VALUES-LIST"](list_r(l24)) end return l14 end, 10, 2, false, false)); i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("G"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 local l5 = n if n ~= l2 then  single_value();  l5 = CL_LIB["FORMAT-ERROR"]("Colon flag not allowed", l()) else  l5 = n.bound end i( l5 );
 single_value();  local l8 = n if n ~= l4 then  local l9 = l4; single_value();  local l10 = (l9)[1]; single_value();  single_value();  local l11 = (l9)[2]; single_value();  l4 = l11 i( l4 );
 single_value();  l8 = l10 else  l8 = n.bound end local l7 = l8; single_value();  local l12 = n if n ~= l7 then  l12 = l7 else  l12 = n.bound end local l6 = l12; local l15 = n if n ~= l4 then  local l16 = l4; single_value();  local l17 = (l16)[1]; single_value();  single_value();  local l18 = (l16)[2]; single_value();  l4 = l18 i( l4 );
 single_value();  l15 = l17 else  l15 = n.bound end local l14 = l15; single_value();  local l19 = n if n ~= l14 then  l19 = l14 else  l19 = n.bound end local l13 = l19; local l22 = n if n ~= l4 then  local l23 = l4; single_value();  local l24 = (l23)[1]; single_value();  single_value();  local l25 = (l23)[2]; single_value();  l4 = l25 i( l4 );
 single_value();  l22 = l24 else  l22 = n.bound end local l21 = l22; single_value();  local l26 = n if n ~= l21 then  l26 = l21 else  l26 = n.bound end local l20 = l26; local l29 = n if n ~= l4 then  local l30 = l4; single_value();  local l31 = (l30)[1]; single_value();  single_value();  local l32 = (l30)[2]; single_value();  l4 = l32 i( l4 );
 single_value();  l29 = l31 else  l29 = n.bound end local l28 = l29; single_value();  local l33 = n if n ~= l28 then  l33 = l28 else  l33 = n.bound end local l27 = l33; local l36 = n if n ~= l4 then  local l37 = l4; single_value();  local l38 = (l37)[1]; single_value();  single_value();  local l39 = (l37)[2]; single_value();  l4 = l39 i( l4 );
 single_value();  l36 = l38 else  l36 = n.bound end local l35 = l36; single_value();  local l40 = n if n ~= l35 then  l40 = l35 else  l40 = n.bound end local l34 = l40; local l43 = n if n ~= l4 then  local l44 = l4; single_value();  local l45 = (l44)[1]; single_value();  single_value();  local l46 = (l44)[2]; single_value();  l4 = l46 i( l4 );
 single_value();  l43 = l45 else  l43 = n.bound end local l42 = l43; single_value();  local l47 = n if n ~= l42 then  l47 = l42 else  l47 = LCL['CL-LIB']['MAKE-CHAR'](" ") end local l41 = l47; local l50 = n if n ~= l4 then  local l51 = l4; single_value();  local l52 = (l51)[1]; single_value();  single_value();  local l53 = (l51)[2]; single_value();  l4 = l53 i( l4 );
 single_value();  l50 = l52 else  l50 = n.bound end local l49 = l50; single_value();  local l54 = n if n ~= l49 then  l54 = l49 else  l54 = n.bound end local l48 = l54; local l55 = n if n ~= l4 then  single_value();  l55 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l55 = n.bound end i( l55 );
 single_value();  local l56 = CL_LIB["POP-FORMAT-ARG"](); single_value();  local l57 = n if n ~= CL["FLOATP"](l56) then  l57 = CL_LIB["FORMAT-GENERAL-AUX"](l1, l56, l6, l13, l20, l27, l34, l41, l48, l3) else  local l58 = n if n ~= CL["RATIONALP"](l56) then  l58 = CL_LIB["FORMAT-GENERAL-AUX"](l1, CL["COERCE"](l56, CL["FLOAT"]), l6, l13, l20, l27, l34, l41, l48, l3) else  local l59 = CL["*PRINT-BASE*"].bound; single_value();  local l60 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l62 = CL["*PRINT-BASE*"].bound; CL["*PRINT-BASE*"].bound = 10 i( CL["*PRINT-BASE*"].bound );
 single_value();  local l61 = l62; single_value();  single_value();  return CL_LIB["FORMAT-WRITE-FIELD"](l1, CL["PRINC-TO-STRING"](l56), l6, 1, 0, LCL['CL-LIB']['MAKE-CHAR'](" "), CL["T"].bound) end, 0, 0, false, false))); CL["*PRINT-BASE*"].bound = l59 i( CL["*PRINT-BASE*"].bound );
 single_value(); if l60.error ~= n and true then if l60.error == KEYWORD.TAG then  error(l60) else error(l60[1]) end end l58 = CL["VALUES-LIST"](list_r(l60)) end l57 = l58 end return l57 end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-GENERAL-FLOAT"]; tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-GENERAL-AUX"] , CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL["NUMBER"],{CL_LIB["W"],{CL_LIB["D"],{CL_LIB["E"],{CL_LIB["K"],{CL_LIB["OVF"],{CL_LIB["PAD"],{CL_LIB["MARKER"],{CL_LIB["ATSIGN"],n}}}}}}}}}},function (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10,  ...)   single_value();  local l11 = n.bound; local l12 = n.bound; local l13 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l14 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l16 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l15 = l16; single_value();  single_value();  l11,l12= unpack_mv(CL_LIB["FLONUM-TO-STRING"](l2, false, false, false), 2) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l13 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l14.error ~= n and true then if l14.error == KEYWORD.TAG then  error(l14) else error(l14[1]) end end i( CL["VALUES-LIST"](list_r(l14)) );
 single_value();  local l18 = l4; single_value();  local l19 = n if n ~= l18 then  l19 = l18 else  l19 = CL["MAX"](l(CL["LENGTH"](l11),CL["MIN"](l(l12,7)))) end local l17 = l19; single_value();  local l21 = n if n ~= l5 then  l21 = (l5 + 2) else  l21 = 4 end local l20 = l21; single_value();  local l23 = n if n ~= l3 then  l23 = (l3 - l20) else  l23 = n.bound end local l22 = l23; single_value();  local l24 = (l17 - l12); single_value();  single_value();  local l25 = n if n ~= CL["<="](l(0,l24,l17)) then  i( CL_LIB["FORMAT-FIXED-AUX"](l1, l2, l22, l24, n.bound, l7, l8, l10) );
 single_value();  local l26 = 0; single_value();  local l27 = CL["GENSYM"](false); single_value();  local l28 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l29 = n if n ~= CL[">="](l(l26,l20)) then  single_value(); do break end; l29 = n.bound else  l29 = n.bound end i( l29 );
 i( n.bound );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR'](" "), l1) );
 single_value();  local l30 = (1 + l26); single_value();  single_value();  single_value();  local l31 = l30; single_value();  l26 = l31 local tmpres = l26 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l28.error ~= n and (l28.error ~= KEYWORD.TAG or l28.tag ~= l27) then if l28.error == KEYWORD.TAG then  error(l28) else error(l28[1]) end end l25 = CL["VALUES-LIST"](list_r(l28)) else  local l32 = n if n ~= CL["T"].bound then  single_value();  local l33 = l6; single_value();  local l34 = n if n ~= l33 then  l34 = l33 else  l34 = 1 end l32 = CL_LIB["FORMAT-EXP-AUX"](l1, l2, l3, l4, l5, l34, l7, l8, l9, l10, n.bound, l12) else  l32 = n.bound end l25 = l32 end return l25 end, 10, 0, false, false)); i( CL_LIB["ADD-FORMAT-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("$"), CL_LIB["ALLOC-FUNCTION"]({CL["STREAM"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["&REST"],{CL_LIB["PARMS"],n}}}}},function (l1, l2, l3, l4,  ...)   i( n.bound );
 single_value();  local l7 = n if n ~= l4 then  local l8 = l4; single_value();  local l9 = (l8)[1]; single_value();  single_value();  local l10 = (l8)[2]; single_value();  l4 = l10 i( l4 );
 single_value();  l7 = l9 else  l7 = n.bound end local l6 = l7; single_value();  local l11 = n if n ~= l6 then  l11 = l6 else  l11 = 2 end local l5 = l11; local l14 = n if n ~= l4 then  local l15 = l4; single_value();  local l16 = (l15)[1]; single_value();  single_value();  local l17 = (l15)[2]; single_value();  l4 = l17 i( l4 );
 single_value();  l14 = l16 else  l14 = n.bound end local l13 = l14; single_value();  local l18 = n if n ~= l13 then  l18 = l13 else  l18 = 1 end local l12 = l18; local l21 = n if n ~= l4 then  local l22 = l4; single_value();  local l23 = (l22)[1]; single_value();  single_value();  local l24 = (l22)[2]; single_value();  l4 = l24 i( l4 );
 single_value();  l21 = l23 else  l21 = n.bound end local l20 = l21; single_value();  local l25 = n if n ~= l20 then  l25 = l20 else  l25 = 0 end local l19 = l25; local l28 = n if n ~= l4 then  local l29 = l4; single_value();  local l30 = (l29)[1]; single_value();  single_value();  local l31 = (l29)[2]; single_value();  l4 = l31 i( l4 );
 single_value();  l28 = l30 else  l28 = n.bound end local l27 = l28; single_value();  local l32 = n if n ~= l27 then  l32 = l27 else  l32 = LCL['CL-LIB']['MAKE-CHAR'](" ") end local l26 = l32; local l33 = n if n ~= l4 then  single_value();  l33 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l33 = n.bound end i( l33 );
 single_value();  local l34 = CL["FLOAT"](CL_LIB["POP-FORMAT-ARG"](), false); single_value();  local l36 = n if n ~= CL["MINUSP"](CL["FLOAT-SIGN"](l34, false)) then  l36 = "-" else  local l37 = n if n ~= l3 then  l37 = "+" else  l37 = "" end l36 = l37 end local l35 = l36; single_value();  local l38 = n.bound; single_value();  local l39 = n.bound; single_value();  single_value();  local l40 = n.bound; local l41 = n.bound; local l42 = n.bound; local l43 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l44 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l46 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l45 = l46; single_value();  single_value();  l40,l41,l42= unpack_mv(CL_LIB["FLONUM-TO-STRING"](l34, n.bound, l5, false), 3) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l43 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l44.error ~= n and true then if l44.error == KEYWORD.TAG then  error(l44) else error(l44[1]) end end i( CL["VALUES-LIST"](list_r(l44)) );
 l39 = CL["LENGTH"](l40) i( l39 );
 l38 = (l19 - (CL["LENGTH"](l35) + CL["MAX"](l(l41,l12)) + 1 + l5)) i( l38 );
 local l47 = n if n ~= l2 then  single_value();  l47 = CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, l35) else  l47 = n.bound end i( l47 );
 local l48 = 0; single_value();  local l49 = CL["GENSYM"](false); single_value();  local l50 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l51 = n if n ~= CL[">="](l(l48,l38)) then  single_value(); do break end; l51 = n.bound else  l51 = n.bound end i( l51 );
 i( CL["WRITE-CHAR"](l26, l1) );
 single_value();  local l52 = (1 + l48); single_value();  single_value();  single_value();  local l53 = l52; single_value();  l48 = l53 local tmpres = l48 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l50.error ~= n and (l50.error ~= KEYWORD.TAG or l50.tag ~= l49) then if l50.error == KEYWORD.TAG then  error(l50) else error(l50[1]) end end i( CL["VALUES-LIST"](list_r(l50)) );
 local l54 = n if n ~= l2 then  l54 = n.bound else  single_value();  l54 = CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, l35) end i( l54 );
 single_value();  local l55 = n if n ~= CL[">"](l(l41,0)) then  local l56 = 0; single_value();  local l57 = CL["GENSYM"](false); single_value();  local l58 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l59 = n if n ~= CL[">="](l(l56,(l12 - l41))) then  single_value(); do break end; l59 = n.bound else  l59 = n.bound end i( l59 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) );
 single_value();  local l60 = (1 + l56); single_value();  single_value();  single_value();  local l61 = l60; single_value();  l56 = l61 local tmpres = l56 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l58.error ~= n and (l58.error ~= KEYWORD.TAG or l58.tag ~= l57) then if l58.error == KEYWORD.TAG then  error(l58) else error(l58[1]) end end i( CL["VALUES-LIST"](list_r(l58)) );
 single_value();  local l62 = n if n ~= CL[">"](l(l39,l41)) then  i( CL["WRITE-STRING"](l40, l1, k(CL_LIB["START"], 0, CL_LIB["END"], l41)) );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("."), l1) );
 i( CL["WRITE-STRING"](l40, l1, k(CL_LIB["START"], l41, CL_LIB["END"], l39)) );
 single_value();  local l63 = 0; single_value();  local l64 = CL["GENSYM"](false); single_value();  local l65 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l66 = n if n ~= CL[">="](l(l63,(l5 - (l39 - l41)))) then  single_value(); do break end; l66 = n.bound else  l66 = n.bound end i( l66 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) );
 single_value();  local l67 = (1 + l63); single_value();  single_value();  single_value();  local l68 = l67; single_value();  l63 = l68 local tmpres = l63 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l65.error ~= n and (l65.error ~= KEYWORD.TAG or l65.tag ~= l64) then if l65.error == KEYWORD.TAG then  error(l65) else error(l65[1]) end end l62 = CL["VALUES-LIST"](list_r(l65)) else  local l69 = n if n ~= CL["T"].bound then  i( CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, l40) );
 local l70 = 0; single_value();  local l71 = CL["GENSYM"](false); single_value();  local l72 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l73 = n if n ~= CL[">="](l(l70,(l41 - l39))) then  single_value(); do break end; l73 = n.bound else  l73 = n.bound end i( l73 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) );
 single_value();  local l74 = (1 + l70); single_value();  single_value();  single_value();  local l75 = l74; single_value();  l70 = l75 local tmpres = l70 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l72.error ~= n and (l72.error ~= KEYWORD.TAG or l72.tag ~= l71) then if l72.error == KEYWORD.TAG then  error(l72) else error(l72[1]) end end i( CL["VALUES-LIST"](list_r(l72)) );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("."), l1) );
 single_value();  local l76 = 0; single_value();  local l77 = CL["GENSYM"](false); single_value();  local l78 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l79 = n if n ~= CL[">="](l(l76,l5)) then  single_value(); do break end; l79 = n.bound else  l79 = n.bound end i( l79 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) );
 single_value();  local l80 = (1 + l76); single_value();  single_value();  single_value();  local l81 = l80; single_value();  l76 = l81 local tmpres = l76 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l78.error ~= n and (l78.error ~= KEYWORD.TAG or l78.tag ~= l77) then if l78.error == KEYWORD.TAG then  error(l78) else error(l78[1]) end end l69 = CL["VALUES-LIST"](list_r(l78)) else  l69 = n.bound end l62 = l69 end l55 = l62 else  local l82 = n if n ~= CL["T"].bound then  local l83 = 0; single_value();  local l84 = CL["GENSYM"](false); single_value();  local l85 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l86 = n if n ~= CL[">="](l(l83,l12)) then  single_value(); do break end; l86 = n.bound else  l86 = n.bound end i( l86 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) );
 single_value();  local l87 = (1 + l83); single_value();  single_value();  single_value();  local l88 = l87; single_value();  l83 = l88 local tmpres = l83 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l85.error ~= n and (l85.error ~= KEYWORD.TAG or l85.tag ~= l84) then if l85.error == KEYWORD.TAG then  error(l85) else error(l85[1]) end end i( CL["VALUES-LIST"](list_r(l85)) );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("."), l1) );
 local l89 = 0; single_value();  local l90 = CL["GENSYM"](false); single_value();  local l91 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l92 = n if n ~= CL[">="](l(l89,- l41)) then  single_value(); do break end; l92 = n.bound else  l92 = n.bound end i( l92 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) );
 single_value();  local l93 = (1 + l89); single_value();  single_value();  single_value();  local l94 = l93; single_value();  l89 = l94 local tmpres = l89 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l91.error ~= n and (l91.error ~= KEYWORD.TAG or l91.tag ~= l90) then if l91.error == KEYWORD.TAG then  error(l91) else error(l91[1]) end end i( CL["VALUES-LIST"](list_r(l91)) );
 i( CL_LIB["STREAM-WRITE-ENTIRE-STRING"](l1, l40) );
 single_value();  local l95 = 0; single_value();  local l96 = CL["GENSYM"](false); single_value();  local l97 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l98 = n if n ~= CL[">="](l(l95,(l5 + l42))) then  single_value(); do break end; l98 = n.bound else  l98 = n.bound end i( l98 );
 i( CL["WRITE-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("0"), l1) );
 single_value();  local l99 = (1 + l95); single_value();  single_value();  single_value();  local l100 = l99; single_value();  l95 = l100 local tmpres = l95 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l97.error ~= n and (l97.error ~= KEYWORD.TAG or l97.tag ~= l96) then if l97.error == KEYWORD.TAG then  error(l97) else error(l97[1]) end end l82 = CL["VALUES-LIST"](list_r(l97)) else  l82 = n.bound end l55 = l82 end return l55 end, 3, 0, true, false)) );
 single_value();  tmp = CL_LIB["FORMAT-DOLLARS"]; tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["Y-OR-N-P"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{CL_LIB["FORMAT-STRING"],{CL["&REST"],{CL_LIB["ARGUMENTS"],{CL["&AUX"],{CL_LIB["RESPONSE"],n}}}}}},function (l1, l2,  ...)  if not l1 then  l1 = n.bound end l3 = n.bound  i( "Y-OR-N-P prints the message, if any, and reads characters from\n   *QUERY-IO* until the user enters y or Y as an affirmative, or either\n   n or N as a negative answer. It asks again if you enter any other\n   characters." );
 i( n.bound );
 single_value();  local l4 = CL["GENSYM"](false); single_value();  local l5 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  single_value();  local l6 = n if n ~= l1 then  i( CL["FRESH-LINE"](CL["*QUERY-IO*"].bound) );
 single_value();  l6 = CL["APPLY"](CL["FORMAT"], CL["*QUERY-IO*"].bound, l(l1,l2)) else  l6 = n.bound end i( l6 );
 i( CL["PRINC"](" (y or n)  ", CL["*QUERY-IO*"].bound) );
 l3 = CL["READ-CHAR"](CL["*QUERY-IO*"].bound, false, false, false) i( l3 );
 local l7 = n if n ~= CL["PEEK-CHAR"](LCL['CL-LIB']['MAKE-CHAR']("\n"), CL["*QUERY-IO*"].bound, n.bound, false, false) then  single_value();  l7 = CL["READ-CHAR"](CL["*QUERY-IO*"].bound, false, false, false) else  l7 = n.bound end i( l7 );
 i( CL["CLEAR-INPUT"](CL["*QUERY-IO*"].bound) );
 local l8 = n if n ~= CL["CHAR-EQUAL"](l3, l(LCL['CL-LIB']['MAKE-CHAR']("y"))) then  local l9 = CL["FUNCALL"](l, l(unpack_mv(CL["T"].bound))); single_value();  l8 = error({tag=CL["IDENTITY"](LCL["%BR"]["COMMON-LISP*NIL"].bound),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l9)) end)()}) else  l8 = n.bound end i( l8 );
 local l10 = n if n ~= CL["CHAR-EQUAL"](l3, l(LCL['CL-LIB']['MAKE-CHAR']("n"))) then  local l11 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l10 = error({tag=CL["IDENTITY"](LCL["%BR"]["COMMON-LISP*NIL"].bound),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l11)) end)()}) else  l10 = n.bound end i( l10 );
 single_value();  local tmpres = CL["FORMAT"](CL["*QUERY-IO*"].bound, "Please answer y or n.", l()) end return n end, 0, 0, false, false))); single_value(); if l5.error ~= n and (l5.error ~= KEYWORD.TAG or l5.tag ~= l4) then if l5.error == KEYWORD.TAG then  error(l5) else error(l5[1]) end end return CL_LIB["FUNCALL-LUA"]( CL_LIB["WITH-TERMINAL-INPUT"].fbound, {CL["CLEAR-INPUT"](CL["*QUERY-IO*"].bound), CL["VALUES-LIST"](list_r(l5)), }) end, 0, 1, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["YES-OR-NO-P"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{CL_LIB["FORMAT-STRING"],{CL["&REST"],{CL_LIB["ARGUMENTS"],{CL["&AUX"],{CL_LIB["RESPONSE"],n}}}}}},function (l1, l2,  ...)  if not l1 then  l1 = n.bound end l3 = n.bound  i( "YES-OR-NO-P is similar to Y-OR-N-P, except that it clears the\n   input buffer, beeps, and uses READ-LINE to get the strings\n   YES or NO." );
 i( n.bound );
 single_value();  local l4 = CL["GENSYM"](false); single_value();  local l5 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  while true do  single_value();  local l6 = n if n ~= l1 then  i( CL["FRESH-LINE"](CL["*QUERY-IO*"].bound) );
 single_value();  l6 = CL["APPLY"](CL["FORMAT"], CL["*QUERY-IO*"].bound, l(l1,l2)) else  l6 = n.bound end i( l6 );
 i( CL["PRINC"](" (yes or no)  ", CL["*QUERY-IO*"].bound) );
 i( CL["FORMAT"](CL["*QUERY-IO*"].bound, "~A", l(n.bound)) );
 l3 = CL["READ-LINE"](CL["*QUERY-IO*"].bound) i( l3 );
 i( CL["CLEAR-INPUT"](CL["*QUERY-IO*"].bound) );
 single_value();  local l7 = n if n ~= l3 then  l3 = CL["STRING-TRIM"](CL_LIB["WSP"].bound, l3) i( l3 );
 local l8 = n if n ~= CL["STRING-EQUAL"](l3, l("yes")) then  local l9 = CL["FUNCALL"](l, l(unpack_mv(CL["T"].bound))); single_value();  l8 = error({tag=CL["IDENTITY"](LCL["%BR"]["COMMON-LISP*NIL"].bound),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l9)) end)()}) else  l8 = n.bound end i( l8 );
 local l10 = n if n ~= CL["STRING-EQUAL"](l3, l("no")) then  local l11 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l10 = error({tag=CL["IDENTITY"](LCL["%BR"]["COMMON-LISP*NIL"].bound),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l11)) end)()}) else  l10 = n.bound end i( l10 );
 single_value();  l7 = CL["FORMAT"](CL["*QUERY-IO*"].bound, "Please answer yes or no.", l()) else  l7 = n.bound end local tmpres = l7 end return n end, 0, 0, false, false))); single_value(); if l5.error ~= n and (l5.error ~= KEYWORD.TAG or l5.tag ~= l4) then if l5.error == KEYWORD.TAG then  error(l5) else error(l5[1]) end end return CL_LIB["FUNCALL-LUA"]( CL_LIB["WITH-TERMINAL-INPUT"].fbound, {CL["VALUES-LIST"](list_r(l5)), }) end, 0, 1, true, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["NOTE-FORMAT-SCAN-OPTION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["CELL"],n},function (l1,  ...)   local l2 = n if n ~= l1 then  single_value();  local l3 = n if n ~= CL["NULL"]((l1)[2]) then  local l4 = l1; single_value();  single_value();  local l5 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; single_value();  i( CL_LIB["%CAR-UPDATE"](l4, l5) );
 single_value();  single_value();  local l6 = l1; single_value();  single_value();  local l7 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound; single_value();  l3 = CL_LIB["%CDR-UPDATE"](l6, l7) else  local l8 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; single_value();  local l9 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound; single_value();  local l10 = CL["LENGTH"](l8); single_value();  local l11 = (l1)[1]; single_value();  local l12 = (l1)[2]; single_value();  local l13 = CL["LENGTH"](l11); single_value();  local l14 = CL["MIN"](l((l10 - l9),(l13 - l12))); single_value();  single_value();  local l15 = n if n ~= CL[">="](l(l10,l13)) then  local l16 = l1; single_value();  single_value();  local l17 = l8; single_value();  i( CL_LIB["%CAR-UPDATE"](l16, l17) );
 single_value();  single_value();  local l18 = l1; single_value();  single_value();  local l19 = (l10 - l14); single_value();  l15 = CL_LIB["%CDR-UPDATE"](l18, l19) else  single_value();  local l20 = l1; single_value();  single_value();  local l21 = (l13 - l14); single_value();  l15 = CL_LIB["%CDR-UPDATE"](l20, l21) end l3 = l15 end l2 = l3 else  l2 = n.bound end i( l2 );
 single_value();  return l1 end, 1, 0, false, false)); tmp = CL_LIB["MACRO-SETQ"](CL_LIB["WITH-FORMAT-SCAN-OPTIONS"],CL_LIB["ALLOC-FUNCTION"]({LCL["NIL"]["G243786"],{CL["&OPTIONAL"],{LCL["NIL"]["G243787"],n}}},function (l1, l2,  ...)  if not l2 then  l2 = n.bound end  single_value();  local l3 = (l1)[2]; single_value();  local l4 = (l1)[2]; single_value();  local l6 = l4; single_value();  local l7 = (l6)[1]; single_value();  single_value();  local l8 = (l6)[2]; single_value();  l4 = l8 i( l4 );
 single_value();  local l5 = l7; single_value();  local l10 = l5; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l5 = l12 i( l5 );
 single_value();  local l9 = l11; single_value();  local l13 = l4; single_value();  single_value();  local l14 = CL["GENSYM"](false); single_value();  return CL["CONS"](CL["LET*"], CL["CONS"](CL["CONS"](CL["CONS"](l14, CL["CONS"](CL["CONS"](CL["CONS"], CL["CONS"](n, CL["CONS"](n, n))), n)), CL["CONS"](CL["CONS"](l9, CL["CONS"](l14, n)), n)), CL["CONS"](CL["CONS"](CL["DECLARE"], CL["CONS"](CL["CONS"](CL_LIB["DYNAMIC-EXTENT"], CL["CONS"](l14, n)), n)), CL["CONS"](CL["CONS"](CL["PROG1"], CL["CONS"](CL["CONS"](CL["PROGN"], CL["APPEND"](l(l13,n))), CL["CONS"](CL["CONS"](CL["SETQ"], CL["CONS"](CL_LIB["*FORMAT-ARGUMENTS*"], CL["CONS"](CL["CONS"](CL["CAR"], CL["CONS"](l14, n)), CL["CONS"](CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"], CL["CONS"](CL["CONS"](CL["CDR"], CL["CONS"](l14, n)), n))))), n))), n)))) end, 1, 1, false, false)); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL_LIB["*FORMAT-ESCAPE-OPTIONS*"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["NX1-CHECK-FORMAT-CALL"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["CONTROL-STRING"],{CL_LIB["FORMAT-ARGUMENTS"],{CL["&OPTIONAL"],{{CL_LIB["ENV"],{CL_LIB["*NX-LEXICAL-ENVIRONMENT*"],n}},n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = CL_LIB["*NX-LEXICAL-ENVIRONMENT*"].bound end  i( "Format-arguments are expressions that will evaluate to the actual arguments.\n  Pre-scan process the format string, nx1-whine if find errors" );
 single_value();  local l4 = l3; single_value();  local l5 = CL_LIB["*FORMAT-TOP-LEVEL*"].bound; single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l8 = CL_LIB["*FORMAT-TOP-LEVEL*"].bound; CL_LIB["*FORMAT-TOP-LEVEL*"].bound = CL["T"].bound i( CL_LIB["*FORMAT-TOP-LEVEL*"].bound );
 single_value();  local l7 = l8; single_value();  single_value();  local l9 = CL_LIB["*LOGICAL-BLOCK-XP*"].bound; single_value();  local l10 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l12 = CL_LIB["*LOGICAL-BLOCK-XP*"].bound; CL_LIB["*LOGICAL-BLOCK-XP*"].bound = n.bound i( CL_LIB["*LOGICAL-BLOCK-XP*"].bound );
 single_value();  local l11 = l12; single_value();  single_value();  local l13 = CL_LIB["*FORMAT-PPRINT*"].bound; single_value();  local l14 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l16 = CL_LIB["*FORMAT-PPRINT*"].bound; CL_LIB["*FORMAT-PPRINT*"].bound = n.bound i( CL_LIB["*FORMAT-PPRINT*"].bound );
 single_value();  local l15 = l16; single_value();  single_value();  local l17 = CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"].bound; single_value();  local l18 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l20 = CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"].bound; CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"].bound = n.bound i( CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"].bound );
 single_value();  local l19 = l20; single_value();  single_value();  single_value();  local l22 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   i( CL_LIB["FORMAT-SCAN"](l1, l2, 0) );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l22.error ~= n and (l22.error ~= KEYWORD.TAG or l22.tag ~= CL_LIB["FORMAT-ERROR"]) then if l22.error == KEYWORD.TAG then  error(l22) else error(l22[1]) end end local l21 = CL["VALUES-LIST"](list_r(l22)); single_value();  local l23 = n if n ~= l21 then  single_value();  i( CL["FUNCALL"](CL["CADAR"].setfbound, l(CL["CONCATENATE"](CL["STRING"], l(CL["CADAR"](l21)," in format string:")),l21)) );
 i( CL_LIB["FUNCALL-LUA"]( CL_LIB["NX1-WHINE"].fbound, {LCL["KEYWORD"]["FORMAT-ERROR"], CL["NREVERSE"](l21), }) );
 single_value();  l23 = CL["T"].bound else  l23 = n.bound end return l23 end, 0, 0, false, false))); CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"].bound = l17 i( CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"].bound );
 single_value(); if l18.error ~= n and true then if l18.error == KEYWORD.TAG then  error(l18) else error(l18[1]) end end return CL["VALUES-LIST"](list_r(l18)) end, 0, 0, false, false))); CL_LIB["*FORMAT-PPRINT*"].bound = l13 i( CL_LIB["*FORMAT-PPRINT*"].bound );
 single_value(); if l14.error ~= n and true then if l14.error == KEYWORD.TAG then  error(l14) else error(l14[1]) end end return CL["VALUES-LIST"](list_r(l14)) end, 0, 0, false, false))); CL_LIB["*LOGICAL-BLOCK-XP*"].bound = l9 i( CL_LIB["*LOGICAL-BLOCK-XP*"].bound );
 single_value(); if l10.error ~= n and true then if l10.error == KEYWORD.TAG then  error(l10) else error(l10[1]) end end return CL["VALUES-LIST"](list_r(l10)) end, 0, 0, false, false))); CL_LIB["*FORMAT-TOP-LEVEL*"].bound = l5 i( CL_LIB["*FORMAT-TOP-LEVEL*"].bound );
 single_value(); if l6.error ~= n and true then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end return CL["VALUES-LIST"](list_r(l6)) end, 2, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-SCAN"] , CL_LIB["ALLOC-FUNCTION"]({CL["STRING"],{CL_LIB["ARGS"],{CL_LIB["VAR"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL_LIB["*FORMAT-CONTROL-STRING*"].bound; local l5 = CL_LIB["*FORMAT-COLON-REST*"].bound; local l6 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound; local l7 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; local l8 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; single_value();  local l9 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l11 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound = l2 i( CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound );
 single_value();  local l10 = l11; local l13 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; CL_LIB["*FORMAT-ARGUMENTS*"].bound = l2 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  local l12 = l13; local l15 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound; CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = l3 i( CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound );
 single_value();  local l14 = l15; local l17 = CL_LIB["*FORMAT-COLON-REST*"].bound; CL_LIB["*FORMAT-COLON-REST*"].bound = CL["ERROR"] i( CL_LIB["*FORMAT-COLON-REST*"].bound );
 single_value();  local l16 = l17; local l19 = CL_LIB["*FORMAT-CONTROL-STRING*"].bound; CL_LIB["*FORMAT-CONTROL-STRING*"].bound = CL_LIB["ENSURE-SIMPLE-STRING"](l1) i( CL_LIB["*FORMAT-CONTROL-STRING*"].bound );
 single_value();  local l18 = l19; single_value();  local l20 = CL["CONS"](n.bound, n.bound); single_value();  local l21 = CL_LIB["*FORMAT-ESCAPE-OPTIONS*"].bound; single_value();  local l22 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l24 = CL_LIB["*FORMAT-ESCAPE-OPTIONS*"].bound; CL_LIB["*FORMAT-ESCAPE-OPTIONS*"].bound = l20 i( CL_LIB["*FORMAT-ESCAPE-OPTIONS*"].bound );
 single_value();  local l23 = l24; single_value();  single_value();  i( n.bound );
 single_value();  single_value();  local l26 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   i( CL_LIB["SUB-FORMAT-SCAN"](0, CL["LENGTH"](CL_LIB["*FORMAT-CONTROL-STRING*"].bound)) );
 single_value();  return CL_LIB["NOTE-FORMAT-SCAN-OPTION"](CL_LIB["*FORMAT-ESCAPE-OPTIONS*"].bound) end, 0, 0, false, false))); single_value(); if l26.error ~= n and (l26.error ~= KEYWORD.TAG or l26.tag ~= CL_LIB["FORMAT-ESCAPE"]) then if l26.error == KEYWORD.TAG then  error(l26) else error(l26[1]) end end local l25 = CL["VALUES-LIST"](list_r(l26)); single_value();  local l27 = (l20)[1]; single_value();  CL_LIB["*FORMAT-ARGUMENTS*"].bound = l27 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  single_value();  single_value();  local l28 = (l20)[2]; single_value();  CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = l28 i( CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound );
 single_value();  return l25 end, 0, 0, false, false))); CL_LIB["*FORMAT-ESCAPE-OPTIONS*"].bound = l21 i( CL_LIB["*FORMAT-ESCAPE-OPTIONS*"].bound );
 single_value(); if l22.error ~= n and true then if l22.error == KEYWORD.TAG then  error(l22) else error(l22[1]) end end i( CL["VALUES-LIST"](list_r(l22)) );
 single_value();  local l29 = n if n ~= CL[">"](l(CL["LENGTH"](CL_LIB["*FORMAT-ARGUMENTS*"].bound),CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound)) then  single_value();  l29 = CL_LIB["FORMAT-ERROR"]("Too many format arguments", l()) else  l29 = n.bound end return l29 end, 0, 0, false, false))); CL_LIB["*FORMAT-CONTROL-STRING*"].bound = l4 i( CL_LIB["*FORMAT-CONTROL-STRING*"].bound );
 CL_LIB["*FORMAT-COLON-REST*"].bound = l5 i( CL_LIB["*FORMAT-COLON-REST*"].bound );
 CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = l6 i( CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound );
 CL_LIB["*FORMAT-ARGUMENTS*"].bound = l7 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound = l8 i( CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound );
 single_value(); if l9.error ~= n and true then if l9.error == KEYWORD.TAG then  error(l9) else error(l9[1]) end end return CL["VALUES-LIST"](list_r(l9)) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["SUB-FORMAT-SCAN"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["I"],{CL_LIB["END"],n}},function (l1, l2,  ...)   single_value();  local l3 = CL_LIB["*FORMAT-LENGTH*"].bound; local l4 = CL_LIB["*FORMAT-INDEX*"].bound; single_value();  local l5 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l7 = CL_LIB["*FORMAT-INDEX*"].bound; CL_LIB["*FORMAT-INDEX*"].bound = l1 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value();  local l6 = l7; local l9 = CL_LIB["*FORMAT-LENGTH*"].bound; CL_LIB["*FORMAT-LENGTH*"].bound = l2 i( CL_LIB["*FORMAT-LENGTH*"].bound );
 single_value();  local l8 = l9; local l10 = CL_LIB["*FORMAT-CONTROL-STRING*"].bound; single_value();  single_value();  local l11 = CL["GENSYM"](false); single_value();  local l12 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  local l13 = CL["LIST"](l(n.bound)); single_value();  local l14 = CL["LIST"](l(n.bound)); single_value();  local l15 = l13; single_value();  local l16 = l13; single_value();  local l17 = l13; single_value();  single_value();  local l18 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l19; local l20; local l21;l19 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( l20[1], {}) end, 0, 0, false, false)};l20 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l22 = n.bound; local l23 = n.bound; local l24 = n.bound; local l25 = n.bound; local l26 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l27 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l29 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l28 = l29; single_value();  single_value();  l22,l23,l24,l25= unpack_mv(CL_LIB["PARSE-FORMAT-OPERATION"](CL["T"].bound), 4) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l26 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l27.error ~= n and true then if l27.error == KEYWORD.TAG then  error(l27) else error(l27[1]) end end i( CL["VALUES-LIST"](list_r(l27)) );
 l25 = CL["CHAR-UPCASE"](l25) i( l25 );
 local l30 = CL_LIB["FUNCALL-LUA"]( CL_LIB["%CHAR-CODE"].fbound, {l25, }); single_value();  local l32 = n if n ~= CL["<"](l(-1,l30,CL["LENGTH"](CL_LIB["*FORMAT-CHAR-TABLE*"].bound))) then  l32 = CL["SVREF"](CL_LIB["*FORMAT-CHAR-TABLE*"].bound, l30) else  l32 = n.bound end local l31 = n if n ~= l32 then  l31 = n.bound else  single_value();  l31 = CL_LIB["FORMAT-ERROR"]("Unknown directive ~c", l(l25)) end i( l31 );
 i( CL_LIB["FORMAT-SCAN-DIRECTIVE"](l25, l23, l24, l22) );
 single_value();  single_value();  local l33 = (1 + CL_LIB["*FORMAT-INDEX*"].bound); single_value();  CL_LIB["*FORMAT-INDEX*"].bound = l33 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value();  CL_LIB["*FORMAT-INDEX*"].bound = CL["POSITION"](LCL['CL-LIB']['MAKE-CHAR']("~"), l10, k(CL_LIB["START"], CL_LIB["*FORMAT-INDEX*"].bound, CL_LIB["END"], l2)) local l34 = n if n ~= CL_LIB["*FORMAT-INDEX*"].bound then  l34 = n.bound else  single_value();  l34 = error({tag=CL["IDENTITY"](l17),(function () single_value() return unpack_mv(l21[1]) end)()}) end i( l34 );
 i( error({tag=CL["IDENTITY"](l16),(function () single_value() return unpack_mv(l20[1]) end)()}) );
 single_value();  return CL_LIB["FUNCALL-LUA"]( l21[1], {}) end, 0, 0, false, false)};l21 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l35 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  i( error({tag=CL["IDENTITY"](l11),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l35)) end)()}) );
 single_value();  return error({tag=CL["IDENTITY"](l14),(function () single_value() return unpack_mv(n) end)()}) end, 0, 0, false, false)}; single_value();  local l36 = l19[1]; single_value();  while true do  single_value();  local l37 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB['FUNCALL-LUA'](l36,{}) end, 0, 0, false, false))); single_value(); if l37.error ~= n and (l37.error ~= KEYWORD.TAG or l37.tag ~= l13) then if l37.error == KEYWORD.TAG then  error(l37) else error(l37[1]) end end l36 = CL["VALUES-LIST"](list_r(l37)) local tmpres = l36 end return n end, 0, 0, false, false))); single_value(); if l18.error ~= n and (l18.error ~= KEYWORD.TAG or l18.tag ~= l14) then if l18.error == KEYWORD.TAG then  error(l18) else error(l18[1]) end end return CL["VALUES-LIST"](list_r(l18)) end, 0, 0, false, false))); single_value(); if l12.error ~= n and (l12.error ~= KEYWORD.TAG or l12.tag ~= l11) then if l12.error == KEYWORD.TAG then  error(l12) else error(l12[1]) end end return CL["VALUES-LIST"](list_r(l12)) end, 0, 0, false, false))); CL_LIB["*FORMAT-LENGTH*"].bound = l3 i( CL_LIB["*FORMAT-LENGTH*"].bound );
 CL_LIB["*FORMAT-INDEX*"].bound = l4 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value(); if l5.error ~= n and true then if l5.error == KEYWORD.TAG then  error(l5) else error(l5[1]) end end return CL["VALUES-LIST"](list_r(l5)) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["NX-COULD-BE-TYPE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FORM"],{CL["TYPE"],{CL["&OPTIONAL"],{CL_LIB["TRANSFORMED"],{CL["&AUX"],{{CL_LIB["ENV"],{CL_LIB["*NX-LEXICAL-ENVIRONMENT*"],n}},n}}}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = n.bound end l4 = CL_LIB["*NX-LEXICAL-ENVIRONMENT*"].bound  local l5 = n if n ~= l3 then  l5 = n.bound else  single_value();  l1 = CL_LIB["FUNCALL-LUA"]( CL_LIB["NX-TRANSFORM"].fbound, {l1, l4, }) l5 = l1 end i( l5 );
 single_value();  local l6 = n if n ~= CL_LIB["FUNCALL-LUA"]( CL_LIB["NX-FORM-CONSTANT-P"].fbound, {l1, l4, }) then  l6 = CL["TYPEP"](CL_LIB["FUNCALL-LUA"]( CL_LIB["NX-FORM-CONSTANT-VALUE"].fbound, {l1, l4, }), l2, l4) else  l6 = CL["NOT"](CL_LIB["FUNCALL-LUA"]( CL_LIB["TYPES-DISJOINT-P"].fbound, {CL_LIB["FUNCALL-LUA"]( CL_LIB["NX-FORM-TYPE"].fbound, {l1, l4, }), l2, l4, })) end return l6 end, 2, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-REQUIRE-TYPE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["FORM"],{CL["TYPE"],{CL["&OPTIONAL"],{CL_LIB["DESCRIPTION"],n}}}},function (l1, l2, l3,  ...)  if not l3 then  l3 = n.bound end  single_value();  local l4 = n if n ~= CL_LIB["NX-COULD-BE-TYPE"](l1, l2, false) then  l4 = n.bound else  single_value();  local l5 = l3; single_value();  local l6 = n if n ~= l5 then  l6 = l5 else  l6 = l1 end l4 = CL_LIB["FORMAT-ERROR"]("~a must be of type ~s", l(l6,l2)) end return l4 end, 2, 1, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-SCAN-DIRECTIVE"] , CL_LIB["ALLOC-FUNCTION"]({CL["CHAR"],{CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL_LIB["PARMS"],n}}}},function (l1, l2, l3, l4,  ...)   single_value();  local l5 = l1; single_value();  local l6 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("%"),{LCL['CL-LIB']['MAKE-CHAR']("&"),{LCL['CL-LIB']['MAKE-CHAR']("~"),{LCL['CL-LIB']['MAKE-CHAR']("|"),n}}}}, k()) then  single_value();  local l9 = n if n ~= l4 then  local l10 = l4; single_value();  local l11 = (l10)[1]; single_value();  single_value();  local l12 = (l10)[2]; single_value();  l4 = l12 i( l4 );
 single_value();  l9 = l11 else  l9 = n.bound end local l8 = l9; single_value();  local l13 = n if n ~= l8 then  l13 = l8 else  l13 = 1 end local l7 = l13; local l14 = n if n ~= l4 then  single_value();  l14 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l14 = n.bound end i( l14 );
 i( CL_LIB["FORMAT-NO-FLAGS"](l2, l3) );
 single_value();  l6 = CL_LIB["FORMAT-REQUIRE-TYPE"](l7, {CL["INTEGER"],{0,n}}, false) else  local l15 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("\n"),n}, k()) then  single_value();  local l16 = n if n ~= l4 then  single_value();  l16 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l16 = n.bound end i( l16 );
 local l18 = n if n ~= l3 then  l18 = l2 else  l18 = n.bound end local l17 = n if n ~= l18 then  single_value();  l17 = CL_LIB["FORMAT-ERROR"]("~:@<newline> is undefined", l()) else  l17 = n.bound end i( l17 );
 single_value();  local l19 = n if n ~= l2 then  l19 = n.bound else  single_value();  l19 = CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-EAT-WHITESPACE"].fbound, {}) end l15 = l19 else  local l20 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("P"),n}, k()) then  single_value();  local l21 = n if n ~= l4 then  single_value();  l21 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l21 = n.bound end i( l21 );
 local l22 = n if n ~= l2 then  single_value();  local l23 = CL["GENSYM"](false); single_value();  local l24 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l25 = CL["GENSYM"](false); single_value();  local l26 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l27 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; i( n.bound );
 single_value();  local l28 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; i( n.bound );
 single_value();  single_value();  local l29 = CL["LIST"](l(n.bound)); single_value();  local l30 = CL["LIST"](l(n.bound)); single_value();  local l31 = l29; single_value();  local l32 = l29; single_value();  local l33 = l29; single_value();  single_value();  local l34 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l35; local l36; local l37;l35 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( l36[1], {}) end, 0, 0, false, false)};l36 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l38 = n if n ~= CL["ENDP"](l28) then  l38 = error({tag=CL["IDENTITY"](l33),(function () single_value() return unpack_mv(l37[1]) end)()}) else  local l39 = n if n ~= CL["EQ"]((l28)[2], l27) then  single_value();  CL_LIB["*FORMAT-ARGUMENTS*"].bound = l28 local l40 = CL["FUNCALL"](l, l(unpack_mv(CL_LIB["*FORMAT-ARGUMENTS*"].bound))); single_value();  l39 = error({tag=CL["IDENTITY"](l23),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l40)) end)()}) else  single_value();  l39 = n.bound end i( l39 );
 single_value();  local l41 = (l28)[2]; single_value();  single_value();  single_value();  local l42 = l41; single_value();  l28 = l42 l38 = l28 end i( l38 );
 i( error({tag=CL["IDENTITY"](l32),(function () single_value() return unpack_mv(l36[1]) end)()}) );
 single_value();  return CL_LIB["FUNCALL-LUA"]( l37[1], {}) end, 0, 0, false, false)};l37 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l44 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound; single_value();  local l45 = n if n ~= l44 then  l45 = l44 else  l45 = 0 end local l43 = n if n ~= CL[">"](l(l45,0)) then  single_value();  local l46 = (-1 + CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound); single_value();  CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = l46 l43 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound else  l43 = CL_LIB["FORMAT-ERROR"]("No previous argument", l()) end i( l43 );
 local l47 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  i( error({tag=CL["IDENTITY"](l25),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l47)) end)()}) );
 single_value();  return error({tag=CL["IDENTITY"](l30),(function () single_value() return unpack_mv(n) end)()}) end, 0, 0, false, false)}; single_value();  local l48 = l35[1]; single_value();  while true do  single_value();  local l49 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB['FUNCALL-LUA'](l48,{}) end, 0, 0, false, false))); single_value(); if l49.error ~= n and (l49.error ~= KEYWORD.TAG or l49.tag ~= l29) then if l49.error == KEYWORD.TAG then  error(l49) else error(l49[1]) end end l48 = CL["VALUES-LIST"](list_r(l49)) local tmpres = l48 end return n end, 0, 0, false, false))); single_value(); if l34.error ~= n and (l34.error ~= KEYWORD.TAG or l34.tag ~= l30) then if l34.error == KEYWORD.TAG then  error(l34) else error(l34[1]) end end return CL["VALUES-LIST"](list_r(l34)) end, 0, 0, false, false))); single_value(); if l26.error ~= n and (l26.error ~= KEYWORD.TAG or l26.tag ~= l25) then if l26.error == KEYWORD.TAG then  error(l26) else error(l26[1]) end end return CL["VALUES-LIST"](list_r(l26)) end, 0, 0, false, false))); single_value(); if l24.error ~= n and (l24.error ~= KEYWORD.TAG or l24.tag ~= l23) then if l24.error == KEYWORD.TAG then  error(l24) else error(l24[1]) end end l22 = CL["VALUES-LIST"](list_r(l24)) else  l22 = n.bound end i( l22 );
 single_value();  l20 = CL_LIB["POP-FORMAT-ARG"]() else  local l50 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("A"),{LCL['CL-LIB']['MAKE-CHAR']("S"),n}}, k()) then  local l53 = n if n ~= l4 then  local l54 = l4; single_value();  local l55 = (l54)[1]; single_value();  single_value();  local l56 = (l54)[2]; single_value();  l4 = l56 i( l4 );
 single_value();  l53 = l55 else  l53 = n.bound end local l52 = l53; single_value();  local l57 = n if n ~= l52 then  l57 = l52 else  l57 = 0 end local l51 = l57; local l60 = n if n ~= l4 then  local l61 = l4; single_value();  local l62 = (l61)[1]; single_value();  single_value();  local l63 = (l61)[2]; single_value();  l4 = l63 i( l4 );
 single_value();  l60 = l62 else  l60 = n.bound end local l59 = l60; single_value();  local l64 = n if n ~= l59 then  l64 = l59 else  l64 = 1 end local l58 = l64; local l67 = n if n ~= l4 then  local l68 = l4; single_value();  local l69 = (l68)[1]; single_value();  single_value();  local l70 = (l68)[2]; single_value();  l4 = l70 i( l4 );
 single_value();  l67 = l69 else  l67 = n.bound end local l66 = l67; single_value();  local l71 = n if n ~= l66 then  l71 = l66 else  l71 = 0 end local l65 = l71; local l74 = n if n ~= l4 then  local l75 = l4; single_value();  local l76 = (l75)[1]; single_value();  single_value();  local l77 = (l75)[2]; single_value();  l4 = l77 i( l4 );
 single_value();  l74 = l76 else  l74 = n.bound end local l73 = l74; single_value();  local l78 = n if n ~= l73 then  l78 = l73 else  l78 = LCL['CL-LIB']['MAKE-CHAR'](" ") end local l72 = l78; local l79 = n if n ~= l4 then  single_value();  l79 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l79 = n.bound end i( l79 );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l51, CL["INTEGER"], "mincol (first parameter)") );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l58, {CL["INTEGER"],{1,n}}, "colinc (second parameter)") );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l65, CL["INTEGER"], "minpad (third parameter)") );
 single_value();  i( CL_LIB["FORMAT-REQUIRE-TYPE"](l72, {CL["OR"],{{CL["INTEGER"],{0,{256,n}}},{CL["CHARACTER"],n}}}, "padchar (fourth parameter)") );
 single_value();  l50 = CL_LIB["POP-FORMAT-ARG"]() else  local l80 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("I"),n}, k()) then  single_value();  local l83 = n if n ~= l4 then  local l84 = l4; single_value();  local l85 = (l84)[1]; single_value();  single_value();  local l86 = (l84)[2]; single_value();  l4 = l86 i( l4 );
 single_value();  l83 = l85 else  l83 = n.bound end local l82 = l83; single_value();  local l87 = n if n ~= l82 then  l87 = l82 else  l87 = 0 end local l81 = l87; local l88 = n if n ~= l4 then  single_value();  l88 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l88 = n.bound end i( l88 );
 i( CL_LIB["FORMAT-NO-FLAGS"](n.bound, l3) );
 i( CL_LIB["FORMAT-NO-SEMI"](l1, false, false) );
 single_value();  l80 = CL_LIB["FORMAT-REQUIRE-TYPE"](l81, CL_LIB["REAL"], false) else  local l89 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("_"),n}, k()) then  single_value();  local l90 = n if n ~= l4 then  single_value();  l90 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l90 = n.bound end i( l90 );
 single_value();  l89 = CL_LIB["FORMAT-NO-SEMI"](l1, false, false) else  local l91 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("T"),n}, k()) then  single_value();  local l94 = n if n ~= l4 then  local l95 = l4; single_value();  local l96 = (l95)[1]; single_value();  single_value();  local l97 = (l95)[2]; single_value();  l4 = l97 i( l4 );
 single_value();  l94 = l96 else  l94 = n.bound end local l93 = l94; single_value();  local l98 = n if n ~= l93 then  l98 = l93 else  l98 = 1 end local l92 = l98; local l101 = n if n ~= l4 then  local l102 = l4; single_value();  local l103 = (l102)[1]; single_value();  single_value();  local l104 = (l102)[2]; single_value();  l4 = l104 i( l4 );
 single_value();  l101 = l103 else  l101 = n.bound end local l100 = l101; single_value();  local l105 = n if n ~= l100 then  l105 = l100 else  l105 = 1 end local l99 = l105; local l106 = n if n ~= l4 then  single_value();  l106 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l106 = n.bound end i( l106 );
 local l107 = n if n ~= l2 then  single_value();  l107 = CL_LIB["FORMAT-NO-SEMI"](l1, CL["T"].bound, false) else  l107 = n.bound end i( l107 );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l92, CL["INTEGER"], "colnum (first parameter)") );
 single_value();  l91 = CL_LIB["FORMAT-REQUIRE-TYPE"](l99, CL["INTEGER"], "colinc (second parameter)") else  local l108 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("W"),n}, k()) then  local l109 = n if n ~= l4 then  single_value();  l109 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l109 = n.bound end i( l109 );
 single_value();  i( CL_LIB["FORMAT-NO-SEMI"](LCL['CL-LIB']['MAKE-CHAR']("W"), false, false) );
 single_value();  l108 = CL_LIB["POP-FORMAT-ARG"]() else  local l110 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("C"),n}, k()) then  single_value();  local l111 = n if n ~= l4 then  single_value();  l111 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l111 = n.bound end i( l111 );
 single_value();  l110 = CL_LIB["FORMAT-REQUIRE-TYPE"](CL_LIB["POP-FORMAT-ARG"](), {CL["OR"],{CL["CHARACTER"],{CL["FIXNUM"],{{CL["STRING"],{1,n}},n}}}}, false) else  local l112 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("D"),{LCL['CL-LIB']['MAKE-CHAR']("B"),{LCL['CL-LIB']['MAKE-CHAR']("O"),{LCL['CL-LIB']['MAKE-CHAR']("X"),{LCL['CL-LIB']['MAKE-CHAR']("R"),n}}}}}, k()) then  local l113 = n if n ~= CL["EQL"](l1, LCL['CL-LIB']['MAKE-CHAR']("R")) then  single_value();  local l115 = l4; single_value();  local l116 = (l115)[1]; single_value();  single_value();  local l117 = (l115)[2]; single_value();  l4 = l117 i( l4 );
 single_value();  local l114 = l116; single_value();  local l118 = n if n ~= l114 then  single_value();  l118 = CL_LIB["FORMAT-REQUIRE-TYPE"](l114, {CL["INTEGER"],{2,{36,n}}}, false) else  l118 = n.bound end l113 = l118 else  l113 = n.bound end i( l113 );
 local l121 = n if n ~= l4 then  local l122 = l4; single_value();  local l123 = (l122)[1]; single_value();  single_value();  local l124 = (l122)[2]; single_value();  l4 = l124 i( l4 );
 single_value();  l121 = l123 else  l121 = n.bound end local l120 = l121; single_value();  local l125 = n if n ~= l120 then  l125 = l120 else  l125 = 0 end local l119 = l125; local l128 = n if n ~= l4 then  local l129 = l4; single_value();  local l130 = (l129)[1]; single_value();  single_value();  local l131 = (l129)[2]; single_value();  l4 = l131 i( l4 );
 single_value();  l128 = l130 else  l128 = n.bound end local l127 = l128; single_value();  local l132 = n if n ~= l127 then  l132 = l127 else  l132 = LCL['CL-LIB']['MAKE-CHAR'](" ") end local l126 = l132; local l135 = n if n ~= l4 then  local l136 = l4; single_value();  local l137 = (l136)[1]; single_value();  single_value();  local l138 = (l136)[2]; single_value();  l4 = l138 i( l4 );
 single_value();  l135 = l137 else  l135 = n.bound end local l134 = l135; single_value();  local l139 = n if n ~= l134 then  l139 = l134 else  l139 = LCL['CL-LIB']['MAKE-CHAR'](",") end local l133 = l139; local l142 = n if n ~= l4 then  local l143 = l4; single_value();  local l144 = (l143)[1]; single_value();  single_value();  local l145 = (l143)[2]; single_value();  l4 = l145 i( l4 );
 single_value();  l142 = l144 else  l142 = n.bound end local l141 = l142; single_value();  local l146 = n if n ~= l141 then  l146 = l141 else  l146 = 3 end local l140 = l146; local l147 = n if n ~= l4 then  single_value();  l147 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l147 = n.bound end i( l147 );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l119, CL["INTEGER"], "mincol (first parameter)") );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l126, CL["CHARACTER"], "padchar (second parameter)") );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l133, CL["CHARACTER"], "comma char (third parameter)") );
 single_value();  i( CL_LIB["FORMAT-REQUIRE-TYPE"](l140, CL["INTEGER"], "comma interval (fourth parameter)") );
 single_value();  l112 = CL_LIB["POP-FORMAT-ARG"]() else  local l148 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("F"),n}, k()) then  i( CL_LIB["FORMAT-NO-FLAGS"](l2, n.bound) );
 local l151 = n if n ~= l4 then  local l152 = l4; single_value();  local l153 = (l152)[1]; single_value();  single_value();  local l154 = (l152)[2]; single_value();  l4 = l154 i( l4 );
 single_value();  l151 = l153 else  l151 = n.bound end local l150 = l151; single_value();  local l155 = n if n ~= l150 then  l155 = l150 else  l155 = n.bound end local l149 = l155; local l158 = n if n ~= l4 then  local l159 = l4; single_value();  local l160 = (l159)[1]; single_value();  single_value();  local l161 = (l159)[2]; single_value();  l4 = l161 i( l4 );
 single_value();  l158 = l160 else  l158 = n.bound end local l157 = l158; single_value();  local l162 = n if n ~= l157 then  l162 = l157 else  l162 = n.bound end local l156 = l162; local l165 = n if n ~= l4 then  local l166 = l4; single_value();  local l167 = (l166)[1]; single_value();  single_value();  local l168 = (l166)[2]; single_value();  l4 = l168 i( l4 );
 single_value();  l165 = l167 else  l165 = n.bound end local l164 = l165; single_value();  local l169 = n if n ~= l164 then  l169 = l164 else  l169 = n.bound end local l163 = l169; local l172 = n if n ~= l4 then  local l173 = l4; single_value();  local l174 = (l173)[1]; single_value();  single_value();  local l175 = (l173)[2]; single_value();  l4 = l175 i( l4 );
 single_value();  l172 = l174 else  l172 = n.bound end local l171 = l172; single_value();  local l176 = n if n ~= l171 then  l176 = l171 else  l176 = n.bound end local l170 = l176; local l179 = n if n ~= l4 then  local l180 = l4; single_value();  local l181 = (l180)[1]; single_value();  single_value();  local l182 = (l180)[2]; single_value();  l4 = l182 i( l4 );
 single_value();  l179 = l181 else  l179 = n.bound end local l178 = l179; single_value();  local l183 = n if n ~= l178 then  l183 = l178 else  l183 = LCL['CL-LIB']['MAKE-CHAR'](" ") end local l177 = l183; local l184 = n if n ~= l4 then  single_value();  l184 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l184 = n.bound end i( l184 );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l149, {CL["OR"],{CL["NULL"],{{CL["INTEGER"],{0,n}},n}}}, "w (first parameter)") );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l156, {CL["OR"],{CL["NULL"],{{CL["INTEGER"],{0,n}},n}}}, "d (second parameter)") );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l163, {CL["OR"],{CL["NULL"],{CL["INTEGER"],n}}}, "k (third parameter)") );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l170, {CL["OR"],{CL["NULL"],{CL["CHARACTER"],n}}}, "overflowchar (fourth parameter)") );
 single_value();  i( CL_LIB["FORMAT-REQUIRE-TYPE"](l177, {CL["OR"],{CL["NULL"],{CL["CHARACTER"],n}}}, "padchar (fifth parameter)") );
 single_value();  l148 = CL_LIB["POP-FORMAT-ARG"]() else  local l185 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("E"),{LCL['CL-LIB']['MAKE-CHAR']("G"),n}}, k()) then  i( CL_LIB["FORMAT-NO-FLAGS"](l2, n.bound) );
 local l188 = n if n ~= l4 then  local l189 = l4; single_value();  local l190 = (l189)[1]; single_value();  single_value();  local l191 = (l189)[2]; single_value();  l4 = l191 i( l4 );
 single_value();  l188 = l190 else  l188 = n.bound end local l187 = l188; single_value();  local l192 = n if n ~= l187 then  l192 = l187 else  l192 = n.bound end local l186 = l192; local l195 = n if n ~= l4 then  local l196 = l4; single_value();  local l197 = (l196)[1]; single_value();  single_value();  local l198 = (l196)[2]; single_value();  l4 = l198 i( l4 );
 single_value();  l195 = l197 else  l195 = n.bound end local l194 = l195; single_value();  local l199 = n if n ~= l194 then  l199 = l194 else  l199 = n.bound end local l193 = l199; local l202 = n if n ~= l4 then  local l203 = l4; single_value();  local l204 = (l203)[1]; single_value();  single_value();  local l205 = (l203)[2]; single_value();  l4 = l205 i( l4 );
 single_value();  l202 = l204 else  l202 = n.bound end local l201 = l202; single_value();  local l206 = n if n ~= l201 then  l206 = l201 else  l206 = n.bound end local l200 = l206; local l209 = n if n ~= l4 then  local l210 = l4; single_value();  local l211 = (l210)[1]; single_value();  single_value();  local l212 = (l210)[2]; single_value();  l4 = l212 i( l4 );
 single_value();  l209 = l211 else  l209 = n.bound end local l208 = l209; single_value();  local l213 = n if n ~= l208 then  l213 = l208 else  l213 = 1 end local l207 = l213; local l216 = n if n ~= l4 then  local l217 = l4; single_value();  local l218 = (l217)[1]; single_value();  single_value();  local l219 = (l217)[2]; single_value();  l4 = l219 i( l4 );
 single_value();  l216 = l218 else  l216 = n.bound end local l215 = l216; single_value();  local l220 = n if n ~= l215 then  l220 = l215 else  l220 = n.bound end local l214 = l220; local l223 = n if n ~= l4 then  local l224 = l4; single_value();  local l225 = (l224)[1]; single_value();  single_value();  local l226 = (l224)[2]; single_value();  l4 = l226 i( l4 );
 single_value();  l223 = l225 else  l223 = n.bound end local l222 = l223; single_value();  local l227 = n if n ~= l222 then  l227 = l222 else  l227 = LCL['CL-LIB']['MAKE-CHAR'](" ") end local l221 = l227; local l230 = n if n ~= l4 then  local l231 = l4; single_value();  local l232 = (l231)[1]; single_value();  single_value();  local l233 = (l231)[2]; single_value();  l4 = l233 i( l4 );
 single_value();  l230 = l232 else  l230 = n.bound end local l229 = l230; single_value();  local l234 = n if n ~= l229 then  l234 = l229 else  l234 = n.bound end local l228 = l234; local l235 = n if n ~= l4 then  single_value();  l235 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l235 = n.bound end i( l235 );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l186, {CL["OR"],{CL["NULL"],{{CL["INTEGER"],{0,n}},n}}}, "w (first parameter)") );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l193, {CL["OR"],{CL["NULL"],{{CL["INTEGER"],{0,n}},n}}}, "d (second parameter)") );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l200, {CL["OR"],{CL["NULL"],{{CL["INTEGER"],{0,n}},n}}}, "e (third parameter)") );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l207, {CL["OR"],{CL["NULL"],{CL["INTEGER"],n}}}, "k (fourth parameter)") );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l214, {CL["OR"],{CL["NULL"],{CL["CHARACTER"],n}}}, "overflowchar (fifth parameter)") );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l221, {CL["OR"],{CL["NULL"],{CL["CHARACTER"],n}}}, "padchar (sixth parameter)") );
 single_value();  i( CL_LIB["FORMAT-REQUIRE-TYPE"](l228, {CL["OR"],{CL["NULL"],{CL["CHARACTER"],n}}}, "exponentchar (seventh parameter)") );
 single_value();  l185 = CL_LIB["POP-FORMAT-ARG"]() else  local l236 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("$"),n}, k()) then  local l239 = n if n ~= l4 then  local l240 = l4; single_value();  local l241 = (l240)[1]; single_value();  single_value();  local l242 = (l240)[2]; single_value();  l4 = l242 i( l4 );
 single_value();  l239 = l241 else  l239 = n.bound end local l238 = l239; single_value();  local l243 = n if n ~= l238 then  l243 = l238 else  l243 = 2 end local l237 = l243; local l246 = n if n ~= l4 then  local l247 = l4; single_value();  local l248 = (l247)[1]; single_value();  single_value();  local l249 = (l247)[2]; single_value();  l4 = l249 i( l4 );
 single_value();  l246 = l248 else  l246 = n.bound end local l245 = l246; single_value();  local l250 = n if n ~= l245 then  l250 = l245 else  l250 = 1 end local l244 = l250; local l253 = n if n ~= l4 then  local l254 = l4; single_value();  local l255 = (l254)[1]; single_value();  single_value();  local l256 = (l254)[2]; single_value();  l4 = l256 i( l4 );
 single_value();  l253 = l255 else  l253 = n.bound end local l252 = l253; single_value();  local l257 = n if n ~= l252 then  l257 = l252 else  l257 = 0 end local l251 = l257; local l260 = n if n ~= l4 then  local l261 = l4; single_value();  local l262 = (l261)[1]; single_value();  single_value();  local l263 = (l261)[2]; single_value();  l4 = l263 i( l4 );
 single_value();  l260 = l262 else  l260 = n.bound end local l259 = l260; single_value();  local l264 = n if n ~= l259 then  l264 = l259 else  l264 = LCL['CL-LIB']['MAKE-CHAR'](" ") end local l258 = l264; local l265 = n if n ~= l4 then  single_value();  l265 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l265 = n.bound end i( l265 );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l237, {CL["OR"],{CL["NULL"],{{CL["INTEGER"],{0,n}},n}}}, "d (first parameter)") );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l244, {CL["OR"],{CL["NULL"],{{CL["INTEGER"],{0,n}},n}}}, "n (second parameter)") );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l251, {CL["OR"],{CL["NULL"],{{CL["INTEGER"],{0,n}},n}}}, "w (third parameter)") );
 single_value();  i( CL_LIB["FORMAT-REQUIRE-TYPE"](l258, {CL["OR"],{CL["NULL"],{CL["CHARACTER"],n}}}, "pad (fourth parameter)") );
 single_value();  l236 = CL_LIB["FORMAT-REQUIRE-TYPE"](CL_LIB["POP-FORMAT-ARG"](), CL_LIB["REAL"], false) else  local l266 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("*"),n}, k()) then  single_value();  local l269 = n if n ~= l4 then  local l270 = l4; single_value();  local l271 = (l270)[1]; single_value();  single_value();  local l272 = (l270)[2]; single_value();  l4 = l272 i( l4 );
 single_value();  l269 = l271 else  l269 = n.bound end local l268 = l269; single_value();  local l273 = n if n ~= l268 then  l273 = l268 else  l273 = n.bound end local l267 = l273; local l274 = n if n ~= l4 then  single_value();  l274 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l274 = n.bound end i( l274 );
 local l275 = n if n ~= l267 then  single_value();  l275 = CL_LIB["FORMAT-REQUIRE-TYPE"](l267, CL["INTEGER"], "count parameter") else  l275 = n.bound end i( l275 );
 single_value();  l267 = CL_LIB["FUNCALL-LUA"]( CL_LIB["NX-TRANSFORM"].fbound, {l267, }) local l276 = n if n ~= CL["TYPEP"](l267, {CL["OR"],{CL["NULL"],{CL["INTEGER"],n}}}, false) then  l276 = CL_LIB["FORMAT-SCAN-GOTO"](l2, l3, l267) else  single_value();  local l277 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; single_value();  CL_LIB["*FORMAT-ARGUMENTS*"].bound = l277 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  single_value();  single_value();  local l278 = CL["LENGTH"](CL_LIB["*FORMAT-ARGUMENTS*"].bound); single_value();  CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = l278 l276 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound end l266 = l276 else  local l279 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("?"),n}, k()) then  local l280 = n if n ~= l4 then  single_value();  l280 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l280 = n.bound end i( l280 );
 single_value();  i( CL_LIB["FORMAT-NO-FLAGS"](l2, n.bound) );
 single_value();  local l281 = CL_LIB["POP-FORMAT-ARG"](); i( CL_LIB["FORMAT-REQUIRE-TYPE"](l281, {CL["OR"],{CL["STRING"],{CL["FUNCTION"],n}}}, false) );
 single_value();  local l282 = n if n ~= l3 then  CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = CL["LENGTH"](CL_LIB["*FORMAT-ARGUMENTS*"].bound) l282 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound else  local l283 = CL_LIB["POP-FORMAT-ARG"](); single_value();  l282 = CL_LIB["FORMAT-REQUIRE-TYPE"](l283, CL["LIST"], false) end l279 = l282 else  local l284 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("/"),n}, k()) then  single_value();  local l285 = CL_LIB["*FORMAT-CONTROL-STRING*"].bound; single_value();  local l286 = CL["1+"](CL_LIB["*FORMAT-INDEX*"].bound); single_value();  local l287 = CL_LIB["%STR-MEMBER"](LCL['CL-LIB']['MAKE-CHAR']("/"), CL_LIB["*FORMAT-CONTROL-STRING*"].bound, l286, CL_LIB["*FORMAT-LENGTH*"].bound); single_value();  local l288 = n if n ~= CL["NOT"](l287) then  single_value();  l288 = CL_LIB["FORMAT-ERROR"]("Unmatched ~~/", l()) else  l288 = n.bound end i( l288 );
 single_value();  local l289 = CL_LIB["%STR-MEMBER"](LCL['CL-LIB']['MAKE-CHAR'](":"), CL_LIB["*FORMAT-CONTROL-STRING*"].bound, l286, l287); single_value();  local l291 = n if n ~= l289 then  local l292 = CL["STRING-UPCASE"](CL_LIB["FUNCALL-LUA"]( CL_LIB["%SUBSTR"].fbound, {l285, l286, l289, }), k()); local l293 = n if n ~= CL["EQL"](LCL['CL-LIB']['MAKE-CHAR'](":"), CL["SCHAR"](l285, (1 + l289))) then  single_value();  l289 = (l289 + 1) l293 = l289 else  l293 = n.bound end i( l293 );
 l286 = (l289 + 1) i( l286 );
 single_value();  l291 = l292 else  l291 = "CL-USER" end local l290 = l291; single_value();  local l294 = CL["FIND-PACKAGE"](l290); single_value();  local l296 = n if n ~= l294 then  l296 = CL["FIND-SYMBOL"](CL["STRING-UPCASE"](CL_LIB["FUNCALL-LUA"]( CL_LIB["%SUBSTR"].fbound, {l285, l286, l287, }), k()), l294) else  l296 = n.bound end local l295 = l296; single_value();  local l297 = CL_LIB["POP-FORMAT-ARG"](); single_value();  CL_LIB["*FORMAT-INDEX*"].bound = l287 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value();  local l298 = n if n ~= l295 then  single_value();  local l299 = n if n ~= CL_LIB["FUNCALL-LUA"]( CL_LIB["NX1-CHECK-TYPED-CALL"].fbound, {l295, CL["LIST*"](l(CL["*STANDARD-OUTPUT*"],l297,l2,l3,l4)), }) then  single_value();  l299 = error({tag=CL["IDENTITY"](CL_LIB["FORMAT-ERROR"]),(function () single_value() return unpack_mv(n.bound) end)()}) else  l299 = n.bound end l298 = l299 else  l298 = n.bound end l284 = l298 else  local l300 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("["),n}, k()) then  local l302 = n if n ~= l2 then  l302 = l3 else  l302 = n.bound end local l301 = n if n ~= l302 then  single_value();  l301 = CL_LIB["FORMAT-ERROR"]("~~:@[ undefined", l()) else  l301 = n.bound end i( l301 );
 i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  local l303 = n if n ~= l2 then  single_value();  l303 = CL_LIB["FORMAT-SCAN-BOOLEAN-CONDITION"](l4) else  local l304 = n if n ~= l3 then  single_value();  l304 = CL_LIB["FORMAT-SCAN-FUNNY-CONDITION"](l4) else  local l305 = n if n ~= CL["T"].bound then  single_value();  l305 = CL_LIB["FORMAT-SCAN-UNTAGGED-CONDITION"](l4) else  l305 = n.bound end l304 = l305 end l303 = l304 end l300 = l303 else  local l306 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("("),n}, k()) then  single_value();  local l307 = n if n ~= l4 then  single_value();  l307 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l307 = n.bound end i( l307 );
 i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  local l308 = n.bound; local l309 = n.bound; local l310 = n.bound; local l311 = n.bound; local l312 = n.bound; local l313 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l314 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l316 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l315 = l316; single_value();  single_value();  l308,l309,l310,l311,l312= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](")"),n}, false, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l313 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l314.error ~= n and true then if l314.error == KEYWORD.TAG then  error(l314) else error(l314[1]) end end i( CL["VALUES-LIST"](list_r(l314)) );
 local l317 = n if n ~= l310 then  single_value();  l317 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l317 = n.bound end i( l317 );
 single_value();  i( CL_LIB["FORMAT-NO-FLAGS"](l311, l312) );
 single_value();  l306 = CL_LIB["SUB-FORMAT-SCAN"](l308, l309) else  local l318 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("^"),n}, k()) then  i( CL_LIB["FORMAT-NO-FLAGS"](n.bound, l3) );
 single_value();  local l321 = n if n ~= l4 then  local l322 = l4; single_value();  local l323 = (l322)[1]; single_value();  single_value();  local l324 = (l322)[2]; single_value();  l4 = l324 i( l4 );
 single_value();  l321 = l323 else  l321 = n.bound end local l320 = l321; single_value();  local l325 = n if n ~= l320 then  l325 = l320 else  l325 = n.bound end local l319 = l325; local l328 = n if n ~= l4 then  local l329 = l4; single_value();  local l330 = (l329)[1]; single_value();  single_value();  local l331 = (l329)[2]; single_value();  l4 = l331 i( l4 );
 single_value();  l328 = l330 else  l328 = n.bound end local l327 = l328; single_value();  local l332 = n if n ~= l327 then  l332 = l327 else  l332 = n.bound end local l326 = l332; local l335 = n if n ~= l4 then  local l336 = l4; single_value();  local l337 = (l336)[1]; single_value();  single_value();  local l338 = (l336)[2]; single_value();  l4 = l338 i( l4 );
 single_value();  l335 = l337 else  l335 = n.bound end local l334 = l335; single_value();  local l339 = n if n ~= l334 then  l339 = l334 else  l339 = n.bound end local l333 = l339; local l340 = n if n ~= l4 then  single_value();  l340 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l340 = n.bound end i( l340 );
 single_value();  local l342 = n if n ~= l333 then  single_value();  local l343 = n if n ~= CL["EVERY"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["P"],n},function (l344,  ...)   single_value();  return CL_LIB["NX-COULD-BE-TYPE"](l344, CL_LIB["REAL"], false) end, 1, 0, false, false), l(l4)) then  l343 = CL["CONS"](CL["<"], CL["CONS"](l319, CL["CONS"](l326, CL["CONS"](l333, n)))) else  local l345 = n if n ~= CL["EVERY"](CL_LIB["ALLOC-FUNCTION"]({CL_LIB["P"],n},function (l346,  ...)   single_value();  return CL_LIB["NX-COULD-BE-TYPE"](l346, CL["CHARACTER"], false) end, 1, 0, false, false), l(l4)) then  l345 = CL["CONS"](CL["CHAR<"], CL["CONS"](l319, CL["CONS"](l326, CL["CONS"](l333, n)))) else  l345 = CL_LIB["FORMAT-ERROR"]("Wrong type of parameters for three-way comparison", l()) end l343 = l345 end l342 = l343 else  local l347 = n if n ~= l326 then  single_value();  l347 = CL["CONS"](CL["EQUAL"], CL["CONS"](l319, CL["CONS"](l326, n))) else  local l348 = n if n ~= l319 then  single_value();  l348 = CL["CONS"](CL["EQ"], CL["CONS"](l319, CL["CONS"](0, n))) else  local l349 = n if n ~= CL["T"].bound then  single_value();  local l350 = n if n ~= l2 then  l350 = CL_LIB["*FORMAT-COLON-REST*"].bound else  l350 = CL_LIB["*FORMAT-ARGUMENTS*"].bound end l349 = CL["NULL"](l350) else  l349 = n.bound end l348 = l349 end l347 = l348 end l342 = l347 end local l341 = CL_LIB["FUNCALL-LUA"]( CL_LIB["NX-TRANSFORM"].fbound, {l342, }); single_value();  local l351 = n if n ~= l341 then  i( CL_LIB["NOTE-FORMAT-SCAN-OPTION"](CL_LIB["*FORMAT-ESCAPE-OPTIONS*"].bound) );
 single_value();  local l352 = n if n ~= CL_LIB["NX-COULD-BE-TYPE"](l341, CL["NULL"], CL["T"].bound) then  l352 = n.bound else  single_value();  l352 = error({tag=CL["IDENTITY"](CL_LIB["FORMAT-ESCAPE"]),(function () single_value() return unpack_mv(CL["T"].bound) end)()}) end l351 = l352 else  l351 = n.bound end l318 = l351 else  local l353 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("{"),n}, k()) then  single_value();  local l356 = n if n ~= l4 then  local l357 = l4; single_value();  local l358 = (l357)[1]; single_value();  single_value();  local l359 = (l357)[2]; single_value();  l4 = l359 i( l4 );
 single_value();  l356 = l358 else  l356 = n.bound end local l355 = l356; single_value();  local l360 = n if n ~= l355 then  l360 = l355 else  l360 = -1 end local l354 = l360; local l361 = n if n ~= l4 then  single_value();  l361 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l361 = n.bound end i( l361 );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l354, CL["INTEGER"], "max-iter parameter") );
 i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  local l362 = n.bound; local l363 = n.bound; local l364 = n.bound; local l365 = n.bound; local l366 = n.bound; local l367 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l368 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l370 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l369 = l370; single_value();  single_value();  l362,l363,l364,l365,l366= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR']("}"),n}, false, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l367 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l368.error ~= n and true then if l368.error == KEYWORD.TAG then  error(l368) else error(l368[1]) end end i( CL["VALUES-LIST"](list_r(l368)) );
 i( n.bound );
 local l371 = n if n ~= l364 then  single_value();  l371 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l371 = n.bound end i( l371 );
 single_value();  i( CL_LIB["FORMAT-NO-FLAGS"](n.bound, l366) );
 local l372 = n if n ~= CL["EQ"](l362, l363) then  single_value();  local l373 = CL_LIB["POP-FORMAT-ARG"](); single_value();  local l374 = n if n ~= CL_LIB["NX-COULD-BE-TYPE"](l373, {CL["OR"],{CL["STRING"],{CL["FUNCTION"],n}}}, false) then  l374 = n.bound else  single_value();  l374 = CL_LIB["FORMAT-ERROR"]("Control string is not a string or function", l()) end l372 = l374 else  l372 = n.bound end i( l372 );
 single_value();  local l375 = n if n ~= l3 then  CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = CL["LENGTH"](CL_LIB["*FORMAT-ARGUMENTS*"].bound) l375 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound else  l375 = CL_LIB["FORMAT-REQUIRE-TYPE"](CL_LIB["POP-FORMAT-ARG"](), CL["LIST"], false) end l353 = l375 else  local l376 = n if n ~= CL["MEMBER"](l5, {LCL['CL-LIB']['MAKE-CHAR']("<"),n}, k()) then  single_value();  local l377 = n.bound; local l378 = n.bound; local l379 = n.bound; local l380 = n.bound; local l381 = n.bound; local l382 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l383 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l385 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l384 = l385; single_value();  single_value();  l377,l378,l379,l380,l381= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](">"),n}, false, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l382 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l383.error ~= n and true then if l383.error == KEYWORD.TAG then  error(l383) else error(l383[1]) end end i( CL["VALUES-LIST"](list_r(l383)) );
 i( n.bound );
 CL_LIB["*FORMAT-INDEX*"].bound = l377 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value();  local l386 = n if n ~= l380 then  l386 = CL_LIB["FORMAT-LOGICAL-BLOCK-SCAN"](l2, l3, l4) else  l386 = CL_LIB["FORMAT-JUSTIFICATION-SCAN"](l2, l3, l4) end l376 = l386 else  local l387 = n if n ~= CL["T"].bound then  single_value();  l387 = CL["ERROR"]("ECASE", l()) else  l387 = n.bound end l376 = l387 end l353 = l376 end l318 = l353 end l306 = l318 end l300 = l306 end l284 = l300 end l279 = l284 end l266 = l279 end l236 = l266 end l185 = l236 end l148 = l185 end l112 = l148 end l110 = l112 end l108 = l110 end l91 = l108 end l89 = l91 end l80 = l89 end l50 = l80 end l20 = l50 end l15 = l20 end l6 = l15 end return l6 end, 4, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-JUSTIFICATION-SCAN"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL_LIB["PARMS"],n}}},function (l1, l2, l3,  ...)   i( n.bound );
 local l6 = n if n ~= l3 then  local l7 = l3; single_value();  local l8 = (l7)[1]; single_value();  single_value();  local l9 = (l7)[2]; single_value();  l3 = l9 i( l3 );
 single_value();  l6 = l8 else  l6 = n.bound end local l5 = l6; single_value();  local l10 = n if n ~= l5 then  l10 = l5 else  l10 = 0 end local l4 = l10; local l13 = n if n ~= l3 then  local l14 = l3; single_value();  local l15 = (l14)[1]; single_value();  single_value();  local l16 = (l14)[2]; single_value();  l3 = l16 i( l3 );
 single_value();  l13 = l15 else  l13 = n.bound end local l12 = l13; single_value();  local l17 = n if n ~= l12 then  l17 = l12 else  l17 = 1 end local l11 = l17; local l20 = n if n ~= l3 then  local l21 = l3; single_value();  local l22 = (l21)[1]; single_value();  single_value();  local l23 = (l21)[2]; single_value();  l3 = l23 i( l3 );
 single_value();  l20 = l22 else  l20 = n.bound end local l19 = l20; single_value();  local l24 = n if n ~= l19 then  l24 = l19 else  l24 = 0 end local l18 = l24; local l27 = n if n ~= l3 then  local l28 = l3; single_value();  local l29 = (l28)[1]; single_value();  single_value();  local l30 = (l28)[2]; single_value();  l3 = l30 i( l3 );
 single_value();  l27 = l29 else  l27 = n.bound end local l26 = l27; single_value();  local l31 = n if n ~= l26 then  l31 = l26 else  l31 = LCL['CL-LIB']['MAKE-CHAR'](" ") end local l25 = l31; local l32 = n if n ~= l3 then  single_value();  l32 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l32 = n.bound end i( l32 );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l4, CL["INTEGER"], "mincol (first parameter)") );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l11, {CL["INTEGER"],{1,n}}, "colinc (second parameter)") );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l18, CL["INTEGER"], "minpad (third parameter)") );
 single_value();  i( CL_LIB["FORMAT-REQUIRE-TYPE"](l25, CL["CONS"](CL["OR"], CL["CONS"](CL["CHARACTER"], CL["CONS"](CL["CONS"](CL["INTEGER"], CL["CONS"](0, CL["CONS"](256, n))), n))), "padchar (fourth parameter)") );
 single_value();  local l33 = n.bound; local l34 = n.bound; local l35 = 0; local l36 = CL["CONS"](n.bound, n.bound); single_value();  local l37 = CL_LIB["*FORMAT-ESCAPE-OPTIONS*"].bound; single_value();  local l38 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l40 = CL_LIB["*FORMAT-ESCAPE-OPTIONS*"].bound; CL_LIB["*FORMAT-ESCAPE-OPTIONS*"].bound = l36 i( CL_LIB["*FORMAT-ESCAPE-OPTIONS*"].bound );
 single_value();  local l39 = l40; single_value();  single_value();  i( n.bound );
 single_value();  while true do  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  local l42 = n.bound; local l43 = n.bound; local l44 = n.bound; local l45 = n.bound; local l46 = n.bound; local l47 = n.bound; local l48 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l49 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l51 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l50 = l51; single_value();  single_value();  l42,l43,l44,l45,l46,l47= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](";"),{LCL['CL-LIB']['MAKE-CHAR'](">"),n}}, n.bound, CL["T"].bound), 6) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l48 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l49.error ~= n and true then if l49.error == KEYWORD.TAG then  error(l49) else error(l49[1]) end end i( CL["VALUES-LIST"](list_r(l49)) );
 local l53 = n if n ~= CL["EQL"](l35, 0) then  local l54 = n if n ~= CL["EQL"](l47, LCL['CL-LIB']['MAKE-CHAR'](";")) then  l54 = l45 else  l54 = n.bound end l53 = l54 else  l53 = n.bound end local l52 = n if n ~= l53 then  i( CL_LIB["FORMAT-NO-FLAGS"](n.bound, l46) );
 l34 = CL["T"].bound i( l34 );
 CL_LIB["*FORMAT-INDEX*"].bound = l43 i( CL_LIB["*FORMAT-INDEX*"].bound );
 single_value();  l33 = CL["NTH"](2, CL["FUNCALL"](l, l(unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](";"),{LCL['CL-LIB']['MAKE-CHAR'](">"),n}}, CL["T"].bound, CL["T"].bound))))) l52 = l33 else  local l55 = n if n ~= l44 then  single_value();  l55 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l55 = n.bound end i( l55 );
 single_value();  l52 = CL_LIB["FORMAT-NO-FLAGS"](l45, l46) end i( l52 );
 local l57 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   i( CL_LIB["SUB-FORMAT-SCAN"](l42, l43) );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l57.error ~= n and (l57.error ~= KEYWORD.TAG or l57.tag ~= CL_LIB["FORMAT-ESCAPE"]) then if l57.error == KEYWORD.TAG then  error(l57) else error(l57[1]) end end local l56 = n if n ~= CL["VALUES-LIST"](list_r(l57)) then  local l58 = n if n ~= CL["EQ"](l47, LCL['CL-LIB']['MAKE-CHAR'](">")) then  l58 = n.bound else  single_value();  l58 = CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](">"),n}, n.bound, CL["T"].bound) end i( l58 );
 single_value(); do break end; l56 = n.bound else  l56 = n.bound end i( l56 );
 single_value();  local l59 = (1 + l35); single_value();  l35 = l59 i( l35 );
 single_value();  local l60 = n if n ~= CL["EQ"](l47, LCL['CL-LIB']['MAKE-CHAR'](">")) then  single_value();  local l61 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l60 = error({tag=CL["IDENTITY"](LCL["%BR"]["COMMON-LISP*NIL"].bound),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l61)) end)()}) else  l60 = n.bound end local tmpres = l60 end i( n );
 single_value();  local l41 = CL_LIB["NOTE-FORMAT-SCAN-OPTION"](CL_LIB["*FORMAT-ESCAPE-OPTIONS*"].bound); single_value();  local l62 = (l36)[1]; single_value();  CL_LIB["*FORMAT-ARGUMENTS*"].bound = l62 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  single_value();  single_value();  local l63 = (l36)[2]; single_value();  CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = l63 i( CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound );
 single_value();  return l41 end, 0, 0, false, false))); CL_LIB["*FORMAT-ESCAPE-OPTIONS*"].bound = l37 i( CL_LIB["*FORMAT-ESCAPE-OPTIONS*"].bound );
 single_value(); if l38.error ~= n and true then if l38.error == KEYWORD.TAG then  error(l38) else error(l38[1]) end end i( CL["VALUES-LIST"](list_r(l38)) );
 single_value();  local l64 = n if n ~= l34 then  local l65 = n if n ~= CL_LIB["*FORMAT-PPRINT*"].bound then  single_value();  l65 = CL_LIB["FORMAT-ERROR"]("Justification illegal in this context", l()) else  l65 = n.bound end i( l65 );
 CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"].bound = CL["T"].bound i( CL_LIB["*FORMAT-JUSTIFICATION-SEMI*"].bound );
 single_value();  local l68 = n if n ~= l33 then  local l69 = l33; single_value();  local l70 = (l69)[1]; single_value();  single_value();  local l71 = (l69)[2]; single_value();  l33 = l71 i( l33 );
 single_value();  l68 = l70 else  l68 = n.bound end local l67 = l68; single_value();  local l72 = n if n ~= l67 then  l72 = l67 else  l72 = 0 end local l66 = l72; local l75 = n if n ~= l33 then  local l76 = l33; single_value();  local l77 = (l76)[1]; single_value();  single_value();  local l78 = (l76)[2]; single_value();  l33 = l78 i( l33 );
 single_value();  l75 = l77 else  l75 = n.bound end local l74 = l75; single_value();  local l79 = n if n ~= l74 then  l79 = l74 else  l79 = 0 end local l73 = l79; local l80 = n if n ~= l33 then  single_value();  l80 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l80 = n.bound end i( l80 );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l66, CL["INTEGER"], "spare (first parameter)") );
 single_value();  l64 = CL_LIB["FORMAT-REQUIRE-TYPE"](l73, CL["INTEGER"], "line length (second parameter)") else  l64 = n.bound end return l64 end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-LOGICAL-BLOCK-SCAN"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL_LIB["PARAMS"],n}}},function (l1, l2, l3,  ...)   i( n.bound );
 local l4 = n if n ~= l3 then  single_value();  l4 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l4 = n.bound end i( l4 );
 single_value();  i( CL_LIB["FORMAT-NO-SEMI"](LCL['CL-LIB']['MAKE-CHAR']("<"), false, false) );
 single_value();  local l5 = CL_LIB["*FORMAT-CONTROL-STRING*"].bound; local l6 = ""; local l7 = ""; local l8 = n.bound; local l9 = n.bound; local l10 = n.bound; local l11 = n.bound; local l12 = n.bound; local l13 = n.bound; local l14 = n.bound; local l15 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l16 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l18 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l17 = l18; single_value();  single_value();  l9,l10,l11,l12,l13,l14= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](";"),{LCL['CL-LIB']['MAKE-CHAR'](">"),n}}, false, false), 6) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l15 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l16.error ~= n and true then if l16.error == KEYWORD.TAG then  error(l16) else error(l16[1]) end end i( CL["VALUES-LIST"](list_r(l16)) );
 l8 = CL_LIB["FUNCALL-LUA"]( CL_LIB["%SUBSTR"].fbound, {l5, CL["1+"](l9), l10, }) i( l8 );
 single_value();  local l19 = n if n ~= l11 then  single_value();  l19 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l19 = n.bound end i( l19 );
 single_value();  local l20 = n if n ~= CL["EQ"](l14, LCL['CL-LIB']['MAKE-CHAR'](";")) then  i( CL_LIB["FORMAT-NO-FLAGS"](l12, n.bound) );
 l6 = l8 i( l6 );
 local l21 = n.bound; local l22 = n.bound; local l23 = n.bound; local l24 = n.bound; local l25 = n.bound; local l26 = n.bound; local l27 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l28 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l30 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l29 = l30; single_value();  single_value();  l21,l22,l23,l24,l25,l26= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](";"),{LCL['CL-LIB']['MAKE-CHAR'](">"),n}}, false, false), 6) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l27 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l28.error ~= n and true then if l28.error == KEYWORD.TAG then  error(l28) else error(l28[1]) end end i( CL["VALUES-LIST"](list_r(l28)) );
 l9 = l21 i( l9 );
 l10 = l22 i( l10 );
 l11 = l23 i( l11 );
 l12 = l24 i( l12 );
 l13 = l25 i( l13 );
 single_value();  l14 = l26 i( l14 );
 single_value();  local l31 = n if n ~= l11 then  single_value();  l31 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l31 = n.bound end i( l31 );
 l8 = CL_LIB["FUNCALL-LUA"]( CL_LIB["%SUBSTR"].fbound, {l5, CL["1+"](l9), l10, }) i( l8 );
 single_value();  local l32 = n if n ~= CL["EQ"](l14, LCL['CL-LIB']['MAKE-CHAR'](";")) then  i( CL_LIB["FORMAT-NO-FLAGS"](l12, l13) );
 local l33 = n.bound; local l34 = n.bound; local l35 = n.bound; local l36 = n.bound; local l37 = n.bound; local l38 = n.bound; local l39 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l40 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l42 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l41 = l42; single_value();  single_value();  l33,l34,l35,l36,l37,l38= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](";"),{LCL['CL-LIB']['MAKE-CHAR'](">"),n}}, false, false), 6) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l39 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l40.error ~= n and true then if l40.error == KEYWORD.TAG then  error(l40) else error(l40[1]) end end i( CL["VALUES-LIST"](list_r(l40)) );
 l9 = l33 i( l9 );
 l10 = l34 i( l10 );
 l11 = l35 i( l11 );
 l12 = l36 i( l12 );
 l13 = l37 i( l13 );
 single_value();  l14 = l38 i( l14 );
 single_value();  local l43 = n if n ~= l11 then  single_value();  l43 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l43 = n.bound end i( l43 );
 l7 = CL_LIB["FUNCALL-LUA"]( CL_LIB["%SUBSTR"].fbound, {l5, CL["1+"](l9), l10, }) i( l7 );
 single_value();  local l44 = n if n ~= CL["EQ"](l14, LCL['CL-LIB']['MAKE-CHAR'](";")) then  single_value();  l44 = CL_LIB["FORMAT-ERROR"]("Too many sections", l()) else  l44 = n.bound end l32 = l44 else  l32 = n.bound end l20 = l32 else  l20 = n.bound end i( l20 );
 local l45;l45 = CL_LIB["ALLOC-FUNCTION"]({CL_LIB["STR"],{CL_LIB["WHERE"],n}},function (l46, l47,  ...)   single_value();  local l49 = n if n ~= l46 then  local l50 = CL_LIB["%STR-MEMBER"](LCL['CL-LIB']['MAKE-CHAR']("~"), l46, false, false); single_value();  local l51 = n if n ~= l50 then  l51 = l50 else  l51 = CL_LIB["%STR-MEMBER"](LCL['CL-LIB']['MAKE-CHAR']("\n"), l46, false, false) end l49 = l51 else  l49 = n.bound end local l48 = n if n ~= l49 then  single_value();  l48 = CL_LIB["FORMAT-ERROR"]("~A must be simple", l(l47)) else  l48 = n.bound end return l48 end, 2, 0, false, false); i( CL_LIB["FUNCALL-LUA"]( l45, {l6, "Prefix", }) );
 single_value();  i( CL_LIB["FUNCALL-LUA"]( l45, {l7, "Suffix", }) );
 single_value();  local l52 = n if n ~= l2 then  local l53 = CL["T"].bound; i( CL_LIB["FORMAT-SCAN"](l8, CL_LIB["*FORMAT-ARGUMENTS*"].bound, CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound) );
 single_value();  single_value();  local l54 = n.bound; single_value();  CL_LIB["*FORMAT-ARGUMENTS*"].bound = l54 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  single_value();  single_value();  local l55 = 0; single_value();  CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = l55 l52 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound else  local l56 = n if n ~= CL_LIB["*FORMAT-ARGUMENTS*"].bound then  single_value();  l56 = CL_LIB["POP-FORMAT-ARG"]() else  l56 = n.bound end l52 = l56 end return l52 end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-SCAN-UNTAGGED-CONDITION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PARMS"],n},function (l1,  ...)   single_value();  local l2 = CL["GENSYM"](false); single_value();  local l3 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l6 = n if n ~= l1 then  local l7 = l1; single_value();  local l8 = (l7)[1]; single_value();  single_value();  local l9 = (l7)[2]; single_value();  l1 = l9 i( l1 );
 single_value();  l6 = l8 else  l6 = n.bound end local l5 = l6; single_value();  local l10 = n if n ~= l5 then  l10 = l5 else  l10 = n.bound end local l4 = l10; local l11 = n if n ~= l1 then  single_value();  l11 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l11 = n.bound end i( l11 );
 local l12 = n if n ~= l4 then  l12 = n.bound else  single_value();  l4 = CL_LIB["POP-FORMAT-ARG"]() l12 = l4 end i( l12 );
 i( CL_LIB["FORMAT-REQUIRE-TYPE"](l4, CL["INTEGER"], false) );
 single_value();  local l13 = CL["CONS"](n.bound, n.bound); single_value();  local l14 = l13; single_value();  i( n.bound );
 single_value();  single_value();  local l16 = CL["GENSYM"](false); single_value();  local l17 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l18 = n.bound; i( n.bound );
 single_value();  single_value();  local l19 = CL["LIST"](l(n.bound)); single_value();  local l20 = CL["LIST"](l(n.bound)); single_value();  local l21 = l19; single_value();  local l22 = l19; single_value();  local l23 = l19; single_value();  single_value();  local l24 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l25; local l26; local l27;l25 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["FUNCALL-LUA"]( l26[1], {}) end, 0, 0, false, false)};l26 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l28 = n.bound; local l29 = n.bound; local l30 = n.bound; local l31 = n.bound; local l32 = n.bound; local l33 = n.bound; local l34 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l35 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l37 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l36 = l37; single_value();  single_value();  l28,l29,l30,l31,l32,l33= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](";"),{LCL['CL-LIB']['MAKE-CHAR']("]"),n}}, false, false), 6) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l34 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l35.error ~= n and true then if l35.error == KEYWORD.TAG then  error(l35) else error(l35[1]) end end i( CL["VALUES-LIST"](list_r(l35)) );
 local l39 = n if n ~= l18 then  l39 = CL["EQ"](l33, LCL['CL-LIB']['MAKE-CHAR'](";")) else  l39 = n.bound end local l38 = n if n ~= l39 then  single_value();  l38 = CL_LIB["FORMAT-ERROR"]("~:; must be the last clause", l()) else  l38 = n.bound end i( l38 );
 local l40 = n if n ~= l30 then  single_value();  l40 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l40 = n.bound end i( l40 );
 local l41 = n if n ~= CL["EQ"](l33, LCL['CL-LIB']['MAKE-CHAR']("]")) then  l41 = l31 else  l41 = n.bound end i( CL_LIB["FORMAT-NO-FLAGS"](l41, l32) );
 single_value();  local l42 = n if n ~= l31 then  single_value();  l18 = CL["T"].bound l42 = l18 else  l42 = n.bound end i( l42 );
 i( CL_LIB["FORMAT-SCAN-OPTIONAL-CLAUSE"](l28, l29, l14) );
 local l43 = n if n ~= CL["EQ"](l33, LCL['CL-LIB']['MAKE-CHAR']("]")) then  local l44 = n if n ~= l18 then  l44 = n.bound else  single_value();  l44 = CL_LIB["NOTE-FORMAT-SCAN-OPTION"](l14) end i( l44 );
 single_value();  local l45 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  l43 = error({tag=CL["IDENTITY"](l2),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l45)) end)()}) else  l43 = n.bound end i( l43 );
 single_value();  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 i( error({tag=CL["IDENTITY"](l22),(function () single_value() return unpack_mv(l26[1]) end)()}) );
 single_value();  return CL_LIB["FUNCALL-LUA"]( l27[1], {}) end, 0, 0, false, false)};l27 = {CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   local l46 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  i( error({tag=CL["IDENTITY"](l16),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l46)) end)()}) );
 single_value();  return error({tag=CL["IDENTITY"](l20),(function () single_value() return unpack_mv(n) end)()}) end, 0, 0, false, false)}; single_value();  local l47 = l25[1]; single_value();  while true do  single_value();  local l48 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB['FUNCALL-LUA'](l47,{}) end, 0, 0, false, false))); single_value(); if l48.error ~= n and (l48.error ~= KEYWORD.TAG or l48.tag ~= l19) then if l48.error == KEYWORD.TAG then  error(l48) else error(l48[1]) end end l47 = CL["VALUES-LIST"](list_r(l48)) local tmpres = l47 end return n end, 0, 0, false, false))); single_value(); if l24.error ~= n and (l24.error ~= KEYWORD.TAG or l24.tag ~= l20) then if l24.error == KEYWORD.TAG then  error(l24) else error(l24[1]) end end return CL["VALUES-LIST"](list_r(l24)) end, 0, 0, false, false))); single_value(); if l17.error ~= n and (l17.error ~= KEYWORD.TAG or l17.tag ~= l16) then if l17.error == KEYWORD.TAG then  error(l17) else error(l17[1]) end end local l15 = CL["VALUES-LIST"](list_r(l17)); single_value();  local l49 = (l13)[1]; single_value();  CL_LIB["*FORMAT-ARGUMENTS*"].bound = l49 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  single_value();  single_value();  local l50 = (l13)[2]; single_value();  CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = l50 i( CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound );
 single_value();  return l15 end, 0, 0, false, false))); single_value(); if l3.error ~= n and (l3.error ~= KEYWORD.TAG or l3.tag ~= l2) then if l3.error == KEYWORD.TAG then  error(l3) else error(l3[1]) end end return CL["VALUES-LIST"](list_r(l3)) end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-SCAN-FUNNY-CONDITION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PARMS"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= l1 then  single_value();  l2 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l2 = n.bound end i( l2 );
 single_value();  local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = n.bound; local l8 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l9 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l11 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l10 = l11; single_value();  single_value();  l3,l4,l5,l6,l7= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR']("]"),n}, false, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l8 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l9.error ~= n and true then if l9.error == KEYWORD.TAG then  error(l9) else error(l9[1]) end end i( CL["VALUES-LIST"](list_r(l9)) );
 local l12 = n if n ~= l5 then  single_value();  l12 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l12 = n.bound end i( l12 );
 single_value();  i( CL_LIB["FORMAT-NO-FLAGS"](l6, l7) );
 local l13 = n if n ~= CL["NULL"](CL_LIB["*FORMAT-ARGUMENTS*"].bound) then  single_value();  l13 = CL_LIB["POP-FORMAT-ARG"]() else  l13 = n.bound end i( l13 );
 single_value();  local l14 = CL["CONS"](n.bound, n.bound); single_value();  local l15 = l14; single_value();  i( n.bound );
 single_value();  single_value();  local l17 = CL_LIB["FUNCALL-LUA"]( CL_LIB["NX-TRANSFORM"].fbound, {(CL_LIB["*FORMAT-ARGUMENTS*"].bound)[1], }); local l18 = n if n ~= CL_LIB["NX-COULD-BE-TYPE"](l17, CL["NULL"], CL["T"].bound) then  single_value();  local l19 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound; local l20 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; single_value();  local l21 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l23 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; CL_LIB["*FORMAT-ARGUMENTS*"].bound = CL_LIB["*FORMAT-ARGUMENTS*"].bound i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  local l22 = l23; local l25 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound; CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound i( CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound );
 single_value();  local l24 = l25; single_value();  local l26 = n if n ~= CL["EQL"](CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound, CL["LENGTH"](CL_LIB["*FORMAT-ARGUMENTS*"].bound)) then  single_value();  single_value();  local l27 = (-1 + CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound); single_value();  CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = l27 l26 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound else  l26 = n.bound end i( l26 );
 local l28 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; single_value();  local l29 = (l28)[1]; single_value();  single_value();  local l30 = (l28)[2]; single_value();  CL_LIB["*FORMAT-ARGUMENTS*"].bound = l30 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  i( l29 );
 single_value();  return CL_LIB["NOTE-FORMAT-SCAN-OPTION"](l15) end, 0, 0, false, false))); CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = l19 i( CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound );
 CL_LIB["*FORMAT-ARGUMENTS*"].bound = l20 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value(); if l21.error ~= n and true then if l21.error == KEYWORD.TAG then  error(l21) else error(l21[1]) end end l18 = CL["VALUES-LIST"](list_r(l21)) else  l18 = n.bound end i( l18 );
 single_value();  local l31 = n if n ~= l17 then  single_value();  l31 = CL_LIB["FORMAT-SCAN-OPTIONAL-CLAUSE"](l3, l4, l15) else  l31 = n.bound end local l16 = l31; single_value();  local l32 = (l14)[1]; single_value();  CL_LIB["*FORMAT-ARGUMENTS*"].bound = l32 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  single_value();  single_value();  local l33 = (l14)[2]; single_value();  CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = l33 i( CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound );
 single_value();  return l16 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-SCAN-BOOLEAN-CONDITION"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PARMS"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= l1 then  single_value();  l2 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l2 = n.bound end i( l2 );
 single_value();  local l3 = n.bound; local l4 = n.bound; local l5 = n.bound; local l6 = n.bound; local l7 = n.bound; local l8 = n.bound; local l9 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l10 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l12 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l11 = l12; single_value();  single_value();  l3,l4,l5,l6,l7,l8= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR'](";"),{LCL['CL-LIB']['MAKE-CHAR']("]"),n}}, false, false), 6) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l9 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l10.error ~= n and true then if l10.error == KEYWORD.TAG then  error(l10) else error(l10[1]) end end i( CL["VALUES-LIST"](list_r(l10)) );
 local l13 = n if n ~= CL["EQ"](l8, LCL['CL-LIB']['MAKE-CHAR']("]")) then  single_value();  l13 = CL_LIB["FORMAT-ERROR"]("Two clauses separated by ~~; are required for ~~:[", l()) else  l13 = n.bound end i( l13 );
 local l14 = n if n ~= l5 then  single_value();  l14 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l14 = n.bound end i( l14 );
 single_value();  i( CL_LIB["FORMAT-NO-FLAGS"](l6, l7) );
 i( CL_LIB["FUNCALL-LUA"]( CL_LIB["FORMAT-NEXTCHAR"].fbound, {}) );
 single_value();  local l15 = CL["CONS"](n.bound, n.bound); single_value();  local l16 = l15; single_value();  i( n.bound );
 single_value();  single_value();  local l18 = CL_LIB["FUNCALL-LUA"]( CL_LIB["NX-TRANSFORM"].fbound, {CL_LIB["POP-FORMAT-ARG"](), }); local l19 = n if n ~= CL_LIB["NX-COULD-BE-TYPE"](l18, CL["NULL"], CL["T"].bound) then  single_value();  l19 = CL_LIB["FORMAT-SCAN-OPTIONAL-CLAUSE"](l3, l4, l16) else  l19 = n.bound end i( l19 );
 single_value();  local l20 = n.bound; local l21 = n.bound; local l22 = n.bound; local l23 = n.bound; local l24 = n.bound; local l25 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; single_value();  local l26 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l28 = CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound; CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = CL["MULTIPLE-VALUES-LIMIT"].bound i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value();  local l27 = l28; single_value();  single_value();  l20,l21,l22,l23,l24= unpack_mv(CL_LIB["FORMAT-FIND-COMMAND"]({LCL['CL-LIB']['MAKE-CHAR']("]"),n}, false, false), 5) return n.bound end, 0, 0, false, false))); CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound = l25 i( CL_LIB["*MULTIPLE-VALUES-COUNT*"].bound );
 single_value(); if l26.error ~= n and true then if l26.error == KEYWORD.TAG then  error(l26) else error(l26[1]) end end i( CL["VALUES-LIST"](list_r(l26)) );
 local l29 = n if n ~= l22 then  single_value();  l29 = CL_LIB["FORMAT-ERROR"]("Too many parameters", l()) else  l29 = n.bound end i( l29 );
 single_value();  i( CL_LIB["FORMAT-NO-FLAGS"](l23, l24) );
 single_value();  local l30 = n if n ~= l18 then  single_value();  l30 = CL_LIB["FORMAT-SCAN-OPTIONAL-CLAUSE"](l20, l21, l16) else  l30 = n.bound end local l17 = l30; single_value();  local l31 = (l15)[1]; single_value();  CL_LIB["*FORMAT-ARGUMENTS*"].bound = l31 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  single_value();  single_value();  local l32 = (l15)[2]; single_value();  CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = l32 i( CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound );
 single_value();  return l17 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-SCAN-OPTIONAL-CLAUSE"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["START"],{CL_LIB["END"],{CL_LIB["COND-OPTION"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound; local l5 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; single_value();  local l6 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l8 = CL_LIB["*FORMAT-ARGUMENTS*"].bound; CL_LIB["*FORMAT-ARGUMENTS*"].bound = CL_LIB["*FORMAT-ARGUMENTS*"].bound i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  local l7 = l8; local l10 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound; CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound i( CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound );
 single_value();  local l9 = l10; single_value();  single_value();  local l11 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   i( CL_LIB["SUB-FORMAT-SCAN"](l1, l2) );
 i( CL_LIB["NOTE-FORMAT-SCAN-OPTION"](l3) );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l11.error ~= n and (l11.error ~= KEYWORD.TAG or l11.tag ~= CL_LIB["FORMAT-ESCAPE"]) then if l11.error == KEYWORD.TAG then  error(l11) else error(l11[1]) end end return CL["VALUES-LIST"](list_r(l11)) end, 0, 0, false, false))); CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = l4 i( CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound );
 CL_LIB["*FORMAT-ARGUMENTS*"].bound = l5 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value(); if l6.error ~= n and true then if l6.error == KEYWORD.TAG then  error(l6) else error(l6[1]) end end return CL["VALUES-LIST"](list_r(l6)) end, 3, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["FORMAT-SCAN-GOTO"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["COLON"],{CL_LIB["ATSIGN"],{CL["COUNT"],n}}},function (l1, l2, l3,  ...)   single_value();  local l4 = n if n ~= l2 then  local l5 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; single_value();  local l6 = (CL["LENGTH"](l5) - CL["LENGTH"](CL_LIB["*FORMAT-ARGUMENTS*"].bound)); single_value();  local l8 = l3; single_value();  local l9 = n if n ~= l8 then  l9 = l8 else  l9 = 0 end local l7 = l9; single_value();  i( CL_LIB["FORMAT-NO-FLAGS"](l1, n.bound) );
 CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = CL["MAX"](l(0,(l6 - l7))) i( CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound );
 single_value();  CL_LIB["*FORMAT-ARGUMENTS*"].bound = CL_LIB["NTHCDR-NO-OVERFLOW"](l7, l5) l4 = CL_LIB["*FORMAT-ARGUMENTS*"].bound else  local l10 = n if n ~= CL["NULL"](l3) then  single_value();  l3 = 1 l10 = l3 else  l10 = n.bound end i( l10 );
 local l11 = n if n ~= l1 then  single_value();  l3 = - l3 l11 = l3 else  l11 = n.bound end i( l11 );
 single_value();  local l12 = n if n ~= CL[">"](l(l3,0)) then  local l13 = n if n ~= CL[">"](l(l3,CL["LENGTH"](CL_LIB["*FORMAT-ARGUMENTS*"].bound))) then  single_value();  l13 = CL_LIB["FORMAT-ERROR"]("Target position for ~~* out of bounds", l()) else  l13 = n.bound end i( l13 );
 CL_LIB["*FORMAT-ARGUMENTS*"].bound = CL["NTHCDR"](l3, CL_LIB["*FORMAT-ARGUMENTS*"].bound) i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  local l14 = n if n ~= CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound then  single_value();  CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = CL["MIN"](l(CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound,CL["LENGTH"](CL_LIB["*FORMAT-ARGUMENTS*"].bound))) l14 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound else  l14 = n.bound end l12 = l14 else  local l15 = n if n ~= CL_LIB["%<"](l3, 0) then  single_value();  local l16 = CL_LIB["*FORMAT-ORIGINAL-ARGUMENTS*"].bound; single_value();  local l17 = (CL["LENGTH"](l16) - CL["LENGTH"](CL_LIB["*FORMAT-ARGUMENTS*"].bound)); single_value();  local l18 = (l17 + l3); single_value();  local l20 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound; single_value();  local l21 = n if n ~= l20 then  l21 = l20 else  l21 = 0 end local l19 = (l18 + l21); single_value();  local l22 = n if n ~= CL_LIB["%<"](l19, 0) then  single_value();  l22 = CL_LIB["FORMAT-ERROR"]("Target position for ~~* out of bounds", l()) else  l22 = n.bound end i( l22 );
 l19 = CL["1-"]((l19 - l3)) i( l19 );
 single_value();  local l23 = n if n ~= CL_LIB["%<"](l18, 0) then  single_value();  local l24 = l16; single_value();  CL_LIB["*FORMAT-ARGUMENTS*"].bound = l24 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  single_value();  single_value();  local l25 = l19; single_value();  CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = l25 l23 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound else  single_value();  local l26 = CL["NTHCDR"](l18, l16); single_value();  CL_LIB["*FORMAT-ARGUMENTS*"].bound = l26 i( CL_LIB["*FORMAT-ARGUMENTS*"].bound );
 single_value();  single_value();  single_value();  local l27 = (l19 - l18); single_value();  CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound = l27 l23 = CL_LIB["*FORMAT-ARGUMENTS-VARIANCE*"].bound end l15 = l23 else  l15 = n.bound end l12 = l15 end l4 = l12 end return l4 end, 3, 0, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); local l1 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l2 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  local l3 = CL_LIB["*THREAD*"].bound; single_value();  single_value();  local l4 = CL["CONS"](CL["LIST"](l(CL["LIST"](l(CL["ERROR"],CL_LIB["ALLOC-FUNCTION"]({CL["CONDITION"],n},function (l5,  ...)   single_value();  return error({tag=CL["IDENTITY"](LCL["NIL"]["G250205"]),(function () single_value() return unpack_mv(n.bound) end)()}) end, 1, 0, false, false))))), CL_LIB["THREAD-STORAGE-HANDLERS"](CL_LIB["*THREAD*"].bound)); single_value();  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l6, l7,  ...)   single_value();  local l8 = l7; single_value(); l6[CL["IDENTITY"](CL_LIB["HANDLERS"])] = l8 return l8 end, 2, 0, false, false), {l3, l4, }) );
 single_value();  return CL["IMPORT"](LCL["CLOSETTE"]["+CLOSETTE-SYMBOLS+"].bound, LCL["KEYWORD"]["COMMON-LISP"]) end, 0, 0, false, false))); local l9 = CL_LIB["THREAD-STORAGE-HANDLERS"](CL_LIB["*THREAD*"].bound); single_value();  local l10 = (l9)[1]; single_value();  local l11 = CL_LIB["*THREAD*"].bound; single_value();  single_value();  local l12 = (l9)[2]; single_value();  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l13, l14,  ...)   single_value();  local l15 = l14; single_value(); l13[CL["IDENTITY"](CL_LIB["HANDLERS"])] = l15 return l15 end, 2, 0, false, false), {l11, l12, }) );
 single_value();  i( l10 );
 single_value(); if l2.error ~= n and true then if l2.error == KEYWORD.TAG then  error(l2) else error(l2[1]) end end return CL["VALUES-LIST"](list_r(l2)) end, 0, 0, false, false))); single_value(); if l1.error ~= n and (l1.error ~= KEYWORD.TAG or l1.tag ~= LCL["NIL"]["G250205"]) then if l1.error == KEYWORD.TAG then  error(l1) else error(l1[1]) end end tmp = CL["VALUES-LIST"](list_r(l1)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%FIND-CLASS"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["CLASS"],n},function (l1,  ...)   single_value();  local l2 = n if n ~= CL["TYPEP"](l1, LCL["CLOSETTE"]["STANDARD-CLASS"], false) then  l2 = l1 else  l2 = LCL["CLOSETTE"]["FIND-CLASS"](l1, n.bound) end return l2 end, 1, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%PRINT-CLOS-OBJECT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],{CL["STREAM"],n}},function (l1, l2,  ...)   i( CL["WRITE-STRING"]("#<", l2, k()) );
 i( CL["WRITE-STRING"](CL["STRING"](LCL["CLOSETTE"]["CLASS-NAME"](LCL["CLOSETTE"]["CLASS-OF"](l1))), l2, k()) );
 single_value();  return CL["WRITE-STRING"](">", l2, k()) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["%SUBCLASSP"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["T1"],{CL_LIB["T2"],n}},function (l1, l2,  ...)   single_value();  return LCL["CLOSETTE"]["SUBCLASSP"](l1, l2) end, 2, 0, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["TYPEP-EXT"] , CL_LIB["ALLOC-FUNCTION"]({CL_LIB["OBJECT"],{CL_LIB["SPEC-SYMBOL"],{CL_LIB["SPEC-ARGS"],n}}},function (l1, l2, l3,  ...)   single_value();  local l5 = n if n ~= CL["NULL"](l3) then  l5 = LCL["CLOSETTE"]["FIND-CLASS"](l2, n.bound) else  l5 = n.bound end local l4 = n if n ~= l5 then  l4 = LCL["CLOSETTE"]["SUBCLASSP"](LCL["CLOSETTE"]["CLASS-OF"](l1), LCL["CLOSETTE"]["FIND-CLASS"](l2, false)) else  l4 = n.bound end return l4 end, 3, 0, false, false)); tmp = CL_LIB["%IN-PACKAGE"](LCL["KEYWORD"]["CL-LIB"]); tmp = CL_LIB["%DEFPACKAGE"](LCL["KEYWORD"]["COMMON-LISP-USER"], {{LCL["KEYWORD"]["NICKNAMES"],{LCL["KEYWORD"]["CL-USER"],n}},{{LCL["KEYWORD"]["USE"],{LCL["KEYWORD"]["CL"],n}},n}}); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["*"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["**"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["***"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["+"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["++"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["+++"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["/"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["//"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["///"],l1); local l1 = n.bound; single_value();  tmp = CL_LIB.DEF(CL["-"],l1); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["REPL"] , CL_LIB["ALLOC-FUNCTION"]({CL["&OPTIONAL"],{{CL_LIB["NEST"],{0,n}},{CL_LIB["RESTARTS"],n}}},function (l1, l2,  ...)  if not l1 then  l1 = 0 end if not l2 then  l2 = n.bound end  single_value();  local l3 = CL["GENSYM"](false); single_value();  local l4 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l5 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  local l6 = CL_LIB["*THREAD*"].bound; single_value();  single_value();  local l7 = CL["CONS"](CL["LIST"](l(CL_LIB["MAKE-RESTART"](k(CL_LIB["NAME"], CL["ABORT"], CL["FUNCTION"], CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l8 = CL["FUNCALL"](l, l(unpack_mv(n.bound))); single_value();  return error({tag=CL["IDENTITY"](l3),(function () single_value() return unpack_mv(CL["VALUES-LIST"](l8)) end)()}) end, 0, 0, false, false))))), CL_LIB["THREAD-STORAGE-RESTARTS"](CL_LIB["*THREAD*"].bound)); single_value();  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l9, l10,  ...)   single_value();  local l11 = l10; single_value(); l9[CL["IDENTITY"](CL_LIB["RESTARTS"])] = l11 return l11 end, 2, 0, false, false), {l6, l7, }) );
 CL_LIB["*DEBUGGER-HOOK*"].bound = CL_LIB["ALLOC-FUNCTION"]({CL["CONDITION"],{CL_LIB["D"],n}},function (l12, l13,  ...)   i( CL["WRITE-STRING"]("\n*UNCAUGHT ERROR of type ", CL["*ERROR-OUTPUT*"].bound, k()) );
 i( CL["WRITE-STRING"](CL["STRING"](LCL["CLOSETTE"]["CLASS-NAME"](LCL["CLOSETTE"]["CLASS-OF"](l12))), CL["*ERROR-OUTPUT*"].bound, k()) );
 i( CL["WRITE-LINE"]("*", CL["*ERROR-OUTPUT*"].bound, k()) );
 local l14 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  local l15 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  single_value();  local l16 = CL_LIB["*THREAD*"].bound; single_value();  single_value();  local l17 = CL["CONS"](CL["LIST"](l(CL["LIST"](l(CL["ERROR"],CL_LIB["ALLOC-FUNCTION"]({CL_LIB["E"],n},function (l18,  ...)   single_value();  single_value();  return error({tag=CL["IDENTITY"](LCL["NIL"]["G253058"]),(function () single_value() return unpack_mv(CL["WRITE-LINE"]("(Error while printing error)", CL["*ERROR-OUTPUT*"].bound, k())) end)()}) end, 1, 0, false, false))))), CL_LIB["THREAD-STORAGE-HANDLERS"](CL_LIB["*THREAD*"].bound)); single_value();  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l19, l20,  ...)   single_value();  local l21 = l20; single_value(); l19[CL["IDENTITY"](CL_LIB["HANDLERS"])] = l21 return l21 end, 2, 0, false, false), {l16, l17, }) );
 single_value();  return CL_LIB["REPORT-CONDITION"](l(l12,CL["*ERROR-OUTPUT*"].bound)) end, 0, 0, false, false))); local l22 = CL_LIB["THREAD-STORAGE-HANDLERS"](CL_LIB["*THREAD*"].bound); single_value();  local l23 = (l22)[1]; single_value();  local l24 = CL_LIB["*THREAD*"].bound; single_value();  single_value();  local l25 = (l22)[2]; single_value();  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l26, l27,  ...)   single_value();  local l28 = l27; single_value(); l26[CL["IDENTITY"](CL_LIB["HANDLERS"])] = l28 return l28 end, 2, 0, false, false), {l24, l25, }) );
 single_value();  i( l23 );
 single_value(); if l15.error ~= n and true then if l15.error == KEYWORD.TAG then  error(l15) else error(l15[1]) end end return CL["VALUES-LIST"](list_r(l15)) end, 0, 0, false, false))); single_value(); if l14.error ~= n and (l14.error ~= KEYWORD.TAG or l14.tag ~= LCL["NIL"]["G253058"]) then if l14.error == KEYWORD.TAG then  error(l14) else error(l14[1]) end end i( CL["VALUES-LIST"](list_r(l14)) );
 i( CL["WRITE-LINE"]("", CL["*ERROR-OUTPUT*"].bound, k()) );
 i( CL["WRITE-LINE"]("restarts (number to call interactively): ", CL["*ERROR-OUTPUT*"].bound, k()) );
 single_value();  local l29 = CL["COMPUTE-RESTARTS"](l12); local l30 = 0; local l31 = CL["COMPUTE-RESTARTS"](l12); single_value();  local l32 = (l31)[1]; single_value();  single_value();  local l33 = CL["GENSYM"](false); single_value();  local l34 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l35 = n if n ~= CL["NOT"](l31) then  single_value(); do break end; l35 = n.bound else  l35 = n.bound end i( l35 );
 i( CL["WRITE-STRING"](CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL_LIB["NUMBER-TO-LUA"](l30), ": [", CL["STRING"](CL["RESTART-NAME"](l32)), "] ", }), CL["*ERROR-OUTPUT*"].bound, k()) );
 local l36 = n if n ~= CL_LIB["RESTART-REPORT-FUNCTION"](l32) then  l36 = CL["FUNCALL"](CL_LIB["RESTART-REPORT-FUNCTION"](l32), l(CL["*ERROR-OUTPUT*"].bound)) else  l36 = n.bound end i( l36 );
 i( CL["FRESH-LINE"](CL["*ERROR-OUTPUT*"].bound) );
 single_value();  local l37 = (1 + l30); single_value();  l30 = l37 i( l30 );
 single_value();  single_value();  local l38 = (l31)[2]; single_value();  l31 = l38 i( l31 );
 single_value();  single_value();  single_value();  local l39 = (l31)[1]; single_value();  l32 = l39 local tmpres = l32 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l34.error ~= n and (l34.error ~= KEYWORD.TAG or l34.tag ~= l33) then if l34.error == KEYWORD.TAG then  error(l34) else error(l34[1]) end end i( CL["VALUES-LIST"](list_r(l34)) );
 i( CL["FRESH-LINE"](CL["*ERROR-OUTPUT*"].bound) );
 i( CL["WRITE-LINE"]("STACK TRACE", CL["*ERROR-OUTPUT*"].bound, k()) );
 i( print(debug.traceback()) );
 i( CL_LIB["REPL"]((1 + l1), l29) );
 single_value();  return CL["INVOKE-RESTART-INTERACTIVELY"](CL["ELT"](l29, CL["READ"](false, false, false, false))) end, 2, 0, false, false) i( CL_LIB["*DEBUGGER-HOOK*"].bound );
 single_value();  while true do  i( CL["FRESH-LINE"](false) );
 local l40 = n if n ~= CL[">"](l(l1,0)) then  l40 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL_LIB["NUMBER-TO-LUA"](l1), "] ", }) else  l40 = CL_LIB["FUNCALL-LUA"]( CL_LIB["CONCAT-STRING"].fbound, {CL["PACKAGE-NAME"](CL["*PACKAGE*"].bound), "> ", }) end i( CL["WRITE-STRING"](l40, false, k()) );
 local l41 = CL["++"].bound; local l42 = CL["+"].bound; local l43 = CL["-"].bound; local l44 = CL["READ"](false, false, false, false); single_value();  single_value();  local l45 = l44; single_value();  CL["-"].bound = l45 i( CL["-"].bound );
 single_value();  single_value();  local l46 = l43; single_value();  CL["+"].bound = l46 i( CL["+"].bound );
 single_value();  single_value();  local l47 = l42; single_value();  CL["++"].bound = l47 i( CL["++"].bound );
 single_value();  single_value();  single_value();  local l48 = l41; single_value();  CL["+++"].bound = l48 i( CL["+++"].bound );
 local l49 = CL["//"].bound; local l50 = CL["/"].bound; local l53 = n if n ~= CL["NUMBERP"](CL["-"].bound) then  l53 = CL[">"](l(l1,0)) else  l53 = n.bound end local l52 = n if n ~= l53 then  l52 = CL["INVOKE-RESTART-INTERACTIVELY"](CL["ELT"](l2, CL["-"].bound)) else  l52 = CL["EVAL"](CL["-"].bound) end local l51 = CL["FUNCALL"](l, l(unpack_mv(l52))); single_value();  single_value();  local l54 = l51; single_value();  CL["/"].bound = l54 i( CL["/"].bound );
 single_value();  single_value();  local l55 = l50; single_value();  CL["//"].bound = l55 i( CL["//"].bound );
 single_value();  single_value();  single_value();  local l56 = l49; single_value();  CL["///"].bound = l56 i( CL["///"].bound );
 local l57 = CL["**"].bound; local l58 = CL["*"].bound; local l59 = (CL["/"].bound)[1]; single_value();  single_value();  local l60 = l59; single_value();  CL["*"].bound = l60 i( CL["*"].bound );
 single_value();  single_value();  local l61 = l58; single_value();  CL["**"].bound = l61 i( CL["**"].bound );
 single_value();  single_value();  single_value();  local l62 = l57; single_value();  CL["***"].bound = l62 i( CL["***"].bound );
 single_value();  local l63 = CL["/"].bound; single_value();  local l64 = (l63)[1]; single_value();  single_value();  local l65 = CL["GENSYM"](false); single_value();  local l66 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   while true do  local l67 = n if n ~= CL["NOT"](l63) then  single_value(); do break end; l67 = n.bound else  l67 = n.bound end i( l67 );
 i( CL["PRINT"](l64, false) );
 single_value();  single_value();  local l68 = (l63)[2]; single_value();  l63 = l68 i( l63 );
 single_value();  single_value();  single_value();  local l69 = (l63)[1]; single_value();  l64 = l69 local tmpres = l64 end i( n );
 single_value();  return n.bound end, 0, 0, false, false))); single_value(); if l66.error ~= n and (l66.error ~= KEYWORD.TAG or l66.tag ~= l65) then if l66.error == KEYWORD.TAG then  error(l66) else error(l66[1]) end end local tmpres = CL["VALUES-LIST"](list_r(l66)) end return n end, 0, 0, false, false))); local l70 = CL_LIB["THREAD-STORAGE-RESTARTS"](CL_LIB["*THREAD*"].bound); single_value();  local l71 = (l70)[1]; single_value();  local l72 = CL_LIB["*THREAD*"].bound; single_value();  single_value();  local l73 = (l70)[2]; single_value();  i( CL_LIB["FUNCALL-LUA"]( CL_LIB["ALLOC-FUNCTION"]({CL_LIB["PLACE"],{CL_LIB["NEW"],n}},function (l74, l75,  ...)   single_value();  local l76 = l75; single_value(); l74[CL["IDENTITY"](CL_LIB["RESTARTS"])] = l76 return l76 end, 2, 0, false, false), {l72, l73, }) );
 single_value();  i( l71 );
 single_value(); if l5.error ~= n and true then if l5.error == KEYWORD.TAG then  error(l5) else error(l5[1]) end end return CL["VALUES-LIST"](list_r(l5)) end, 0, 0, false, false))); single_value(); if l4.error ~= n and (l4.error ~= KEYWORD.TAG or l4.tag ~= l3) then if l4.error == KEYWORD.TAG then  error(l4) else error(l4[1]) end end return CL["VALUES-LIST"](list_r(l4)) end, 0, 2, false, false)); tmp = CL_LIB["FUNCTION-SETQ"](CL_LIB["MAIN"] , CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   CL["*PACKAGE*"].bound = LCL["KEYWORD"]["CL-USER"] i( CL["*PACKAGE*"].bound );
 single_value();  local l1 = l((table.unpack or unpack)(arg)); single_value();  while true do  single_value();  local l2 = (pcallmv(CL_LIB["ALLOC-FUNCTION"](n,function ( ...)   single_value();  return CL_LIB["REPL"](false, false) end, 0, 0, false, false))); single_value();  local l4 = "error"; local l5 = n.bound; single_value();  local l3 = n if n ~= ((l2)[l4] or l5) then  single_value();  local l6 = "tag"; local l7 = n.bound; single_value();  l3 = CL["FORMAT"](CL["T"].bound, "*UNCAUGHT-NLR* ~@[[TAG: ~S]~]~{~&~A~}", l(((l2)[l6] or l7),list_r(l2))) else  l3 = n.bound end local tmpres = l3 end return n end, 0, 0, false, false));
